---
title: 2.1.16
tags: Sort
weight: 2116
date: 2018-06-30 15:27:00
---

# 2.1.16


## 解答

如果移动数据时新建了对象，那么虽然值没有改变，但是数组中的对象被修改了。

## 代码

插入排序中的 Exch() 换成了如下方式：

```csharp
string temp = new string(s[i].ToCharArray());
s[i] = s[min];
s[min] = temp;
```

全部程序代码如下：

```csharp
using System;

namespace _2._1._16
{
    /*
     * 2.1.16
     * 
     * 验证。
     * 编写一个 check() 方法，
     * 调用 sort() 对任意数组排序。
     * 如果排序成功而且数组中的所有对象均没有被修改则返回 true，
     * 否则返回 false。
     * 不要假设 sort() 只能通过 exch() 来移动数据，
     * 可以信任并使用 Array.sort()。
     * 
     */
    public class Program
    {
        static void Main(string[] args)
        {
            string[] test = new string[5] { "a", "b", "d", "c", "e" };
            Console.WriteLine(CheckArraySort(test));
            Console.WriteLine(CheckSelectionSort(test));
        }

        /// <summary>
        /// 测试 Array.Sort() 方法。
        /// </summary>
        /// <param name="a">用于测试的数组。</param>
        /// <returns>如果数组对象没有改变，返回 true，否则返回 false。</returns>
        static bool CheckArraySort(string[] a)
        {
            string[] backup = new string[a.Length];
            a.CopyTo(backup, 0);

            Array.Sort(a);

            foreach (string n in a)
            {
                bool isFind = false;
                for (int i = 0; i < a.Length; i++)
                {
                    if (ReferenceEquals(n, backup[i]))
                    {
                        isFind = true;
                        break;
                    }
                }
                if (!isFind)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// 测试选择排序。
        /// </summary>
        /// <param name="a">用于测试的数组。</param>
        /// <returns>如果数组对象没有改变，返回 true，否则返回 false。</returns>
        static bool CheckSelectionSort(string[] a)
        {
            string[] backup = new string[a.Length];
            a.CopyTo(backup, 0);

            SelectionSort(a);

            foreach (string n in a)
            {
                bool isFind = false;
                for (int i = 0; i < a.Length; i++)
                {
                    if (ReferenceEquals(n, backup[i]))
                    {
                        isFind = true;
                        break;
                    }
                }
                if (!isFind)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// 选择排序，其中的交换部分使用新建对象并复制的方法。
        /// </summary>
        /// <param name="s">用于排序的数组。</param>
        public static void SelectionSort(string[] s)
        {
            for (int i = 0; i < s.Length; i++)
            {
                int min = i;
                for (int j = i + 1; j < s.Length; j++)
                {
                    if (s[j].CompareTo(s[min]) < 0)
                    {
                        min = j;
                    }
                }
                string temp = new string(s[i].ToCharArray());
                s[i] = s[min];
                s[min] = temp;
            }
        }
    }
}
```
