<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>《算法（第四版）》C# 题解</title><link>https://alg4.ikesnowy.com/</link><description>Recent content on 《算法（第四版）》C# 题解</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 31 May 2018 11:55:24 +0000</lastBuildDate><atom:link href="https://alg4.ikesnowy.com/index.xml" rel="self" type="application/rss+xml"/><item><title>特别感谢</title><link>https://alg4.ikesnowy.com/thanks/</link><pubDate>Thu, 24 Jan 2019 10:56:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/thanks/</guid><description>代码避免不了 bug，题解也避免不了错误，感谢你们对于题解中问题的指出！
（排名不分先后）
@杨晗 ，1.3.49 等 。⬅ 他写了一份 Java 版的题解，做的比我多，点此进入
第一章 # @ljdhhp ，1.3.31 #539
@ShuXin ，1.4.15 #321
@雨碎江南 ，1.4.8，1.4.18 #437
@张越 ，1.4.19
@5ME，1.1.1 #592
@Hao Liu, 公式渲染问题 #596, #594
@Hao Liu, 1.4.15, 1.4.20, #595
@Heshan, 1.1.25 #615
第二章 # @雨碎江南 ，2.2.12 #532
@cx666 , 2.2.12 #588
@TianDao ，2.3.20 #587
@wssb ，2.2.16，2.4.13
@miyuexingchen ，2.4.6 #521
@玉垒浮云 ，2.4.35 #590
@Hao Liu, 2.3.22 #614
第三章 # @雨碎江南 ，3.1.24 #538</description></item><item><title>1.1.1</title><link>https://alg4.ikesnowy.com/1-1-1/</link><pubDate>Mon, 14 May 2018 19:01:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-1/</guid><description> 1.1.1 # 解答 # a.7
b.200.0000002
c.True
代码 # var a = (0 + 15) / 2; var b = 2.0e-6 * 100000000.1; var c = true &amp;amp;&amp;amp; false || true &amp;amp;&amp;amp; true; // Console.WriteLine 向控制台窗口输出一行 Console.WriteLine($&amp;#34;a.{a}&amp;#34;); Console.WriteLine($&amp;#34;b.{b}&amp;#34;); Console.WriteLine($&amp;#34;c.{c}&amp;#34;);</description></item><item><title>1.1.2</title><link>https://alg4.ikesnowy.com/1-1-2/</link><pubDate>Mon, 14 May 2018 19:21:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-2/</guid><description>1.1.2 # 解答 # Name Type Value a System.Double 1.618 b System.Double 10 c System.Boolean True d System.String 33 代码 # // var 变量名 = 初始值 根据初始值自动判断变量类型 var a = (1 + 2.236) / 2; var b = 1 + 2 + 3 + 4.0; var c = 4.1 &amp;gt;= 4; var d = 1 + 2 + &amp;#34;3&amp;#34;; // Console.WriteLine 向控制台输出一行 // 变量名.GetType() 返回变量类型 Console.WriteLine(&amp;#34;\tName\tType \tValue&amp;#34;); Console.WriteLine($&amp;#34;\ta\t{a.GetType()}\t{a}&amp;#34;); Console.WriteLine($&amp;#34;\tb\t{b.GetType()}\t{b}&amp;#34;); Console.</description></item><item><title>1.1.3</title><link>https://alg4.ikesnowy.com/1-1-3/</link><pubDate>Mon, 14 May 2018 19:33:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-3/</guid><description> 1.1.3 # 解答 # 简单的 if 判断即可。
代码 # /* * 输入 * * 用空格隔开的三个整数，例如 * 3 3 3 * * 输出 * * equal 或 not equal */ var input = Console.ReadLine(); var a = int.Parse(input.Split(&amp;#39; &amp;#39;)[0]); var b = int.Parse(input.Split(&amp;#39; &amp;#39;)[1]); var c = int.Parse(input.Split(&amp;#39; &amp;#39;)[2]); if (a == b &amp;amp;&amp;amp; b == c) { Console.WriteLine(&amp;#34;equal&amp;#34;); } else { Console.WriteLine(&amp;#34;not equal&amp;#34;); }</description></item><item><title>1.1.4</title><link>https://alg4.ikesnowy.com/1-1-4/</link><pubDate>Mon, 14 May 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-4/</guid><description> 1.1.4 # 解答 # a. if 后跟 then 的语法不能在 C# 中使用。
b. if 后的判断语句需要在括号内。
c. 正确，只有一条语句时大括号可以省略。
d. c = 0 后缺少分号。
代码 # var a = 1; var b = 2; var c = 0; // if (a &amp;gt; b) then c = 0; // if 后不能跟 then // if a &amp;gt; b { c = 0; } // if后必须跟括号 if (a &amp;gt; b) c = 0; // 正确 // if (a &amp;gt; b) c = 0 else b = 0; // c = 0后缺少分号</description></item><item><title>1.1.5</title><link>https://alg4.ikesnowy.com/1-1-5/</link><pubDate>Mon, 14 May 2018 19:37:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-5/</guid><description> 1.1.5 # 解答 # 比较简单，直接判断即可。
代码 # // 修改这两个值进行测试 var x = 0.05; var y = 0.01; if (x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 1 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 1) { Console.WriteLine(&amp;#34;true&amp;#34;); } else { Console.WriteLine(&amp;#34;false&amp;#34;); }</description></item><item><title>1.1.6</title><link>https://alg4.ikesnowy.com/1-1-6/</link><pubDate>Mon, 14 May 2018 19:39:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-6/</guid><description> 1.1.6 # 解答 # 输出斐波那契数列。
将书中的代码直接实现即可。
代码 # //输出斐波那契数列 var f = 0; var g = 1; for (var i = 0; i &amp;lt;= 15; i++) { Console.WriteLine(f); f = f + g; g = f - g; }</description></item><item><title>1.1.7</title><link>https://alg4.ikesnowy.com/1-1-7/</link><pubDate>Mon, 14 May 2018 19:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-7/</guid><description>1.1.7 # 解答 # 同上题，直接实现即可。
a
3.00009
double计算存在误差，并不精确。
b
499500
1000 + 999 + 998……
c
10000
1000 * 10，外层循环的结束条件为 $2^i &amp;gt;1000$
代码 # static void A() { Console.WriteLine(&amp;#34;a&amp;#34;); var t = 9.0; while (Math.Abs(t - 9.0 / t) &amp;gt; .001) { t = (9.0 / t + t) / 2.0; } Console.WriteLine($&amp;#34;{t:N5}&amp;#34;); // :N5代表保留5位小数，同理可使用N1、N2…… } static void B() { Console.WriteLine(&amp;#34;\nb&amp;#34;); var sum = 0; for (var i = 1; i &amp;lt; 1000; i++) { for (var j = 0; j &amp;lt; i; j++) { sum++; } } Console.</description></item><item><title>1.1.8</title><link>https://alg4.ikesnowy.com/1-1-8/</link><pubDate>Mon, 14 May 2018 20:00:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-8/</guid><description> 1.1.8 # 解答 # b
197
e
代码 # Console.WriteLine(&amp;#39;b&amp;#39;); Console.WriteLine(&amp;#39;b&amp;#39; + &amp;#39;c&amp;#39;); // char 被隐式转为为 int 类型，取 ascii 码 Console.WriteLine((char)(&amp;#39;a&amp;#39; + 4)); // 强制转换后，ascii 码被转换为相应的字符</description></item><item><title>1.1.9</title><link>https://alg4.ikesnowy.com/1-1-9/</link><pubDate>Mon, 14 May 2018 20:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-9/</guid><description> 1.1.9 # 解答 # 有两种方法，要么直接调用库函数，要么用书中给出的代码转换。
代码 # var n = 4; // 1.直接转换 Convert.ToString(int, int) 第一个为要转换的数，第二个为要转换的进制 Console.WriteLine($&amp;#34;{Convert.ToString(n, 2)}&amp;#34;); // 2.转换为二进制数 var s = &amp;#34;&amp;#34;; for (var i = n; i &amp;gt; 0; i /= 2) { s = (i % 2) + s; } Console.WriteLine(s);</description></item><item><title>1.1.10</title><link>https://alg4.ikesnowy.com/1-1-10/</link><pubDate>Mon, 14 May 2018 20:05:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-10/</guid><description> 1.1.10 # 解答 # 变量使用前需要先赋值。
代码 # int[] a; for (var i = 0; i &amp;lt; 10; i++) { // a[i] = i * i; // 不允许使用未赋值的局部变量 } a = new int[10]; for (var i = 0; i &amp;lt; 10; i++) { a[i] = i * i; // 初始化后可用 }</description></item><item><title>1.1.11</title><link>https://alg4.ikesnowy.com/1-1-11/</link><pubDate>Mon, 14 May 2018 20:31:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-11/</guid><description>1.1.11 # 解答 # 注意，二维数组 bool[M, N] 代表 M 行 N 列的布尔数组。
使用二重循环即可实现。
输出使用制表符 ’\t’ 作为分隔。
代码 # var array = new[,] { { true, true }, { false, false }, { true, false } }; PrintArray2D(array); // 打印二维数组 static void PrintArray2D(bool[,] array) { var rows = array.GetLength(0); // 获取行数 var columns = array.GetLength(1); // 获取列数 //输出列号 for (var i = 0; i &amp;lt; columns; i++) { Console.Write($&amp;#34;\t{i + 1}&amp;#34;); } Console.</description></item><item><title>1.1.12</title><link>https://alg4.ikesnowy.com/1-1-12/</link><pubDate>Mon, 14 May 2018 20:55:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-12/</guid><description>1.1.12 # 解答 # 第一个循环初始化数组 {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
第二个循环用相应位置的值作为下标取值，例如：a[0] = a[a[0]] = a[9] = 0
最后结果为：0,1,2,3,4,4,3,2,1,0
代码 # var a = new int[10]; for (var i = 0; i &amp;lt; 10; i++) { a[i] = 9 - i; } // a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} for (var i = 0; i &amp;lt; 10; i++) { a[i] = a[a[i]]; } // a[0] = a[9] = 0; a[1] = a[8] = 1; a[2] = a[7] = 2;.</description></item><item><title>1.1.13</title><link>https://alg4.ikesnowy.com/1-1-13/</link><pubDate>Mon, 14 May 2018 21:00:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-13/</guid><description>1.1.13 # 解答 # 转置输出只需要在二重循环的时候将行、列输出顺序取反即可。
代码 # var m = 2; var n = 3; var array = new int[m, n]; // 新建一个二维数组 for (var i = 0; i &amp;lt; m; i++) { for (var j = 0; j &amp;lt; n; j++) { array[i, j] = i + j; } } Console.WriteLine(&amp;#34;Origin&amp;#34;); PrintArray2D(array, m, n); Console.WriteLine(&amp;#34;Transposed&amp;#34;); PrintArrayTranspose2D(array, m, n); // 转置输出 static void PrintArrayTranspose2D(int[,] array, int rows, int columns) { // 交换行、列输出顺序 for (var i = 0; i &amp;lt; columns; i++) { for (var j = 0; j &amp;lt; rows; j++) { Console.</description></item><item><title>1.1.14</title><link>https://alg4.ikesnowy.com/1-1-14/</link><pubDate>Mon, 14 May 2018 21:01:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-14/</guid><description> 1.1.14 # 解答 # 简单使用 log 的定义逼近即可。
代码 # const int n = 9; Console.WriteLine($&amp;#34;{Lg(n)}&amp;#34;); // 利用循环逼近 n，得到 log2(n) 的值 static int Lg(int n) { const int baseNumber = 2; var pow = 1; var sum = 2; for (pow = 1; sum &amp;lt; n; pow++) { sum *= baseNumber; } return pow - 1; }</description></item><item><title>1.1.15</title><link>https://alg4.ikesnowy.com/1-1-15/</link><pubDate>Mon, 14 May 2018 21:03:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-15/</guid><description>1.1.15 # 解答 # 利用二重循环，查找每个值在数组中出现的次数。
代码 # var a = new int[10]; const int m = 10; for (var i = 0; i &amp;lt; 10; i++) { a[i] = i; } var result = Histogram(a, m); Console.WriteLine($&amp;#34;a.length: {a.Length}&amp;#34;); Console.WriteLine($&amp;#34;sum of result array: {result.Sum()}&amp;#34;); static int[] Histogram(int[] a, int m) { var result = new int[m]; for (var i = 0; i &amp;lt; m; i++) { // 初始化 result[i] = 0; // 遍历数组，计算数组中值为 i 的元素个数 for (var j = 0; j &amp;lt; a.</description></item><item><title>1.1.16</title><link>https://alg4.ikesnowy.com/1-1-16/</link><pubDate>Mon, 14 May 2018 21:23:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-16/</guid><description>1.1.16 # 解答 # 填入代码测试即可。
用字符串拼接的方式展示递归。
代码 # Console.WriteLine($&amp;#34;{ExR1(6)}&amp;#34;); // ExR1(6) = // ExR1(3) + 6 + ExR1(4) + 6 // ExR1(0) + 3 + ExR1(1) + 3 + 6 + ExR1(4) + 6 // &amp;#34;&amp;#34; + 3 + ExR1(-2) + 1 + ExR1(-1) + 1 + 3 + 6 + ExR1(4) + 6 // &amp;#34;&amp;#34; + 3 + &amp;#34;&amp;#34; + 1 + &amp;#34;&amp;#34; + 1 + 3 + 6 + ExR1(4) + 6 // &amp;#34;31136&amp;#34; + ExR1(4) + 6 // .</description></item><item><title>1.1.17</title><link>https://alg4.ikesnowy.com/1-1-17/</link><pubDate>Mon, 14 May 2018 21:57:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-17/</guid><description> 1.1.17 # 解答 # 书中已经给出了解释。
递归时结束条件必须放在递归语句的前面，否则会不断展开而无法结束。
代码 # Console.WriteLine($&amp;#34;{ExR2(6)}&amp;#34;); // 抛出 StackOverflow Exception static string ExR2(int n) { var s = ExR2(n - 3) + n + ExR2(n - 2) + n; // 运行到 ExR2 即展开，不会再运行下一句 if (n &amp;lt;= 0) { return &amp;#34;&amp;#34;; } return s; }</description></item><item><title>1.1.18</title><link>https://alg4.ikesnowy.com/1-1-18/</link><pubDate>Mon, 14 May 2018 21:59:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-18/</guid><description>1.1.18 # 解答 # 其实就是一种快速乘法的实现，换成乘号之后就变成了快速乘幂。
例如对于乘法 $2 \times 4$ ，可以用 $2 + 2 + 2 + 2$ 做四次加法计算；也可以变为 $(2 + 2) \times 2 = (2 + 2) + (2 + 2)$ 的形式，用两次加法就可以完成（先计算 $2 + 2$ 的值，再计算 $4 + 4$ 的值）。
同理对于乘幂 $2^8$ ，既可以用 $2\times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2$ 做 8 次乘法，也可以只用三次乘法就计算出来：
$$ 2^2 = 2 \times 2 \newline 2^4 = 2^2 \times 2^2\newline 2^8 = 2^4 \times 2^4 $$</description></item><item><title>1.1.19</title><link>https://alg4.ikesnowy.com/1-1-19/</link><pubDate>Mon, 14 May 2018 22:09:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-19/</guid><description>1.1.19 # 解答 # 普通的递归算法效率很低，原因是越到后面重复运算的数目越多。
比如：
F(2) = F(1) + F(0)
F(3) = F(2) + F(1) = F(1) + F(1) + F(0)
可以看到 F(1) 被重复计算了两次。
改进的方式是将每次运算的结果保存在数组中，之后计算过的数据直接从数组中提取。
代码 # // long 类型不够大，换成 UINT64 类型 // 用于保存计算结果的数组，UInt64? 代表可以赋值为普通 UInt64 类型的值以及 null 值 var fibnacciResults = new UInt64?[100]; var timer = Stopwatch.StartNew(); for (var n = 0; n &amp;lt; 100; n++) { // 书本中的代码，非常慢，1小时后 n = 50 // Console.WriteLine($&amp;#34;{n} {F(n)}&amp;#34;); // 利用已知结果加速 // 全部计算完毕耗时 84ms Console.</description></item><item><title>1.1.20</title><link>https://alg4.ikesnowy.com/1-1-20/</link><pubDate>Tue, 15 May 2018 11:46:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-20/</guid><description> 1.1.20 # 解答 # 根据对数的性质可以得到：
$$ \ln(N!) = \ln(N) + \ln(N – 1) + \ln(N – 2)… $$
代码 # const int n = 4; Console.WriteLine($&amp;#34;{FactorialLn(n)}&amp;#34;); // ln(N!) = // ln(N * (N - 1) * ... * 1) = // ln(N) + ln((N - 1)!) static double FactorialLn(int n) { if (n == 1) { return 0; } return Math.Log(n) + FactorialLn(n - 1); }</description></item><item><title>1.1.21</title><link>https://alg4.ikesnowy.com/1-1-21/</link><pubDate>Tue, 15 May 2018 11:48:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-21/</guid><description>1.1.21 # 解答 # 实现上没什么难度，打印表格的部分可以参考之前打印二位布尔数组的方法。
注意整型数据之间相除得到的仍然是整型，小数部分会直接舍去，例如 2 / 3 的结果会是 0。
代码 # /* * 输入示例： * * 3 * hi 1 2 * hey 1 3 * hello 1 4 * */ var columns = 2; var rows = int.Parse(Console.ReadLine()); // 行号 var names = new string[rows]; // 姓名 var array = new int[rows, columns]; // 输入的两个整数 var results = new double[rows]; // 计算结果 for (var i = 0; i &amp;lt; rows; i++) { var temp = Console.</description></item><item><title>1.1.22</title><link>https://alg4.ikesnowy.com/1-1-22/</link><pubDate>Tue, 15 May 2018 11:54:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-22/</guid><description> 1.1.22 # 解答 # 按照书中的提示增加一个保存深度的参数。
代码 # var array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; Rank(9, array); static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1, 1); } static int RankInternal(int key, int[] a, int lo, int hi, int number) { for (var i = 0; i &amp;lt; number; i++) { Console.Write(&amp;#34; &amp;#34;); } Console.WriteLine($&amp;#34;{number}: {lo} {hi}&amp;#34;); if (lo &amp;gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key &amp;lt; a[mid]) { return RankInternal(key, a, lo, mid - 1, number + 1); } else if (key &amp;gt; a[mid]) { return RankInternal(key, a, mid + 1, hi, number + 1); } else { return mid; } }</description></item><item><title>1.1.23</title><link>https://alg4.ikesnowy.com/1-1-23/</link><pubDate>Tue, 15 May 2018 11:55:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-23/</guid><description>1.1.23 # 解答 # 在主函数里做一下判断就可以了，加号则输出所有找不到的值，减号则相反。
代码 # // 从largeW.txt中读取数据 var whiteListLines = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var whiteList = new int[whiteListLines.Length]; for (var i = 0; i &amp;lt; whiteListLines.Length; i++) { whiteList[i] = int.Parse(whiteListLines[i]); } Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); // 输入样例：5 824524 478510 387221 var input = Console.ReadLine(); var query = new int[input.Split(&amp;#39; &amp;#39;).Length]; for (var i = 0; i &amp;lt; query.Length; i++) { query[i] = int.Parse(input.Split(&amp;#39; &amp;#39;)[i]); } Console.</description></item><item><title>1.1.24</title><link>https://alg4.ikesnowy.com/1-1-24/</link><pubDate>Tue, 15 May 2018 12:09:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-24/</guid><description> 1.1.24 # 解答 # 在书本中 GCD 的基础上，在函数开始时增加一条输出语句即可。
代码 # Gcd(105, 24); Console.WriteLine(); Gcd(111111, 1234567); static int Gcd(int a, int b) { Console.WriteLine($&amp;#34;{a} {b}&amp;#34;); if (b == 0) { return a; } return Gcd(b, a % b); }</description></item><item><title>1.1.25</title><link>https://alg4.ikesnowy.com/1-1-25/</link><pubDate>Tue, 15 May 2018 12:11:10 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-25/</guid><description>1.1.25 # 解答 # 已知：$a,b$ 皆为正整数，且 $a&amp;gt;b$。$g$ 是 $a,b$ 的最大公约数.
设 $\ r_0=a \bmod b$，$r_1=b \bmod r_0$ ，$r_k = r_{k-2} \bmod\ r_{k-1}$ 。
那么有 $\gcd(a,b)=\gcd(b,r_0)=\gcd(r_0,r_1)&amp;hellip;=\gcd(r_{n-1},r_n)=r_{n-1}$ ，且 $r_n=0$ （此时算法终止），且 $n$ 是有限的。
令 $q_n=\lfloor r_{n-2}/r_{n-1} \rfloor$
有 $r_{n-2}=q_n\times r_{n-1} + r_n=q_n\times r_{n-1}$ （被除数=商✕除数+余数）。
可得 $r_{n-2}$ 能被 $r_{n-1}$ 整除。
则有
$$ \begin{aligned} r_{n-3} &amp;amp;= q_{n-1} \times r_{n-2} + r_{n-1}\newline &amp;amp;=q_{n-1}\times (q_n \times r_{n-1})+r_{n-1}\newline &amp;amp;=q_{n-1}\times q_n \times r_{n-1} + r_{n-1} \newline &amp;amp;=(q_{n-1} \times q_n +1)\times r_{n-1} \end{aligned} $$</description></item><item><title>1.1.26</title><link>https://alg4.ikesnowy.com/1-1-26/</link><pubDate>Tue, 15 May 2018 19:28:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-26/</guid><description>1.1.26 # 解答 # 见代码部分。
代码 # var a = 3; var b = 2; var c = 1; var t = 0; if (a &amp;gt; b) { t = a; a = b; b = t; } // 如果 a &amp;gt; b，那么 a, b 交换，保证b &amp;gt;= a if (a &amp;gt; c) { t = a; a = c; c = t; } // 如果 b &amp;gt;= a &amp;gt; c，那么 a, c 交换，保证 c &amp;gt;= a if (b &amp;gt; c) { t = b; b = c; c = t; } // 如果 b &amp;gt; c &amp;gt;= a，那么 b, c 交换，保证 c &amp;gt;= b Console.</description></item><item><title>1.1.27</title><link>https://alg4.ikesnowy.com/1-1-27/</link><pubDate>Tue, 15 May 2018 19:34:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-27/</guid><description>1.1.27 # 解答 # 与之前的斐波那契数列类似，都是重复计算的问题。
答案是 7751 次。
代码 # var binomialCalled = 0; // 计算递归调用次数 double?[,] binomialCache; // 保存计算结果的数组 binomialCache = new double?[101, 51]; Console.WriteLine(Binomial(100, 50, 0.25)); Console.WriteLine(binomialCalled); double? Binomial(int n, int k, double p) { binomialCalled++; if (n == 0 &amp;amp;&amp;amp; k == 0) return 1.0; if (n &amp;lt; 0 || k &amp;lt; 0) return 0.0; if (binomialCache[n, k] != null) { return binomialCache[n, k]; } binomialCache[n, k] = (1.</description></item><item><title>1.1.28</title><link>https://alg4.ikesnowy.com/1-1-28/</link><pubDate>Tue, 15 May 2018 19:42:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-28/</guid><description>1.1.28 # 解答 # 实现方法有很多，这里是使用一个 HashSet 做中转，删除所有的重复元素。
也可以使用 Linq 里的 Distinct() 方法，
也可以排序后直接遍历一遍，遇到相同的就删除，遇到不同的就保存起来用于之后的比较。
代码 # // 从largeW.txt中读取数据 // 用 HashSet 的不可重复性去除重复 var hashSet = new HashSet&amp;lt;string&amp;gt;(File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;)); var strings = new string[hashSet.Count]; hashSet.CopyTo(strings); var whiteList = new int[strings.Length]; for (var i = 0; i &amp;lt; strings.Length; i++) { whiteList[i] = int.Parse(strings[i]); } Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); // 输入样例：5 824524 478510 387221 var input = Console.ReadLine(); var query = new int[input.</description></item><item><title>1.1.29</title><link>https://alg4.ikesnowy.com/1-1-29/</link><pubDate>Tue, 15 May 2018 19:46:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-29/</guid><description>1.1.29 # 解答 # 查找小于指定值的元素数量可以多次使用二分查找实现。
例如：
序号：0 1 2 3 4 5 6 7 8
元素：1 2 2 2 2 2 2 2 3
二分查找返回 4
再次在 0~3 之间查找
二分查找返回 1
再次在 0~1 之间查找
二分查找返回 -1，没有指定值了
因此小于该值的元素数量就是 1 – 0 = 1 个
用同样的方法可以找到大于指定值的元素个数，
从总数中减去这两个数值就是等于指定值的元素数量。
代码 # var whiteList = new[] { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 }; Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); var input = Console.</description></item><item><title>1.1.30</title><link>https://alg4.ikesnowy.com/1-1-30/</link><pubDate>Tue, 15 May 2018 19:51:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-30/</guid><description>1.1.30 # 解答 # 互质可以用之前的 GCD 最大公因数算法判断，如果最大公因数是 1 则两数互质。
代码 # // 互质 = 最大公约数为 1 = gcd(i, j) == 1 var n = int.Parse(Console.ReadLine()); var a = new bool[n, n]; for (var i = 0; i &amp;lt; n; i++) { for (var j = 0; j &amp;lt; n; j++) { a[i, j] = (Gcd(i, j) == 1); } } PrintArray2D(a, n, n); static int Gcd(int a, int b) { if (b == 0) return a; return Gcd(b, a % b); } static void PrintArray2D(bool[,] array, int rows, int columns) { for (var i = 0; i &amp;lt; rows; i++) { for (var j = 0; j &amp;lt; columns; j++) { Console.</description></item><item><title>1.1.31</title><link>https://alg4.ikesnowy.com/1-1-31/</link><pubDate>Tue, 15 May 2018 19:53:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-31/</guid><description>1.1.31 # 解答 # 概率的实现方法：
例如概率是 60 %，就在 [0, 100) 之间随机一个值，小于等于 60 则执行操作，反之不执行。
需要更精确的情况可以增大随机的范围，例如 [0, 1000)。
绘图结果
N = 10,p = 0.2, 0.5, 1
完整项目可以到 Github 上下载。
代码 # /// &amp;lt;summary&amp;gt; /// 主绘图函数 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;点的总数目&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;每对点之间连接的概率&amp;lt;/param&amp;gt; public static void StartDrawing(int N, double p) { int pointSize = 5;//每个点绘制的大小 int precious = 1000;//概率判断的精度 //新建一个绘图窗口 Form2 DrawPad = new Form2(); //显示绘图窗口 DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.</description></item><item><title>1.1.32</title><link>https://alg4.ikesnowy.com/1-1-32/</link><pubDate>Tue, 15 May 2018 19:57:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-32/</guid><description>1.1.32 # 解答 # 绘图结果：
完整的项目代码可以去 Github 上下载。
代码 # public static void StartDrawing(double[] array, int N, double l, double r) { //创建并显示绘图窗口 Form2 DrawPad = new Form2(); DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, DrawPad.Height); graphics.ScaleTransform(1, -1); //对原始数组排序 Array.Sort(array); //计算各区域的值 int[] counts = new int[N]; int index = 0; for (int i = 0; i &amp;lt; N; ++i) { for (int j = index; j &amp;lt; array.Length; ++j) { if (array[j] &amp;lt;= (r - l) * (i + 1) / N) { counts[i]++; index++; } else { break; } } } //获取最大值 double max = counts.</description></item><item><title>1.1.33</title><link>https://alg4.ikesnowy.com/1-1-33/</link><pubDate>Tue, 15 May 2018 20:01:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-33/</guid><description>1.1.33 # 解答 # 这里矩阵使用交错数组实现（方便取行向量），不是普通的二维数组。
矩阵和矩阵、矩阵和向量、向量和矩阵都使用行向量点乘列向量的方式计算。
代码 # public class Matrix { /// &amp;lt;summary&amp;gt; /// 计算两个向量的点积 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;需要点乘的向量&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;需要点乘的另一个向量&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回点乘的结果&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;FormatException&amp;#34;&amp;gt;&amp;lt;/exception&amp;gt; public static double Dot(double[] x, double[] y) { //确保两向量等长 if (x.Length != y.Length) { throw new FormatException(&amp;#34;the length of two vectors must be equal&amp;#34;); } //点乘 double result = 0; for (int i = 0; i &amp;lt; x.Length; ++i) { result += x[i] * y[i]; } return result; } /// &amp;lt;summary&amp;gt; /// 计算两个矩阵相乘的结果，返回一个矩阵 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;用交错数组表示的 m * p 矩阵&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;b&amp;#34;&amp;gt;用交错数组表示的 p * n 矩阵&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回 m * n 的矩阵&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;FormatException&amp;#34;&amp;gt;&amp;lt;/exception&amp;gt; /// &amp;lt;example&amp;gt; /// a = {(1,2,3),(4,5,6)} /// b = {(1,4),(2,5),(3,6)} /// Mult(a, b) = {(14,32),(32,77)} /// &amp;lt;/example&amp;gt; public static double[][] Mult(double[][] a, double[][] b) { if (a[0].</description></item><item><title>1.1.34</title><link>https://alg4.ikesnowy.com/1-1-34/</link><pubDate>Tue, 15 May 2018 20:18:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-34/</guid><description>1.1.34 # 解答 # 第二个以及最后三个需要，其他都可以设计成过滤器的模式。
这里的 largeW.txt 只需要保留前 100 个数字就可以了，太多的话最后两个测试会刷屏。
代码 # var allNumbers = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var n = allNumbers.Length; var input = new int[n]; for (var i = 0; i &amp;lt; n; i++) { input[i] = int.Parse(allNumbers[i]); } MinAndMax(input); Console.WriteLine(); MidNumber(input); Console.WriteLine(); NumberK(4, input); Console.WriteLine(); SquareSum(input); Console.WriteLine(); AboveAverage(input); Console.WriteLine(); Ascending(input); Console.WriteLine(); Shuffle(input); Console.WriteLine(); static void MinAndMax(int[] input) { // 只用到了两个变量 var min = input[0]; var max = input[0]; // 只对输入值正向遍历一遍，不需要保存 for (var i = 1; i &amp;lt; input.</description></item><item><title>1.1.35</title><link>https://alg4.ikesnowy.com/1-1-35/</link><pubDate>Tue, 15 May 2018 21:04:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-35/</guid><description>1.1.35 # 解答 # 这里用 Random 类模拟掷骰子并计算概率，最后和程序得出的比较。
代码 # // 书中给出的程序 const int sides = 6; var dist = new double[2 * sides + 1]; for (var i = 1; i &amp;lt;= sides; i++) for (var j = 1; j &amp;lt;= sides; j++) dist[i + j] += 1.0; for (var k = 2; k &amp;lt;= 2 * sides; k++) dist[k] /= 36.0; // 不断进行模拟，直至误差小于 0.001 var n = 36; var isAccepted = false; double[] distTemp = null; const double error = 0.</description></item><item><title>1.1.36</title><link>https://alg4.ikesnowy.com/1-1-36/</link><pubDate>Tue, 15 May 2018 21:10:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-36/</guid><description>1.1.36 # 解答 # N 取到 1000 左右数据就比较明显了。
N = 1000， M = 10
代码 # const int m = 10; // 数组大小 const int n = 1000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i &amp;lt; n; i++) { // 初始化 for (var j = 0; j &amp;lt; a.Length; j++) { a[j] = j; } // 打乱 Shuffle(a, i); // 记录 for (var j = 0; j &amp;lt; m; j++) { result[a[j], j]++; } } PrintMatrix(result); static void Shuffle(int[] a, int seed) { var n = a.</description></item><item><title>1.1.37</title><link>https://alg4.ikesnowy.com/1-1-37/</link><pubDate>Tue, 15 May 2018 21:13:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-37/</guid><description>1.1.37 # 解答 # 使用 0~N-1 的随机数会导致每次交换的数字可能相同。
例如：
原数组： 1 2 3 4。
第一次： 2 1 3 4
random = 1，第 0 个和第 1 个交换。
第二次： 1 2 3 4
random = 0，第 1 个和第 0 个交换。
代码 # // 使用 0~N-1 的随机数会导致每次交换的数字可能相同 // 例如： // 原数组： 1 2 3 4 // 第一次： 2 1 3 4 random = 1，第 0 个和第 1 个交换 // 第二次： 1 2 3 4 random = 0，第 1 个和第 0 个交换 const int m = 10; // 数组大小 const int n = 100000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i &amp;lt; n; i++) { // 初始化 for (var j = 0; j &amp;lt; a.</description></item><item><title>1.1.38</title><link>https://alg4.ikesnowy.com/1-1-38/</link><pubDate>Tue, 15 May 2018 21:15:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-38/</guid><description>1.1.38 # 解答 # 为了使差距比较明显，故意取了比较靠后的数字。
代码 # var largeWString = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var largeW = new int[largeWString.Length]; for (var i = 0; i &amp;lt; largeW.Length; i++) { largeW[i] = int.Parse(largeWString[i]); } var timer = Stopwatch.StartNew(); BruteForceSearch(111111, largeW); Console.WriteLine($&amp;#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms&amp;#34;); timer.Restart(); Rank(111111, largeW); Console.WriteLine($&amp;#34;BinarySearch: {timer.ElapsedMilliseconds} ms&amp;#34;); var largeTString = File.ReadAllLines(&amp;#34;largeT.txt&amp;#34;); var largeT = new int[largeTString.Length]; for (var i = 0; i &amp;lt; largeW.Length; i++) { largeT[i] = int.Parse(largeTString[i]); } timer.Restart(); BruteForceSearch(111111, largeT); Console.</description></item><item><title>1.1.39</title><link>https://alg4.ikesnowy.com/1-1-39/</link><pubDate>Tue, 15 May 2018 21:16:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-39/</guid><description>1.1.39 # 解答 # 按照要求编程就好，视机器不同需要的时间也不同。
代码 # // 需要 6 秒左右的运算时间 var r = new Random(); var baseNum = 10; var powNum = 3; var T = 10; var m = 4; var matrix = new double[m, 2]; for (var i = 0; i &amp;lt; m; i++) { var n = (int)Math.Pow(baseNum, powNum + i); double sum = 0; for (var j = 0; j &amp;lt; T; j++) { sum += Test(n, r.</description></item><item><title>1.2.1</title><link>https://alg4.ikesnowy.com/1-2-1/</link><pubDate>Tue, 15 May 2018 21:38:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-1/</guid><description>1.2.1 # 解答 # 这里自己实现了一个 Point2D 类（包含在了 Geometry 库中）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Point2D.java.html。
求最近两点只需要反复调用 Point2D 类中的 DistTo() 方法就可以了。
代码 # Point2D 类 # /// &amp;lt;summary&amp;gt; /// Point2D 二维点类。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;summary&amp;gt; public sealed class Point2D : IComparable&amp;lt;Point2D&amp;gt; { /// 以 X 坐标升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以 X 坐标升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; XOrderComparer = new XOrder(); /// &amp;lt;summary&amp;gt; /// 以 Y 坐标升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以 Y 坐标升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; YOrderComparer = new YOrder(); /// &amp;lt;summary&amp;gt; /// 以极半径升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以极半径升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; ROrderComparer = new ROrder(); /// &amp;lt;summary&amp;gt; /// 二维点的 X 坐标。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;X 坐标。&amp;lt;/value&amp;gt; public double X { get; } /// &amp;lt;summary&amp;gt; /// 二维坐标的 Y 坐标。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;Y 坐标。&amp;lt;/value&amp;gt; public double Y { get; } /// &amp;lt;summary&amp;gt; /// 绘制时点的半径，以像素为单位，默认值为 2。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;点的半径，以像素为单位。&amp;lt;/value&amp;gt; public int Radius { get; set; } /// &amp;lt;summary&amp;gt; /// 构造一个二维点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;点的 X 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;点的 Y 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;当 &amp;lt;paramref name=&amp;#34;x&amp;#34;/&amp;gt; 或 &amp;lt;paramref name=&amp;#34;y&amp;#34;/&amp;gt; 为±无穷时抛出此异常。&amp;lt;/exception&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentNullException&amp;#34;&amp;gt;当 &amp;lt;paramref name=&amp;#34;x&amp;#34;/&amp;gt; 或 &amp;lt;paramref name=&amp;#34;y&amp;#34;/&amp;gt; 为 &amp;lt;see cref=&amp;#34;double.</description></item><item><title>1.2.2</title><link>https://alg4.ikesnowy.com/1-2-2/</link><pubDate>Tue, 15 May 2018 21:47:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-2/</guid><description>1.2.2 # 解答 # 同样实现了一个 Interval1D 类（位于 Geometry 库）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval1D.java.html。
直接调用其中的 Intersect() 方法即可
代码 # Interval1D 类： # /// &amp;lt;summary&amp;gt; /// 一维闭区间。 /// &amp;lt;/summary&amp;gt; public class Interval1D { /// &amp;lt;summary&amp;gt; /// 优先以起点升序排序，起点相同时按照终点升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;优先以起点升序排序，起点相同时按照终点升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; MinOrder = new MinEndpointComparer(); /// &amp;lt;summary&amp;gt; /// 优先以终点升序排序，起点相同时按照起点升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;优先以终点升序排序，起点相同时按照起点升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; MaxOrder = new MaxEndpointComparer(); /// &amp;lt;summary&amp;gt; /// 以区间长度升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以区间长度升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; LengthOrder = new LengthComparer(); /// &amp;lt;summary&amp;gt; /// 区间起点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;区间起点。&amp;lt;/value&amp;gt; /// &amp;lt;remarks&amp;gt;这个属性是只读的。&amp;lt;/remarks&amp;gt; public double Min { get; } /// &amp;lt;summary&amp;gt; /// 区间终点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;区间终点。&amp;lt;/value&amp;gt; /// &amp;lt;remarks&amp;gt;这个属性是只读的。&amp;lt;/remarks&amp;gt; public double Max { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;一维区域的下界。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;一维区域的上界。&amp;lt;/param&amp;gt; public Interval1D(double lo, double hi) { if (double.</description></item><item><title>1.2.3</title><link>https://alg4.ikesnowy.com/1-2-3/</link><pubDate>Tue, 15 May 2018 21:49:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-3/</guid><description>1.2.3 # 解答 # 首先先实现一个 Interval2D 类（位于 Geometry 库），再使用窗体应用程序绘图。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval2D.java.html。
代码 # Interval2D： # /// &amp;lt;summary&amp;gt; /// 二维闭合区间。 /// &amp;lt;/summary&amp;gt; public class Interval2D { private readonly Interval1D _x; private readonly Interval1D _y; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;x 轴上的范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;y 轴上的范围。&amp;lt;/param&amp;gt; public Interval2D(Interval1D x, Interval1D y) { _x = x; _y = y; } /// &amp;lt;summary&amp;gt; /// 判断两个平面是否相交。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;that&amp;#34;&amp;gt;需要判断的另一个平面。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;相交则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public bool Intersects(Interval2D that) { if (!</description></item><item><title>1.2.4</title><link>https://alg4.ikesnowy.com/1-2-4/</link><pubDate>Tue, 15 May 2018 21:51:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-4/</guid><description> 1.2.4 # 解答 # 在 C# 中，这段代码能够完成交换的工作，输出为：
world hello 代码 # var string1 = &amp;#34;hello&amp;#34;; var string2 = string1; string1 = &amp;#34;world&amp;#34;; Console.WriteLine(string1); Console.WriteLine(string2);</description></item><item><title>1.2.5</title><link>https://alg4.ikesnowy.com/1-2-5/</link><pubDate>Tue, 15 May 2018 21:52:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-5/</guid><description> 1.2.5 # 解答 # string 类型中的 Uppercase() 以及 Substring() 都不会改变原有字符串，而是新建一个字符串并返回。
因此输出仍然为 Hello World。
代码 # var s = &amp;#34;Hello World&amp;#34;; s.ToUpper(); s.Substring(6, 5); // C# 中两个参数分别代表子串起始下标和长度 Console.WriteLine(s);</description></item><item><title>1.2.6</title><link>https://alg4.ikesnowy.com/1-2-6/</link><pubDate>Tue, 15 May 2018 21:53:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-6/</guid><description>1.2.6 # 解答 # 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） 其回环变位则为 s' = s2 + s1
显然 s' + s' = s2 + s1 + s2 + s1
即 s' + s' = s2 + s + s1，其中必定包含 s
例如 ABC 和 BCA， BCABCA 显然包含 ABC
代码 # var s1 = &amp;#34;ACTGACG&amp;#34;; var s2 = &amp;#34;TGACGAC&amp;#34;; Console.WriteLine(Circular(s1, s2)); // 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） // 其回环变位则为 s&amp;#39; = s2 + s1 // 显然 s&amp;#39; + s&amp;#39; = s2 + s1 + s2 + s1 // 即 s&amp;#39; + s&amp;#39; = s2 + s + s1，其中必定包含 s // 例如 ABC 和 BCA， BCABCA 显然包含 ABC static bool Circular(string s1, string s2) { return s1.</description></item><item><title>1.2.7</title><link>https://alg4.ikesnowy.com/1-2-7/</link><pubDate>Tue, 15 May 2018 21:55:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-7/</guid><description> 1.2.7 # 解答 # 递归交换字符顺序，最后返回反序的字符串。
Mystery(ABCD) = Mystery(CD) + Mystery(AB) = Mystery(D) + Mystery(C) + Mystery(B) + Mystery(A) = DCBA 代码 # Console.WriteLine(Mystery(&amp;#34;Hello1&amp;#34;)); static string Mystery(string s) { var n = s.Length; if (n &amp;lt;= 1) return s; var a = s.Substring(0, n / 2); var b = s.Substring(n / 2, n - n / 2); return Mystery(b) + Mystery(a); }</description></item><item><title>1.2.8</title><link>https://alg4.ikesnowy.com/1-2-8/</link><pubDate>Tue, 15 May 2018 21:56:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-8/</guid><description>1.2.8 # 解答 # 作用就是交换两个数组。
但在 C# 或 JAVA 中，数组变量实际是数组的一个引用（类似于指针），交换两个引用的效率与数组大小无关（可以理解为只是交换了数组的名字，数组实际内容在内存中的位置没有改变），都是常数时间的。
代码 # // 读取 largeW.txt var allNums = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var n = allNums.Length; var a = new int[n]; var b = new int[n]; // 数组 a 与数组 b 数字顺序相反 for (var i = 0; i &amp;lt; n; i++) { a[i] = int.Parse(allNums[i]); b[n - i - 1] = a[i]; } // 输出前5个数字 Console.WriteLine(&amp;#34;Before Swap&amp;#34;); Console.Write(&amp;#34;a:&amp;#34;); for (var i = 0; i &amp;lt; 5; i++) { Console.</description></item><item><title>1.2.9</title><link>https://alg4.ikesnowy.com/1-2-9/</link><pubDate>Wed, 16 May 2018 07:32:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-9/</guid><description>1.2.9 # 解答 # 首先实现一个 Counter 类，随后使用非递归版本的 BinarySearch，每进行一次 While 循环就让 Counter 加一。
代码 # Counter 类 # class Counter { private readonly string _name; private int _count; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; public Counter(string id) { _name = id; } /// &amp;lt;summary&amp;gt; /// 计数器加一。 /// &amp;lt;/summary&amp;gt; public void Increment() { _count++; } /// &amp;lt;summary&amp;gt; /// 获取当前计数值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Tally() { return _count; } /// &amp;lt;summary&amp;gt; /// 输出形如 “1 counter” 的字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override string ToString() { return _count + &amp;#34; &amp;#34; + _name; } } Main # // 参考 1.</description></item><item><title>1.2.10</title><link>https://alg4.ikesnowy.com/1-2-10/</link><pubDate>Wed, 16 May 2018 08:17:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-10/</guid><description>1.2.10 # 解答 # 在 Counter 类基础上修改即可。
代码 # VisualCounter 类 # internal class VisualCounter { private readonly string _name; private int _count; private readonly int _max; private int _operatorTimes; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;max&amp;#34;&amp;gt;计数器的最大值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;operatorTimes&amp;#34;&amp;gt;计数器的最大操作数。&amp;lt;/param&amp;gt; public VisualCounter(string id, int max, int operatorTimes) { _name = id; _max = max; _operatorTimes = operatorTimes; } /// &amp;lt;summary&amp;gt; /// 计数器加一。 /// &amp;lt;/summary&amp;gt; public bool Increment() { if (_operatorTimes &amp;lt;= 0) return false; if (_count &amp;lt; _max) { _count++; _operatorTimes--; } return true; } /// &amp;lt;summary&amp;gt; /// 计数器减一。 /// &amp;lt;/summary&amp;gt; public bool Decreasement() { if (_operatorTimes &amp;lt;= 0) return false; if (_count &amp;gt; 0) { _count--; _operatorTimes--; } return true; } /// &amp;lt;summary&amp;gt; /// 获取当前计数值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回计数值。&amp;lt;/returns&amp;gt; public int Tally() { return _count; } /// &amp;lt;summary&amp;gt; /// 返回形如 “1 counter” 的字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回形如 “1 counter” 的字符串。&amp;lt;/returns&amp;gt; public override string ToString() { return _count + &amp;#34; &amp;#34; + _name; } /// &amp;lt;summary&amp;gt; /// 绘制计数器的图形。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;g&amp;#34;&amp;gt;画布。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;width&amp;#34;&amp;gt;绘图区宽度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;height&amp;#34;&amp;gt;绘图区高度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;font&amp;#34;&amp;gt;显示的字体。&amp;lt;/param&amp;gt; public void Draw(Graphics g, int width, int height, Font font) { // 空画布 g.</description></item><item><title>1.2.11</title><link>https://alg4.ikesnowy.com/1-2-11/</link><pubDate>Wed, 16 May 2018 08:25:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-11/</guid><description>1.2.11 # 解答 # 在构造函数开始时做一次判断，非法时抛出异常。
首先建立一个数组，数组的第 1 项至第 12 项的值就是每个月的天数。
再声明一个布尔类型的变量，用于标记是否是闰年。
代码 # internal class SmartDate { public int Month { get; } // 月 public int Day { get; } // 日 public int Year { get; } // 年 // 每个月对应的天数，第 0 位空出来 private static readonly int[] DayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public SmartDate(int m, int d, int y) { if (Vaildation(m, d, y) == false) throw new FormatException(&amp;#34;Invaild Date&amp;#34;); Month = m; Day = d; Year = y; } private bool Vaildation(int m, int d, int y) { if (y &amp;lt; 0) return false; var isLeapYear = IsLeapYear(y); if (m &amp;gt; 12 || m &amp;lt; 1) return false; if (d &amp;lt; 0) return false; if (m == 2 &amp;amp;&amp;amp; d &amp;gt; 29 &amp;amp;&amp;amp; isLeapYear) return false; if (d &amp;gt; DayOfMonth[m]) return false; return true; } private bool IsLeapYear(int y) { if (y % 400 == 0) return true; if (y % 100 !</description></item><item><title>1.2.12</title><link>https://alg4.ikesnowy.com/1-2-12/</link><pubDate>Wed, 16 May 2018 08:29:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-12/</guid><description>1.2.12 # 解答 # 这里使用蔡勒公式来推算星期。
参考：http://www.cnblogs.com/mq0036/p/3534314.html
代码 # /// &amp;lt;summary&amp;gt; /// 计算当前日期是星期几，返回对应的星期名称。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public string DayOfTheWeek() { var d = Day; var m = Month; var y = Year; if (m &amp;lt; 3) { m += 12; y--; } // 使用蔡勒公式计算，参见 http://www.cnblogs.com/mq0036/p/3534314.html var w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return DayOfWeek[w]; } 另请参阅 # 蔡勒公式-维基百科</description></item><item><title>1.2.13</title><link>https://alg4.ikesnowy.com/1-2-13/</link><pubDate>Wed, 16 May 2018 08:33:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-13/</guid><description>1.2.13 # 解答 # 直接实现即可。
JAVA 版本可以参考：http://algs4.cs.princeton.edu/12oop/Transaction.java.html。
代码 # public class Transaction : IComparable&amp;lt;Transaction&amp;gt; { /// &amp;lt;summary&amp;gt; /// 客户姓名。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;客户姓名。&amp;lt;/value&amp;gt; public string Who { get; } /// &amp;lt;summary&amp;gt; /// 交易日期。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;交易日期。&amp;lt;/value&amp;gt; /// &amp;lt;seealso cref=&amp;#34;Date&amp;#34;/&amp;gt; public Date When { get; } /// &amp;lt;summary&amp;gt; /// 交易金额。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;交易金额。&amp;lt;/value&amp;gt; public double Amount { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { var a = transaction.</description></item><item><title>1.2.14</title><link>https://alg4.ikesnowy.com/1-2-14/</link><pubDate>Wed, 16 May 2018 08:36:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-14/</guid><description>1.2.14 # 解答 # 上一题中的代码已经包含了对 Equals() 方法的实现。
代码 # /// &amp;lt;summary&amp;gt; /// 比较两笔交易是否相同。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;obj&amp;#34;&amp;gt;另一个对象。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Transaction)obj; return Math.Abs(that.Amount - Amount) &amp;lt; float.Epsilon * 5 &amp;amp;&amp;amp; that.When.Equals(When) &amp;amp;&amp;amp; that.Who == Who; } 另请参阅 # Commercial 库</description></item><item><title>1.2.15</title><link>https://alg4.ikesnowy.com/1-2-15/</link><pubDate>Wed, 16 May 2018 08:38:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-15/</guid><description> 1.2.15 # 解答 # 这里我们基于 File.ReadAllLines() 进行实现。
代码 # static int[] ReadInts(string path) { var allLines = File.ReadAllLines(path); var result = new int[allLines.Length]; for (var i = 0; i &amp;lt; allLines.Length; i++) { result[i] = int.Parse(allLines[i]); } return result; }</description></item><item><title>1.2.16</title><link>https://alg4.ikesnowy.com/1-2-16/</link><pubDate>Wed, 16 May 2018 08:39:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-16/</guid><description>1.2.16 # 解答 # JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Rational.java.html
欧几里得算法仅适用于正整数，使用前需要注意。
用欧几里得算法找到公因子之后直接化简即可。
代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNegative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { _isNegative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { _isNegative = true; } else { _isNegative = false; } var gcd = Gcd(Math.</description></item><item><title>1.2.17</title><link>https://alg4.ikesnowy.com/1-2-17/</link><pubDate>Wed, 16 May 2018 08:40:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-17/</guid><description>1.2.17 # 解答 # 在 C# 中使用 checked 关键字包裹整数运算的代码即可自动检查溢出。
在 JAVA 中可以考虑在运算前控制运算数的大小。
例如 a + b 之前保证 long.MaxValue – b &amp;gt;= a 等等。
代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNagative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { _isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { _isNagative = true; } else { _isNagative = false; } var gcd = Gcd(Math.</description></item><item><title>1.2.18</title><link>https://alg4.ikesnowy.com/1-2-18/</link><pubDate>Wed, 16 May 2018 08:44:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-18/</guid><description>1.2.18 # 解答 # 当数据比较大时—— 例如 10^9 加上随机小数组成的数列，这时 double 的小数精度将受限。
求和之后整数部分更大，小数部分将自动四舍五入，出现误差
这时再计算平均值时将会带来较大的误差。
因此采用另一个递推公式：
k 为下标。
$M_k = M_{k-1}+ (x_k – M_{k-1})/k$
$S_k = S_{k-1} + (x_k – M_{k-1})\times(x_k – M_k)$.
方差 $s^2 = S_k/(k – 1)$.
这种情况下并没有直接对所有输入值求和，小数精度不会过多受到整数部分长度的影响。
有关这两个公式的证明可以参考这篇论文，或者去查看我的知乎回答。
代码 # public class Accumulator { private double _m; private double _s; private int _n; public void AddDataValue(double x) { _n++; _s = _s + 1.0 * (_n - 1) / _n * (x - _m) * (x - _m); _m = _m + (x - _m) / _n; } public double Mean() { return _m; } public double Var() { return _s / (_n - 1); } public double Stddev() { return Math.</description></item><item><title>1.2.19</title><link>https://alg4.ikesnowy.com/1-2-19/</link><pubDate>Wed, 16 May 2018 08:48:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-19/</guid><description>1.2.19 # 解答 # 之前的 Date 和 Transaction 已经包含了这些实现。
代码 # Date # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;date&amp;#34;&amp;gt;形如 &amp;#34;05/31/2017&amp;#34; 的字符串。&amp;lt;/param&amp;gt; public Date(string date) { string[] a = date.Split(&amp;#39;/&amp;#39;); if (a.Length != 3) throw new ArgumentException(&amp;#34;Illgal Date&amp;#34;); Month = int.Parse(a[0]); Day = int.Parse(a[1]); Year = int.Parse(a[2]); } Transaction # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { string[] a = transaction.</description></item><item><title>1.3.1</title><link>https://alg4.ikesnowy.com/1-3-1/</link><pubDate>Wed, 16 May 2018 09:02:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-1/</guid><description>1.3.1 # 解答 # 首先是 FixedCapacityStackOfStrings 类，官方 JAVA 版本参考：FixedCapacityStackOfStrings.java
IsFull() 的实现比较简单，判断 N 与数组长度是否相等即可。
代码 # internal class FixedCapacityStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private readonly string[] _a; private int _n; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfStrings(int capacity) { _a = new string[capacity]; _n = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _n == 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _n == _a.</description></item><item><title>1.3.2</title><link>https://alg4.ikesnowy.com/1-3-2/</link><pubDate>Wed, 16 May 2018 09:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-2/</guid><description>1.3.2 # 解答 # 首先是 Stack&amp;lt;&amp;gt; 类的实现，官方 JAVA 版本参考：Stack.java
输出内容：was best times of the was the it
代码 # /// &amp;lt;summary&amp;gt; /// 栈类（链表实现）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;栈中存放的元素类型。&amp;lt;/typeparam&amp;gt; public class Stack&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _first; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Stack() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 复制构造函数，链表中的元素都是浅拷贝。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;用于复制的栈。&amp;lt;/param&amp;gt; public Stack(Stack&amp;lt;TItem&amp;gt; s) { if (s.</description></item><item><title>1.3.3</title><link>https://alg4.ikesnowy.com/1-3-3/</link><pubDate>Wed, 16 May 2018 09:06:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-3/</guid><description> 1.3.3 # 解答 # 这个问题的通用解法见习题 1.3.46 的解答。
第 2、6、7 个不可能产生，可以画个栈模拟一下。
第 2 个
​ 输出数 栈内数 4 0~3 6 0~3 + 5 8 0~3 + 5 + 7 7 0~3 + 5 5 0~3 3 0~2 2 0~1 9 0~1 0 Error 第 6 个
输出数 栈内数 0 null 4 1~3 6 1~3 + 5 5 1~3 3 1~2 8 1~2 + 7 1 Error 第 7 个
输出数 栈内数 1 0 4 0 + 2~3 7 0 + 2~3 + 5~6 9 0 + 2~3 + 5~6 + 8 8 0 + 2~3 + 5~6 6 0 + 2~3 + 5 5 0 + 2~3 3 0 + 2 0 Error</description></item><item><title>1.3.4</title><link>https://alg4.ikesnowy.com/1-3-4/</link><pubDate>Wed, 16 May 2018 09:07:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-4/</guid><description>1.3.4 # 解答 # 官方 JAVA 版本参考：Parentheses.java。
遇到左括号就入栈，遇到右括号就检查是否和栈顶的左括号匹配，如果匹配则弹栈，否则返回 false。
结束时如果栈不为空则返回 false，否则返回 true。
代码 # var input = &amp;#34;[()]{}{[()()]()}&amp;#34;; Console.WriteLine(IsBalanced(input)); var input2 = &amp;#34;[(])&amp;#34;; Console.WriteLine(IsBalanced(input2)); static bool IsBalanced(string input) { var stack = new Stack&amp;lt;char&amp;gt;(); foreach (var i in input) { if (i == &amp;#39;(&amp;#39; || i == &amp;#39;[&amp;#39; || i == &amp;#39;{&amp;#39;) stack.Push(i); else { if (stack.Peek() == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; i == &amp;#39;)&amp;#39;) stack.Pop(); else if (stack.Peek() == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; i == &amp;#39;}&amp;#39;) stack.</description></item><item><title>1.3.5</title><link>https://alg4.ikesnowy.com/1-3-5/</link><pubDate>Wed, 16 May 2018 09:09:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-5/</guid><description>1.3.5 # 解答 # 实际上是用除二取余法求一个十进制数的二进制形式。
代码 # var n = 50; var stack = new Stack&amp;lt;int&amp;gt;(); while (n &amp;gt; 0) { stack.Push(n % 2); n = n / 2; } foreach (var d in stack) { Console.WriteLine(d); } Console.WriteLine(); 另请参阅 # Generics 库</description></item><item><title>1.3.6</title><link>https://alg4.ikesnowy.com/1-3-6/</link><pubDate>Wed, 16 May 2018 09:10:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-6/</guid><description>1.3.6 # 解答 # 利用一个栈对队列元素进行反序操作。
先把队列中的元素全部入栈，再依次弹出并加入队列中。
代码 # var q = new Queue&amp;lt;string&amp;gt;(); q.Enqueue(&amp;#34;first&amp;#34;); q.Enqueue(&amp;#34;second&amp;#34;); q.Enqueue(&amp;#34;third&amp;#34;); q.Enqueue(&amp;#34;fourth&amp;#34;); var stack = new Stack&amp;lt;string&amp;gt;(); while (!q.IsEmpty()) stack.Push(q.Dequeue()); while (!stack.IsEmpty()) q.Enqueue(stack.Pop()); Console.WriteLine(q.ToString()); 另请参阅 # Generics 库</description></item><item><title>1.3.7</title><link>https://alg4.ikesnowy.com/1-3-7/</link><pubDate>Wed, 16 May 2018 09:11:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-7/</guid><description> 1.3.7 # 解答 # 链表实现的话就是返回第一个结点 first 的 item 字段。
数组实现的话就是返回 first 对应的数组元素。
这里给出链表实现，完整实现见习题 1.3.2 的代码。
代码 # /// &amp;lt;summary&amp;gt; /// 返回栈顶元素（但不弹出它）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Stack Underflow&amp;#34;); return this.first.item; }</description></item><item><title>1.3.8</title><link>https://alg4.ikesnowy.com/1-3-8/</link><pubDate>Wed, 16 May 2018 09:12:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-8/</guid><description>1.3.8 # 解答 # 首先是 DoublingStackOfStrings 类，据我猜测应该是用数组实现的栈，扩容时长度增加一倍，缩短时长度减小一半。
官方 JAVA 代码参考：FixedCapacityStackOfString.java。
代码 # DoublingStackOfStrings 类 # /// &amp;lt;summary&amp;gt; /// 容量自动加倍的字符串栈。 /// &amp;lt;/summary&amp;gt; internal class DoublingStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private string[] _items; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个字符串栈。 /// &amp;lt;/summary&amp;gt; public DoublingStackOfStrings() { _items = new string[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回栈中字符串的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向栈中压入一个字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(string s) { if (_count == _items.</description></item><item><title>1.3.9</title><link>https://alg4.ikesnowy.com/1-3-9/</link><pubDate>Wed, 16 May 2018 09:18:49 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-9/</guid><description>1.3.9 # 解答 # 在计算中序表达式算法的基础上做修改。
压入数字时将该数字所在的位置也一并压入。
弹出数字进行运算时在位置靠前的数字前加上左括号。
A + B ) * C + D ) ) 为例。
A 压入栈中并记录位置 。
&amp;lsquo;+&amp;rsquo; 压入栈中。
B 压入栈中并记录位置。
) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置。
&amp;lsquo;*&amp;rsquo; 压入栈中。
C 压入栈中并记录位置。
&amp;lsquo;+&amp;rsquo; 压入栈中。
D 压入栈中并记录位置。
) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置。
) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。
代码 # var input = &amp;#34;1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )&amp;#34;; var operators = new Stack&amp;lt;char&amp;gt;(); var numbers = new Stack&amp;lt;Number&amp;gt;(); var leftBrackets = new int[input.</description></item><item><title>1.3.10</title><link>https://alg4.ikesnowy.com/1-3-10/</link><pubDate>Thu, 17 May 2018 20:53:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-10/</guid><description>1.3.10 # 解答 # 官方 JAVA 代码：InfixToPostfix.java。
其实就是把右括号换成相应运算符
对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出
结果 A B +，变成后序表达式
代码 # // 其实就是把右括号换成相应运算符 // 对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出 // 结果 A B +，变成后序表达式 var stack = new Stack&amp;lt;string&amp;gt;(); var input = &amp;#34;( 1 + ( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) ) )&amp;#34;.Split(&amp;#39; &amp;#39;); foreach (var n in input) { if (n == &amp;#34; &amp;#34;) { continue; } if (n == &amp;#34;+&amp;#34; || n == &amp;#34;-&amp;#34; || n == &amp;#34;*&amp;#34; || n == &amp;#34;/&amp;#34;) { stack.</description></item><item><title>1.3.11</title><link>https://alg4.ikesnowy.com/1-3-11/</link><pubDate>Thu, 17 May 2018 20:57:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-11/</guid><description>1.3.11 # 解答 # 官方 JAVA 代码：EvaluatePostfix.java。
遇到数字就入栈，遇到运算符就弹出两个数字运算，再把结果入栈。
如果倒着读取的话也可以用递归做，当作前序表达式计算即可。
代码 # var stack = new Stack&amp;lt;int&amp;gt;(); var input = &amp;#34;7 16 * 5 + 16 * 3 + 16 * 1 +&amp;#34;.Split(&amp;#39; &amp;#39;); foreach (var n in input) { if (n == &amp;#34; &amp;#34;) { continue; } if (n == &amp;#34;+&amp;#34;) { stack.Push(stack.Pop() + stack.Pop()); } else if (n == &amp;#34;-&amp;#34;) { var temp = stack.Pop(); stack.Push(stack.Pop() - temp); } else if (n == &amp;#34;*&amp;#34;) { stack.</description></item><item><title>1.3.12</title><link>https://alg4.ikesnowy.com/1-3-12/</link><pubDate>Thu, 17 May 2018 21:00:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-12/</guid><description>1.3.12 # 解答 # 先用 foreach 语句遍历一遍栈，把所有元素都压入一个临时栈中。
此时临时栈变成了源栈的一个倒序副本。
再将临时栈中的元素依次压入目标栈中，就得到了源栈的一个副本。
代码 # var src = new Stack&amp;lt;string&amp;gt;(); src.Push(&amp;#34;first&amp;#34;); src.Push(&amp;#34;second&amp;#34;); src.Push(&amp;#34;third&amp;#34;); var des = CopyTo(src); while (!des.IsEmpty()) { Console.WriteLine(des.Pop()); } static Stack&amp;lt;string&amp;gt; CopyTo(Stack&amp;lt;string&amp;gt; src) { var des = new Stack&amp;lt;string&amp;gt;(); var temp = new Stack&amp;lt;string&amp;gt;(); foreach (var s in src) { temp.Push(s); } while (!temp.IsEmpty()) { des.Push(temp.Pop()); } return des; } 另请参阅 # Generics 库</description></item><item><title>1.3.13</title><link>https://alg4.ikesnowy.com/1-3-13/</link><pubDate>Thu, 17 May 2018 21:03:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-13/</guid><description>1.3.13 # 解答 # 除了第一个以外都不可能。
根据题意，0 一定是最先入列的。
那么根据队列的特性，0 一定是最先出列的，因此除第一个以外其他几个序列都不可能。</description></item><item><title>1.3.14</title><link>https://alg4.ikesnowy.com/1-3-14/</link><pubDate>Thu, 17 May 2018 21:45:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-14/</guid><description>1.3.14 # 解答 # 对于 ResizingArrayQueueOfStrings 类，给出官方 JAVA 代码参考：ResizingArrayQueue.java。
代码 # ResizingArrayQueue 类 # /// &amp;lt;summary&amp;gt; /// 可变长度的队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; internal class ResizingArrayQueueOfStrings&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _q; private int _count; private int _first; private int _last; public ResizingArrayQueueOfStrings() { _q = new TItem[2]; _count = 0; _first = 0; } public bool IsEmpty() { return _count == 0; } public int Size() { return _count; } private void Resize(int capacity) { if (capacity &amp;lt; 0) throw new ArgumentException(&amp;#34;capacity should be above zero&amp;#34;); var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _q[(_first + i) % _q.</description></item><item><title>1.3.15</title><link>https://alg4.ikesnowy.com/1-3-15/</link><pubDate>Thu, 17 May 2018 21:47:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-15/</guid><description>1.3.15 # 解答 # 方法有很多，只要把所有输入保存，之后算出倒数第 k 个是正数第几个就可以了。
这里先全部入队，之后算出是正数第几个，再把前面的元素全部出队，剩下的第一个就是要求的元素了。
代码 # var queue = new Queue&amp;lt;string&amp;gt;(); var input = &amp;#34;1 2 3 4 5 6 7 8 9 10&amp;#34;.Split(&amp;#39; &amp;#39;); var k = 4; foreach (var s in input) { queue.Enqueue(s); } var count = queue.Size() - k; for (var i = 0; i &amp;lt; count; i++) { queue.Dequeue(); } Console.WriteLine(queue.Peek()); 另请参阅 # Generics 库</description></item><item><title>1.3.16</title><link>https://alg4.ikesnowy.com/1-3-16/</link><pubDate>Thu, 17 May 2018 21:49:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-16/</guid><description> 1.3.16 # 解答 # 在习题 1.2.19 里已经写好了接受字符串作为参数构造函数
这里只要把所有字符串读入并调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入按行读取所有日期，返回一个日期数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Date[] ReadDates() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Date[] d = new Date[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { d[i] = new Date(input[i]); } return d; }</description></item><item><title>1.3.17</title><link>https://alg4.ikesnowy.com/1-3-17/</link><pubDate>Thu, 17 May 2018 21:50:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-17/</guid><description> 1.3.17 # 解答 # 和前一题类似，按行读取输入再调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入中按行读取所有交易信息，返回一个 Transaction 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Transaction[] ReadTransactions() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Transaction[] t = new Transaction[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { t[i] = new Transaction(input[i]); } return t; }</description></item><item><title>1.3.18</title><link>https://alg4.ikesnowy.com/1-3-18/</link><pubDate>Thu, 17 May 2018 21:51:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-18/</guid><description>1.3.18 # 解答 # 删除该结点的下一个结点。
如下图，没有任何结点指向 y 结点，失去了所有引用的 y 结点会被 GC 清理掉。
代码 # var x = new Node&amp;lt;string&amp;gt;(); x.Item = &amp;#34;first&amp;#34;; var y = new Node&amp;lt;string&amp;gt;(); y.Item = &amp;#34;second&amp;#34;; x.Next = y; var z = new Node&amp;lt;string&amp;gt;(); z.Item = &amp;#34;third&amp;#34;; y.Next = z; Console.WriteLine(&amp;#34;x: &amp;#34; + x.Item); Console.WriteLine(&amp;#34;x.next: &amp;#34; + x.Next.Item); x.Next = x.Next.Next; Console.WriteLine(); Console.WriteLine(&amp;#34;x: &amp;#34; + x.Item); Console.WriteLine(&amp;#34;x.next: &amp;#34; + x.Next.Item); 另请参阅 # Generics 库</description></item><item><title>1.3.19</title><link>https://alg4.ikesnowy.com/1-3-19/</link><pubDate>Thu, 17 May 2018 21:53:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-19/</guid><description>1.3.19 # 解答 # 建立一个结点引用 Cur，让它移动到尾结点的前一个结点，让那个结点的 next 变为 null。
代码 # var first = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;first&amp;#34; }; var second = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;second&amp;#34; }; var third = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;third&amp;#34; }; first.Next = second; second.Next = third; third.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.Next; } DeleteLast(first); Console.WriteLine(); current = first; while (current !</description></item><item><title>1.3.20</title><link>https://alg4.ikesnowy.com/1-3-20/</link><pubDate>Fri, 18 May 2018 13:17:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-20/</guid><description>1.3.20 # 解答 # 和上一题类似，只不过这次让 Cur 移动 k – 1 次即可。
代码 # /// &amp;lt;summary&amp;gt; /// 删除指定位置的元素，返回该元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;index&amp;#34;&amp;gt;需要删除元素的位置。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Delete(int index) { if (index &amp;gt;= this.count) { throw new IndexOutOfRangeException(); } Node&amp;lt;Item&amp;gt; front = this.first; Item temp = this.first.item; if (index == 0) { this.first = this.first.next; return temp; } for (int i = 1; i &amp;lt; index; ++i) { front = front.</description></item><item><title>1.3.21</title><link>https://alg4.ikesnowy.com/1-3-21/</link><pubDate>Fri, 18 May 2018 13:28:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-21/</guid><description>1.3.21 # 解答 # 遍历整条链表，方法和前两题类似，用一个结点引用 Cur 去访问就可以了。
代码 # var link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); Console.WriteLine(Find(link, &amp;#34;second&amp;#34;)); Console.WriteLine(Find(link, &amp;#34;fourth&amp;#34;)); static bool Find&amp;lt;TItem&amp;gt;(LinkedList&amp;lt;TItem&amp;gt; link, TItem key) { foreach (var i in link) { if (i.Equals(key)) { return true; } } return false; } 另请参阅 # Generics 库</description></item><item><title>1.3.22</title><link>https://alg4.ikesnowy.com/1-3-22/</link><pubDate>Fri, 18 May 2018 13:30:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-22/</guid><description>1.3.22 # 解答 # 在 x 之后插入 t，如下图所示。
代码 # // 将 t 插入到 x 之后 var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.</description></item><item><title>1.3.23</title><link>https://alg4.ikesnowy.com/1-3-23/</link><pubDate>Fri, 18 May 2018 13:32:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-23/</guid><description>1.3.23 # 解答 # 由于先后问题，y 在第一句代码执行完毕之后无法访问，t 的 next 会指向自己。
代码 # // x.next = t x 的下一个是 t // t.next = x.next t 的下一个和 x 的下一个相同（也就是 t） // 于是 t.next = t, 遍历会出现死循环。 var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.</description></item><item><title>1.3.24</title><link>https://alg4.ikesnowy.com/1-3-24/</link><pubDate>Fri, 18 May 2018 13:34:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-24/</guid><description>1.3.24 # 解答 # 直接把该节点的 next 域设为 null，后续元素就会因无法访问而被清理掉。
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.</description></item><item><title>1.3.25</title><link>https://alg4.ikesnowy.com/1-3-25/</link><pubDate>Fri, 18 May 2018 13:36:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-25/</guid><description>1.3.25 # 解答 # 见练习 1.3.22，加入一些对边界情况的处理即可。
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; first.Next = second; second.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.Next; } InsertAfter(second, third); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.</description></item><item><title>1.3.26</title><link>https://alg4.ikesnowy.com/1-3-26/</link><pubDate>Fri, 18 May 2018 16:28:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-26/</guid><description>1.3.26 # 解答 # 之前已经写过了删除指定结点（习题 1.3.20）和查找指定结点（习题 1.3.21），结合使用即可。
代码 # var link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); link.Insert(&amp;#34;third&amp;#34;, 3); link.Insert(&amp;#34;third&amp;#34;, 4); Console.WriteLine(link); Remove(link, &amp;#34;third&amp;#34;); Console.WriteLine(link); static void Remove(LinkedList&amp;lt;string&amp;gt; link, string key) { for (var i = 0; i &amp;lt; link.Size(); i++) { if (link.Find(i) == key) { link.Delete(i); i--; } } } 另请参阅 # Generics 库</description></item><item><title>1.3.27</title><link>https://alg4.ikesnowy.com/1-3-27/</link><pubDate>Fri, 18 May 2018 16:31:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-27/</guid><description>1.3.27 # 解答 # 遍历一遍即可。
代码 # var first = new Node&amp;lt;int&amp;gt;(); var second = new Node&amp;lt;int&amp;gt;(); var third = new Node&amp;lt;int&amp;gt;(); var fourth = new Node&amp;lt;int&amp;gt;(); first.Item = 1; second.Item = 2; third.Item = 3; fourth.Item = 4; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; Console.WriteLine(&amp;#34;Max:&amp;#34; + Max(first)); static int Max(Node&amp;lt;int&amp;gt; first) { var max = 0; var current = first; while (current !</description></item><item><title>1.3.28</title><link>https://alg4.ikesnowy.com/1-3-28/</link><pubDate>Fri, 18 May 2018 16:32:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-28/</guid><description>1.3.28 # 解答 # 其实链表本身就是一个递归结构，链表的定义可以用递归的方式表示：
链表 = 头结点A + 链表B = 头结点A + 头结点B + 链表C……
所以 Max() 可以这么写：
Max(Node&amp;lt;Item&amp;gt; Cur, int nowmax) 如果 Cur 为空，则直接返回 nowmax。 否则检查 Cur 结点的值是否大于目前找到的最大值 nowmax。 如果不大于，继续查找下一个结点，返回 Max(Cur.next, nowmax) 否则，把 nowmax 修改为当前结点的值，继续查找，返回 Max(Cur.next, Cur.item) 代码 # var first = new Node&amp;lt;int&amp;gt;(); var second = new Node&amp;lt;int&amp;gt;(); var third = new Node&amp;lt;int&amp;gt;(); var fourth = new Node&amp;lt;int&amp;gt;(); first.Item = 1; second.Item = 2; third.Item = 3; fourth.</description></item><item><title>1.3.29</title><link>https://alg4.ikesnowy.com/1-3-29/</link><pubDate>Fri, 18 May 2018 16:35:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-29/</guid><description>1.3.29 # 解答 # 其实就是一个长这样的链表：
显然说 first 和最后一个节点的指针重复了，所以我们只需要保留 last 的指针就行了。
入队（注意顺序）
出队
代码 # Queue.cs # /// &amp;lt;summary&amp;gt; /// 队列类。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中存放的元素。&amp;lt;/typeparam&amp;gt; public class Queue&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Queue() { _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _last == null; } /// &amp;lt;summary&amp;gt; /// 返回队列中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 返回队列中的第一个元素（但不让它出队）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Queue underflow&amp;#34;); return _last.</description></item><item><title>1.3.30</title><link>https://alg4.ikesnowy.com/1-3-30/</link><pubDate>Fri, 18 May 2018 16:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-30/</guid><description>1.3.30 # 解答 # 书中给出了代码，这里说一下递归的实现。
如果说一个链表除了第一个结点剩下的都已经反转了，那么我们就只要把该结点插入到最后就行了（也就是原先的第二个结点之后）。
像这样：
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.Next; } first = Reverse(first); Console.</description></item><item><title>1.3.31</title><link>https://alg4.ikesnowy.com/1-3-31/</link><pubDate>Fri, 18 May 2018 16:56:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-31/</guid><description>1.3.31 # 解答 # 双向链表的插入有顺序，务必当心。
双向链表长这样（似乎有一种画法是把空指针画成“接地”的样子）：
删除中间那个：
再插回去：
原则是不要让有用的结点变得无法访问。
代码 # DoubleNode&amp;lt;&amp;gt; # /// &amp;lt;summary&amp;gt; /// 双向链表。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;链表中要存放的元素。&amp;lt;/typeparam&amp;gt; public class DoubleLinkList&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Prev; public DoubleNode&amp;lt;T&amp;gt; Next; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一条双向链表。 /// &amp;lt;/summary&amp;gt; public DoubleLinkList() { _first = null; _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查链表是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回链表中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 在表头插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void InsertFront(TItem item) { var node = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Next = _first, Prev = null }; if (_first !</description></item><item><title>1.3.32</title><link>https://alg4.ikesnowy.com/1-3-32/</link><pubDate>Fri, 18 May 2018 17:00:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-32/</guid><description>1.3.32 # 解答 # 在队列的基础上增加一个在队首插入元素的方法即可。
代码 # Steque.cs # /// &amp;lt;summary&amp;gt; /// Steque。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;Steque 中要存放的元素。&amp;lt;/typeparam&amp;gt; public class Steque&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _first; private Node&amp;lt;TItem&amp;gt; _last; private int _count; private class Node&amp;lt;T&amp;gt; { public T Item; public Node&amp;lt;T&amp;gt; Next; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Steque() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回栈内元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 将一个元素压入栈中。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要压入栈中的元素。&amp;lt;/param&amp;gt; public void Push(TItem item) { var oldFirst = _first; _first = new Node&amp;lt;TItem&amp;gt;(); _first.</description></item><item><title>1.3.33</title><link>https://alg4.ikesnowy.com/1-3-33/</link><pubDate>Fri, 18 May 2018 17:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-33/</guid><description>1.3.33 # 解答 # 动态数组这里要注意 first 不要小于零。
代码 # Deque 类 # /// &amp;lt;summary&amp;gt; /// 双端队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; public class Deque&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Next; public DoubleNode&amp;lt;T&amp;gt; Prev; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _first = null; _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回队列中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向左端添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要添加的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.</description></item><item><title>1.3.34</title><link>https://alg4.ikesnowy.com/1-3-34/</link><pubDate>Fri, 18 May 2018 17:06:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-34/</guid><description>1.3.34 # 解答 # 在初始化迭代器的时候随机生成一个访问序列，
之后按照这个访问序列进行迭代即可。
代码 # RandomBag.cs # /// &amp;lt;summary&amp;gt; /// 随机背包。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;背包中要存放的元素。&amp;lt;/typeparam&amp;gt; public class RandomBag&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _bag; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一个随机背包。 /// &amp;lt;/summary&amp;gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查背包是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回背包中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向背包中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向背包中添加的元素。&amp;lt;/param&amp;gt; public void Add(TItem item) { if (_count == _bag.</description></item><item><title>1.3.35</title><link>https://alg4.ikesnowy.com/1-3-35/</link><pubDate>Fri, 18 May 2018 17:15:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-35/</guid><description>1.3.35 # 解答 # 事实上只需要在普通队列的基础上稍作修改就可以了。
出队时先随机选择一个元素，之后让它和最开始的元素做交换，之后正常出队即可。
代码 # RandomQueue.cs # /// &amp;lt;summary&amp;gt; /// 随机队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; public class RandomQueue&amp;lt;TItem&amp;gt; { private TItem[] _queue; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配内存空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { if (capacity &amp;lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// &amp;lt;summary&amp;gt; /// 向队列中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向队列中添加的元素。&amp;lt;/param&amp;gt; public void Enqueue(TItem item) { if (_queue.</description></item><item><title>1.3.36</title><link>https://alg4.ikesnowy.com/1-3-36/</link><pubDate>Fri, 18 May 2018 17:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-36/</guid><description>1.3.36 # 解答 # 实现方法和 1.3.34 类似，初始化迭代器的时候同时初始化一个随机访问序列。
代码 # RandomQueue.cs # /// &amp;lt;summary&amp;gt; /// 随机队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要保存的元素。&amp;lt;/typeparam&amp;gt; public class RandomQueue&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _queue; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配内存空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { if (capacity &amp;lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// &amp;lt;summary&amp;gt; /// 向队列中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向队列中添加的元素。&amp;lt;/param&amp;gt; public void Enqueue(TItem item) { if (_queue.</description></item><item><title>1.3.37</title><link>https://alg4.ikesnowy.com/1-3-37/</link><pubDate>Fri, 18 May 2018 17:17:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-37/</guid><description>1.3.37 # 解答 # 也就是约瑟夫问题，官方给出的 JAVA 版答案：Josephus.java。
报数时将一个人出队然后入队来模拟一个环。
报到 M 个后将那个人出队但不入队（删除）
随后继续循环。
代码 # var numOfPeople = 7; var callForDeath = 2; var queue = new Queue&amp;lt;int&amp;gt;(); for (var i = 0; i &amp;lt; numOfPeople; i++) { queue.Enqueue(i); } while (!queue.IsEmpty()) { for (var i = 0; i &amp;lt; callForDeath - 1; i++) { queue.Enqueue(queue.Dequeue()); } Console.Write(queue.Dequeue() + &amp;#34; &amp;#34;); } Console.WriteLine(); 另请参阅 # Generics 库
约瑟夫问题-维基百科——给出了约瑟夫问题的数学通解</description></item><item><title>1.3.38</title><link>https://alg4.ikesnowy.com/1-3-38/</link><pubDate>Fri, 18 May 2018 17:22:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-38/</guid><description>1.3.38 # 解答 # 这里采用“假删除”的方式，对要删除的元素不直接删除而是打上标记，这样就可以维持插入的顺序。
代码 # 数组实现 # /// &amp;lt;summary&amp;gt; /// 以一维数组为基础的队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要保存的元素。&amp;lt;/typeparam&amp;gt; internal class ArrayBasedGeneralizeQueue&amp;lt;TItem&amp;gt; { private TItem[] _queue; private bool[] _isVisited; private int _count; private int _last; /// &amp;lt;summary&amp;gt; /// 建立一个队列。 /// &amp;lt;/summary&amp;gt; public ArrayBasedGeneralizeQueue() { _queue = new TItem[2]; _isVisited = new bool[2]; _last = 0; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; var t = new bool[capacity]; for (var i = 0; i &amp;lt; _count; i++) { t[i] = _isVisited[i]; } _isVisited = t; } /// &amp;lt;summary&amp;gt; /// 向队列中插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入队列的元素。&amp;lt;/param&amp;gt; public void Insert(TItem item) { if (_count == _queue.</description></item><item><title>1.3.39</title><link>https://alg4.ikesnowy.com/1-3-39/</link><pubDate>Fri, 18 May 2018 17:24:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-39/</guid><description>1.3.39 # 解答 # 可以直接套用队列的实现方式，在满或空时抛出相应异常。
代码 # /// &amp;lt;summary&amp;gt; /// 环形缓冲区。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;缓冲区包含的元素类型。&amp;lt;/typeparam&amp;gt; internal class RingBuffer&amp;lt;TItem&amp;gt; { private readonly TItem[] _buffer; private int _count; private int _first; // 读指针 private int _last; // 写指针 /// &amp;lt;summary&amp;gt; /// 建立一个缓冲区。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;缓冲区的大小。&amp;lt;/param&amp;gt; public RingBuffer(int n) { _buffer = new TItem[n]; _count = 0; _first = 0; _last = 0; } /// &amp;lt;summary&amp;gt; /// 检查缓冲区是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _count == _buffer.</description></item><item><title>1.3.40</title><link>https://alg4.ikesnowy.com/1-3-40/</link><pubDate>Fri, 18 May 2018 17:29:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-40/</guid><description>1.3.40 # 解答 # 每次插入时都先搜索一遍链表，再判定相应动作。
代码 # /// &amp;lt;summary&amp;gt; /// 前移编码队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;需要前移编码的元素类型。&amp;lt;/typeparam&amp;gt; internal class MoveToFront&amp;lt;TItem&amp;gt; { private class Node&amp;lt;T&amp;gt; { public T Item; public Node&amp;lt;T&amp;gt; Next; } private Node&amp;lt;TItem&amp;gt; _first; private int _count; /// &amp;lt;summary&amp;gt; /// 检查编码组是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _first == null; } /// &amp;lt;summary&amp;gt; /// 建立一个前移编码组。 /// &amp;lt;/summary&amp;gt; public MoveToFront() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 找到相应元素的前驱结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要寻找的元素。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private Node&amp;lt;TItem&amp;gt; Find(TItem item) { if (IsEmpty()) { return null; } var current = _first; while (current.</description></item><item><title>1.3.41</title><link>https://alg4.ikesnowy.com/1-3-41/</link><pubDate>Mon, 21 May 2018 21:17:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-41/</guid><description> 1.3.41 # 解答 # 可以按照书上的提示出队再入队，也可以直接用迭代器访问一遍进行复制。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;r&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Queue(Queue&amp;lt;Item&amp;gt; r) { foreach (Item i in r) { Enqueue(i); } }</description></item><item><title>1.3.42</title><link>https://alg4.ikesnowy.com/1-3-42/</link><pubDate>Mon, 21 May 2018 21:19:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-42/</guid><description> 1.3.42 # 解答 # 直接把链栈的整个链表复制一份即可。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Stack(Stack&amp;lt;Item&amp;gt; s) { if (s.first != null) { this.first = new Node&amp;lt;Item&amp;gt;(s.first); for (Node&amp;lt;Item&amp;gt; x = this.first; x.next != null; x = x.next) { x.next = new Node&amp;lt;Item&amp;gt;(x.next); } } this.count = s.count; }</description></item><item><title>1.3.43</title><link>https://alg4.ikesnowy.com/1-3-43/</link><pubDate>Mon, 21 May 2018 21:20:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-43/</guid><description>1.3.43 # 解答 # C# 中可以用 Directory 类里面的几个方法来获得文件路径和文件名。
代码 # // 获取当前目录 var path = Directory.GetCurrentDirectory(); path = Directory.GetParent(path).FullName; path = Directory.GetParent(path).FullName; // 获取文件 Console.WriteLine(path + &amp;#34;中的所有文件&amp;#34;); Search(path, 0); static void Search(string path, int tabs) { var dirs = Directory.GetDirectories(path); var files = Directory.GetFiles(path); foreach (var p in dirs) { for (var i = 0; i &amp;lt; tabs; i++) { Console.Write(&amp;#34; &amp;#34;); } Console.WriteLine(p.Split(&amp;#39;\\&amp;#39;).Last()); Search(p, tabs + 1); } foreach (var f in files) { for (var i = 0; i &amp;lt; tabs; i++) { Console.</description></item><item><title>1.3.44</title><link>https://alg4.ikesnowy.com/1-3-44/</link><pubDate>Mon, 21 May 2018 21:21:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-44/</guid><description>1.3.44 # 解答 # 这里我们使用两个栈来模拟缓冲区。
向左/向右移动 = 从左/右栈弹出相应数量的元素并压入另外一个栈。
插入/删除 = 左栈压入/弹出一个元素。
字符数量 = 左栈数量 + 右栈数量。
代码 # internal class Buffer { private readonly Stack&amp;lt;char&amp;gt; _leftside; private readonly Stack&amp;lt;char&amp;gt; _rightside; /// &amp;lt;summary&amp;gt; /// 建立一个文本缓冲区。 /// &amp;lt;/summary&amp;gt; public Buffer() { _leftside = new Stack&amp;lt;char&amp;gt;(); _rightside = new Stack&amp;lt;char&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 在光标位置插入字符 c。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;c&amp;#34;&amp;gt;要插入的字符。&amp;lt;/param&amp;gt; public void Insert(char c) { _leftside.Push(c); } /// &amp;lt;summary&amp;gt; /// 删除并返回光标位置的字符。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public char Delete() { return _leftside.</description></item><item><title>1.3.45</title><link>https://alg4.ikesnowy.com/1-3-45/</link><pubDate>Tue, 22 May 2018 13:39:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-45/</guid><description>1.3.45 # 解答 # 书上已经给出了思路，简单说明一下。
第一问是给定输入判断是否会下溢出，只要记录栈中元素的数量即可，一旦为负数则返回 true。
第二问是给定输出判断是否可能。
对于输出序列中的每一个数，如果栈顶为空或者栈顶数字小于当前输出序列的数，那么就从输入序列中输入数字，直到栈顶数字和当前输出序列中的数字相等。
如果当前输出序列中的数字和栈顶元素相等，从栈中弹出相应元素。
最后如果栈为空则可能，否则不可能。
可以结合习题 1.3.3 的解答查看。
通用解法见下一题。
代码 # // 给定输入序列，判断是否会出现下溢出。 var input = &amp;#34;- 0 1 2 3 4 5 6 7 8 9 - - - - - - - - -&amp;#34;; Console.WriteLine(IsUnderflow(input.Split(&amp;#39; &amp;#39;))); //True input = &amp;#34;0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -&amp;#34;; Console.WriteLine(IsUnderflow(input.Split(&amp;#39; &amp;#39;))); //False // 给定输出序列，判定是否可能。 int[] output = { 4, 3, 2, 1, 0, 9, 8, 7, 6, 5 }; Console.</description></item><item><title>1.3.46</title><link>https://alg4.ikesnowy.com/1-3-46/</link><pubDate>Tue, 22 May 2018 13:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-46/</guid><description>1.3.46 # 解答 # 这道题的解答参考了这篇博文：http://ceeji.net/blog/forbidden-triple-for-stack-generability/。
显然书中的解答已经十分明确，这里简单说明一下：
首先有结论：对于栈顶元素 Sn，栈中所有小于 Sn 的值都以递减形式保存（已经输出的不算）。
表现在输出序列中，Sn 输出之后，如果有小于 Sn 的值输出，其顺序必定是递减的。
例如序列 4 3 2 1 0 9 8 7 6 5
4 输出之后，3 2 1 0 递减输出；9 输出之后，8 7 6 5 递减输出。
依次验证其中的每个值都能满足结论。
而对于序列 4 6 8 7 5 3 2 9 0 1
对于 4，之后的 3 2 1 0 并不是以递减顺序输出的，因此这个序列是不合法的。</description></item><item><title>1.3.47</title><link>https://alg4.ikesnowy.com/1-3-47/</link><pubDate>Tue, 22 May 2018 13:42:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-47/</guid><description>1.3.47 # 解答 # 这里用的都是链式结构，头尾相接即可。
代码 # Queue # /// &amp;lt;summary&amp;gt; /// 在当前队列之后附加一个队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;q1&amp;#34;&amp;gt;需要被附加的队列。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q2&amp;#34;&amp;gt;需要附加的队列（将被删除）。&amp;lt;/param&amp;gt; public static Queue&amp;lt;Item&amp;gt; Catenation(Queue&amp;lt;Item&amp;gt; q1, Queue&amp;lt;Item&amp;gt; q2) { if (q1.IsEmpty()) { q1.first = q2.first; q1.last = q2.last; q1.count = q2.count; } else { q1.last.next = q2.first; q1.last = q2.last; q1.count += q2.count; } q2 = null; return q1; } Stack # /// &amp;lt;summary&amp;gt; /// 将两个栈连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s1&amp;#34;&amp;gt;第一个栈。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;s2&amp;#34;&amp;gt;第二个栈（将被删除）。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Stack&amp;lt;Item&amp;gt; Catenation(Stack&amp;lt;Item&amp;gt; s1, Stack&amp;lt;Item&amp;gt; s2) { if (s1.</description></item><item><title>1.3.48</title><link>https://alg4.ikesnowy.com/1-3-48/</link><pubDate>Wed, 23 May 2018 09:06:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-48/</guid><description>1.3.48 # 解答 # 按照双向队列原本的操作就可以实现，需要维护两个栈的长度以防越界。（左侧栈弹出了右侧栈栈底的内容）
代码 # public class DeStack&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Next; public DoubleNode&amp;lt;T&amp;gt; Prev; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _leftCount; private int _rightCount; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端栈。 /// &amp;lt;/summary&amp;gt; public DeStack() { _first = null; _last = null; _leftCount = 0; _rightCount = 0; } /// &amp;lt;summary&amp;gt; /// 检查左侧栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsLeftEmpty() { return _leftCount == 0; } /// &amp;lt;summary&amp;gt; /// 检查右侧栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsRightEmpty() { return _rightCount == 0; } /// &amp;lt;summary&amp;gt; /// 返回左侧栈中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int LeftSize() { return _leftCount; } /// &amp;lt;summary&amp;gt; /// 返回右侧栈中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int RightSize() { return _rightCount; } /// &amp;lt;summary&amp;gt; /// 向左端添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要添加的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.</description></item><item><title>1.3.49</title><link>https://alg4.ikesnowy.com/1-3-49/</link><pubDate>Wed, 23 May 2018 09:17:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-49/</guid><description>1.3.49 # 解答 # 那么这里就使用六个栈来解决这个问题。 这个算法来自于这篇论文。
原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。
先导知识——用两个栈模拟一个队列 # 如何使用两个栈来模拟一个队列操作？
这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。
首先我们有两个栈，H 和 T，分别用作出队和入队用。
这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。
如果 H 不为空，出队操作等同于 H 出栈，H 的出栈操作也只需要 O(1) 时间。
但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。
下图分别展示了这三种情况。
显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。
分摊 O(n) # 那么，怎么解决这个问题呢？
一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H&amp;rsquo; 中，等到栈 H 为空时，直接交换 H 和 H&amp;rsquo; 即可。
假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。
现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H&amp;rsquo; 中。
每一次出队都执行两个操作，元素出队和元素复制（Pop &amp;amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。</description></item><item><title>1.3.50</title><link>https://alg4.ikesnowy.com/1-3-50/</link><pubDate>Wed, 23 May 2018 16:52:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-50/</guid><description>1.3.50 # 解答 # 初始化迭代器的时候记录栈已经进行过的 Pop 和 Push 数，迭代的时候检查这两个值是否改变，一旦改变就抛出异常。
代码 # private class StackEnumerator : IEnumerator&amp;lt;Item&amp;gt; { private Stack&amp;lt;Item&amp;gt; s; private int popcount; private int pushcount; private Node&amp;lt;Item&amp;gt; current; public StackEnumerator(Stack&amp;lt;Item&amp;gt; s) { this.s = s; this.current = s.first; this.popcount = s.popcount; this.pushcount = s.pushcount; } Item IEnumerator&amp;lt;Item&amp;gt;.Current =&amp;gt; current.item; object IEnumerator.Current =&amp;gt; current.item; void IDisposable.Dispose() { this.current = null; this.s = null; } bool IEnumerator.MoveNext() { if (s.popcount !</description></item><item><title>1.4.1</title><link>https://alg4.ikesnowy.com/1-4-1/</link><pubDate>Wed, 23 May 2018 18:21:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-1/</guid><description>1.4.1 # 解答 # 即为证明组合计算公式：
$C(N, 3)$
$= N! / [(N - 3)! × 3!]$
$= [(N - 2) * (N - 1) * N] / 3!$
$= N(N - 1)(N - 2) / 6$
显然 N 必须大于等于 3。
$N = 3$ 时公式正确，只有一种组合。
$N = 4$ 时公式正确，只有四种组合。
扩展到 $N+1$ 个数，将 $N = N + 1$ 代入，可得：
$(N + 1)N(N - 1) / 6$
$N + 1$ 个数能组成的三位数组合可以这样理解
前 N 个数中取三个数的所有组合 +多出的一个数和前 N 个数中的任意取两个数的所有组合</description></item><item><title>1.4.2</title><link>https://alg4.ikesnowy.com/1-4-2/</link><pubDate>Wed, 23 May 2018 18:35:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-2/</guid><description>1.4.2 # 解答 # 将 a[i] + a[j] + a[k] 改为 (long)a[i] + a[j] + a[k] 即可。
此时整个式子将按照精度最高（也就是 long）的标准计算。
long.MaxValue = 9223372036854775807 &amp;gt; int.MaxValue * 3 = 6442450941 代码 # /// &amp;lt;summary&amp;gt; /// 计算和为零的三元组的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;输入数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;和为零的三元组的数量。&amp;lt;/returns&amp;gt; public static int Count(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { for (var k = j + 1; k &amp;lt; n; k++) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } return count; } 另请参阅 # Measurement 库</description></item><item><title>1.4.3</title><link>https://alg4.ikesnowy.com/1-4-3/</link><pubDate>Wed, 23 May 2018 18:37:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-3/</guid><description>1.4.3 # 解答 # 见代码，这里贴出绘图函数，窗体只是在得到测试结果之后简单调用以下这两个函数。
代码 # public static void PaintLinear(double[] testResult) { //新建一个绘图窗口 Form2 linear = new Form2(); linear.Show(); //新建画布 Graphics canvas = linear.CreateGraphics(); //获取窗口区域 Rectangle rect = linear.ClientRectangle; //计算单位长度（十等分） int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补） Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系 canvas.DrawLine(Pens.Black, center.X, center.Y, center.X, center.Y + center.</description></item><item><title>1.4.4</title><link>https://alg4.ikesnowy.com/1-4-4/</link><pubDate>Wed, 23 May 2018 18:39:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-4/</guid><description> 1.4.4 # 解答 #</description></item><item><title>1.4.5</title><link>https://alg4.ikesnowy.com/1-4-5/</link><pubDate>Wed, 23 May 2018 18:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-5/</guid><description>1.4.5 # 解答 # 类似于取极限的做法。
a. $N$
b. $1$
c. $1$
d. $2N^3$
e. $1$
f. $2$
g. $\frac{N^{100}}{2^n}$</description></item><item><title>1.4.6</title><link>https://alg4.ikesnowy.com/1-4-6/</link><pubDate>Wed, 23 May 2018 20:49:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-6/</guid><description>1.4.6 # 解答 # a. N + N/2 + N/4 + … = ~2N，线性。
b. 1 + 2 + 4 + … = ~2N，线性。
c. NlogN，线性对数。</description></item><item><title>1.4.7</title><link>https://alg4.ikesnowy.com/1-4-7/</link><pubDate>Wed, 23 May 2018 21:11:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-7/</guid><description>1.4.7 # 解答 # 最外层循环进行了 N 次比较。
次外层循环进行了 N^2 次比较。
最里层循环进行了 N^3 次比较。
内部 if 语句进行了 N^3 次比较。
if 内部进行了 N(N-1) 次加法。
加起来，~2N^3。</description></item><item><title>1.4.8</title><link>https://alg4.ikesnowy.com/1-4-8/</link><pubDate>Wed, 23 May 2018 21:12:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-8/</guid><description>1.4.8 # 解答 # 平方级别：直接二层循环遍历一遍。
线性对数：
先对数组排序，然后遍历一遍数组，在遍历过程中计算重复元素的数量，
然后用公式 $1+2+\cdots+n-1=n(n-1)/2$ 计算重复整数对的数量。
代码 # /// &amp;lt;summary&amp;gt; /// 暴力查找数组中相等的整数对。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int CountEqual(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { if (a[i] == a[j]) count++; } } return count; } /// &amp;lt;summary&amp;gt; /// 利用 Array.</description></item><item><title>1.4.9</title><link>https://alg4.ikesnowy.com/1-4-9/</link><pubDate>Wed, 23 May 2018 21:14:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-9/</guid><description>1.4.9 # 解答 # 由题意可得：
$$ T(2N_0)=2^bT\newline T(4N_0)=2^b(2^bT)=2^{2b}T\newline &amp;hellip;&amp;hellip;\newline T(2^rN_0)=2^{rb}T $$
设：
$$ N=2^rN_0 $$
则：
$$ r=log_2(\frac{N}{N_0}) $$
所以：
$$ T(N) = 2^{log_2(\frac{N}{N_0})b}T $$</description></item><item><title>1.4.10</title><link>https://alg4.ikesnowy.com/1-4-10/</link><pubDate>Wed, 23 May 2018 21:19:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-10/</guid><description> 1.4.10 # 解答 # 修改二分查找的结束条件，找到后仍然向左侧寻找，如果还能找到更小的，则返回较小的下标；否则返回当前下标。
代码 # public static int Rank(int key, int[] a, int lo, int hi) { if (hi &amp;lt; lo) return -1; var mid = (hi - lo) / 2 + lo; if (a[mid] == key) { var mini = Rank(key, a, lo, mid - 1); if (mini != -1) return mini; return mid; } if (a[mid] &amp;lt; key) { return Rank(key, a, mid + 1, hi); } return Rank(key, a, lo, mid - 1); }</description></item><item><title>1.4.11</title><link>https://alg4.ikesnowy.com/1-4-11/</link><pubDate>Wed, 23 May 2018 21:21:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-11/</guid><description>1.4.11 # 解答 # 这里给出官网上的 Java 实现：StaticSETofInts.java。
howMany() 可以用二分查找实现，在找到一个值后继续向两侧查找，最后返回找到的次数。
代码 # /// &amp;lt;summary&amp;gt; /// 有序数组，能够快速查找并自动维护其中的顺序。 /// &amp;lt;/summary&amp;gt; public class StaticSeTofInts { private readonly int[] _a; /// &amp;lt;summary&amp;gt; /// 用一个数组初始化有序数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;源数组。&amp;lt;/param&amp;gt; public StaticSeTofInts(int[] keys) { _a = new int[keys.Length]; for (var i = 0; i &amp;lt; keys.Length; i++) { _a[i] = keys[i]; } Array.Sort(_a); } /// &amp;lt;summary&amp;gt; /// 检查数组中是否存在指定元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要查找的值。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;存在则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public bool Contains(int key) { return Rank(key, 0, _a.</description></item><item><title>1.4.12</title><link>https://alg4.ikesnowy.com/1-4-12/</link><pubDate>Wed, 23 May 2018 21:23:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-12/</guid><description>1.4.12 # 解答 # 由于两个数组都是有序的，可以同时进行比较。
设 i, j 分别为两个数组的下标。
如果 a[i] == a[j]，i 和 j 都向后移动一位。
如果 a[i] != a[j]，比较小的那个向后移动一位。
循环直到某个数组遍历完毕。
这样最后的时间复杂度 ~2N
代码 # var a = new[] { 2, 3, 4, 10 }; var b = new[] { 1, 3, 3, 5, 10, 11 }; // 2N 次数组访问，数组 a 和数组 b 各遍历一遍 for (int i = 0, j = 0; i &amp;lt; a.Length &amp;amp;&amp;amp; j &amp;lt; b.Length;) { if (a[i] &amp;lt; b[j]) { i++; } else if (a[i] &amp;gt; b[j]) { j++; } else { Console.</description></item><item><title>1.4.13</title><link>https://alg4.ikesnowy.com/1-4-13/</link><pubDate>Wed, 23 May 2018 21:25:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-13/</guid><description>1.4.13 # 解答 # 对象的固定开销用 Object 表示。
a. Accumulator 使用 1.2.4.3 节给出的实现。
= int * 1 + double + Object * 1 = 4 * 1 + 8 + 16 * 1 = 32 b. Transaction
= string * 1 + Date * 1 + double * 1 + Object * 1 = (40 + 16 + 4 + 4 + 2N) * 1 + (8 + 32) * 1 + 8 * 1 + 16 * 1 = 128 + 2N c.</description></item><item><title>1.4.14</title><link>https://alg4.ikesnowy.com/1-4-14/</link><pubDate>Wed, 23 May 2018 21:27:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-14/</guid><description>1.4.14 # 解答 # 这里给出暴力方法，将最内侧循环换成二分查找即为优化版本。
代码 # public static class FourSum { /// &amp;lt;summary&amp;gt; /// 输出数组中所有和为 0 的四元组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;包含所有元素的数组。&amp;lt;/param&amp;gt; public static void PrintAll(long[] a) { var n = a.Length; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { for (var k = j + 1; k &amp;lt; n; k++) { for (var l = k + 1; l &amp;lt; n; l++) { if (a[i] + a[j] + a[k] + a[l] == 0) { Console.</description></item><item><title>1.4.15</title><link>https://alg4.ikesnowy.com/1-4-15/</link><pubDate>Wed, 23 May 2018 21:28:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-15/</guid><description>1.4.15 # 解答 # 由于数组已经排序（从小到大），负数在左侧，正数在右侧。
TwoSumFaster
设最左侧下标为 lo，最右侧下标为 hi。
如果 a[lo] + a[hi] &amp;gt; 0, 说明正数太大，hi&amp;ndash;。
如果 a[lo] + a[hi] &amp;lt; 0，说明负数太小，lo++。
否则就找到了一对和为零的整数对，lo++, hi&amp;ndash;。
ThreeSumFaster
对于数组中的每一个数 a，ThreeSum 问题就等于求剩余数组中所有和为 -a 的 TwoSum 问题。
只要在 TwoSumFaster 外层再套一个循环即可。
代码 # /// &amp;lt;summary&amp;gt; /// TwoSum 的快速实现。（线性级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的整数对数量。&amp;lt;/returns&amp;gt; static int TwoSumFaster(int[] a) { var lo = 0; var hi = a.Length - 1; var count = 0; while (lo &amp;lt; hi) { if (a[lo] + a[hi] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] &amp;lt; 0) { lo++; } else { hi--; } } return count; } /// &amp;lt;summary&amp;gt; /// ThreeSum 的快速实现。（平方级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的三元组数量。&amp;lt;/returns&amp;gt; static int ThreeSumFaster(int[] a) { var count = 0; for (var i = 0; i &amp;lt; a.</description></item><item><title>1.4.16</title><link>https://alg4.ikesnowy.com/1-4-16/</link><pubDate>Wed, 23 May 2018 21:29:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-16/</guid><description>1.4.16 # 解答 # 先将数组从小到大排序，再遍历一遍即可得到差距最小的两个数。
排序算法需要消耗 NlogN，具体见 MSDN：Array.Sort 方法 (Array)。
代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; Array.Sort(a); // Nlog(N) 具体见 https://msdn.microsoft.com/zh-cn/library/6tf1f0bc(v=vs.110).aspx 备注部分 var minDiff = double.MaxValue; double minA = 0; double minB = 0; for (var i = 0; i &amp;lt; a.Length - 1; i++) //N { if (a[i + 1] - a[i] &amp;lt; minDiff) { minA = a[i]; minB = a[i + 1]; minDiff = a[i + 1] - a[i]; } } Console.</description></item><item><title>1.4.17</title><link>https://alg4.ikesnowy.com/1-4-17/</link><pubDate>Wed, 23 May 2018 21:31:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-17/</guid><description> 1.4.17 # 解答 # 遍历找到最小值和最大值即可。
代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; double min = int.MaxValue; double max = int.MinValue; for (var i = 0; i &amp;lt; a.Length; i++) { if (a[i] &amp;gt; max) { max = a[i]; } if (a[i] &amp;lt; min) { min = a[i]; } } Console.WriteLine($&amp;#34;MaxDiff Pair: {min} {max}, Max Difference: {Math.Abs(max - min)}&amp;#34;);</description></item><item><title>1.4.18</title><link>https://alg4.ikesnowy.com/1-4-18/</link><pubDate>Wed, 23 May 2018 21:38:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-18/</guid><description>1.4.18 # 解答 # 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。
在三个数中比较得到最小值需要两次比较，因此最坏情况下为 $~2\lg N$ 次比较。
代码 # var a = new[] { 1, 2, 5, 3, 5 }; Console.WriteLine(LocalMinimum(a)); static int LocalMinimum(int[] a) { var lo = 0; var hi = a.Length - 1; while (lo &amp;lt;= hi) { var mid = (hi - lo) / 2 + lo; var min = mid; // 取左中右最小值的下标 if (mid != hi &amp;amp;&amp;amp; a[min] &amp;gt;= a[mid + 1]) min = mid + 1; if (mid !</description></item><item><title>1.4.19</title><link>https://alg4.ikesnowy.com/1-4-19/</link><pubDate>Wed, 23 May 2018 21:42:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-19/</guid><description>1.4.19 # 解答 # 问题类似于 POJ 上的一道题「滑雪」，从数值较高的一侧向周围数值较小的一侧移动，直到到达「山谷」（局部最小）。
首先在中间行搜索最小值，再将最小值与其上下两个元素比较，如果不满足题意，则“滑向”较小的一侧，矩阵被分为了两半（上下两侧）。
在较小的一侧，找到中间列的最小值，再将最小值与其左右两个元素比较，如果不满足题意，类似的移动到较小的一侧（左右两侧）。
现在查找范围缩小到了原来矩阵的四分之一，递归的进行上述操作，最后可以得到答案。
每次查找最小值都是对行/列进行遍历，遍历耗时和 N 成正比。
代码 # // 先查找 N/2 行中的最小元素，并令其与上下元素比较， // 如果不满足题意，则向相邻的最小元素靠近再次查找 var matrix = new[,] { { 26, 3, 4, 10, 11 }, { 5, 1, 6, 12, 13 }, { 7, 8, 9, 14, 15 }, { 16, 17, 18, 27, 20 }, { 21, 22, 23, 24, 25 } }; Console.WriteLine(MinimumRow(matrix, 0, 5, 0, 5)); static int MinimumRow(int[,] matrix, int rowStart, int rowLength, int colStart, int colLength) { var min = int.</description></item><item><title>1.4.20</title><link>https://alg4.ikesnowy.com/1-4-20/</link><pubDate>Wed, 23 May 2018 21:57:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-20/</guid><description>1.4.20 # 解答 # 首先给出 BitMax 类的官方 Java 实现：BitonicMax.java。
我们使用这个类生成双调数组，并使用其中的 Max() 方法找到双调数组的最大值。
找到最大值之后分别对左右两侧进行二分查找，注意对于升序和降序的数组二分查找的实现有所不同。
代码 # BitonicMax 类 # public class BitonicMax { /// &amp;lt;summary&amp;gt; /// 生成双调数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;数组的大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static int[] Bitonic(int n) { var random = new Random(); var mid = random.Next(n); var a = new int[n]; for (var i = 1; i &amp;lt; mid; i++) { a[i] = a[i - 1] + 1 + random.</description></item><item><title>1.4.21</title><link>https://alg4.ikesnowy.com/1-4-21/</link><pubDate>Wed, 23 May 2018 21:59:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-21/</guid><description>1.4.21 # 解答 # 直接将 Contains() 实现为二分查找即可。
代码 # /// &amp;lt;summary&amp;gt; /// 检查数组中是否存在指定元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要查找的值。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;存在则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;查找的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;查找的结束下标。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回关键值的下标，如果不存在则返回 -1。&amp;lt;/returns&amp;gt; public int Rank(int key, int lo, int hi) { while (lo &amp;lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key &amp;lt; this.</description></item><item><title>1.4.22</title><link>https://alg4.ikesnowy.com/1-4-22/</link><pubDate>Wed, 23 May 2018 22:00:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-22/</guid><description>1.4.22 # 解答 # 普通二分查找是通过除法不断减半缩小搜索范围。
这里我们用斐波那契数列来缩小范围。
举个例子，例如数组大小是 100，比它大的最小斐波那契数是 144。
斐波那契数列如下：0 1 1 2 3 5 8 13 21 34 55 89 144
我们记 F(n) = 144,F(n-1) = 89, F(n-2) = 55。
我们先查看第 0 + F(n-2) 个数，如果比关键值小则直接将范围缩小到 [55, 100]；否则则在[0, 55]之间查找。
之后我们令 n = n-1。
递归上述过程即可完成查找。
代码 # /// &amp;lt;summary&amp;gt; /// 使用斐波那契数列进行的查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回查找到的关键值下标，没有结果则返回 -1。&amp;lt;/returns&amp;gt; static int Rank(int[] a, int key) { // 使用斐波那契数列作为缩减范围的依据 var fk = 1; var fk1 = 1; var fk2 = 0; // 获得 Fk，Fk需要大于等于数组的大小，复杂度 lgN while (fk &amp;lt; a.</description></item><item><title>1.4.23</title><link>https://alg4.ikesnowy.com/1-4-23/</link><pubDate>Wed, 23 May 2018 22:02:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-23/</guid><description>1.4.23 # 解答 # 根据书中的提示，将二分查找中判断相等的条件改为两个数的差小于等于 $1/N^2$。
代码 # // 将二分查找中的相等判定条件修改为差值小于 x，其中 x = 1/N^2。 /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结果的下标，没有结果时返回 -1。&amp;lt;/returns&amp;gt; static int BinarySearch(double[] a, double key) { var lo = 0; var hi = a.Length - 1; var threshold = 1.0 / (a.Length * a.Length); while (lo &amp;lt;= hi) { var mid = lo + (hi - lo) / 2; if (Math.</description></item><item><title>1.4.24</title><link>https://alg4.ikesnowy.com/1-4-24/</link><pubDate>Wed, 23 May 2018 22:03:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-24/</guid><description>1.4.24 # 解答 # 第一问：二分查找即可。
第二问： 按照第 1, 2, 4, 8,&amp;hellip;, 2^k 层顺序查找，一直到 2^k &amp;gt; F， 随后在 [2^(k - 1), 2^k] 范围中二分查找。
代码 # 这里建立了一个结构体用于返回测试结果：
internal struct TestResult { public int F; // 找到的 F 值。 public int BrokenEggs; // 打碎的鸡蛋数。 } 用于测试的方法：
/// &amp;lt;summary&amp;gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;floor&amp;#34;&amp;gt;扔鸡蛋的高度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static bool ThrowEgg(int floor) { return floor &amp;lt;= f; } /// &amp;lt;summary&amp;gt; /// 第一种方案。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;大楼。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static TestResult PlanA(int[] a) { var lo = 0; var hi = a.</description></item><item><title>1.4.25</title><link>https://alg4.ikesnowy.com/1-4-25/</link><pubDate>Wed, 23 May 2018 22:07:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-25/</guid><description>1.4.25 # 解答 # 第一问：
第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),&amp;hellip;, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k &amp;lt;= √(N)。
k-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次。
第二问：
按照第 1, 3, 6, 10,&amp;hellip;, 1/2k^2 层顺序查找，一直到 1/2k^2 &amp;gt; F，
随后在 [1/2k^2 - k, 1/2k^2] 范围中顺序查找。
代码 # 这里我们同样定义了一个结构体：
internal struct TestResult { public int F; // 测试得出的 F 值 public int BrokenEggs; // 碎掉的鸡蛋数。 public int ThrowTimes; // 扔鸡蛋的次数。 } 之后是测试用的方法：
/// &amp;lt;summary&amp;gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;floor&amp;#34;&amp;gt;扔鸡蛋的高度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static bool ThrowEgg(int floor) { return floor &amp;lt;= f; } /// &amp;lt;summary&amp;gt; /// 第一种方案。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;大楼。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; // 第一种方案。 static TestResult PlanA(int[] a) { var lo = 0; var hi = 0; var eggs = 0; var throwTimes = 0; var result = new TestResult(); while (ThrowEgg(hi)) { throwTimes++; lo = hi; hi += (int)Math.</description></item><item><title>1.4.26</title><link>https://alg4.ikesnowy.com/1-4-26/</link><pubDate>Wed, 23 May 2018 22:09:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-26/</guid><description>1.4.26 # 解答 # 首先，我们将问题转化为证明三点
$$ A(a,a^3),B(b,b^3),C(c,c^3) $$
共线，当且仅当满足
$$ a+b+c=0 $$
证明： 若 $A,B,C$ 三点共线，则直线 $AB$ 和 $BC$ 的斜率必定相等，有方程：
$$ \frac{b^3-a^3}{b-a}=\frac{c^3-b^3}{c-b} $$
由立方差公式：
$$ \frac{(b-a)(b^2+ba+a^2)}{b-a}=\frac{(c-b)(c^2+cb+b^2)}{c-b} $$
化简有：
$$ b^2+ba+a^2=c^2+cb+b^2\newline ba+a^2=c^2+cb $$
移项，将 $c$ 视为未知数：
$$ c^2+cb-ba-a^2=0 $$
利用十字相乘法进行因式分解：
$$ (a+b+c)(c-a)=0 $$
解得：
$$ c_1=-a-b,c_2=a $$
显然 $c\ne a$ ，因此当且仅当 $a+b+c=0$ 时 $A,B,C$ 三点共线。 证毕。</description></item><item><title>1.4.27</title><link>https://alg4.ikesnowy.com/1-4-27/</link><pubDate>Wed, 23 May 2018 22:20:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-27/</guid><description>1.4.27 # 解答 # 实现比较简单，想象两个栈背靠背接在一起，左侧栈负责出队，右侧栈负责入队。
当左侧栈为空时就把右侧栈中的元素倒到左侧栈，这个过程是 O(n) 的。
但在这个过程之前必然有 n 个元素入栈，均摊后即为 O(1)。
代码 # internal class StackQueue&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _h;// 用于保存出队元素 private readonly Stack&amp;lt;TItem&amp;gt; _;// 用于保存入队元素 /// &amp;lt;summary&amp;gt; /// 构造一个队列。 /// &amp;lt;/summary&amp;gt; public StackQueue() { _h = new Stack&amp;lt;TItem&amp;gt;(); _ = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 将栈 T 中的元素依次弹出并压入栈 H 中。 /// &amp;lt;/summary&amp;gt; private void Reverse() { while (!_.IsEmpty()) { _h.Push(_.Pop()); } } /// &amp;lt;summary&amp;gt; /// 将一个元素出队。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public TItem Dequeue() { // 如果没有足够的出队元素，则将 T 中的元素移动过来 if (_h.</description></item><item><title>1.4.28</title><link>https://alg4.ikesnowy.com/1-4-28/</link><pubDate>Thu, 31 May 2018 09:12:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-28/</guid><description>1.4.28 # 解答 # 每次入队的时候将队列倒转，这样入队的元素就是第一个了。
代码 # internal class QueueStack&amp;lt;TItem&amp;gt; { private readonly Queue&amp;lt;TItem&amp;gt; _queue; /// &amp;lt;summary&amp;gt; /// 初始化一个栈。 /// &amp;lt;/summary&amp;gt; public QueueStack() { _queue = new Queue&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(TItem item) { _queue.Enqueue(item); var size = _queue.Size(); // 倒转队列 for (var i = 0; i &amp;lt; size - 1; i++) { _queue.Enqueue(_queue.Dequeue()); } } /// &amp;lt;summary&amp;gt; /// 从栈中弹出一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public TItem Pop() { return _queue.</description></item><item><title>1.4.29</title><link>https://alg4.ikesnowy.com/1-4-29/</link><pubDate>Thu, 31 May 2018 09:13:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-29/</guid><description>1.4.29 # 解答 # 和用两个栈实现队列的方法类似。
push 的时候把右侧栈内容倒到左侧栈，之后再入栈。
pop 的时候也做相同操作，右侧栈内容进左侧栈，之后再出栈。
enqueue 的时候则将左侧栈内容倒到右侧栈，之后再入队。
代码 # internal class StackSteque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _h; private readonly Stack&amp;lt;TItem&amp;gt; _t; /// &amp;lt;summary&amp;gt; /// 初始化一个 Steque /// &amp;lt;/summary&amp;gt; public StackSteque() { _h = new Stack&amp;lt;TItem&amp;gt;(); _t = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(TItem item) { ReverseT(); _h.Push(item); } /// &amp;lt;summary&amp;gt; /// 将 T 中的元素弹出并压入到 H 中。 /// &amp;lt;/summary&amp;gt; private void ReverseT() { while (!</description></item><item><title>1.4.30</title><link>https://alg4.ikesnowy.com/1-4-30/</link><pubDate>Thu, 31 May 2018 09:14:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-30/</guid><description>1.4.30 # 解答 # steque 作为队列的头部，stack 作为队列的尾部。
pushLeft：直接 push 到 steque 中即可。
pushRight：如果 stack 为空，则直接 enqueue 到 steque 中，否则就 push 到 stack 中。
popLeft：如果 steque 为空，则将 stack 中的元素倒到 steque 中去（steque.push(stack.pop())），然后再从 steque 中 pop。
popRight：如果 stack 为空，则将 steque 中的元素倒到 stack 中去，然后再从 stack 中 pop。
代码 # internal class Deque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _stack; // 代表队列尾部 private readonly Steque&amp;lt;TItem&amp;gt; _steque;// 代表队列头部 /// &amp;lt;summary&amp;gt; /// 创建一条空的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _stack = new Stack&amp;lt;TItem&amp;gt;(); _steque = new Steque&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 在左侧插入一个新元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { _steque.</description></item><item><title>1.4.31</title><link>https://alg4.ikesnowy.com/1-4-31/</link><pubDate>Thu, 31 May 2018 09:15:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-31/</guid><description>1.4.31 # 解答 # 三个栈分别命名为左中右。
左侧栈和右侧栈负责模拟队列，和用两个栈模拟队列的方法类似。
由于是双向队列，左栈和右栈会频繁的倒来倒去，因此每次都只倒一半的元素可以有效减少开销。
有一侧栈为空时，另一侧栈中上半部分先移动到中间栈中，下半部分倒到另一侧栈里，再从中间栈拿回上半部分元素。
这样可以确保接下来的 pop 操作一定是常数级别的。
代码 # internal class Deque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _left; private readonly Stack&amp;lt;TItem&amp;gt; _middle; private readonly Stack&amp;lt;TItem&amp;gt; _right; /// &amp;lt;summary&amp;gt; /// 构造一条新的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _left = new Stack&amp;lt;TItem&amp;gt;(); _middle = new Stack&amp;lt;TItem&amp;gt;(); _right = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向双向队列左侧插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { _left.Push(item); } /// &amp;lt;summary&amp;gt; /// 向双向队列右侧插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void PushRight(TItem item) { _right.</description></item><item><title>1.4.32</title><link>https://alg4.ikesnowy.com/1-4-32/</link><pubDate>Thu, 31 May 2018 09:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-32/</guid><description>1.4.32 # 解答 # 首先，不需要扩容数组的的操作都只需访问数组一次，$M$ 次操作就是 $M$ 次访问。
随后我们有性质， $M$ 次栈操作后额外复制访问数组的次数小于 $2M$。
这里简单证明，设 $M$ 次操作之后栈的大小为 $n$，那么额外访问数组的次数为：
$S = \frac{n}{2} + \frac{n}{4} + \frac{n}{8} +&amp;hellip;+ 2 &amp;lt; n$
为了能使栈大小达到 $n$，$M$ 必须大于等于 $\frac{n}{2}$
因此 $2M \ge n &amp;gt; S$，得证。
因此我们可以得到 $M$ 次操作后访问数组次数的总和 $S&amp;rsquo; = S + M &amp;lt; 3M$。</description></item><item><title>1.4.33</title><link>https://alg4.ikesnowy.com/1-4-33/</link><pubDate>Thu, 31 May 2018 09:21:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-33/</guid><description>1.4.33 # 解答 # Integer = 4(int) + 8(对象开销) = 12
Date = 3 × 4(int × 3) + 8(对象开销) = 20
Counter = 4(String 的引用) + 4(int) + 8(对象开销) = 16
int[] = 8(对象开销) + 4(数组长度) + 4N = 12 + 4N
double[] = 8(对象开销) + 4(数组长度) + 8N = 12 + 8N
double[][] = 8(对象开销) + 4(数组长度) + 4M(引用) + M(12 + 8N)(M 个一维数组) = 12 + 16M + 8MN</description></item><item><title>1.4.34</title><link>https://alg4.ikesnowy.com/1-4-34/</link><pubDate>Thu, 31 May 2018 09:22:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-34/</guid><description>1.4.34 # 解答 # 第一种方案，类似于二分查找，先猜测左边界(lo)，再猜测右边界(hi)，如果边界值猜中的话直接返回，否则：
如果右边界比较热，那么左边界向右边界靠，lo=mid；否则，右边界向左边界靠，hi=mid。其中，mid = lo + (hi – lo)/2。
每次二分查找都要猜测两次，~2lgN。
第二种方案，假设上次猜测值为 $lastGuess$，本次即将要猜测的值为 $nowGuess$，通过方程：
$(lastGuess + nowGuess)/2 = (lo + hi)/2$
可以求得 $nowGuess$，具体可以查看示意图：
数字是猜测顺序，黑色范围是猜测值的范围（$lastGuess$ 和 $nowGuess$），绿色的是实际查找的范围（lo 和 hi）。
代码 # 首先是 Game 类
internal class Game { public int N { get; } // 目标值的最大范围。 public int SecretNumber { get; } // 目标值。 public int LastGuess { get; private set; } // 上次猜测的值 /// &amp;lt;summary&amp;gt; /// 构造函数，新开一局游戏。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;目标值的最大范围。&amp;lt;/param&amp;gt; public Game(int n) { var random = new Random(); N = n; SecretNumber = random.</description></item><item><title>1.4.35</title><link>https://alg4.ikesnowy.com/1-4-35/</link><pubDate>Thu, 31 May 2018 09:27:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-35/</guid><description>1.4.35 # 解答 # 1. 一个 Node 对象包含一个 int(泛型 Item) 的引用和下一个 Node 对象的引用。push 操作创建新 Node 对象时会创建一个引用。
因此对于第一种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象，创建了 2N 个引用。
2. 比起上一种情况，每个 Node 对象多包含了一个指向 Integer 的引用。
因此对于第二种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象和 N 个 Integer 对象，比起第一种情况多创建了 N 个引用。
3. 对于数组来说，创建对象只有扩容时重新创建数组对象一种情况，对于 N 次 push 操作只需要 lgN 次扩容，因此创建的对象为 lgN 个。
每次扩容都需要重新创建引用，(4 + 8 +&amp;hellip;+ 2N)(扩容) + N(每次 push 操作) = 5N - 4 = ~5N</description></item><item><title>1.4.36</title><link>https://alg4.ikesnowy.com/1-4-36/</link><pubDate>Thu, 31 May 2018 18:17:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-36/</guid><description>1.4.36 # 解答 # 1. N 个 Node 对象的空间开销 = N * (16(对象开销) + 4(int) + 8(下一个 Node 的引用) + 4(填充字节)) = 32N
2. 比起上一题来说，空间开销变为
= N * (16(Node 对象开销) + 8(Integer 对象引用) + (16(Integer 对象开销) + 4(int) + 4(填充字节)) + 8(下一个对象的引用) = 32N + 24N = 56N。
3. 如果不扩容则是 4N，N 个元素最多可以维持 4N 的栈空间（少于四分之一将缩小）。
4. 比起上一题，数组元素变成了引用每个占用 8 字节，还要额外加上 Integer 对象的每个 24 字节。
= (8 + 24)N ~ (8 * 4 + 24)N</description></item><item><title>1.4.37</title><link>https://alg4.ikesnowy.com/1-4-37/</link><pubDate>Thu, 31 May 2018 18:19:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-37/</guid><description>1.4.37 # 解答 # 数据量比较大时才会有比较明显的差距。
代码 # FixedCapacityStackOfInts
/// &amp;lt;summary&amp;gt; /// 固定大小的整型数据栈。 /// &amp;lt;/summary&amp;gt; internal class FixedCapacityStackOfInts : IEnumerable&amp;lt;int&amp;gt; { private readonly int[] _a; private int _n; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfInts(int capacity) { _a = new int[capacity]; _n = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _n == 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _n == _a.</description></item><item><title>1.4.38</title><link>https://alg4.ikesnowy.com/1-4-38/</link><pubDate>Thu, 31 May 2018 18:29:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-38/</guid><description>1.4.38 # 解答 # 把 DoublingTest 中调用的函数稍作修改即可。
代码 # ThreeSum 测试类
public static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n) { var a = new int[n]; var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i &amp;lt; n; i++) { a[i] = random.Next(-MaximumInteger, MaximumInteger); } var timer = new Measurement.</description></item><item><title>1.4.39</title><link>https://alg4.ikesnowy.com/1-4-39/</link><pubDate>Thu, 31 May 2018 18:33:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-39/</guid><description>1.4.39 # 解答 # 执行 N 次后取平均即可。
代码 # 修改后的 DoublingTest：
public static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;repeatTimes&amp;#34;&amp;gt;重复测试的次数。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n, int repeatTimes) { var a = new int[n]; double sum = 0; var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i &amp;lt; n; i++) { a[i] = random.</description></item><item><title>1.4.40</title><link>https://alg4.ikesnowy.com/1-4-40/</link><pubDate>Thu, 31 May 2018 18:36:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-40/</guid><description>1.4.40 # 解答 # N 个数可组成的三元组的总数为：
$C(N, 3) = N(N-1)(N-2)/3! = ~ (N^3)/6​$ （组合数公式）
$[-M, M]​$ 中随机 $N​$ 次，有 $(2M+1)^N​$ 种随机序列（每次随机都有 $2M+1​$ 种可能）
按照分步计数方法，将随机序列分为和为零的三元组和其余 $N-3​$ 个数
这些序列中，和为零的三元组有 $3M^2 + 3M + 1​$ 种可能。
其他不为零的 $N-3​$ 个位置有 $(2M+1)^{(N-3)}​$ 种可能。
总共有 $((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}​$ 种可能性
平均值为：
$[((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}] / (2M+1)^N​$ $=N^3/16M​$
$3M^2 + 3M + 1$ 的推导：
在 $[-M,M]$ 中取三个数，和为零的序列有几个？ 假设第一个数取 $0$， 取 $(0, 0, 0)$ 的情况最后加上。</description></item><item><title>1.4.41</title><link>https://alg4.ikesnowy.com/1-4-41/</link><pubDate>Thu, 31 May 2018 19:58:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-41/</guid><description>1.4.41 # 解答 # 代码 # 这里使用了委托来简化代码。
DoublingRatio
public delegate int Count(int[] a); internal static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { var split = new[] { &amp;#39;\n&amp;#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i &amp;lt; a.Length; i++) { a[i] = int.Parse(input[i]); } return a; } /// &amp;lt;summary&amp;gt; /// 使用给定的数组进行一次测试，返回耗时（毫秒）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;count&amp;#34;&amp;gt;要测试的方法。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;测试用的数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;耗时（秒）。&amp;lt;/returns&amp;gt; public static double TimeTrial(Count count, int[] a) { var timer = new Stopwatch(); count(a); return timer.</description></item><item><title>1.4.42</title><link>https://alg4.ikesnowy.com/1-4-42/</link><pubDate>Thu, 31 May 2018 20:20:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-42/</guid><description>1.4.42 # 解答 # 这里我们把时限设置为一小时，使用上一题的数据估计。
1.ThreeSum 暴力方法在输入倍增时耗时增加 2^3 = 8 倍。
1K 数据耗费了 1.15 秒，在一小时内（3600 秒）可以完成 2^3 = 8K 数据。
2.ThreeSumFast 方法在输入倍增时耗时增加 2^2 = 4 倍。
1K 数据耗费了 0.05 秒，在一小时内（3600 秒）可以完成 2^8 = 256K 数据。
3.TwoSum 暴力方法在输入倍增时耗时增加 2^2 = 4 倍。
8K 数据耗费了 0.14 秒，在一小时内（3600 秒）可以完成 2^10 = 1024K 数据。
4.TwoSumFast 在输入倍增时耗时增加 2^1 = 2 倍。
32K 数据耗费了 0.008 秒，在一小时内（3600 秒）可以完成 2^16 = 65536K 数据。</description></item><item><title>1.4.43</title><link>https://alg4.ikesnowy.com/1-4-43/</link><pubDate>Thu, 31 May 2018 20:22:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-43/</guid><description>1.4.43 # 解答 # 代码 # 修改后的 DoublingRatio
internal static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { var split = new[] { &amp;#39;\n&amp;#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i &amp;lt; a.Length; i++) { a[i] = int.Parse(input[i]); } return a; } /// &amp;lt;summary&amp;gt; /// 使用给定的数组对链栈进行一次测试，返回耗时（毫秒）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;测试用的数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;耗时（毫秒）。&amp;lt;/returns&amp;gt; public static double TimeTrialLinkedStack(int[] a) { var stack = new LinkedStack&amp;lt;int&amp;gt;(); var n = a.</description></item><item><title>1.4.44</title><link>https://alg4.ikesnowy.com/1-4-44/</link><pubDate>Thu, 31 May 2018 20:25:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-44/</guid><description> 1.4.44 # 解答 # 每生成一个随机数都和之前生成过的随机数相比较。
代码 # var random = new Random(); const int n = 10000; var a = new int[n]; var dupNum = 0; int times; for (times = 0; times &amp;lt; 500; times++) { for (var i = 0; i &amp;lt; n; i++) { a[i] = random.Next(n); if (IsDuplicated(a, i)) { dupNum += i; Console.WriteLine($&amp;#34;生成{i + 1}个数字后发生重复&amp;#34;); break; } } } Console.WriteLine($&amp;#34;√(πN/2)={Math.Sqrt(Math.PI * n / 2.0)}，平均生成{dupNum / times}个数字后出现重复&amp;#34;); // 检查是否有重复的数字出现。 static bool IsDuplicated(int[] a, int i) { for (var j = 0; j &amp;lt; i; j++) { if (a[j] == a[i]) { return true; } } return false; }</description></item><item><title>1.4.45</title><link>https://alg4.ikesnowy.com/1-4-45/</link><pubDate>Thu, 31 May 2018 20:26:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-45/</guid><description>1.4.45 # 解答 # 建立一个布尔数组，将每次随机出来的数作为下标，将相应位置的布尔值改为 true，每次随机都检查一遍这个数组是否都是 true。
代码 # // HN 指的是调和级数 var random = new Random(); var n = 10000; var a = new bool[n]; var randomSize = 0; int times; for (times = 0; times &amp;lt; 20; times++) { for (var i = 0; i &amp;lt; n; i++) { a[i] = false; } for (var i = 0; true; i++) { var now = random.Next(n); a[now] = true; if (IsAllGenerated(a)) { randomSize += i; Console.</description></item><item><title>1.5.1</title><link>https://alg4.ikesnowy.com/1-5-1/</link><pubDate>Fri, 22 Jun 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-1/</guid><description>1.5.1 # 解答 # quick-find 的官方实现：QuickFindUF.java。
只要实现相应并查集，然后输入内容即可。
增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
样例输出：
1 2 3 4 5 6 7 8 0 数组访问：13 1 2 4 4 5 6 7 8 0 数组访问：13 1 2 4 4 8 6 7 8 0 数组访问：13 1 2 4 4 8 6 2 8 0 数组访问：13 1 1 4 4 8 6 1 8 0 数组访问：14 1 1 4 4 1 6 1 1 0 数组访问：14 1 1 4 4 1 6 1 1 4 数组访问：14 1 1 1 1 1 6 1 1 1 数组访问：16 代码 # QuickFindUF.</description></item><item><title>1.5.2</title><link>https://alg4.ikesnowy.com/1-5-2/</link><pubDate>Fri, 22 Jun 2018 19:39:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-2/</guid><description>1.5.2 # 解答 # quick-union 的官方实现：QuickUnionUF.java。
和上题一样的方式，增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
程序输出的森林，用缩进表示子树：
|---- 0 |---- 9 |---- 1 |---- 2 |---- 3 |---- 4 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 6 |---- 7 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 3 |---- 6 数组访问：7 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 0 |---- 9 |---- 3 |---- 6 数组访问：3 |---- 1 |---- 2 |---- 7 |---- 4 |---- 0 |---- 9 |---- 3 |---- 8 |---- 5 |---- 6 数组访问：3 代码 # QuickUnionUF.</description></item><item><title>1.5.3</title><link>https://alg4.ikesnowy.com/1-5-3/</link><pubDate>Fri, 22 Jun 2018 19:41:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-3/</guid><description>1.5.3 # 解答 # 加权 quick-union 的官方实现：WeightedQuickUnionUF.java。
样例输出：
1 2 3 4 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 5 9 数组访问：3 1 7 3 3 5 6 7 5 9 数组访问：3 7 7 3 3 5 6 7 5 9 数组访问：5 7 7 3 3 7 6 7 5 9 数组访问：3 7 7 9 3 7 6 7 5 9 数组访问：5 7 7 9 3 7 6 7 5 7 数组访问：9 代码 # WeightedQuickUnionUF.</description></item><item><title>1.5.4</title><link>https://alg4.ikesnowy.com/1-5-4/</link><pubDate>Fri, 22 Jun 2018 19:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-4/</guid><description>1.5.4 # 解答 # 对照输入和最坏输入均在书中出现，中文版见：P146，英文版见：P229。
样例输出：
3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 8 9 size: 1 1 1 1 2 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 4 9 size: 1 1 1 1 3 1 1 1 1 1 parent visit count:5 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 9 size: 1 1 1 1 3 1 2 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 4 size: 1 1 1 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:6 size visit count:0 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 3 1 1 1 parent visit count:5 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 3 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:5 size visit count:4 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:8 size visit count:0 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:6 size visit count:0 ------------------------------------- 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 2 3 4 5 6 7 8 9 size: 2 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 3 4 5 6 7 8 9 size: 3 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 4 5 6 7 8 9 size: 4 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 5 6 7 8 9 size: 5 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 6 7 8 9 size: 6 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 6 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 7 8 9 size: 7 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 8 9 size: 8 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 9 size: 9 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 0 size: 10 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 代码 # Main 方法：</description></item><item><title>1.5.5</title><link>https://alg4.ikesnowy.com/1-5-5/</link><pubDate>Fri, 22 Jun 2018 19:44:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-5/</guid><description>1.5.5 # 解答 # $10^6$ 条连接 = $10^6$ 组输入。
对于 quick-find 算法，每次 union() 都要遍历整个数组。
因此总共进行了 $10^9 \times 10^6 = 10^{15}$ 次 for 循环迭代。
每次 for 循环迭代都需要 $10$ 条机器指令，
因此总共执行了 $10 \times10^{15} = 10^{16}$ 条机器指令。
已知计算机每秒能够执行 $10^9$ 条机器指令，
因此执行完所有指令需要 $10^{16} / 10^9 = 10^7$ 秒 = $115.74$ 天。</description></item><item><title>1.5.6</title><link>https://alg4.ikesnowy.com/1-5-6/</link><pubDate>Fri, 22 Jun 2018 19:47:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-6/</guid><description>1.5.6 # 解答 # 加权 quick-union 算法最多只需要 $lgN $次迭代就可以完成一次 union()。
因此按照上题思路，总共需要 $(lg(10^9) \times 10^6 \times 10) / 10^9 = 0.299$ 秒。</description></item><item><title>1.5.7</title><link>https://alg4.ikesnowy.com/1-5-7/</link><pubDate>Fri, 22 Jun 2018 19:50:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-7/</guid><description>1.5.7 # 解答 # 见 1.5.1 和 1.5.2 的解答。</description></item><item><title>1.5.8</title><link>https://alg4.ikesnowy.com/1-5-8/</link><pubDate>Fri, 22 Jun 2018 19:51:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-8/</guid><description>1.5.8 # 解答 # 当有多个元素需要修改的时候，这个直观算法可能会出现错误。
例如如下情况：
index 0 1 2 3 4 5 6 7 8 9 id 0 0 0 0 0 5 5 5 5 5 输入 0, 5
i = 0 时，id[i] == id[p]，此时 id[i] = id[q]。
数组变为 5 0 0 0 0 5 5 5 5 5
i = 1 时，id[i] != id[p]，算法出现错误。
只要在 id[p] 之后还有需要修改的元素，那么这个算法就会出现错误。</description></item><item><title>1.5.9</title><link>https://alg4.ikesnowy.com/1-5-9/</link><pubDate>Fri, 22 Jun 2018 19:52:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-9/</guid><description>1.5.9 # 解答 # 不可能。 树如下所示。
由于加权 quick-union 算法任意节点的最大深度为 lgN （节点总数为 N）。
（这个结论可以在中文版 P146，或者英文版 P228 找到）
上面这个树的最大深度为 4 &amp;gt; lg10
因此这棵树不可能是通过加权 quick-union 算法得到的。</description></item><item><title>1.5.10</title><link>https://alg4.ikesnowy.com/1-5-10/</link><pubDate>Fri, 22 Jun 2018 19:54:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-10/</guid><description>1.5.10 # 解答 # 本题答案已经给出，也很好理解。
如果合并时只是把子树挂到结点 q 上而非其根节点，
树的高度会明显增加，进而增加每次 Find() 操作的开销。</description></item><item><title>1.5.11</title><link>https://alg4.ikesnowy.com/1-5-11/</link><pubDate>Fri, 22 Jun 2018 19:55:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-11/</guid><description>1.5.11 # 解答 # 类似于加权 quick-union 的做法，新增一个 size[] 数组以记录各个根节点的大小。
每次合并时先比较一下两棵树的大小，再进行合并。
这样会略微减少赋值语句的执行次数，提升性能。
代码 # WeightedQuickFindUF.cs
/// &amp;lt;summary&amp;gt; /// 用加权 QuickFind 算法实现的并查集。 /// &amp;lt;/summary&amp;gt; public class WeightedQuickFindUf { private readonly int[] _size; // 记录每个连通分量的大小。 private readonly int[] _id; // 记录每个结点的连通分量。 private int _count;// 连通分量总数。 public int ArrayVisitCount { get; private set; } //记录数组访问的次数。 /// &amp;lt;summary&amp;gt; /// 新建一个使用加权 quick-find 实现的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickFindUf(int n) { _count = n; _id = new int[n]; _size = new int[n]; for (var i = 0; i &amp;lt; n; i++) { _id[i] = i; _size[i] = 1; } } /// &amp;lt;summary&amp;gt; /// 重置数组访问计数。 /// &amp;lt;/summary&amp;gt; public void ResetArrayCount() { ArrayVisitCount = 0; } /// &amp;lt;summary&amp;gt; /// 表示并查集中连通分量的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回并查集中连通分量的数量。&amp;lt;/returns&amp;gt; public int Count() { return _count; } /// &amp;lt;summary&amp;gt; /// 寻找 p 所在的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回 p 所在的连通分量。&amp;lt;/returns&amp;gt; public int Find(int p) { Validate(p); ArrayVisitCount++; return _id[p]; } /// &amp;lt;summary&amp;gt; /// 判断两个结点是否属于同一个连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要判断的结点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q&amp;#34;&amp;gt;需要判断的另一个结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果属于同一个连通分量则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; public bool IsConnected(int p, int q) { Validate(p); Validate(q); ArrayVisitCount += 2; return _id[p] == _id[q]; } /// &amp;lt;summary&amp;gt; /// 将两个结点所在的连通分量合并。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要合并的结点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q&amp;#34;&amp;gt;需要合并的另一个结点。&amp;lt;/param&amp;gt; public void Union(int p, int q) { Validate(p); Validate(q); var pId = _id[p]; var qId = _id[q]; ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。 if (pId == qId) { return; } // 判断较大的连通分量和较小的连通分量。 int larger; int smaller; if (_size[pId] &amp;gt; _size[qId]) { larger = pId; smaller = qId; _size[pId] += _size[qId]; } else { larger = qId; smaller = pId; _size[qId] += _size[pId]; } // 将较小的连通分量连接到较大的连通分量上， // 这会减少赋值语句的执行次数，略微减少数组访问。 for (var i = 0; i &amp;lt; _id.</description></item><item><title>1.5.12</title><link>https://alg4.ikesnowy.com/1-5-12/</link><pubDate>Fri, 22 Jun 2018 19:57:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-12/</guid><description>1.5.12 # 解答 # QuickUnionPathCompression 的官方实现：QuickUnionPathCompressionUF.java
在找到根节点之后，再访问一遍 p 到根节点这条路径上的所有结点，将它们直接和根节点相连。
重写过后的 Find() 方法：
/// &amp;lt;summary&amp;gt; /// 寻找结点所属的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结点所属的连通分量。&amp;lt;/returns&amp;gt; public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } 由于路径压缩是在 Find() 方法中实现的，
只要输入保证是根节点两两相连即可构造较长的路径。
代码 # QuickUnionPathCompressionUF.cs 直接从 QuickUnionUF.</description></item><item><title>1.5.13</title><link>https://alg4.ikesnowy.com/1-5-13/</link><pubDate>Fri, 22 Jun 2018 19:59:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-13/</guid><description>1.5.13 # 解答 # 官方实现：WeightedQuickUnionPathCompressionUF。
加权 quick-union 中，两个大小相等的树合并可以有效增加高度，同时输入必须保证是根节点以规避路径压缩。
代码 # WeightedQuickUnionPathCompressionUF.cs 从 WeightedQuickUnionUF.cs 继承，详情参见 1.5.3 的解答。
public class WeightedQuickUnionPathCompressionUf : WeightedQuickUnionUf { /// &amp;lt;summary&amp;gt; /// 新建一个大小为 n 的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;新建并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickUnionPathCompressionUf(int n) : base(n) { Size = new int[n]; for (var i = 0; i &amp;lt; n; i++) { Size[i] = 1; } } /// &amp;lt;summary&amp;gt; /// 寻找一个结点所在的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;该结点所属的连通分量。&amp;lt;/returns&amp;gt; public override int Find(int p) { Validate(p); var root = p; while (root !</description></item><item><title>1.5.14</title><link>https://alg4.ikesnowy.com/1-5-14/</link><pubDate>Fri, 22 Jun 2018 20:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-14/</guid><description>1.5.14 # 解答 # WeightedQuickUnionByHeight 的官方实现：WeightedQuickUnionByHeightUF.java。
证明： 一次 Union 操作只可能发生如下两种情况。
两棵树的高度相同，这样合并后的新树的高度等于较大那棵树的高度 + 1。
两棵树的高度不同，这样合并后的新树高度等于较大那棵树的高度。
现在证明通过加权 quick-union 算法构造的高度为 h 的树至少包含 2h 个结点。
基础情况，高度 h = 0, 结点数 k = 1。
为了使高度增加，必须用一棵高度相同的树合并，而 h = 0 时结点数一定是 1，则：
h = 1, k = 2
由于两棵大小不同的树合并，最大高度不会增加，只会增加结点数。
因此，每次都使用相同高度的最小树进行合并，有：
h = 2, k = 4 h = 3, k = 8 h = 4, k = 16 ...... 递推即可得到结论，k ≥ 2^h
因此 h &amp;lt;= lgk</description></item><item><title>1.5.15</title><link>https://alg4.ikesnowy.com/1-5-15/</link><pubDate>Fri, 22 Jun 2018 20:05:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-15/</guid><description>1.5.15 # 解答 # 首先证明在最坏情况下加权 quick-union 算法生成的树中的每一层结点数均为二项式系数。
最坏情况下，每次 union 操作都是合并相同大小的树，如下图所示：
设第 i 层的结点数为 ki，那么最坏情况下每次合并后的 ki’ = ki + ki-1 。
这符合二项式系数的构造特点（详情可以搜索杨辉三角），
第一个结论证明完毕。
接下来求平均深度，首先根据二项式的求和公式，一棵深度为 n 的树（根结点的深度为零）结点总数为：
$$ \sum_{k=0}^{n} \begin{pmatrix} n \newline k \end{pmatrix} =2^n $$
每层结点数 × 该层深度后的和为：
$$ \sum_{k=0}^{n}k \cdot \begin{pmatrix} n \newline k \end{pmatrix}=n\sum_{k=1}^{n} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix}=n\sum_{s=0}^{n-1} \begin{pmatrix} n-1 \newline s \end{pmatrix}=n2^{n-1} $$
这里用到了这个公式化简：
$$ \begin{pmatrix} n \newline k \end{pmatrix}=\frac{n}{k} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix} $$</description></item><item><title>1.5.16</title><link>https://alg4.ikesnowy.com/1-5-16/</link><pubDate>Fri, 22 Jun 2018 20:44:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-16/</guid><description>1.5.16 # 解答 # 给出绘图结果样例：
代码 # 仅给出绘图相关的代码，窗体部分见 github 上的代码：
using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._16 { static class Program { [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { char[] split = { &amp;#39;\n&amp;#39;, &amp;#39;\r&amp;#39; }; string[] input = TestCase.Properties.Resources.mediumUF.Split(split, StringSplitOptions.RemoveEmptyEntries); int size = int.Parse(input[0]); QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); string[] pair; int p, q; int[] quickFindResult = new int[size]; int[] quickUnionResult = new int[size]; for (int i = 1; i &amp;lt; size; ++i) { pair = input[i].</description></item><item><title>1.5.17</title><link>https://alg4.ikesnowy.com/1-5-17/</link><pubDate>Fri, 22 Jun 2018 20:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-17/</guid><description>1.5.17 # 解答 # 官方给出的 ErdosRenyi：ErdosRenyi.java。
为了方便之后做题，除了 Count() 之外，这个类还包含其他方法，具体可以查看注释。
代码 # ErdosRenyi.cs
public class ErdosRenyi { /// &amp;lt;summary&amp;gt; /// 随机生成一组能让并查集只剩一个连通分量的连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;一组能让并查集只剩一个连通分量的连接。&amp;lt;/returns&amp;gt; public static Connection[] Generate(int n) { var random = new Random(); var connections = new List&amp;lt;Connection&amp;gt;(); var uf = new WeightedQuickUnionPathCompressionUf(n); while (uf.Count() &amp;gt; 1) { var p = random.Next(n); var q = random.Next(n); uf.Union(p, q); connections.Add(new Connection(p, q)); } return connections.ToArray(); } /// &amp;lt;summary&amp;gt; /// 随机生成连接，返回令并查集中只剩一个连通分量所需的连接总数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;uf&amp;#34;&amp;gt;用于测试的并查集。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;需要的连接总数。&amp;lt;/returns&amp;gt; public static int Count(Uf uf) { var random = new Random(); var size = uf.</description></item><item><title>1.5.18</title><link>https://alg4.ikesnowy.com/1-5-18/</link><pubDate>Fri, 22 Jun 2018 20:48:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-18/</guid><description>1.5.18 # 解答 # 具体生成的连接样式见下题，这里给出 RandomGrid 的实现，需要使用 1.3 节中的随机背包辅助。
代码 # RandomGrid.cs
public class RandomBag&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _bag; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一个随机背包。 /// &amp;lt;/summary&amp;gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查背包是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回背包中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向背包中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向背包中添加的元素。&amp;lt;/param&amp;gt; public void Add(TItem item) { if (_count == _bag.</description></item><item><title>1.5.19</title><link>https://alg4.ikesnowy.com/1-5-19/</link><pubDate>Fri, 22 Jun 2018 20:55:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-19/</guid><description>1.5.19 # 解答 # 最后绘出的图像：
代码 # 给出绘图部分的代码，窗体部分见 GitHub。
using System; using System.Drawing; using System.Collections.Generic; using System.Windows.Forms; using UnionFind; namespace _1._5._19 { /* * 1.5.19 * * 动画。 * 编写一个 RandomGrid（请见练习 1.5.18）的用例， * 和我们开发用例一样使用 UnionFind 来检查触点的连通性并在处理时用 StdDraw 将它们绘出。 * */ static class Program { static RandomBag&amp;lt;Connection&amp;gt; bag; static Graphics graphics; static TextBox logBox; static PointF[] points; static Timer timer; static List&amp;lt;Connection&amp;gt; connections; static int count = 0; /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.</description></item><item><title>1.5.20</title><link>https://alg4.ikesnowy.com/1-5-20/</link><pubDate>Thu, 28 Jun 2018 13:34:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-20/</guid><description>1.5.20 # 解答 # 将 parent 数组和 size 数组用链表代替即可，很容易实现。
代码 # 修改后的 WeightedQuickUnionUF.cs
public class WeightedQuickUnionUf { protected LinkedList&amp;lt;int&amp;gt; Parent; // 记录各个结点的父级。 protected LinkedList&amp;lt;int&amp;gt; Size; // 记录各个树的大小。 protected int Count; // 分量数目。 /// &amp;lt;summary&amp;gt; /// 建立使用加权 quick-union 的并查集。 /// &amp;lt;/summary&amp;gt; public WeightedQuickUnionUf() { Parent = new LinkedList&amp;lt;int&amp;gt;(); Size = new LinkedList&amp;lt;int&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 获取 parent 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;parent 数组。&amp;lt;/returns&amp;gt; public LinkedList&amp;lt;int&amp;gt; GetParent() { return Parent; } /// &amp;lt;summary&amp;gt; /// 获取 size 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回 size 数组。&amp;lt;/returns&amp;gt; public LinkedList&amp;lt;int&amp;gt; GetSize() { return Size; } /// &amp;lt;summary&amp;gt; /// 在并查集中增加一个新的结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;新结点的下标。&amp;lt;/returns&amp;gt; public int NewSite() { Parent.</description></item><item><title>1.5.21</title><link>https://alg4.ikesnowy.com/1-5-21/</link><pubDate>Thu, 28 Jun 2018 13:37:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-21/</guid><description>1.5.21 # 解答 # 给出我电脑上的结果：
实验结果：16 1/2NlnN：11.51292546497023 实验结果：38 1/2NlnN：29.957322735539908 实验结果：89 1/2NlnN：73.77758908227872 实验结果：194 1/2NlnN：175.28106538695525 实验结果：455 1/2NlnN：406.0139052187061 实验结果：1050 1/2NlnN：922.9313593270035 实验结果：2300 1/2NlnN：2067.6698164331897 实验结果：4918 1/2NlnN：4578.953828424745 实验结果：10812 1/2NlnN：10045.136047966218 实验结果：23478 1/2NlnN：21864.728878165897 代码 # for (var n = 10; n &amp;lt; 10000; n *= 2) { var total = 0; for (var i = 0; i &amp;lt; 100; i++) { var uf = new Uf(n); total += ErdosRenyi.Count(uf); } Console.WriteLine(&amp;#34;实验结果：&amp;#34; + total / 100); Console.WriteLine(&amp;#34;1/2NlnN：&amp;#34; + Math.</description></item><item><title>1.5.22</title><link>https://alg4.ikesnowy.com/1-5-22/</link><pubDate>Thu, 28 Jun 2018 13:39:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-22/</guid><description>1.5.22 # 解答 # 平方级别算法在输入加倍后耗时应该增加四倍，线性则是两倍。
下面给出我电脑上的结果，数据量较大时比较明显：
N:16000 quick-find 平均次数：8452 用时：143 比值：4.46875 quick-union 平均次数：7325 用时：202 比值：3.25806451612903 weighted-quick-union 平均次数：6889 用时：1 N:32000 quick-find 平均次数：15747 用时：510 比值：3.56643356643357 quick-union 平均次数：15108 用时：801 比值：3.96534653465347 weighted-quick-union 平均次数：17575 用时：3 比值：3 N:64000 quick-find 平均次数：33116 用时：2069 比值：4.05686274509804 quick-union 平均次数：38608 用时：4635 比值：5.78651685393258 weighted-quick-union 平均次数：34850 用时：6 比值：2 代码 # long lastTimeQuickFind = 0; long lastTimeQuickUnion = 0; long lastTimeWeightedQuickUnion = 0; for (var n = 2000; n &amp;lt; 100000; n *= 2) { Console.</description></item><item><title>1.5.23</title><link>https://alg4.ikesnowy.com/1-5-23/</link><pubDate>Thu, 28 Jun 2018 13:41:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-23/</guid><description>1.5.23 # 解答 # 先用速度最快的 WeightedQuickUnionUF 生成一系列连接，
保存后用这些连接进行测试，生成连接的方法见 1.5.17 的解答。
下面给出我电脑上的结果：
N:2000 quick-find 耗时（毫秒）：4 quick-union 耗时（毫秒）：5 比值：0.8 N:4000 quick-find 耗时（毫秒）：19 quick-union 耗时（毫秒）：24 比值：0.791666666666667 N:8000 quick-find 耗时（毫秒）：57 quick-union 耗时（毫秒）：74 比值：0.77027027027027 N:16000 quick-find 耗时（毫秒）：204 quick-union 耗时（毫秒）：307 比值：0.664495114006515 N:32000 quick-find 耗时（毫秒）：1127 quick-union 耗时（毫秒）：1609 比值：0.700435052827843 代码 # var n = 2000; for (var t = 0; t &amp;lt; 5; t++) { var input = ErdosRenyi.Generate(n); var quickFind = new QuickFindUf(n); var quickUnion = new QuickUnionUf(n); Console.</description></item><item><title>1.5.24</title><link>https://alg4.ikesnowy.com/1-5-24/</link><pubDate>Thu, 28 Jun 2018 13:47:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-24/</guid><description>1.5.24 # 解答 # 根据上题的代码略作修改即可，路径压缩大概可以快 1/3。
N:10000 加权 quick-find 耗时（毫秒）：9 带路径压缩的加权 quick-union 耗时（毫秒）：6 比值：1.5 N:20000 加权 quick-find 耗时（毫秒）：12 带路径压缩的加权 quick-union 耗时（毫秒）：8 比值：1.5 N:40000 加权 quick-find 耗时（毫秒）：18 带路径压缩的加权 quick-union 耗时（毫秒）：12 比值：1.5 N:80000 加权 quick-find 耗时（毫秒）：36 带路径压缩的加权 quick-union 耗时（毫秒）：30 比值：1.2 N:160000 加权 quick-find 耗时（毫秒）：67 带路径压缩的加权 quick-union 耗时（毫秒）：41 比值：1.63414634146341 代码 # var n = 10000; for (var t = 0; t &amp;lt; 5; t++) { var input = ErdosRenyi.Generate(n); var weightedQuickUnionUf = new WeightedQuickUnionUf(n); var weightedQuickUnionPathCompressionUf = new WeightedQuickUnionPathCompressionUf(n); Console.</description></item><item><title>1.5.25</title><link>https://alg4.ikesnowy.com/1-5-25/</link><pubDate>Thu, 28 Jun 2018 13:48:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-25/</guid><description>1.5.25 # 解答 # 略微修改 1.5.22 的代码即可。 我电脑上的结果：
Quick-Find N:1600 平均用时（毫秒）：4 N:6400 平均用时（毫秒）：67 比值：16.75 N:25600 平均用时（毫秒）：1268 比值：18.9253731343284 N:102400 平均用时（毫秒）：20554 比值：16.2097791798107 Quick-Union N:1600 平均用时（毫秒）：5 比值：0.000243261652233142 N:6400 平均用时（毫秒）：66 比值：13.2 N:25600 平均用时（毫秒）：1067 比值：16.1666666666667 N:102400 平均用时（毫秒）：18637 比值：17.4667291471415 Weighted Quick-Union N:1600 平均用时（毫秒）：0 比值：0 N:6400 平均用时（毫秒）：2 N:25600 平均用时（毫秒）：12 比值：6 N:102400 平均用时（毫秒）：64 比值：5.33333333333333 代码 # var n = 40; var t = 4; // quick-find Console.WriteLine(&amp;#34;Quick-Find&amp;#34;); long last = 0; long now; for (var i = 0; i &amp;lt; t; i++, n *= 2) { Console.</description></item><item><title>1.5.26</title><link>https://alg4.ikesnowy.com/1-5-26/</link><pubDate>Thu, 28 Jun 2018 13:50:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-26/</guid><description>1.5.26 # 解答 # 和 1.5.16 的程序类似，将测试的内容改为 Erdos-Renyi 即可。
样例输出：
代码 # using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._26 { static class Program { /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { int size = 200; QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); WeightedQuickUnionUF weightedQuickUnion = new WeightedQuickUnionUF(size); Connection[] connections = ErdosRenyi.</description></item><item><title>2.1.1</title><link>https://alg4.ikesnowy.com/2-1-1/</link><pubDate>Sat, 30 Jun 2018 14:08:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-1/</guid><description> 2.1.1 # 解答 #</description></item><item><title>2.1.2</title><link>https://alg4.ikesnowy.com/2-1-2/</link><pubDate>Sat, 30 Jun 2018 14:15:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-2/</guid><description>2.1.2 # 解答 # 最多会被交换 n 次，只要将一个有序数列循环右移一位就可以构造这样的情况。
例如：
平均每个元素被交换了 N/N=1 次。（总共 N 个元素，总共发生了 N 次交换）。</description></item><item><title>2.1.3</title><link>https://alg4.ikesnowy.com/2-1-3/</link><pubDate>Sat, 30 Jun 2018 14:17:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-3/</guid><description>2.1.3 # 解答 # 你需要一个逆序的数组。
例如： 9 8 7 6 5 4 3 2 1 i=0 条件满足 8 次，1 和 9 交换，1 8 7 6 5 4 3 2 9。
i=1 条件满足 6 次，2 和 8 交换，1 2 7 6 5 4 3 8 9。
i=2 条件满足 4 次，3 和 7 交换，1 2 3 6 5 4 7 8 9。
i=3 条件满足 2 次，4 和 6 交换。1 2 3 4 5 6 7 8 9。</description></item><item><title>2.1.4</title><link>https://alg4.ikesnowy.com/2-1-4/</link><pubDate>Sat, 30 Jun 2018 14:18:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-4/</guid><description> 2.1.4 # 解答 #</description></item><item><title>2.1.5</title><link>https://alg4.ikesnowy.com/2-1-5/</link><pubDate>Sat, 30 Jun 2018 14:19:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-5/</guid><description>2.1.5 # 解答 # 条件是：
j &amp;gt; 0 &amp;amp;&amp;amp; less(a[j], a[j - 1]) 第一个条件属于循环计数用的条件，与数组元素无关；
第二个条件当 a[j] 和 a[j - 1] 是一组逆序对时满足，因此这个条件总是为假 = 数组没有逆序对 = 数组有序。
因此只要输入已经排好序的数组即可。
逆序对：指序列中顺序相反的两个数，例如 1 2 3 4 5 7 6 8 9 中的 7 6。
另请参阅 # 逆序对-维基百科</description></item><item><title>2.1.6</title><link>https://alg4.ikesnowy.com/2-1-6/</link><pubDate>Sat, 30 Jun 2018 14:22:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-6/</guid><description>2.1.6 # 解答 # 插入排序更快。
选择排序无论如何都需要 $n + (n-1) + (n-2) + … + 1 = \frac{n^2}{2}$ 次比较。
插入排序在这种情况下只需要 n 次比较。（所有主键相同 = 数组已排序）</description></item><item><title>2.1.7</title><link>https://alg4.ikesnowy.com/2-1-7/</link><pubDate>Sat, 30 Jun 2018 14:23:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-7/</guid><description> 2.1.7 # 解答 # 假设比较的开销小于等于交换的开销，此时选择排序更快，具体比较见下表。
排序方法 比较次数 交换次数 插入排序 ~N^2/2 ~N^2/2 选择排序 ~N^2/2 N</description></item><item><title>2.1.8</title><link>https://alg4.ikesnowy.com/2-1-8/</link><pubDate>Sat, 30 Jun 2018 14:25:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-8/</guid><description>2.1.8 # 解答 # 平方级别。
如果数组中元素各不相同，那么这个结论很容易证明（一般的插入排序）。
接下来我们证明有重复元素的情况下，这个结论仍然成立：
首先对于插入排序过程中的某一时刻，我们有下图这样的一般情况：
$$ \underbrace{11&amp;hellip;1}{a} \ \underbrace{22&amp;hellip;2}{b} \ \underbrace{33&amp;hellip;3}{c} \ \underbrace{13121123}{unsorted} $$
其中，1，2，3 分别代表三种不同的取值及其先后顺序。
假设这是第 i 次插入前，如果第 i 次插入的是 1，我们需要交换 b+c 次，插入 2 则需要交换 c 次，插入 3 则不需要交换。
根据题意，这是一个随机数组，我们假设其为均匀分布，那么三种取值的出现几率相等。
第 i 次插入所需要的平均交换次数即为：
$$ \frac{b+c+c}{3}=\frac{b+2c}{3} $$
第 i 次插入后，b + 2c 视插入的元素不同会出现不同的变化：
如果插入的是 1，那么 b+2c 的值不会变化。
如果插入的是 2，那么 b+2c 的值增加 1。
如果插入的是 3，那么 b+2c 的值增加 2。
同样由于三种取值的概率相等，我们得出第 i + 1 次插入平均需要交换的次数为：
$$ \frac{b+2c+\frac{0+1+2}{3}}{3}=\frac{b+2c+1}{3} $$
也就是说，平均每次插入都会使下一次插入的交换次数增加 1/3。</description></item><item><title>2.1.9</title><link>https://alg4.ikesnowy.com/2-1-9/</link><pubDate>Sat, 30 Jun 2018 14:38:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-9/</guid><description> 2.1.9 # 解答 #</description></item><item><title>2.1.10</title><link>https://alg4.ikesnowy.com/2-1-10/</link><pubDate>Sat, 30 Jun 2018 15:02:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-10/</guid><description>2.1.10 # 解答 # 对于部分有序的数组，插入排序比选择排序快。
这个结论可以在中文版 P158， 英文版 P252 找到。</description></item><item><title>2.1.11</title><link>https://alg4.ikesnowy.com/2-1-11/</link><pubDate>Sat, 30 Jun 2018 15:06:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-11/</guid><description>2.1.11 # 解答 # 希尔排序的官方实现：https://algs4.cs.princeton.edu/21elementary/Shell.java.html
只要稍作修改即可，详情见代码。
代码 # public override void Sort&amp;lt;T&amp;gt;(T[] a) { var n = a.Length; var h = new int[2]; // 预先准备好的 h 值数组 var hTemp = 1; int sequenceSize; for (sequenceSize = 0; hTemp &amp;lt; n; sequenceSize++) { if (sequenceSize &amp;gt;= h.Length) // 如果数组不够大则双倍扩容 { var expand = new int[h.Length * 2]; for (var j = 0; j &amp;lt; h.Length; j++) { expand[j] = h[j]; } h = expand; } h[sequenceSize] = hTemp; hTemp = hTemp * 3 + 1; } for (var t = sequenceSize - 1; t &amp;gt;= 0; t--) { for (var i = h[t]; i &amp;lt; n; i++) { for (var j = i; j &amp;gt;= h[t] &amp;amp;&amp;amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.</description></item><item><title>2.1.12</title><link>https://alg4.ikesnowy.com/2-1-12/</link><pubDate>Sat, 30 Jun 2018 15:10:47 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-12/</guid><description>2.1.12 # 解答 # 结果截图如下，同一个 h 值对应的比值在数组大小不同时保持为一个小常数：
代码 # // 查看最后结果 // 可以发现相同的 h 在数组大小不同时所产生的比值十分接近。 var random = new Random(); var sort = new ShellSort(); var size = 100; for (var i = 0; i &amp;lt; 5; i++) { var a = new double[size]; for (var j = 0; j &amp;lt; size; j++) { a[j] = random.NextDouble() * 100; } Console.WriteLine(&amp;#34;ArraySize:&amp;#34; + size); sort.Sort(a); size *= 10; } 另请参阅 # Sort 库</description></item><item><title>2.1.13</title><link>https://alg4.ikesnowy.com/2-1-13/</link><pubDate>Sat, 30 Jun 2018 15:14:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-13/</guid><description>2.1.13 # 解答 # 可以用冒泡排序做，具体方法如下：
翻一二两张，是逆序对就交换，否则什么也不做
翻二三两张，是逆序对就交换，否则什么也不做
一直到最后，可以保证最右侧的是最大花色的牌
然后不断重复上述过程，就可以完全排序</description></item><item><title>2.1.14</title><link>https://alg4.ikesnowy.com/2-1-14/</link><pubDate>Sat, 30 Jun 2018 15:15:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-14/</guid><description>2.1.14 # 解答 # 用一种类似于冒泡的方法做，具体步骤为：
重复以下步骤，直到全部完成一遍之后没有发生交换 重复以下步骤 n-1 次 如果顶端两张牌逆序，那么交换它们。 将第一张牌放到牌堆底部。 具体步骤图：
我们将牌排成一个环，用一支笔隔开，这里我们标记笔的左侧是牌堆顶部，右侧是牌堆底部。
那么我们能做的三个操作在这里即为：
查看最上面两张牌 = 从笔的位置开始，逆时针查看两张牌。
交换最上面两张牌 = 从笔的位置开始，逆时针选择两张牌并交换。
将最上面的一张牌放到最下面 = 将笔的位置逆时针移动一位。
下面我们开始执行开始说过的操作，目标顺序是自顶向下从小到大排列。
初始情况如图所示：
梅花7 和 红桃4 不是逆序对，直接将笔逆时针移动一位。
红桃4 和 黑桃6 不是逆序对，我们将笔逆时针移动一位。
再看 黑桃6 和 方片A，是逆序对，我们交换并将笔逆时针移动一位。
再看 黑桃6 和 红桃J，是逆序对，我们交换并将笔逆时针移动一位。
现在我们已经操作了 4 次，内部循环结束，我们将笔放回初始位置。
这样一次循环之后，我们就把最大的牌放在了最下面，依次类推即可完全排序。
另请参阅 # Sorting a deque using limited operations?-Stock Overflow</description></item><item><title>2.1.15</title><link>https://alg4.ikesnowy.com/2-1-15/</link><pubDate>Sat, 30 Jun 2018 15:25:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-15/</guid><description>2.1.15 # 解答 # 选择排序
交换（也就是 Exch() 方法）需要一个额外空间，这里的条件满足。
现在我们应该使交换次数最少，选择排序只需要 N 次交换，比插入排序平均 N^2/4 少（N &amp;gt; 2）。</description></item><item><title>2.1.16</title><link>https://alg4.ikesnowy.com/2-1-16/</link><pubDate>Sat, 30 Jun 2018 15:27:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-16/</guid><description>2.1.16 # 解答 # 如果移动数据时新建了对象，那么虽然值没有改变，但是数组中的对象被修改了。
代码 # 插入排序中的 Exch() 换成了如下方式：
string temp = new string(s[i].ToCharArray()); s[i] = s[min]; s[min] = temp; 全部程序代码如下：
var test = new[] { &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;e&amp;#34; }; Console.WriteLine(CheckArraySort(test)); Console.WriteLine(CheckSelectionSort(test)); // 测试 Array.Sort() 方法。 static bool CheckArraySort(string[] a) { var backup = new string[a.Length]; a.CopyTo(backup, 0); Array.Sort(a); foreach (var n in a) { var isFind = false; for (var i = 0; i &amp;lt; a.</description></item><item><title>2.1.17</title><link>https://alg4.ikesnowy.com/2-1-17/</link><pubDate>Sat, 30 Jun 2018 19:24:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-17/</guid><description>2.1.17 # 解答 # 选择排序：
插入排序：
代码 # 使用一个 timer 按一定时间重绘数组，排序算法里面一次循环后等待一段时间再进行下一次循环。（这并不是一个很好的方法，但对于演示来说足够了）
这里排序算法是另开线程运行的，防止 Sleep 的时候让程序无响应。
选择排序：
using System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._17 { public partial class Form2 : Form { double[] randomDoubles; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i &amp;lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } drawPanel(); this.timer1.Interval = 60; this.</description></item><item><title>2.1.18</title><link>https://alg4.ikesnowy.com/2-1-18/</link><pubDate>Sat, 30 Jun 2018 19:29:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-18/</guid><description>2.1.18 # 解答 # 选择排序
插入排序
代码 # 与上题类似，但要特别标出移动的元素。 选择排序：
using System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._18 { public partial class Form2 : Form { double[] randomDoubles; int sortI; int sortJ; int sortMin; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i &amp;lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } } /// &amp;lt;summary&amp;gt; /// 选择排序。 /// &amp;lt;/summary&amp;gt; private void SelectionSort() { for (this.</description></item><item><title>2.1.19</title><link>https://alg4.ikesnowy.com/2-1-19/</link><pubDate>Sat, 30 Jun 2018 19:32:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-19/</guid><description>2.1.19 # 解答 # 不得不说这道题意外的难。
放上论文链接：Shellsort and Sorting Networks (Outstanding Dissertations in the Computer Sciences)
这篇论文的第二章给出了一种构造最坏序列的方法，当然理想最坏（n^(3/2)）是达不到的了。
最后结果是 793 次。
@杨晗 通过随机输入获得了一个理论最坏的输入序列，见：https://github.com/YangXiaoHei/Algorithms/blob/master/Ch_2_1_Elementary_Sorts/Practise_2_1_19.java
这个序列是：
48, 46, 54, 97, 83, 69, 76, 25, 10, 5, 87, 12, 21, 99, 61, 33, 30, 47, 57, 4, 36, 42, 98, 66, 100, 17, 94, 81, 11, 77, 24, 89, 73, 53, 38, 7, 29, 8, 27, 23, 56, 70, 60, 85, 39, 65, 9, 75, 15, 67, 64, 22, 51, 82, 43, 3, 37, 91, 45, 13, 34, 63, 74, 71, 95, 55, 80, 92, 2, 19, 62, 40, 84, 41, 50, 88, 86, 59, 28, 44, 72, 68, 14, 35, 93, 26, 18, 78, 31, 58, 96, 6, 1, 90, 49, 16, 52, 79, 32, 20 会比较 999 次。</description></item><item><title>2.1.20</title><link>https://alg4.ikesnowy.com/2-1-20/</link><pubDate>Sat, 30 Jun 2018 19:35:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-20/</guid><description>2.1.20 # 解答 # 由于每次 h 排序都是插入排序，希尔排序最好情况就是插入排序的最好情况，也就是已排序的数组。</description></item><item><title>2.1.21</title><link>https://alg4.ikesnowy.com/2-1-21/</link><pubDate>Sat, 30 Jun 2018 19:38:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-21/</guid><description>2.1.21 # 解答 # 事实上官方给出来的 Date 类以及 Transaction 类都已经实现了这些接口。
Date 类：Date.java
Transaction 类：Transaction.java
代码 # var a = new Transaction[4]; a[0] = new Transaction(&amp;#34;Turing 6/17/1990 644.08&amp;#34;); a[1] = new Transaction(&amp;#34;Tarjan 3/26/2002 4121.85&amp;#34;); a[2] = new Transaction(&amp;#34;Knuth 6/14/1999 288.34&amp;#34;); a[3] = new Transaction(&amp;#34;Dijkstra 8/22/2007 2678.40&amp;#34;); Console.WriteLine(&amp;#34;Unsorted&amp;#34;); for (var i = 0; i &amp;lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(&amp;#34;Sort by amount&amp;#34;); var insertionSort = new InsertionSort(); insertionSort.Sort(a, new Transaction.HowMuchOrder()); for (var i = 0; i &amp;lt; a.</description></item><item><title>2.1.22</title><link>https://alg4.ikesnowy.com/2-1-22/</link><pubDate>Sat, 30 Jun 2018 19:39:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-22/</guid><description>2.1.22 # 解答 # 和上题类似，只要传入事先写好的比较器就可以了。
代码 # var a = new Transaction[4]; // 样例输入 // Turing 6/17/1990 644.08 // Tarjan 3/26/2002 4121.85 // Knuth 6/14/1999 288.34 // Dijkstra 8/22/2007 2678.40 for (var i = 0; i &amp;lt; a.Length; i++) { var input = Console.ReadLine(); a[i] = new Transaction(input); } var insertionSort = new InsertionSort(); Console.WriteLine(&amp;#34;Unsorted&amp;#34;); for (var i = 0; i &amp;lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(&amp;#34;Sort by date&amp;#34;); insertionSort.</description></item><item><title>2.1.23</title><link>https://alg4.ikesnowy.com/2-1-23/</link><pubDate>Sat, 30 Jun 2018 19:40:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-23/</guid><description>2.1.23 # 解答 # 方法多种多样。
首先是冒泡，见习题 2.1.13
插入排序也可以，如下：
从前往后不断翻牌，
对于翻到的每张牌，一直和之前的牌交换，
直至前面的牌比它小或者它已经是第一张了。
也可以用基数排序
从前向后依次翻开牌，
按照花色分成四堆，
然后按花色从大到小重新排列。
比较符合直觉的是选择排序
寻找最小的牌并放到第一位，
寻找范围向右缩减一位，重复上一步，直到最后一张。
还有其他方法，这里不再赘述。</description></item><item><title>2.1.24</title><link>https://alg4.ikesnowy.com/2-1-24/</link><pubDate>Sat, 30 Jun 2018 19:42:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-24/</guid><description>2.1.24 # 解答 # 如果使用官方的实现（InsertionX.java），最后结果可能会比一般插入排序慢，因为它是用冒泡的方法找最小值的。
一般做法是在待排序数组的最前端插入一个很小的值（比如 int.MinValue），然后对 a[1]~a[n] 排序。
代码 # 参考官方实现的插入排序：
public class InsertionSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用插入排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i &amp;gt; 0; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 1; i &amp;lt; n; i++) { for (var j = i; Less(a[j], a[j - 1]); --j) { Exch(a, j, j - 1); } Debug.</description></item><item><title>2.1.25</title><link>https://alg4.ikesnowy.com/2-1-25/</link><pubDate>Sat, 30 Jun 2018 19:44:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-25/</guid><description>2.1.25 # 解答 # 使用依次赋值的方式腾出空间，到达指定位置之后再把元素插入。
看代码会方便理解一点。
官方实现：InsertionX.java。
代码 # public class InsertionSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用插入排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i &amp;gt; 0 ; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 2; i &amp;lt; n; i++) { var j = i; var v = a[i]; while (Less(v, a[j - 1])) { a[j] = a[j - 1]; j--; } a[j] = v; Debug.</description></item><item><title>2.1.26</title><link>https://alg4.ikesnowy.com/2-1-26/</link><pubDate>Sat, 30 Jun 2018 19:44:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-26/</guid><description>2.1.26 # 解答 # 直接针对特殊值的话显然会快很多。
代码 # 直接把泛型改成 int 即可。
public class InsertionSort { /// &amp;lt;summary&amp;gt; /// 利用插入排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public void Sort(int[] a) { var n = a.Length; for (var i = 0; i &amp;lt; n; i++) { for (var j = i; j &amp;gt; 0 &amp;amp;&amp;amp; a[j] &amp;lt; a[j - 1]; --j) { var t = a[j]; a[j] = a[j - 1]; a[j - 1] = t; } } } } 另请参阅 # Sort 库</description></item><item><title>2.1.27</title><link>https://alg4.ikesnowy.com/2-1-27/</link><pubDate>Sat, 30 Jun 2018 19:45:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-27/</guid><description>2.1.27 # 解答 # 数据比较大的时候会比较明显。
代码 # var n = 128; var random = new Random(); double shellPrev = 1; double insertionPrev = 1; double selectionPrev = 1; while (n &amp;lt; 65538) { var testShell = new int[n]; var testInsertion = new int[n]; var testSelection = new int[n]; for (var i = 0; i &amp;lt; n; i++) { testShell[i] = random.Next(); testInsertion[i] = testShell[i]; testSelection[i] = testShell[i]; } Console.WriteLine(&amp;#34;数组大小：&amp;#34; + n); Console.</description></item><item><title>2.1.28</title><link>https://alg4.ikesnowy.com/2-1-28/</link><pubDate>Sat, 30 Jun 2018 19:46:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-28/</guid><description>2.1.28 # 解答 # 插入排序会比选择排序快上许多，当然增长级别不变。
代码 # var n = 1024; var random = new Random(); double insertionPrev = 1; double selectionPrev = 1; while (n &amp;lt; 65538) { var testInsertion = new int[n]; var testSelection = new int[n]; for (var i = 0; i &amp;lt; n; i++) { testInsertion[i] = random.Next(2); testSelection[i] = testInsertion[i]; } Console.WriteLine(&amp;#34;数组大小：&amp;#34; + n); Console.Write(&amp;#34;Insertion Sort:&amp;#34;); var insertionNow = SortCompare.Time(new InsertionSort(), testInsertion); Console.WriteLine(insertionNow + &amp;#34;\tNow/Prev=&amp;#34; + insertionNow / insertionPrev); Console.</description></item><item><title>2.1.29</title><link>https://alg4.ikesnowy.com/2-1-29/</link><pubDate>Sat, 30 Jun 2018 19:48:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-29/</guid><description>2.1.29 # 解答 # 当然是题目给出的递增序列更快啦，因为这个序列就是作者提出来的嘛。
（论文链接： http://linkinghub.elsevier.com/retrieve/pii/0196677486900015）
代码 # 修改了一下 shellsort，让它按照给定的 h 序列排序。
public class ShellSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用希尔排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;待排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;h&amp;#34;&amp;gt;需要使用的递增序列。&amp;lt;/param&amp;gt; public void Sort&amp;lt;T&amp;gt;(T[] a, int[] h) where T : IComparable&amp;lt;T&amp;gt; { var n = a.Length; var t = 0; while (h[t] &amp;lt; a.Length) { t++; if (t &amp;gt;= h.Length) break; } t--; for ( ; t &amp;gt;= 0; t--) { for (var i = h[t]; i &amp;lt; n; i++) { for (var j = i; j &amp;gt;= h[t] &amp;amp;&amp;amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.</description></item><item><title>2.1.30</title><link>https://alg4.ikesnowy.com/2-1-30/</link><pubDate>Sat, 30 Jun 2018 20:07:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-30/</guid><description>2.1.30 # 解答 # 2，3，4
t 越大的话，按照这个递增序列，10^6 次能够满足的 h 也就越少。
代码 # // t = 2, 3, 4 // t 大于 10 之后，由于每次排序 h 缩减的太快， // 时间会越来越近似于直接插入排序。 var array = SortCompare.GetRandomArrayInt(1000000); var array2 = new int[array.Length]; array.CopyTo(array2, 0); var timer = new Stopwatch(); var bestTimes = new long[3]; var bestTs = new long[3]; for (var i = 0; i &amp;lt; bestTimes.Length; i++) { bestTimes[i] = long.MaxValue; bestTs[i] = int.MaxValue; } var shellSort = new ShellSort(); for (var t = 2; t &amp;lt;= 1000000; t++) { Console.</description></item><item><title>2.1.31</title><link>https://alg4.ikesnowy.com/2-1-31/</link><pubDate>Sat, 30 Jun 2018 20:10:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-31/</guid><description>2.1.31 # 解答 # 这里截取数据量比较大的时候的数据。
插入排序和选择排序显然都是平方级别的。
希尔排序猜测是线性的，实际上要比线性大一点（次平方级）。
代码 # var n = 1000; var insertion = new InsertionSort(); var selection = new SelectionSort(); var shell = new ShellSort(); double prevInsertion = 0; double prevSelection = 0; double prevShell = 0; for (var i = 0; i &amp;lt; 10; i++) { Console.WriteLine(&amp;#34;N:&amp;#34; + n); var array = SortCompare.GetRandomArrayInt(n); var arrayBak = new int[n]; array.CopyTo(arrayBak, 0); Console.WriteLine(&amp;#34;\tInsertion Sort&amp;#34;); var now = SortCompare.</description></item><item><title>2.1.32</title><link>https://alg4.ikesnowy.com/2-1-32/</link><pubDate>Sat, 30 Jun 2018 20:11:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-32/</guid><description>2.1.32 # 解答 # 基本上都是这么个样子：
代码 # using System; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._32 { public partial class Form2 : Form { BaseSort sort; int n; double[] result; /// &amp;lt;summary&amp;gt; /// 构造一个绘图结果窗口。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;sort&amp;#34;&amp;gt;用于做测试的排序算法。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;用于测试的初始数据量。&amp;lt;/param&amp;gt; public Form2(BaseSort sort, int n) { InitializeComponent(); this.sort = sort; this.n = n; this.result = Test(n); this.timer1.Interval = 1000; this.timer1.Start(); } /// &amp;lt;summary&amp;gt; /// 执行八次耗时测试，每次数据量翻倍。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;初始数据量。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;测试结果数据。&amp;lt;/returns&amp;gt; public double[] Test(int n) { double[] result = new double[8]; for (int i = 0; i &amp;lt; result.</description></item><item><title>2.1.33</title><link>https://alg4.ikesnowy.com/2-1-33/</link><pubDate>Sat, 30 Jun 2018 20:12:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-33/</guid><description>2.1.33 # 解答 # 这里每次结果的 Y 轴位置都是随机生成的，这样图像会好看点。
X 轴代表消耗的时间。
选择排序：
插入排序：
希尔排序：
代码 # using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._33 { public partial class Form2 : Form { List&amp;lt;double&amp;gt; resultList; List&amp;lt;float&amp;gt; resultYList; Rectangle clientRect; Rectangle drawRect; BaseSort sort; int n; /// &amp;lt;summary&amp;gt; /// 构造一个绘制结果窗口。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;sort&amp;#34;&amp;gt;用于测试的排序算法。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;测试算法是生成的数据量。&amp;lt;/param&amp;gt; public Form2(BaseSort sort, int n) { InitializeComponent(); this.resultList = new List&amp;lt;double&amp;gt;(); this.</description></item><item><title>2.1.34</title><link>https://alg4.ikesnowy.com/2-1-34/</link><pubDate>Sat, 30 Jun 2018 20:15:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-34/</guid><description>2.1.34 # 解答 # 代码 # var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); // 逆序 Console.WriteLine(&amp;#34;逆序&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort Time: &amp;#34; + ReverseSortTest(insertionSort)); Console.WriteLine(&amp;#34;Selection Sort Time: &amp;#34; + ReverseSortTest(selectionSort)); Console.WriteLine(&amp;#34;Shell Sort Time: &amp;#34; + ReverseSortTest(shellSort)); // 顺序 Console.WriteLine(&amp;#34;顺序&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort Time: &amp;#34; + SortedSortTest(insertionSort)); Console.WriteLine(&amp;#34;Selection Sort Time: &amp;#34; + SortedSortTest(selectionSort)); Console.WriteLine(&amp;#34;Shell Sort Time: &amp;#34; + SortedSortTest(shellSort)); // 主键相同 Console.WriteLine(&amp;#34;主键相同&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort Time: &amp;#34; + EqualSortTest(insertionSort)); Console.</description></item><item><title>2.1.35</title><link>https://alg4.ikesnowy.com/2-1-35/</link><pubDate>Sat, 30 Jun 2018 20:16:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-35/</guid><description>2.1.35 # 解答 # 难点是如何生成符合这些分布的随机数。
Java 的话官方给的 stdRandom 里面都有相应的实现。
结果：
代码 # 几种随机数的实现：
public static class SortUtil { /// &amp;lt;summary&amp;gt; /// 随机数发生器，所有对象共享同一个随机数发生器。 /// &amp;lt;/summary&amp;gt; public static Random UniformGenerator = new(); /// &amp;lt;summary&amp;gt; /// 产生符合正态分布的随机数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;average&amp;#34;&amp;gt;正态分布的期望值 μ。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;standardDeviation&amp;#34;&amp;gt;正态分布的标准差 σ。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;符合正态分布的随机数。&amp;lt;/returns&amp;gt; public static double Normal(double average, double standardDeviation) { var u1 = UniformGenerator.NextDouble(); var u2 = UniformGenerator.NextDouble(); var z0 = Math.Sqrt(-2.0 * Math.Log(u1)) * Math.</description></item><item><title>2.1.36</title><link>https://alg4.ikesnowy.com/2-1-36/</link><pubDate>Sat, 30 Jun 2018 20:18:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-36/</guid><description>2.1.36 # 解答 # 最后结果：
代码 # // 选择排序的耗时与输入值的内容无关，不受影响。 // 对于插入排序，以上几种情况都是重复值较多的情况，插入排序的速度会加快。 // 希尔排序本质上也是插入排序，因此也会更快一些。 var n = 10000; var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var arraySelection = new int[n]; var arrayShell = new int[n]; // 对照，完全随机 var arrayInsertion = HalfZeroHalfOne(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(&amp;#34;totally random&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort:&amp;#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(&amp;#34;Selection Sort:&amp;#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(&amp;#34;Shell Sort:&amp;#34; + SortCompare.</description></item><item><title>2.1.37</title><link>https://alg4.ikesnowy.com/2-1-37/</link><pubDate>Sat, 30 Jun 2018 20:19:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-37/</guid><description>2.1.37 # 解答 # 主要说一下第二个的实现，把一个数组按 10 位进行打乱即可。
代码 # // 选择排序的性能只与数组大小有关，以上三种情况耗时都是近似的。 // 插入排序的性能与逆序对数量有关，部分有序的情况下耗时会小于完全随机。 // 希尔排序与插入排序类似。 var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var n = 100000; var insertionArray = new int[n]; var shellArray = new int[n]; // 完全随机的对照 Console.WriteLine(&amp;#34;totally random&amp;#34;); Console.WriteLine(&amp;#34;Selection Sort:&amp;#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(&amp;#34;Insertion Sort:&amp;#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(&amp;#34;Shell Sort:&amp;#34; + SortCompare.TimeRandomInput(shellSort, n, 1)); // 95% 有序，其余部分为随机值。 var selectionArray = Sorted95Random5(n); selectionArray.</description></item><item><title>2.1.38</title><link>https://alg4.ikesnowy.com/2-1-38/</link><pubDate>Sat, 30 Jun 2018 20:34:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-1-38/</guid><description>2.1.38 # 解答 # 这里实现了一个 Pair 类，用来排序。
每一个元素都有相应的 key 值和 value 值，排序时只使用 key 值进行排序。
代码 # var n = 10000; var results = TestA(n); Console.WriteLine(&amp;#34;string + double&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort:&amp;#34; + results[0]); Console.WriteLine(&amp;#34;Selection Sort:&amp;#34; + results[1]); Console.WriteLine(&amp;#34;Shell Sort:&amp;#34; + results[2]); results = TestB(n); Console.WriteLine(&amp;#34;double + 10 string&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort:&amp;#34; + results[0]); Console.WriteLine(&amp;#34;Selection Sort:&amp;#34; + results[1]); Console.WriteLine(&amp;#34;Shell Sort:&amp;#34; + results[2]); results = TestC(n); Console.WriteLine(&amp;#34;int + int[]&amp;#34;); Console.WriteLine(&amp;#34;Insertion Sort:&amp;#34; + results[0]); Console.WriteLine(&amp;#34;Selection Sort:&amp;#34; + results[1]); Console.</description></item><item><title>2.2.1</title><link>https://alg4.ikesnowy.com/2-2-1/</link><pubDate>Wed, 04 Jul 2018 15:31:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-1/</guid><description> 2.2.1 # 解答 #</description></item><item><title>2.2.2</title><link>https://alg4.ikesnowy.com/2-2-2/</link><pubDate>Wed, 04 Jul 2018 15:34:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-2/</guid><description> 2.2.2 # 解答 #</description></item><item><title>2.2.3</title><link>https://alg4.ikesnowy.com/2-2-3/</link><pubDate>Wed, 04 Jul 2018 15:35:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-3/</guid><description> 2.2.3 # 解答 #</description></item><item><title>2.2.4</title><link>https://alg4.ikesnowy.com/2-2-4/</link><pubDate>Wed, 04 Jul 2018 15:36:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-4/</guid><description>2.2.4 # 解答 # 是的，必须要两个子数组都有序时归并才能得到正确结果。
如果说数组不有序的话，那么最后只能得到两个数组的混合。
合并后的数组中，属于原有数组的元素的相对顺序不会被改变。
例如子数组 1 3 1 和 2 8 5 原地归并。
结果是 1 2 3 1 8 5，其中 1 3 1 和 2 8 5 的相对顺序不变。</description></item><item><title>2.2.5</title><link>https://alg4.ikesnowy.com/2-2-5/</link><pubDate>Wed, 04 Jul 2018 15:37:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-5/</guid><description>2.2.5 # 解答 # 每次归并子数组的大小和顺序如下：
自顶向下
2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39
自底向上
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39</description></item><item><title>2.2.6</title><link>https://alg4.ikesnowy.com/2-2-6/</link><pubDate>Wed, 04 Jul 2018 15:38:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-6/</guid><description>2.2.6 # 解答 # 灰色是上限，蓝点是自顶向下，红点是自底向上。
由于两种排序访问数组的次数是一样的，因此蓝点和红点重合。
代码 # 给出绘图部分的代码：
using System; using System.Windows.Forms; using System.Drawing; using Merge; namespace _2._2._6 { static class Program { /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { MergeSort mergeSort = new MergeSort(); MergeSortBU mergeSortBU = new MergeSortBU(); int[] mergeResult = new int[10]; int[] mergeResultBU = new int[10]; int[] upperBound = new int[10]; // 进行计算 int dataSize = 1; for (int i = 0; i &amp;lt; 10; i++) { int[] dataMerge = SortCompare.</description></item><item><title>2.2.7</title><link>https://alg4.ikesnowy.com/2-2-7/</link><pubDate>Wed, 04 Jul 2018 15:39:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-7/</guid><description>2.2.7 # 解答 # 根据书本给出的命题 G 和命题 H（中文版 P173/176，英文版 P275/279），
比较次数的下限 $C(N) = 1/2 \times NlgN$
$N$ 和 $lgN$ 都是单调递增且大于零的($N&amp;gt;1$)，
因此 $C(N)$ 也是单调递增的。</description></item><item><title>2.2.8</title><link>https://alg4.ikesnowy.com/2-2-8/</link><pubDate>Wed, 04 Jul 2018 15:40:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-8/</guid><description>2.2.8 # 解答 # 修改后的算法对已经有序的情况做了优化
数组对半切分并排序后，
如果 a[mid] &amp;lt; a[mid + 1](左半部分的最后一个元素小于右半部分的第一个元素)
那么我们可以直接合并数组，不需要再做多余的操作
现在的输入是一个已经排序的数组
算法唯一的比较发生在判断 a[mid] &amp;lt; a[mid + 1] 这个条件时
假定数组有 $N$ 个元素
比较次数满足 $T(N) = 2 T(N / 2) + 1, T(1) = 0$
转化为非递归形式即为：$T(N) = cN / 2 + N - 1$
其中 $c$ 为任意正整数。</description></item><item><title>2.2.9</title><link>https://alg4.ikesnowy.com/2-2-9/</link><pubDate>Wed, 04 Jul 2018 15:42:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-9/</guid><description>2.2.9 # 解答 # 官方给出的归并排序实现中在 Sort 方法里初始化了 aux 数组。
源码见：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html
C#实现和官方的实现非常类似，
首先定义只接受一个参数的公开 Sort 方法，在这个方法里面初始化 aux 数组。
/// &amp;lt;summary&amp;gt; /// 利用归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } 然后建立一个私有的递归 Sort 方法做实际的排序操作。
/// &amp;lt;summary&amp;gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;aux&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序范围终点。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } 代码 # public class MergeSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var aux = new T[a.</description></item><item><title>2.2.10</title><link>https://alg4.ikesnowy.com/2-2-10/</link><pubDate>Wed, 04 Jul 2018 15:44:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-10/</guid><description>2.2.10 # 解答 # 官方同样给出了 java 实现，如下：
private static void merge(Comparable[] a, int lo, int mid, int hi) { for (int i = lo; i &amp;lt;= mid; i++) aux[i] = a[i]; for (int j = mid+1; j &amp;lt;= hi; j++) aux[j] = a[hi-j+mid+1]; int i = lo, j = hi; for (int k = lo; k &amp;lt;= hi; k++) if (less(aux[j], aux[i])) a[k] = aux[j--]; else a[k] = aux[i++]; } C# 实现见代码部分。</description></item><item><title>2.2.11</title><link>https://alg4.ikesnowy.com/2-2-11/</link><pubDate>Wed, 04 Jul 2018 15:45:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-11/</guid><description>2.2.11 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/22mergesort/MergeX.java.html
在 MergeSortX 类里添加一个 CUTOFF 字段，排序时如果数组长度小于它则直接调用插入排序进行排序。
在调用归并方法前判断第一个有序数组的最后一个元素是否大于第二个有序数组的第一个元素，
如果大于的话就不需要调用归并了，直接首尾相接即可。
归并的空间优化类似于左手倒右手，从一个数组读数据写到另一个数组中去，下一次归并的时候就可以反过来操作，从而节省数组空间。
每次归并都需要两个数组，一个用于存放归并结果，这个数组中的内容是无关紧要的（Merge() 方法中的 dst 数组）
另一个则保存了归并前的数组，用于实际的归并过程（src 数组）。
归并结束后，前一个数组变成归并后的有序结果（也就是下一次归并时的「归并前数组」），后一个数组中的内容则不再有用。
我们可以看到这两个数组的角色在下一次归并时正好可以互换。
要注意的是，交换次数总是一个奇数（左侧排序+右侧排序+总归并），因此在第一次调用 Sort 方法时应该把 aux 和 a 互换传入。
代码 # public class MergeSortX : BaseSort { /// &amp;lt;summary&amp;gt; /// 对小于 CUTOFF 的数组使用插入排序。 /// &amp;lt;/summary&amp;gt; private static int _cutoff = 7; /// &amp;lt;summary&amp;gt; /// 设置启用插入排序的阈值，小于该阈值的数组将采用插入排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;cutoff&amp;#34;&amp;gt;新的阈值。&amp;lt;/param&amp;gt; public void SetCutOff(int cutoff) =&amp;gt; _cutoff = cutoff; /// &amp;lt;summary&amp;gt; /// 将指定范围内的元素归并。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;src&amp;#34;&amp;gt;原始数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;dst&amp;#34;&amp;gt;目标数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;mid&amp;#34;&amp;gt;范围中点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;范围终点。&amp;lt;/param&amp;gt; private void Merge&amp;lt;T&amp;gt;(T[] src, T[] dst, int lo, int mid, int hi) where T : IComparable&amp;lt;T&amp;gt; { int i = lo, j = mid + 1; for (var k = lo; k &amp;lt;= hi; k++) { if (i &amp;gt; mid) dst[k] = src[j++]; else if (j &amp;gt; hi) dst[k] = src[i++]; else if (Less(src[j], src[i])) dst[k] = src[j++]; else dst[k] = src[i++]; } } /// &amp;lt;summary&amp;gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;src&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;dst&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序范围终点。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] src, T[] dst, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { // 小于 CUTOFF 的数组调用插入排序 if (hi &amp;lt;= lo + _cutoff) { var insertion = new InsertionSort(); insertion.</description></item><item><title>2.2.12</title><link>https://alg4.ikesnowy.com/2-2-12/</link><pubDate>Wed, 04 Jul 2018 15:46:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-12/</guid><description>2.2.12 # 解答 # 中文版的翻译比较难理解。
实际上就是另一种归并排序的实现方式。
先把数组分成若干个大小为 M 的块 。
对于每个块，用选择排序进行排序 。
随后遍历数组，将各个块归并起来。
归并时仅复制右侧数组就够了，然后倒着归并（从右到左），可以将额外空间降到 M。
具体归并流程如下：
复制右侧数组到 aux，现在右侧数组a[hi]~a[mid+1]中的元素可以被安全覆盖。 设定指针i,j,k，将数组 a[mid]~a[0] 和 aux[hi-mid-1]~aux[mid + 1] 归并到 a[hi - 1]~a[0]。 在这个流程中左侧数组的指针i是不会大于归并的写入指针k的。
最坏情况下，aux用尽时 i == k，左侧数组可以直接并上去。
代码 # public class MergeSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Sort(a, 1); } /// &amp;lt;summary&amp;gt; /// 利用分块法进行归并排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;待排序的数组内容。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;m&amp;#34;&amp;gt;分块大小。&amp;lt;/param&amp;gt; public void Sort&amp;lt;T&amp;gt;(T[] a, int m) where T : IComparable&amp;lt;T&amp;gt; { var blockNum = (a.</description></item><item><title>2.2.13</title><link>https://alg4.ikesnowy.com/2-2-13/</link><pubDate>Wed, 04 Jul 2018 15:48:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-13/</guid><description>2.2.13 # 解答 # 假设对三个数进行排序，
这三个数是：35，10，17
三个数排序的决策树如下，
结点代表比较对应位置上的数。
对于 35,10,17 来说，路径遵循右、左、左，最后得到的结果就是 2 3 1（10,17,35）。
我们可以发现决策树上的每一个叶子节点都代表一种排列顺序，对于 N 个数，叶子节点就有 $N!$ 个
根据二叉树的性质，高度为 $h$ 的二叉树最多有 $2^h$ 个叶子节点
那么，对于 $N$ 个数，决策树的高度 $h$ 的最小值可以通过下面这个式子得出来
$2^h &amp;gt;= n!$
$h \ge log(n!)$
因此可以得到决策树高度 $h$ 的最小值是 $log(n!)$
接下来我们来计算平均路径长度
我们令函数 $H(k)$ 代表有 $k$ 个叶子节点的平衡决策树的所有路径长度之和
上例中 $H(6) = 2 + 2 + 3 + 3 + 3 + 3 = 16$
由于平衡决策树的性质，$H(k) = 2H(k / 2) + k$ （加上 $k$ 的原因：左右子树的高度比整个树的高度小 $1$，因此每条路径的长度都必须加 $1$，总共多加了 $k$ 次）</description></item><item><title>2.2.14</title><link>https://alg4.ikesnowy.com/2-2-14/</link><pubDate>Wed, 04 Jul 2018 16:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-14/</guid><description> 2.2.14 # 解答 # 比较两个有序队列的第一个元素，取较小的一个出队并放入额外建立的队列中。
重复上述步骤直到两个队列都为空。
代码 # // 归并两个有序队列。输入队列将被清空。 static Queue&amp;lt;T&amp;gt; Merge&amp;lt;T&amp;gt;(Queue&amp;lt;T&amp;gt; a, Queue&amp;lt;T&amp;gt; b) where T : IComparable&amp;lt;T&amp;gt; { var sortedQueue = new Queue&amp;lt;T&amp;gt;(); while (!a.IsEmpty() &amp;amp;&amp;amp; !b.IsEmpty()) { if (a.Peek().CompareTo(b.Peek()) &amp;lt; 0) sortedQueue.Enqueue(a.Dequeue()); else sortedQueue.Enqueue(b.Dequeue()); } while (!a.IsEmpty()) sortedQueue.Enqueue(a.Dequeue()); while (!b.IsEmpty()) sortedQueue.Enqueue(b.Dequeue()); return sortedQueue; }</description></item><item><title>2.2.15</title><link>https://alg4.ikesnowy.com/2-2-15/</link><pubDate>Wed, 04 Jul 2018 16:05:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-15/</guid><description>2.2.15 # 解答 # 程序思路题目已经给出，按照题意实现即可。
Merge 方法可以直接使用前一题的实现。
代码 # internal class MergeSortQueue { /// &amp;lt;summary&amp;gt; /// 利用队列归并进行自底向上的归并排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;array&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public void Sort&amp;lt;T&amp;gt;(T[] array) where T : IComparable&amp;lt;T&amp;gt; { var queueList = new Queue&amp;lt;Queue&amp;lt;T&amp;gt;&amp;gt;(); for (var i = 0; i &amp;lt; array.Length; i++) { var temp = new Queue&amp;lt;T&amp;gt;(); temp.Enqueue(array[i]); queueList.Enqueue(temp); } while (queueList.Size() != 1) { var times = queueList.Size() / 2; for (var i = 0; i &amp;lt; times; i++) { var a = queueList.</description></item><item><title>2.2.16</title><link>https://alg4.ikesnowy.com/2-2-16/</link><pubDate>Wed, 04 Jul 2018 16:06:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-16/</guid><description>2.2.16 # 解答 # 自然归并排序的一个示例如下图所示：
基本过程和自底向上的归并排序类似，只是每次归并的块大小不一定相同。
时间分析
随着有序块的变大，排序速度会加快，但增长的数量级也会变高（平均分块大小变大了）。
代码 # public class MergeSortNatural : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用自然的归并排序进行自底向上的排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;用于排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var aux = new T[a.Length]; while (true) { // 找到第一个块 var lo = 0; var mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid &amp;lt; a.Length - 1) { var hi = FindBlock(mid + 1, a) + mid; Merge(lo, mid, hi, a, aux); lo = hi + 1; mid = FindBlock(lo, a) + lo - 1; } } Debug.</description></item><item><title>2.2.17</title><link>https://alg4.ikesnowy.com/2-2-17/</link><pubDate>Wed, 04 Jul 2018 16:08:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-17/</guid><description>2.2.17 # 解答 # 排序方式和 2.2.16 十分类似，不再赘述，这里介绍一下归并方法。
如 gif 图所示，先把要归并的两个链表拆出来，随后确定表头位置，然后进行归并即可。 归并结束后返回 first。
结果分析如下图所示：
随着有序部分的增加，对于相同大小的数组自然归并排序的耗时会缩短。
对于有序部分相同的情况，随着数组大小的倍增，耗时呈现了O(nlogn)的趋势。
代码 # public class MergeSortNatural : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用自然的归并排序进行自底向上的排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;用于排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var aux = new T[a.Length]; while (true) { // 找到第一个块 var lo = 0; var mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid &amp;lt; a.</description></item><item><title>2.2.18</title><link>https://alg4.ikesnowy.com/2-2-18/</link><pubDate>Wed, 04 Jul 2018 16:11:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-18/</guid><description>2.2.18 # 解答 # 可以在用归并排序的方法做。
将归并时取两边较小的元素改为随机取一侧的值，即可实现打乱的效果。
算法的分析和普通归并排序一致，满足题目要求。
代码 # 分治法打乱链表的实现。
/// &amp;lt;summary&amp;gt; /// 分治法打乱链表。 /// &amp;lt;/summary&amp;gt; public class MergeShuffle { /// &amp;lt;summary&amp;gt; /// 利用分治法打乱链表。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;链表元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;等待打乱的链表。&amp;lt;/param&amp;gt; public void Shuffle&amp;lt;T&amp;gt;(LinkedList&amp;lt;T&amp;gt; a) { var blockLen = 1; var random = new Random(); while (blockLen &amp;lt;= a.Size()) { // 找到第一个块 var lo = a.GetFirst(); var mid = FindBlock(lo, blockLen); if (mid.Next == null) break; while (mid.Next !</description></item><item><title>2.2.19</title><link>https://alg4.ikesnowy.com/2-2-19/</link><pubDate>Wed, 04 Jul 2018 16:12:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-19/</guid><description>2.2.19 # 解答 # 官方实现：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html
事实上只要在归并排序的时候统计 Less(aux[j], aux[i]) 满足的次数即可，这个次数就是我们要的值。
代码 # /// &amp;lt;summary&amp;gt; /// 归并排序类。 /// &amp;lt;/summary&amp;gt; public class MergeSort : BaseSort { public int Counter; /// &amp;lt;summary&amp;gt; /// 利用归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// &amp;lt;summary&amp;gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;aux&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序范围终点。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) return; var mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// &amp;lt;summary&amp;gt; /// 将指定范围内的元素归并。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;aux&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;mid&amp;#34;&amp;gt;范围中点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;范围终点。&amp;lt;/param&amp;gt; private void Merge&amp;lt;T&amp;gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable&amp;lt;T&amp;gt; { for (var k = lo; k &amp;lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k &amp;lt;= hi; k++) { if (i &amp;gt; mid) { a[k] = aux[j]; j++; } else if (j &amp;gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; Counter += mid - i + 1; // 统计逆序对数 j++; } else { a[k] = aux[i]; i++; } } } } 另请参阅 # Merge 库</description></item><item><title>2.2.20</title><link>https://alg4.ikesnowy.com/2-2-20/</link><pubDate>Wed, 04 Jul 2018 16:21:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-20/</guid><description>2.2.20 # 解答 # 官方实现：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html
把 Sort 方法中传入的 a 数组换成一个 index 数组，将 Merge 方法中的判断改为 Less(a[aux[j]], a[aux[i]]) 即可。
代码 # public class MergeSort : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public int[] IndexSort&amp;lt;T&amp;gt;(T[] a) where T : IComparable&amp;lt;T&amp;gt; { var aux = new int[a.Length]; var index = new int[a.Length]; for (var i = 0; i &amp;lt; a.Length; i++) { index[i] = i; } Sort(a, index, aux, 0, a.</description></item><item><title>2.2.21</title><link>https://alg4.ikesnowy.com/2-2-21/</link><pubDate>Wed, 04 Jul 2018 16:23:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-21/</guid><description>2.2.21 # 解答 # 对三份列表进行归并排序（$O(nlogn)$），随后遍历一遍其中的一份表， 用二分查找检查在其余两个表中是否存在相同的姓名（$O(nlogn)$）。
代码 # var name1 = new[] { &amp;#34;Noah&amp;#34;, &amp;#34;Liam&amp;#34;, &amp;#34;Jacob&amp;#34;, &amp;#34;Mason&amp;#34; }; var name2 = new[] { &amp;#34;Sophia&amp;#34;, &amp;#34;Emma&amp;#34;, &amp;#34;Mason&amp;#34;, &amp;#34;Ava&amp;#34; }; var name3 = new[] { &amp;#34;Mason&amp;#34;, &amp;#34;Marcus&amp;#34;, &amp;#34;Alexander&amp;#34;, &amp;#34;Ava&amp;#34; }; var mergeSort = new MergeSort(); mergeSort.Sort(name1); mergeSort.Sort(name2); mergeSort.Sort(name3); for (var i = 0; i &amp;lt; name1.Length; i++) { if (BinarySearch(name1[i], name2, 0, name1.Length) != -1 &amp;amp;&amp;amp; BinarySearch(name1[i], name3, 0, name1.Length) != -1) { Console.</description></item><item><title>2.2.22</title><link>https://alg4.ikesnowy.com/2-2-22/</link><pubDate>Wed, 04 Jul 2018 16:24:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-22/</guid><description>2.2.22 # 解答 # 增长数量级为$O(nlogn)$。
代码 # /// &amp;lt;summary&amp;gt; /// 三向归并排序。 /// &amp;lt;/summary&amp;gt; public class MergeSortThreeWay : BaseSort { /// &amp;lt;summary&amp;gt; /// 利用三项归并排序将数组按升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组中的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;待排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// &amp;lt;summary&amp;gt; /// 自顶向下地对数组指定范围内进行三向归并排序，需要辅助数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;aux&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序范围终点。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) // 小于或等于一个元素 return; var lmid = lo + (hi - lo) / 3; var rmid = hi - (hi - lo) / 3; Sort(a, aux, lo, lmid); Sort(a, aux, lmid + 1, rmid); Sort(a, aux, rmid + 1, hi); Merge(a, aux, lo, lmid, rmid, hi); } /// &amp;lt;summary&amp;gt; /// 返回两个元素中较小的那个。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;比较的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;用于比较的元素。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;b&amp;#34;&amp;gt;用于比较的元素。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;较小的元素。&amp;lt;/returns&amp;gt; private T Min&amp;lt;T&amp;gt;(T a, T b) where T : IComparable&amp;lt;T&amp;gt; { if (Less(a, b)) return a; return b; } /// &amp;lt;summary&amp;gt; /// 将指定范围内的元素归并。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;原数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;aux&amp;#34;&amp;gt;辅助数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;范围起点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lmid&amp;#34;&amp;gt;范围三分之一点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;rmid&amp;#34;&amp;gt;范围三分之二点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;范围终点。&amp;lt;/param&amp;gt; private void Merge&amp;lt;T&amp;gt;(T[] a, T[] aux, int lo, int lmid, int rmid, int hi) where T : IComparable&amp;lt;T&amp;gt; { for (var l = lo; l &amp;lt;= hi; l++) { aux[l] = a[l]; } int i = lo, j = lmid + 1, k = rmid + 1; for (var l = lo; l &amp;lt;= hi; l++) { var flag = 0; if (i &amp;gt; lmid) flag += 1; if (j &amp;gt; rmid) flag += 10; if (k &amp;gt; hi) flag += 100; switch (flag) { case 0: // 三个数组都还没有取完 var min = Min(aux[i], Min(aux[j], aux[k])); if (min.</description></item><item><title>2.2.23</title><link>https://alg4.ikesnowy.com/2-2-23/</link><pubDate>Wed, 04 Jul 2018 16:26:10 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-23/</guid><description>2.2.23 # 解答 # 阈值合适时，大约会有10%的性能提升。
阈值在 10 以下都是比较合适的。
代码 # var mergeSort = new MergeSort(); var mergeSortX = new MergeSortX(); var mergeSortUnstable = new MergeSortUnstable(); var n = 1000000; var cutoff = 2; var trialTime = 4; Console.WriteLine(&amp;#34;归并排序改进前与改进后的比较：&amp;#34;); Console.WriteLine(&amp;#34;数组\t耗时1\t耗时2\t阈值\t比率&amp;#34;); for (var i = 0; i &amp;lt; 20; i++) { double mergeSortTime = 0; double mergeSortXTime = 0; mergeSortX.SetCutOff(cutoff); for (var j = 0; j &amp;lt; trialTime; j++) { var a = SortCompare.</description></item><item><title>2.2.24</title><link>https://alg4.ikesnowy.com/2-2-24/</link><pubDate>Wed, 04 Jul 2018 16:27:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-24/</guid><description>2.2.24 # 解答 # 约为 $lgN$ 次
代码 # var mergeSortX = new MergeSortX(); var n = 10000; var trialTimes = 10; Console.WriteLine(&amp;#34;数组\t平均命中次数&amp;#34;); for (var i = 0; i &amp;lt; 4; i++) { var avgHit = 0; for (var j = 0; j &amp;lt; trialTimes; j++) { mergeSortX.ResetHitTime(); var a = SortCompare.GetRandomArrayInt(n); mergeSortX.Sort(a); avgHit += mergeSortX.GetHitTime(); } Console.WriteLine(n + &amp;#34;\t&amp;#34; + avgHit / trialTimes); n *= 10; } 另请参阅 # Merge 库</description></item><item><title>2.2.25</title><link>https://alg4.ikesnowy.com/2-2-25/</link><pubDate>Wed, 04 Jul 2018 16:28:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-25/</guid><description>2.2.25 # 解答 # 事实上 k 的取值无关紧要，实验也证明了这一点。
算法大致可以分为以下几个步骤 首先将数组划为 k 份，
用一个数组 mids 记录这 k 个子数组的分割位置
随后递归的调用 Sort 方法，将这 k 个子数组排序 随后将这 k 个子数组归并，
每次归并时遍历取 k 个子数组中值最小的一个，
然后对应子数组的指示器 + 1 上面这一步是 $O(k)$ 的，
可以用堆或者败者树优化为对数级别
代码 # /// &amp;lt;summary&amp;gt; /// k 路归并排序。 /// &amp;lt;/summary&amp;gt; public class MergeSortKWay : BaseSort { /// &amp;lt;summary&amp;gt; /// 同时归并的数组数目。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;同时归并的数组数目。&amp;lt;/value&amp;gt; public int K { get; set; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public MergeSortKWay() { K = 2; } /// &amp;lt;summary&amp;gt; /// 用 k 向归并排序对数组 a 进行排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentOutOfRangeException&amp;#34;&amp;gt;数组长度小于 K 值时抛出异常。&amp;lt;/exception&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { if (K &amp;gt; a.</description></item><item><title>2.2.26</title><link>https://alg4.ikesnowy.com/2-2-26/</link><pubDate>Wed, 04 Jul 2018 16:36:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-26/</guid><description>2.2.26 # 解答 # 差距还是比较明显的，由于 Merge 会调用多次，而用于启动递归的 Sort 方法只会调用一次。
代码 # var auxInSort = new AuxInSortMergeSort(); var auxInMerge = new AuxInMergeMergeSort(); var data1 = SortCompare.GetRandomArrayInt(100000); var data2 = new int[data1.Length]; data1.CopyTo(data2, 0); Console.WriteLine(&amp;#34;在Sort中创建aux[]\t&amp;#34; + SortCompare.Time(auxInSort, data1) + &amp;#34;ms&amp;#34;); Console.WriteLine(&amp;#34;在Merge中创建aux[]\t&amp;#34; + SortCompare.Time(auxInMerge, data2) + &amp;#34;ms&amp;#34;); 另请参阅 # Merge 库</description></item><item><title>2.2.27</title><link>https://alg4.ikesnowy.com/2-2-27/</link><pubDate>Wed, 04 Jul 2018 16:38:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-27/</guid><description>2.2.27 # 解答 # 大致上会是一个对数函数，用 Excel 做了简单的拟合。
原始数据：
表中的 n 代表某一个子数组用尽时两个子数组之和，rest 是另一个未用尽的子数组平均剩余长度，times 代表出现次数，表中删去了出现次数小于 100 次的数据。
n rest times 2 0.331378 48576 3 0.333894 213568 6 0.603899 48576 7 0.596223 82496 14 0.773263 48576 15 0.796285 16960 29 0.879808 15808 30 0.883432 16960 60 0.950848 15808 61 0.935764 576 121 0.985163 7616 122 0.96875 576 243 0.93608 3520 244 1.147569 576 487 0.942255 1472 488 1.020833 576 975 1.078125 448 976 1.</description></item><item><title>2.2.28</title><link>https://alg4.ikesnowy.com/2-2-28/</link><pubDate>Wed, 04 Jul 2018 16:44:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-28/</guid><description>2.2.28 # 解答 # 自底向上会快一些，省去了递归过程中函数重复调用的时间。
代码 # var n = 1000; var topBottomMergeSort = new MergeSort(); var bottomUpMergeSort = new MergeSortBu(); var trialTimes = 100; for (var i = 0; i &amp;lt; 4; i++) { Console.Write(&amp;#34;数组大小：&amp;#34; + n + &amp;#34;\t&amp;#34;); int time1 = 0, time2 = 0; for (var j = 0; j &amp;lt; trialTimes; j++) { var data1 = SortCompare.GetRandomArrayDouble(n); var data2 = new double[n]; data1.CopyTo(data2, 0); time1 += (int)SortCompare.</description></item><item><title>2.2.29</title><link>https://alg4.ikesnowy.com/2-2-29/</link><pubDate>Wed, 04 Jul 2018 16:45:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-2-29/</guid><description>2.2.29 # 解答 # 完全有序时只需要一次归并（直接输出），
逆序时需要 n - 1 次归并（退化为插入排序），
平均需要 n/2 次归并。
所以分别需要 500，500000，500000000 次归并。</description></item><item><title>2.3.1</title><link>https://alg4.ikesnowy.com/2-3-1/</link><pubDate>Fri, 06 Jul 2018 14:21:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-1/</guid><description> 2.3.1 # 解答 #</description></item><item><title>2.3.2</title><link>https://alg4.ikesnowy.com/2-3-2/</link><pubDate>Fri, 06 Jul 2018 16:51:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-2/</guid><description> 2.3.2 # 解答 #</description></item><item><title>2.3.3</title><link>https://alg4.ikesnowy.com/2-3-3/</link><pubDate>Sun, 08 Jul 2018 19:36:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-3/</guid><description>2.3.3 # 解答 # N / 2
在快速排序中，一个元素要被交换，有以下两种情况
该元素是枢轴，在切分的最后一步被交换 该元素位于枢轴错误的一侧，需要被交换到另一侧去 注意，以上两种情况在一次切分中只会出现一次
首先来看第一种情况，如果一个元素变成了枢轴
那么在之后的切分中该元素会被排除，不存在后续的交换。
因此我们的目标应该是：
最大的元素总是出现在错误的一侧，同时切分的次数尽可能多。
接下来我们来思考如何构造这样的数组
由于我们针对的是最大的元素，因此「错误的一侧」就是枢轴的左侧。
为了使切分的次数尽可能多，我们需要保持最大值移动的距离尽量短。
但如果每次只移动一位的话，下一次切分时最大值就会变成枢轴
例如 4 10 3 5 6，枢轴为 4，交换后数组变为：
4 3 10 5 6
随后 4 和 3 交换
3 4 10 5 6
下一次切分时 10 会变成枢轴，不再参与后续的切分。
因此我们需要让最大值每次移动两个元素。
考虑下面的数组：
2 10 4 1 6 3 8 5 7 9
第一次切分的时候，枢轴为 2，10 和 1 进行交换
数组变为：
2 1 4 10 6 3 8 5 7 9</description></item><item><title>2.3.4</title><link>https://alg4.ikesnowy.com/2-3-4/</link><pubDate>Sun, 08 Jul 2018 20:09:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-4/</guid><description>2.3.4 # 解答 # 每次只让枢轴变为已排序，这就是最坏情况。
这种时候枢轴是当前子数组的最大值 / 最小值。
由于在我们的实现中总是取子数组的第一个元素作为枢轴。
因此一个已排序的数组可以达到最坏情况，比较次数达到 O(n^ 2)。
如果换作取最后一个元素，最坏情况会变成逆序数组。
我们的实现中如果碰到与枢轴相等的元素也会停止循环，
因此如果数组中有重复的元素会减少比较次数。
例如：
1 2 3 4 5 6 7 8 9 10 2 3 4 5 6 7 8 9 10 11 3 4 5 6 7 8 9 10 11 12 4 5 6 7 8 9 10 11 12 13 5 6 7 8 9 10 11 12 13 14 6 7 8 9 10 11 12 13 14 15 另请参阅 # Analysis of Quicksort-khanacademy Worst case for QuickSort - When can it occur?</description></item><item><title>2.3.5</title><link>https://alg4.ikesnowy.com/2-3-5/</link><pubDate>Sun, 08 Jul 2018 21:59:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-5/</guid><description>2.3.5 # 解答 # 官方实现：https://algs4.cs.princeton.edu/23quicksort/Sort2distinct.java.html
算法 gif 动图
代码 # public class Sort2Distinct : BaseSort { /// &amp;lt;summary&amp;gt; /// 对数组 a 进行排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;数组 a 的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { int lt = 0, gt = a.Length - 1; var i = 0; while (i &amp;lt;= gt) { var cmp = a[i].CompareTo(a[lt]); if (cmp &amp;lt; 0) Exch(a, lt++, i++); else if (cmp &amp;gt; 0) Exch(a, i, gt--); else i++; } } } 另请参阅 # Quick 库</description></item><item><title>2.3.6</title><link>https://alg4.ikesnowy.com/2-3-6/</link><pubDate>Mon, 09 Jul 2018 16:03:23 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-6/</guid><description>2.3.6 # 解答 # 运行结果如下：
代码 # 新建一个 QuickSortAnalyze 类，在 QuickSort 的基础上添加一个 CompareCount 属性，用于记录比较次数。重写 Less 方法，每调用一次就让 CompareCount 增加 1 。
/// &amp;lt;summary&amp;gt; /// 自动记录比较次数以及子数组数量的快速排序类。 /// &amp;lt;/summary&amp;gt; public class QuickSortAnalyze : BaseSort { /// &amp;lt;summary&amp;gt; /// 比较次数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;排序用的比较次数。&amp;lt;/value&amp;gt; public int CompareCount { get; set; } /// &amp;lt;summary&amp;gt; /// 是否启用打乱。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt; /// &amp;lt;list type=&amp;#34;bullet&amp;#34;&amp;gt; /// &amp;lt;item&amp;gt;&amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;: 启用排序前打乱。&amp;lt;/item&amp;gt; /// &amp;lt;item&amp;gt;&amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;: 禁用排序前打乱。&amp;lt;/item&amp;gt; /// &amp;lt;/list&amp;gt; /// &amp;lt;/value&amp;gt; public bool NeedShuffle { get; set; } /// &amp;lt;summary&amp;gt; /// 是否显示轨迹。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt; /// &amp;lt;list type=&amp;#34;bullet&amp;#34;&amp;gt; /// &amp;lt;item&amp;gt;&amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;: 输出排序轨迹。&amp;lt;/item&amp;gt; /// &amp;lt;item&amp;gt;&amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;: 不输出排序轨迹。&amp;lt;/item&amp;gt; /// &amp;lt;/list&amp;gt; /// &amp;lt;/value&amp;gt; public bool NeedPath { get; set; } /// &amp;lt;summary&amp;gt; /// 大小为 0 的子数组数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;大小为 0 的子数组数量。&amp;lt;/value&amp;gt; public int Array0Num { get; set; } /// &amp;lt;summary&amp;gt; /// 大小为 1 的子数组数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;大小为 1 的子数组数量。&amp;lt;/value&amp;gt; public int Array1Num { get; set; } /// &amp;lt;summary&amp;gt; /// 大小为 2 的子数组数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;大小为 2 的子数组数量。&amp;lt;/value&amp;gt; public int Array2Num { get; set; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public QuickSortAnalyze() { CompareCount = 0; NeedShuffle = true; NeedPath = false; Array0Num = 0; Array1Num = 0; Array2Num = 0; } /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Array0Num = 0; Array1Num = 0; Array2Num = 0; CompareCount = 0; if (NeedShuffle) Shuffle(a); if (NeedPath) { for (var i = 0; i &amp;lt; a.</description></item><item><title>2.3.7</title><link>https://alg4.ikesnowy.com/2-3-7/</link><pubDate>Tue, 10 Jul 2018 15:12:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-7/</guid><description>2.3.7 # 解答 # 我讨厌数学= =
证明：
我们设 $C_0(n)$ 代表将 $n$ 个不重复元素排序时大小为 0 的数组的数量。
同理有 $C_1(n)$ 和 $C_2(n)$ 代表大小为 1 的数组的数量以及大小为 2 的数组的数量。
设 k 代表切分位置，显然切分位置随机且概率相等，在 1~n 之间均匀分布。
根据条件，$C_0(n), C_1(n),C_2(n)$ 都满足下式：
$$ C(n)= \frac{\sum_{k=1}^{n}(C(k-1)+C(n-k))}{n} $$
根据快速排序算法， $\sum_{k=1}^{n}C(k-1)=\sum_{k=1}^{n}C(n-k)$ ，因此
$$ C(n)=\frac{2\sum_{k=1}^{n}C(k-1)}{n}\newline nC(n)=2\sum_{k-1}^{n}C(k-1) $$
同理代入 $n-1$ 有
$$ (n-1)C(n-1)=2\sum_{k-1}^{n-1}C(k-1) $$
相减
$$ nC(n)-(n-1)C(n-1)=2C(n-1)\newline C(n)=\frac{n+1}{n}C(n-1) $$
利用累乘法求到通项公式
$$ \frac{C(n)}{C(n-1)}=\frac{n+1}{n} \newline \frac{C(n)}{C(n-1)}\times\frac{C(n-1)}{C(n-2)}\times\dots\times\frac{C(m+1)}{C(m)}= \frac{n+1}{n}\times\frac{n}{n-1}\times\dots\times\frac{m+2}{m+1}\newline \frac{C(n)}{C(m)}=\frac{n+1}{m+1}\newline C(n)=C(m)\frac{n+1}{m+1}，n&amp;gt;m $$
对于 $C_0(n)$ ，我们有初始条件 $C_0(0)=1, C_0(1)=0,C_0(2)=C_0(0)+C_0(1)=1$
$$ C_0(n)=\frac{n+1}{3}, n&amp;gt;2 $$</description></item><item><title>2.3.8</title><link>https://alg4.ikesnowy.com/2-3-8/</link><pubDate>Tue, 10 Jul 2018 18:52:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-8/</guid><description>2.3.8 # 解答 # 每次切分都会把数组平分，共切分 logN 次（二分法），每次切分比较 N 次（i 和 j 会一位一位地从两边向中间靠拢）。
共比较 NlogN 次。</description></item><item><title>2.3.9</title><link>https://alg4.ikesnowy.com/2-3-9/</link><pubDate>Wed, 11 Jul 2018 12:29:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-9/</guid><description>2.3.9 # 解答 # 切分时，枢轴左侧都是小于（或等于）枢轴的，
右侧都是大于（或等于）枢轴的
只有两种主键值时，
第一次切分之后，某一侧的元素将全部相同
（如果枢轴选了较大的，那么右侧将全部相同，反之则左侧全部相同）
只有三种主键值时，和一般快速排序并无不同。
但如果第一次切分时选择了中间值作为枢轴，且中间值只有一个
那么只需要一次切分数组便会有序。</description></item><item><title>2.3.10</title><link>https://alg4.ikesnowy.com/2-3-10/</link><pubDate>Wed, 11 Jul 2018 13:29:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-10/</guid><description>2.3.10 # 解答 # 切比雪夫不等式（Chebyshev’s inequality）
$$ P(|X-\mu|\geq k\sigma)\leq \frac{1}{k^2} $$
其中，$\mu$ 代表期望，$\sigma$ 代表标准差。
对于快速排序的比较次数来说，$\mu = 2N\ln N$ ，$\sigma=0.65N$。
（这两个结论见 2.3 节的命题 K 和命题 L）
题目中要求比较次数大于 $0.1N^2$ ，可以求得 $k$ 的值。
$$ 0.65kN=0.1N^2 \newline k=\frac{2N}{13} $$
将 $N=1,000,000$ 代入
$$ P(|X-27,631,021|\geq 100,000,000,000)\leq 0.00000000004225 $$
另请参阅 # 切比雪夫不等式到底是个什么概念? - 马同学的回答 - 知乎</description></item><item><title>2.3.11</title><link>https://alg4.ikesnowy.com/2-3-11/</link><pubDate>Wed, 11 Jul 2018 15:45:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-11/</guid><description>2.3.11 # 解答 # 只有若干种元素值意味着大量的连续重复。
（由于存在打乱这一步骤，不存在连续重复的可能性是很低的）
接下来我们考虑这样的连续重复在修改后的快排下的性能。
1 1 1 1 1 1 1
对于这样的数组，枢轴选为 1，j 将会在 j = lo 处终止。
因此最后的结果将是每次只有数组的第一个元素被排序
已知每次切分都是 O(k - 1) 的（i 和 j 都将走完整个子数组）
因此这样的快速排序所需时间 = $2 (N - 1 + N - 2 + \cdots + 1) = (N - 1)N$
因此对于值相同的子数组，这样的快排运行时间是平方级别的
那么当数组中这样的连续重复内容越多，运行时间就越接近平方级别。</description></item><item><title>2.3.12</title><link>https://alg4.ikesnowy.com/2-3-12/</link><pubDate>Wed, 11 Jul 2018 17:50:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-12/</guid><description> 2.3.12 # 解答 #</description></item><item><title>2.3.13</title><link>https://alg4.ikesnowy.com/2-3-13/</link><pubDate>Thu, 12 Jul 2018 14:53:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-13/</guid><description>2.3.13 # 解答 # 快速排序先将数组分为 （小于枢轴）枢轴（大于枢轴）三部分，然后再分别递归的排序左右两部分数组。
在这里，我们可以将快速排序的递归树看作是一棵二叉搜索树（BST, Binary Search Tree）。
枢轴作为根结点，左子树即为左数组构造的 BST，右子树即为右数组构造的 BST。
这样题目中所求的递归深度即为所构造的 BST 的高度。
最坏情况，每次都只有枢轴和大于枢轴两部分，BST 退化为链表，高度为 $n-1$。
最好情况，每次枢轴都正好平分数组，构造一棵完全二叉树，高度为 $\log n$。
平均情况，问题转化为：一个由 $n$ 个元素随机构造的 BST 的平均高度是多少？
《算法导论》给出的结论是 $\log n$ ，具体证明如下：
设由 $n$ 个结点随机构成的 BST 的高度为 $h_n$，那么有：
$$ h_n=1+\max(h_{l}+h_{r}) $$
其中，$h_l$ 和 $h_r$ 分别代表左数组和右数组构造的 BST 的高度。
设枢轴位置为 $i$，上式可简化为：
$$ h_n=1+\max(h_{i-1}, h_{n-i}) $$
由于枢轴位置可以在 1~n 之间任意取值且概率相等，因此 BST 的平均高度（即高度的期望）为：
$$ E(h_n)=\frac{1}{n}\sum_{i=1}^{n}\lbrack 1+\max(h_{i-1}, h_{n-i}) \rbrack $$
我们令 $Y_n=2^{h_n}$，可得：
$$ Y_n=2\times\max(Y_{i-1},Y_{n-i}) $$
我们把 $Y_n$ 代入，可得：</description></item><item><title>2.3.14</title><link>https://alg4.ikesnowy.com/2-3-14/</link><pubDate>Sat, 14 Jul 2018 15:03:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-14/</guid><description>2.3.14 # 解答 # 中文版题目有误，详见官方勘误页面
假设 $i &amp;lt; j​$ 。
首先，在快速排序中，如果两个元素要发生交换，意味着其中一个元素被选为枢轴。
而且数组中的元素各不相同，那么两个特定的元素的比较最多发生一次。
那么先考虑一个特殊情况，$i = 1, j = n$ ，即求最大值和最小值比较的概率。
此时，一旦枢轴不是这两个元素之一，
最大值和最小值会被分到两个不同的子数组，无法发生比较。
因此在这种特例下第 $i$ 大的元素和第 $j$ 大的元素发生比较的概率为 $\frac{2}{n} = \frac{2}{j-i+1}$ 。
接下来考虑一般情况，如果枢轴选择了第 $i$ 到第 $j$ 大之外的元素，
那么第 $i$ 大和第 $j$ 大的元素会被分到同一个子数组里，重复上述过程。
因此我们所求的概率只和从第 $i$ 大到第 $j$ 大之间的元素有关，概率为 $\frac{2}{j-i+1}$。
（举个例子，一个箱子里有 2 个红球、1 个蓝球和 7 个白球，现在摸球而不放回。
如果摸到白球可以再摸一次，直到摸到红球或蓝球为止。
显然在这样的规则下摸到红球或蓝球的概率为 1，即白球对概率没有影响。）
现在我们已经得到了某两个元素比较的概率 $E(X_{ij})$，接下来我们求每两个元素比较的概率 $E(X)$。
$$ \begin{align} E(X) &amp;amp;= \sum_{i=1}^{n}\sum_{j=i+1}^{n}E(X_{ij})\newline &amp;amp;=\sum_{i=1}^{n}2(\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n-i+1}) \newline &amp;amp;&amp;lt;2n(\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}) \end{align} $$
根据调和级数的性质（$\ln (n) &amp;lt; 1+ \frac{1}{2}+ \cdots + \frac{1}{n} &amp;lt; 1+\ln(n)$），可以得到结论：</description></item><item><title>2.3.15</title><link>https://alg4.ikesnowy.com/2-3-15/</link><pubDate>Sun, 15 Jul 2018 13:07:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-15/</guid><description>2.3.15 # 解答 # 事实上只需要修改快速排序的切分方法，分两次进行切分。
首先选第一个螺母作为枢轴，找到对应的螺丝（$O(n)$）放到第一位，对螺丝数组进行切分。
然后再用找到的螺丝对螺母数组进行切分。
螺母类，实现了对螺丝类的 IComparable 接口
public class Nut&amp;lt;T&amp;gt; : IComparable&amp;lt;Bolt&amp;lt;T&amp;gt;&amp;gt; where T : IComparable&amp;lt;T&amp;gt; { /// &amp;lt;summary&amp;gt; /// 螺母的值。 /// &amp;lt;/summary&amp;gt; public T Value { get; set; } /// &amp;lt;summary&amp;gt; /// 螺母的构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;value&amp;#34;&amp;gt;螺母的值。&amp;lt;/param&amp;gt; public Nut(T value) =&amp;gt; Value = value; /// &amp;lt;summary&amp;gt; /// 比较方法，螺母只能和螺丝比较。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;other&amp;#34;&amp;gt;需要比较的螺丝。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int CompareTo(Bolt&amp;lt;T&amp;gt; other) { return Value.CompareTo(other.Value); } } 类似的有螺丝类。</description></item><item><title>2.3.16</title><link>https://alg4.ikesnowy.com/2-3-16/</link><pubDate>Thu, 19 Jul 2018 22:06:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-16/</guid><description>2.3.16 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBest.java.html
类似于快速排序的结构，只要中点的两边都是最佳情况，那么整个数组就是最佳情况了。
具体方法是：
首先构造一个有序数组，
然后找到中点（作为枢轴），
对中点左右两侧子数组进行构造，
将选择的枢轴放到开始处(a[lo])。
代码 # 用于构造最佳数组的类。
public class QuickBest { /// &amp;lt;summary&amp;gt; /// 构造函数，这个类不应该被实例化。 /// &amp;lt;/summary&amp;gt; private QuickBest() { } /// &amp;lt;summary&amp;gt; /// 构造适用于快速排序的最佳数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;数组长度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;适用于快速排序的最佳情况数组。&amp;lt;/returns&amp;gt; public static int[] Best(int n) { var a = new int[n]; for (var i = 0; i &amp;lt; n; i++) { a[i] = i; } Best(a, 0, n - 1); return a; } /// &amp;lt;summary&amp;gt; /// 递归的构造数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要构造的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;构造的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;构造的终止下标。&amp;lt;/param&amp;gt; private static void Best(int[] a, int lo, int hi) { if (hi &amp;lt;= lo) return; var mid = lo + (hi - lo) / 2; Best(a, lo, mid - 1); Best(a, mid + 1, hi); Exch(a, lo, mid); } /// &amp;lt;summary&amp;gt; /// 交换数组中的两个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;包含要交换元素的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;需要交换的第一个元素下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;需要交换的第二个元素下标。&amp;lt;/param&amp;gt; private static void Exch(int[] a, int x, int y) { var t = a[x]; a[x] = a[y]; a[y] = t; } } 用于测试的方法</description></item><item><title>2.3.17</title><link>https://alg4.ikesnowy.com/2-3-17/</link><pubDate>Sun, 22 Jul 2018 21:48:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-17/</guid><description>2.3.17 # 解答 # 按照题意修改代码即可，在调用 Suffle() 之后添加一段用于寻找最大值的方法（$O(n)$）。
public override void Sort&amp;lt;T&amp;gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位 var maxIndex = 0; for (var i = 0; i &amp;lt; a.Length; i++) { if (Less(a[maxIndex], a[i])) maxIndex = i; } Exch(a, maxIndex, a.Length - 1); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } 代码 # 修改后的快速排序类。
public class QuickSortX : BaseSort { /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位 var maxIndex = 0; for (var i = 0; i &amp;lt; a.</description></item><item><title>2.3.18</title><link>https://alg4.ikesnowy.com/2-3-18/</link><pubDate>Tue, 24 Jul 2018 18:13:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-18/</guid><description>2.3.18 # 解答 # 每次切分时都取前三个元素的中位数作为枢轴，这可以带来约 5%~10% 的性能提升。
这里通过三次比较将前三个数排序，然后把三个数中的中位数放到数组开头，最大值放到数组末尾。
最大值被放到了末尾，枢轴不可能大于末尾的这个数，因此右边界判断可以去掉。
同时由于枢轴不可能小于自身，因此左边界判断也可以去掉。
这样就可以把切分中的两个边界判断全部去掉了。
最后对于大小为 2 的数组做特殊处理，通过一次比较直接排序并返回。
测试结果：
代码 # QuickSortMedian3 # public class QuickSortMedian3 : BaseSort { /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的数组类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序范围的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序范围的结束下标。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] a, int lo, int hi) where T: IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) // 别越界 return; // 只有两个元素的数组直接排序 if (hi == lo + 1) { if (Less(a[hi], a[lo])) Exch(a, lo, hi); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// &amp;lt;summary&amp;gt; /// 对数组进行切分，返回枢轴位置。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要切分的数组类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要切分的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;切分的起始点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;切分的末尾点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;枢轴下标。&amp;lt;/returns&amp;gt; private int Partition&amp;lt;T&amp;gt;(T[] a, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { int i = lo, j = hi + 1; if (Less(a[lo + 1], a[lo])) Exch(a, lo + 1, lo); if (Less(a[lo + 2], a[lo])) Exch(a, lo + 2, lo); if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 1, lo + 2); Exch(a, lo, lo + 1); // 中位数放最左侧 Exch(a, hi, lo + 2); // 较大的值放最右侧作为哨兵 var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) { } if (i &amp;gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// &amp;lt;summary&amp;gt; /// 打乱数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要打乱的数组类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要打乱的数组。&amp;lt;/param&amp;gt; private void Shuffle&amp;lt;T&amp;gt;(T[] a) { var random = new Random(); for (var i = 0; i &amp;lt; a.</description></item><item><title>2.3.19</title><link>https://alg4.ikesnowy.com/2-3-19/</link><pubDate>Sat, 28 Jul 2018 13:45:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-19/</guid><description>2.3.19 # 解答 # 主要介绍一下这个少于七次比较的五取样算法。
首先假设五个数字为 a b c d e
对 b c 排序，d e 排序。（两次比较）
比较 b 和 d，把较小那一组换到 b c 的位置上去。（一次比较）
此时会有 b &amp;lt; c, b &amp;lt; d &amp;lt; e。
交换 a, b，重新对 b c 排序。（一次比较）
再次比较 b 和 d，把较小的那一组换到 b c 的位置上。（一次比较）
最后比较 c 和 d，较小的那一个即为中位数。（一次比较）
总共需要 6 次比较，严格小于 7 次。
取样完毕后，a b 是最小值和次小值（这里没有对应关系，a 也可以是次小值）。
d 和 e 是最大值和次大值（同样没有对应关系）。
我们把 d 和 e 放到数组的最后作为哨兵，去掉右边界的判断。
同时让左右两侧指针都向中间移动两位，减少不必要的比较。</description></item><item><title>2.3.20</title><link>https://alg4.ikesnowy.com/2-3-20/</link><pubDate>Sun, 29 Jul 2018 21:47:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-20/</guid><description>2.3.20 # 解答 # 事实上就是用一个栈保存每次切分后的子数组下标。
关键代码如下：
/// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Shuffle(a); var stack = new Stack&amp;lt;int&amp;gt;(); stack.Push(0); stack.Push(a.Length - 1); while (stack.Count != 0) { // 压入顺序是先 lo，再 hi，故弹出顺序是先 hi 再 lo var hi = stack.Pop(); var lo = stack.Pop(); if (hi &amp;lt;= lo) continue; var j = Partition(a, lo, hi); // 让较大的子数组先入栈（先排序较小的子数组） if (j - lo &amp;gt; hi - j) { stack.</description></item><item><title>2.3.21</title><link>https://alg4.ikesnowy.com/2-3-21/</link><pubDate>Tue, 31 Jul 2018 22:11:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-21/</guid><description>2.3.21 # 解答 # 首先引入命题 I 的结论，对于互不相同的主键值，基于比较的排序算法的下界等于所形成的比较树的高度，即：
$$ h \ge \log_2{N!} $$
那么我们题目即可转化为求证
$$ h \ge \log_2 (\frac{N!}{f_1!f_2!\cdots f_k!}) \ge \log_2 N! $$
这里的 $f_i$ 为某个主键值出现的频率，即某个主键值出现的次数，因此 $f_i\ge 1$ 。
根据题目给出的条件，如果主键互不重复，此时 $k=N$，且 $f_1=f_2=\cdots=f_k=1$ 。
那么 $f_1!f_2!\cdots f_k!=1$ ，待证式子即为命题 I 的结论。
那么当主键有重复时，此时 $k &amp;lt; N$，为使 $f_1+f_2+ \cdots + f_k=N$ ，至少存在一个 $f_m \ge 2$。
故此时：
$$ f_1!f_2!\cdots f_k! &amp;gt;1\Rightarrow \frac{N!}{f_1!f_2!\cdots f_k!}&amp;lt;N! \Rightarrow \newline h \ge \log_2 (\frac{N!}{f_1!f_2!\cdots f_k!}) \ge \log_2 N! \ \blacksquare $$</description></item><item><title>2.3.22</title><link>https://alg4.ikesnowy.com/2-3-22/</link><pubDate>Thu, 02 Aug 2018 11:31:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-22/</guid><description>2.3.22 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html
快速三向切分 # 论文引用见「另请参阅」部分。
算法演示
Ninther 算法 # 官方实现中用到了 Ninther 算法用于选取近似中位数（作为枢轴），
该算法由 John Tukey 在 1978 年提出，论文引用见「另请参阅」部分。
这个算法的思想其实很简单，假设我们有三个数 $y_1, y_2, y_3$ ，那么其中位数为：
$$ y_A= {\rm median}\lbrace y_1,y_2,y_3 \rbrace $$
现在对于九个数，我们以三个为一组，取三个中位数：
$$ y_A= {\rm median}\lbrace y_1,y_2,y_3 \rbrace \newline y_B= {\rm median}\lbrace y_4,y_5,y_6 \rbrace \newline y_C= {\rm median}\lbrace y_7,y_8,y_9 \rbrace $$
接下来取这三个中位数的中位数，有：
$$ y_E= {\rm median}\lbrace y_A,y_B,y_C \rbrace $$
我们把上述过程封装成函数，即 $y_E= {\rm ninther}\lbrace y_1,y_2,\cdots,y_9 \rbrace$ 。
于是我们获得的 $y_E$ 即为近似中位数，如果 $\lbrace y_1,y_2,\cdots,y_9 \rbrace$ 是单调数列，那么 $y_E$ 就是中位数。</description></item><item><title>2.3.23</title><link>https://alg4.ikesnowy.com/2-3-23/</link><pubDate>Sat, 04 Aug 2018 20:23:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-23/</guid><description>2.3.23 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html
见 2.3.22 的解答，其中已经包含了这些改动。
代码 # QuickBentleyMcIlroy
public class QuickBentleyMcIlroy : BaseSort { /// &amp;lt;summary&amp;gt; /// 小于这个数值的数组调用插入排序。 /// &amp;lt;/summary&amp;gt; private readonly int _insertionSortCutoff = 8; /// &amp;lt;summary&amp;gt; /// 小于这个数值的数组调用中位数作为枢轴。 /// &amp;lt;/summary&amp;gt; private readonly int _medianOf3Cutoff = 40; /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// &amp;lt;summary&amp;gt; /// 对指定范围内的数组进行排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;排序的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;排序的终止下标。&amp;lt;/param&amp;gt; private void Sort&amp;lt;T&amp;gt;(T[] a, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { var n = hi - lo + 1; if (n &amp;lt;= _insertionSortCutoff) { InsertionSort(a, lo, hi); return; } if (n &amp;lt;= _medianOf3Cutoff) { // 对于较小的数组，直接选择左中右三个元素中的中位数作为枢轴。 var m = Median3(a, lo, lo + n / 2, hi); Exch(a, m, lo); } else { // 对于较大的数组使用 Turkey Ninther 作为枢轴。 var eps = n / 8; var mid = lo + n / 2; var m1 = Median3(a, lo, lo + eps, lo + eps + eps); var m2 = Median3(a, mid - eps, mid, mid + eps); var m3 = Median3(a, hi - eps - eps, hi - eps, hi); var ninther = Median3(a, m1, m2, m3); Exch(a, ninther, lo); } // 三向切分 int i = lo, j = hi + 1; int p = lo, q = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) if (j == lo) break; if (i == j &amp;amp;&amp;amp; IsEqual(a[i], v)) Exch(a, ++p, i); if (i &amp;gt;= j) break; Exch(a, i, j); if (IsEqual(a[i], v)) Exch(a, ++p, i); if (IsEqual(a[j], v)) Exch(a, --q, j); } i = j + 1; for (var k = lo; k &amp;lt;= p; k++) Exch(a, k, j--); for (var k = hi; k &amp;gt;= q; k--) Exch(a, k, i++); Sort(a, lo, j); Sort(a, i, hi); } /// &amp;lt;summary&amp;gt; /// 判断两个元素是否值相等。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要判断的元素类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;进行比较的第一个元素。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;b&amp;#34;&amp;gt;进行比较的第二个元素。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;两个元素的值是否相等。&amp;lt;/returns&amp;gt; private bool IsEqual&amp;lt;T&amp;gt;(T a, T b) where T : IComparable&amp;lt;T&amp;gt; { return a.</description></item><item><title>2.3.24</title><link>https://alg4.ikesnowy.com/2-3-24/</link><pubDate>Sun, 05 Aug 2018 22:04:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-24/</guid><description>2.3.24 # 解答 # 取样排序的想法很简单：
常规快排的枢轴只有一个。
如果用一个数组来充当枢轴，根据排序位置的不同自动选择对应的枢轴，
显然能够更好的估计中位数，以求更好的切分效果。
于是引入了「取样」的概念，假如我们从源数组中随机取了 3 个元素并对其排序，
那么这 3 个元素的中位数可以作为第一次切分的枢轴，剩余两个元素则可以充当切分后两个子数组的枢轴。
那么当取样元素到达一个合适的数量时，就能达到提升切分效率的目标。
大致思路如下：
首先先从输入数组里随机取一些元素，作为「取样数组」。
用任意排序算法（比如快排）对取样数组进行排序。
（由于取样数组通常都比较小，这一步的时间消耗通常不会影响性能）
取出取样数组里面的中位数，当作枢轴对剩下的数组进行切分。
之后的切分中，根据排序区间在剩余数组中的相对位置，
用取样数组中对应位置的数作为枢轴，直到整个排序完成。
论文里提到了两种实现方式。
第一种方法
取样数组和剩余数组是分开保存的。
每次切分完成后，并不把枢轴放入剩余数组中，
而是等到剩余数组全部排序完毕之后再用一次归并（merge）操作将取样数组和剩余数组归并。
第二种方法
取样数组和剩余数组保存在同一片空间里，这也是这份题解所实现的方法。
在打乱输入数组之后，取前 2^k-1 个元素作为取样数组，用快排对其排序。
然后把取样数组的后半部分放到整个数组的末尾。
这样操作的结果是输入数组分为了四个部分：
有序的取样数组、取样数组的中位数、无序的剩余数组、有序的取样数组。
中位数则位于第一部分的末尾，我们将其作为枢轴对剩余数组进行切分，数组变为：
有序的取样数组、小于中位数的部分、枢轴、大于中位数的部分、有序的取样数组
接下来我们再对第一个部分取半，放到中位数之前；对最后一部分取半，放到中位数之后：
0 ~ 1/4 取样数组、小于中位数、1/4 ~ 1/2 取样数组、枢轴、1/2~3/4 取样数组、大于中位数、3/4~1 取样数组
你会发现枢轴前后又分别变回了初始条件，递归执行上述操作，便能对整个数组排序。
注意当取样数组用完的时候，直接变回普通的快排。
现代的取样排序
这里的「现代」并不意味着更好，只是让取样排序能更好的适应多线程排序。
首先仍然是取样，取样的数量往往取决于线程的数量，比如说取了 p-1 个，就将数组分为 p 份。
对取样数组进行排序，获得 p 个区间（桶）。
遍历输入的数组，把元素扔到相应的桶里面。
把每个桶和对应的枢轴送到对应的线程进行排序。
汇总各个桶中的结果，排序完毕。
测试结果：
大概能提升 5%~10% 的性能。
代码 # /// &amp;lt;summary&amp;gt; /// 取样排序类。 /// &amp;lt;/summary&amp;gt; public class SampleSort : QuickSort { /// &amp;lt;summary&amp;gt; /// 取样数组长度 2^k - 1 的阶数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;取样数组长度的阶数。&amp;lt;/value&amp;gt; public int K { get; set; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public SampleSort() { K = 8; } /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { if (a.</description></item><item><title>2.3.25</title><link>https://alg4.ikesnowy.com/2-3-25/</link><pubDate>Mon, 06 Aug 2018 19:10:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-25/</guid><description>2.3.25 # 解答 # 切换到插入排序的实现比较简单，在类内添加一个成员变量 M，在 Sort 方法里添加如下代码：
protected void Sort&amp;lt;T&amp;gt;(T[] a, int lo, int hi) where T: IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) // 别越界 return; if (hi - lo &amp;lt;= M) { // 调用插入排序 for (var i = lo; i &amp;lt;= hi; i++) for (var k = i; k &amp;gt; lo &amp;amp;&amp;amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } 下面放上实验结果： N=1000</description></item><item><title>2.3.26</title><link>https://alg4.ikesnowy.com/2-3-26/</link><pubDate>Mon, 06 Aug 2018 21:14:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-26/</guid><description>2.3.26 # 解答 # 在切换为插入排序之前先记录一下当前子数组的大小。
在排序类内添加一个大小为 M+1 的数组，用于记录每种数组大小出现的次数。
结果如下（N=100000）： M=10
M=20
M=50
代码 # using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._26 { public partial class Form2 : Form { private int M; private int N; public Form2(int m, int n) { InitializeComponent(); this.M = m; this.N = n; } /// &amp;lt;summary&amp;gt; /// 启动页面时启动后台测试。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;sender&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;e&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Form2_Shown(object sender, EventArgs e) { this.</description></item><item><title>2.3.27</title><link>https://alg4.ikesnowy.com/2-3-27/</link><pubDate>Mon, 06 Aug 2018 21:42:23 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-27/</guid><description>2.3.27 # 解答 # 实验结果如下：
P.S. 测试机上的缓存是 L1 128K，L2 512K，L3 4MB。
代码 # QuickSortIgnore
public class QuickSortIgnore : BaseSort { /// &amp;lt;summary&amp;gt; /// 切换到插入排序的阈值。 /// &amp;lt;/summary&amp;gt; public int M { get; set; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public QuickSortIgnore() { M = 10; } /// &amp;lt;summary&amp;gt; /// 用快速排序对数组 a 进行升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;T&amp;#34;&amp;gt;需要排序的类型。&amp;lt;/typeparam&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public override void Sort&amp;lt;T&amp;gt;(T[] a) { Shuffle(a); Sort(a, 0, a.</description></item><item><title>2.3.28</title><link>https://alg4.ikesnowy.com/2-3-28/</link><pubDate>Mon, 06 Aug 2018 22:21:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-28/</guid><description>2.3.28 # 解答 # 对 Sort 方法做修改，添加一个层层传递的 depth 参数，每加一层 depth 就加一，结束时取左右较大的 depth 返回。
protected int Sort&amp;lt;T&amp;gt;(T[] a, int lo, int hi, int depth) where T: IComparable&amp;lt;T&amp;gt; { if (hi &amp;lt;= lo) // 别越界 return depth; if (hi - lo &amp;lt;= M) { // 调用插入排序 for (var i = lo; i &amp;lt;= hi; i++) for (var k = i; k &amp;gt; lo &amp;amp;&amp;amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return depth; } var j = Partition(a, lo, hi); var left = Sort(a, lo, j - 1, depth + 1); var right = Sort(a, j + 1, hi, depth + 1); return Less(left, right) ?</description></item><item><title>2.3.29</title><link>https://alg4.ikesnowy.com/2-3-29/</link><pubDate>Mon, 06 Aug 2018 22:40:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-29/</guid><description>2.3.29 # 解答 # 在快排类内部添加一个随机数发生器，每次随机取枢轴并交换至第一位进行切分。
private int Partition&amp;lt;T&amp;gt;(T[] a, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { int i = lo, j = hi + 1; var pivot = _randomGenerator.Next(hi - lo) + lo; Exch(a, pivot, lo); var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i &amp;gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } 测试结果：</description></item><item><title>2.3.30</title><link>https://alg4.ikesnowy.com/2-3-30/</link><pubDate>Mon, 06 Aug 2018 23:00:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-30/</guid><description>2.3.30 # 解答 # 结果如下，在 N=5000000 时，随机选择枢轴会比事先打乱快一点。 代码 # var insertionSort = new QuickSortInsertion(); var randomSort = new QuickSortRandomPivot(); var n = 5000000; // 高斯分布（正态分布） var arrayInsertion = SortCompare.GetNormalDistributionArray(n); var arraySelection = new double[n]; arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(&amp;#34;Normal Distribution:&amp;#34;); Console.WriteLine(&amp;#34;Insertion: &amp;#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(&amp;#34;Random Pivot: &amp;#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 泊松分布 arrayInsertion = SortCompare.GetPossionDistributionArray(n); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(&amp;#34;Poission Distribution:&amp;#34;); Console.WriteLine(&amp;#34;Insertion: &amp;#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(&amp;#34;Random Pivot: &amp;#34; + SortCompare.Time(randomSort, arraySelection)); Console.</description></item><item><title>2.3.31</title><link>https://alg4.ikesnowy.com/2-3-31/</link><pubDate>Tue, 07 Aug 2018 09:37:23 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-3-31/</guid><description>2.3.31 # 解答 # 以下所有结果 T=70
N=1000 N=10000 N=100000 N=1000000 代码 # using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._31 { public partial class Form2 : Form { private int N; private int T; public Form2(int n, int t) { InitializeComponent(); this.N = n; this.T = t; } /// &amp;lt;summary&amp;gt; /// 启动页面时启动后台测试。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;sender&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;e&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Form2_Shown(object sender, EventArgs e) { this.</description></item><item><title>2.4.1</title><link>https://alg4.ikesnowy.com/2-4-1/</link><pubDate>Fri, 10 Aug 2018 20:40:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-1/</guid><description> 2.4.1 # 解答 # R R P O T Y I I U Q E U 优先队列的变化如下：
输入命令 优先队列 输出 P P R P R I P R I O P R I O * P I O R R P I O R * P I O R * I O P I I O I * I I O T I I T * I I T Y I I Y * I I Y * I I * I Q Q U Q U E Q U E * Q E U * E Q * E U U * U E E</description></item><item><title>2.4.2</title><link>https://alg4.ikesnowy.com/2-4-2/</link><pubDate>Fri, 10 Aug 2018 20:56:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-2/</guid><description>2.4.2 # 解答 # 这种方式只能取出一次最大值，这个最大值就是输入序列里面的最大值。
当需要继续取出最大值时（即继续取第二大、第三大、第 i 大的元素），
这个方法就不再适用了（或者说不能在常数时间内完成）。</description></item><item><title>2.4.3</title><link>https://alg4.ikesnowy.com/2-4-3/</link><pubDate>Sun, 12 Aug 2018 20:49:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-3/</guid><description>2.4.3 # 解答 # 有序数组的官方版本：https://algs4.cs.princeton.edu/24pq/OrderedArrayMaxPQ.java.html
无序数组的官方版本：https://algs4.cs.princeton.edu/24pq/UnorderedArrayMaxPQ.java.html
实现 insert() delMax() 有序数组 N 1 有序链表 N 1 无序数组 1 N 无序链表 1 N 在库文件中定义了如下接口，所有的（最大）优先队列都会实现它。
/// &amp;lt;summary&amp;gt; /// 实现优先队列 API 的接口。（最大堆） /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TKey&amp;#34;&amp;gt;优先队列容纳的元素。&amp;lt;/typeparam&amp;gt; public interface IMaxPq&amp;lt;TKey&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 向优先队列中插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;v&amp;#34;&amp;gt;插入元素的类型。&amp;lt;/param&amp;gt; void Insert(TKey v); /// &amp;lt;summary&amp;gt; /// 返回最大元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;最大的元素。&amp;lt;/returns&amp;gt; TKey Max(); /// &amp;lt;summary&amp;gt; /// 删除并返回最大元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;最大的元素。&amp;lt;/returns&amp;gt; TKey DelMax(); /// &amp;lt;summary&amp;gt; /// 返回队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;为空则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; bool IsEmpty(); /// &amp;lt;summary&amp;gt; /// 返回队列中的元素个数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;队列中的元素个数。&amp;lt;/returns&amp;gt; int Size(); } 于是我们就可以使用这样的方法测试所有类型的优先队列：</description></item><item><title>2.4.4</title><link>https://alg4.ikesnowy.com/2-4-4/</link><pubDate>Sun, 12 Aug 2018 21:25:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-4/</guid><description>2.4.4 # 解答 # 是的。
例如这个数组：9 8 7 6 5，画成二叉堆如下：</description></item><item><title>2.4.5</title><link>https://alg4.ikesnowy.com/2-4-5/</link><pubDate>Mon, 13 Aug 2018 21:47:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-5/</guid><description> 2.4.5 # 解答 #</description></item><item><title>2.4.6</title><link>https://alg4.ikesnowy.com/2-4-6/</link><pubDate>Tue, 14 Aug 2018 21:47:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-6/</guid><description>2.4.6 # 解答 # 官方给出的最大堆实现：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html
运行示意图：
运行结果：
P R P R P I R P I O P O I R P I O P O I O I O I I I I T I I I I Y I I I I I Q U Q U Q E Q E E U E 代码 # 最大堆的实现
public class MaxPq&amp;lt;TKey&amp;gt; : IMaxPq&amp;lt;TKey&amp;gt;, IEnumerable&amp;lt;TKey&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 保存元素的数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;保存元素的数组。&amp;lt;/value&amp;gt; protected TKey[] Pq; /// &amp;lt;summary&amp;gt; /// 堆中的元素数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;堆中的元素数量。&amp;lt;/value&amp;gt; protected int N; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public MaxPq() : this(1) { } /// &amp;lt;summary&amp;gt; /// 建立指定容量的最大堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;最大堆的容量。&amp;lt;/param&amp;gt; public MaxPq(int capacity) { Pq = new TKey[capacity + 1]; N = 0; } /// &amp;lt;summary&amp;gt; /// 从已有元素建立一个最大堆。（O(n)） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;已有元素。&amp;lt;/param&amp;gt; public MaxPq(TKey[] keys) { N = keys.</description></item><item><title>2.4.7</title><link>https://alg4.ikesnowy.com/2-4-7/</link><pubDate>Thu, 16 Aug 2018 22:34:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-7/</guid><description>2.4.7 # 解答 # k = 2 时， 只可能出现在位置 2、3 上（根节点的子结点，深度为 2，根节点深度为 1）
k = 3 时， 可以直接是根节点的子结点（第 2 或第 3 位，深度为 2），
也可以是第二大元素的子结点（第 4~7 位，也就是深度为 3 的所有位置）
k = 4 时，
可以直接是根节点的子结点（深度为 2 的点）
也可以是第二大元素的子结点（深度为 3 的点）
也可以是第三大元素的子结点（深度为 4 的点）
故范围为第 2~15 位。
不难看出第 k 大元素只可能出现在深度＜k 的位置（$k \ge 2$）
即位置小于 $2 ^ k - 1, (k \ge 2)$</description></item><item><title>2.4.8</title><link>https://alg4.ikesnowy.com/2-4-8/</link><pubDate>Fri, 17 Aug 2018 20:42:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-8/</guid><description>2.4.8 # 解答 # 不难看出第 k 大元素只可能出现在深度＜k 的位置（$ k \ge 2$）
即位置小于 $ 2^k - 1, (k \ge 2)$。
出现范围为 $[2, \min {2^k -1, n}]$，其中 n 为堆的大小。</description></item><item><title>2.4.9</title><link>https://alg4.ikesnowy.com/2-4-9/</link><pubDate>Fri, 17 Aug 2018 22:00:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-9/</guid><description>2.4.9 # 解答 # 首先 A B C D E 中，根节点必须是 E （假设为最大堆）
D 只能选择 E 作为父结点。
C 可以选择 D 或者 E 作为父结点。
B 可以选择 C 或 D 或 E 作为父结点。
A 可以选择 B 或 C 或 D 或 E 作为父结点。
又由于堆的大小为 5，堆的结构固定，一共三层。
E 只能为根节点
D 可以在左侧或者右侧
当 D 在左侧时，
D 的子结点可以在 A B C 中任取两个，剩下一个当 E 的右侧子结点
总共有 A(3, 2) = 6 种
当 D 在右侧时，
C 的子结点只能取 A 和 B ，故只有 A(2, 2) = 2 种情况。</description></item><item><title>2.4.10</title><link>https://alg4.ikesnowy.com/2-4-10/</link><pubDate>Sat, 18 Aug 2018 20:38:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-10/</guid><description>2.4.10 # 解答 # 左子树位于 $2k+1$，右子树位于 $2k+2$，父结点位于 $\lfloor (i-1)/2 \rfloor$ 。</description></item><item><title>2.4.11</title><link>https://alg4.ikesnowy.com/2-4-11/</link><pubDate>Sat, 18 Aug 2018 20:49:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-11/</guid><description>2.4.11 # 解答 # 有大量插入操作，选择插入操作为常数级别的无序数组实现较为合适。</description></item><item><title>2.4.12</title><link>https://alg4.ikesnowy.com/2-4-12/</link><pubDate>Sat, 18 Aug 2018 21:50:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-12/</guid><description>2.4.12 # 解答 # 堆实现会略优于有序数组实现。
有序数组，查找最大元素操作是 O(1) 的，插入/删除元素是 O(N) 的。
堆要看具体实现，基于数组的实现和有序数组类似，但插入/删除元素的效率更优。
注：
官网给出的堆实现会在插入 / 删除操作之后对整个数组进行检查，
确认是否为最大堆（isMaxHeap 方法）。
在测试时务必删除/注释掉这部分代码。</description></item><item><title>2.4.13</title><link>https://alg4.ikesnowy.com/2-4-13/</link><pubDate>Sun, 19 Aug 2018 17:13:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-13/</guid><description>2.4.13 # 解答 # 在官方实现的基础上直接删除 j&amp;lt;N 语句，随后在 DelMax() 方法中在 Sink(1) 之前让 pq[n + 1] = pq[1] 即可。
首先保存最大值，然后把堆中的第一个元素和最后一个元素交换，随后使 n = n - 1。
随后让 pq[n + 1] = pq[1]，这样在下沉操作时就不会下沉到 pq[n + 1]了。（相等的元素是不会交换的）
故之后的 Sink() 语句中不再需要进行边界判断，直接删去即可。
修改后 DelMax() 的代码如下：
public Key DelMax() { if (IsEmpty()) throw new ArgumentOutOfRangeException(&amp;#34;Priority Queue Underflow&amp;#34;); Key max = pq[1]; Exch(1, n--); pq[n + 1] = pq[1]; Sink(1); pq[n + 1] = default; if ((n &amp;gt; 0) &amp;amp;&amp;amp; (n == pq.</description></item><item><title>2.4.14</title><link>https://alg4.ikesnowy.com/2-4-14/</link><pubDate>Mon, 20 Aug 2018 21:58:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-14/</guid><description>2.4.14 # 解答 # 对于 n &amp;lt;= 2 的堆
第一步让最大元素和末端元素交换。
第二步下沉时由于 n &amp;lt;= 1，不需要交换。
故总共发生了一次交换，两个元素发生了交换。
对于 n = 3 的堆
第一步让最大元素和末端元素交换。
第二步如果末端元素大于另一侧的子结点，那么就不需要交换。
故最优情况时总共发生一次交换，两个元素被交换。
对于 n &amp;gt; 3 的堆。
第一步需要让最末端元素和最大元素交换。
由于堆中第二大的元素必定位于根节点之后。
故最末端元素一定小于该第二大元素。
因此在下沉操作时必定会和第二大元素进行交换。
故至少发生两次交换，总共有三个元素发生了交换。
构造的堆（n=15）
92 和 100 交换，随后 92 和 99 交换
构造最优情况堆的方式如下（取根结点为 100）：
对于每个结点，左子结点大于右子结点，
且左子结点的子元素都小于右子树的最小值，
（上例中省略了这部分元素，可以将它们当作负数）
于是第一次 DelMax 的时候，只需要两次交换，三个元素被交换。（即 87 最后被交换到上例中 99 的位置）
第二次 DelMax 的时候，只需要三次交换，六个元素被交换. （88 交换到 97 的位置）
因此当 n &amp;gt; 7 时，连续两次 DelMax() 最少只需要 5 次交换。</description></item><item><title>2.4.15</title><link>https://alg4.ikesnowy.com/2-4-15/</link><pubDate>Tue, 21 Aug 2018 11:02:23 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-15/</guid><description>2.4.15 # 解答 # MinPQ 的官方实现见：https://algs4.cs.princeton.edu/24pq/MinPQ.java.html
事实上只需要把 MaxPQ 中的比较调换方向即可。
在线性时间内检测是否是面向最小元素的堆的方法：
/// &amp;lt;summary&amp;gt; /// 确定以 k 为根节点的二叉树是不是一个最小堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;需要检查的二叉树根节点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private bool IsMinHeap(int k) { if (k &amp;gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left &amp;lt;= this.n &amp;amp;&amp;amp; Greater(k, left)) return false; if (right &amp;lt;= this.n &amp;amp;&amp;amp; Greater(k, right)) return false; return IsMinHeap(left) &amp;amp;&amp;amp; IsMinHeap(right); } 用递归方法遍历整个二叉树，确认都满足堆的性质。由于每个结点都只会被比较三次（与父结点比较一次，与每个子结点各比较一次），由于 3N~N，因此这个方法是 O(n) 的。</description></item><item><title>2.4.16</title><link>https://alg4.ikesnowy.com/2-4-16/</link><pubDate>Sat, 08 Sep 2018 10:44:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-16/</guid><description>2.4.16 # 解答 # 最好情况比较简单，只需要一个所有键值完全相同的数组即可。
最坏情况的构造方法参考了一篇论文（见「另请参阅」部分），结果如下：
最好输入： 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
最坏输入： 1 4 7 12 10 16 14 19 17 20 5 27 8 28 2 24 9 18 6 23 11 22 21 31 13 26 25 30 15 29 3 32</description></item><item><title>2.4.17</title><link>https://alg4.ikesnowy.com/2-4-17/</link><pubDate>Sun, 09 Sep 2018 10:40:49 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-17/</guid><description>2.4.17 # 解答 # 英文版原文是：insert followed by remove the minimum，因此是先插入再删除。
大致上相当于一个缓冲区，把比较大的留下来，比较小的筛出去。
首先我们有一个大小为 k 的优先队列，保证最小值在最前。 接下来我们插入一个元素，可以分成两种情况。
如果插入的元素比最小值还要小，那么这个插入的元素会在之后被删除，原队列中的元素不变。
如果插入的元素比最小值大（或者相等），那么最小值会被删除，留下插入的元素。
于是可以观察到这样一个逻辑，在不断的插入过程中，比较小的元素会被过滤，只留下较大的元素。
那么我们可以把题目转化为：
向一个优先队列插入 N 个元素，保证队列的大小不超过 k，如果超过 k 了就删除最小值。
那么前 k 次插入不受影响，之后的 N-k 次插入就会按照之前说过的流程进行。
最后只留下 N 个元素中较大的 k 个元素，得证。</description></item><item><title>2.4.18</title><link>https://alg4.ikesnowy.com/2-4-18/</link><pubDate>Sun, 09 Sep 2018 14:28:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-18/</guid><description>2.4.18 # 解答 # 首先看第一种情况，一次 insert() 接一次 delMax()。
由于插入的数比堆中的所有元素都大，这个元素会一路上升到根结点。
记上升路径上的点为 $a_1,a_2,a_3, \dots , a_k$，其中 $a_k$是插入的结点，$a_1$ 是根结点。
插入完成后路径上点的次序变为 $a_k, a_1, a_2, \dots, a_{k-1}$ 。
随后进行一次 delMax()，先做交换，次序变为 $a_{k-1}, a_1, \dots, a_{k-2}, a_k$ 。
由于 $a_1$ 是堆中原来的最大值，下沉时一定会和它交换。
根据定义，二叉堆是父结点总是优于子结点的完全二叉树，因此以后续结点作为根结点的子树也都是堆。
故同理 $a_{k-1}$ 会和 $a_2, a_3, \dots,a_{k-2}$ 交换，即沿原路径返回。
因此这种情况下前后堆不发生改变。
然后看第二种情况，操作顺序为 insert() insert() delMax() delMax()。
根据之前的结论，插入最大结点之后立即删除最大元素不会使堆发生变化，中间的两个操作抵消。
序列变为：insert() delMax()。
同理再次利用刚才的结论，操作抵消，堆不发生变化。
故第二种情况也不会使堆发生改变。</description></item><item><title>2.4.19</title><link>https://alg4.ikesnowy.com/2-4-19/</link><pubDate>Sun, 09 Sep 2018 16:42:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-19/</guid><description>2.4.19 # 解答 # 官方实现已经包含了这部分的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html
相应的构造函数（Java）
public MaxPQ(Key[] keys) { n = keys.length; pq = (Key[]) new Object[keys.length + 1]; for (int i = 0; i &amp;lt; n; i++) pq[i+1] = keys[i]; for (int k = n/2; k &amp;gt;= 1; k--) sink(k); assert isMaxHeap(); } 代码 # 构造函数（C#）
/// &amp;lt;summary&amp;gt; /// 从已有元素建立一个最大堆。（O(n)） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;已有元素。&amp;lt;/param&amp;gt; public MaxPQ(Key[] keys) { _n = keys.Length; pq = new Key[keys.Length + 1]; for (var i = 0; i &amp;lt; keys.</description></item><item><title>2.4.20</title><link>https://alg4.ikesnowy.com/2-4-20/</link><pubDate>Sun, 09 Sep 2018 22:00:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-20/</guid><description>2.4.20 # 解答 # 官网给出了解答：https://algs4.cs.princeton.edu/24pq/
首先介绍第一种解法。
设叶子结点的高度为 $0$，根结点的高度为 $ h ​$。
于是某个结点 sink 时的最大交换次数即为该结点的高度。
故某一层结点的最大交换次数为 该层结点数 × 该层的高度。
于是总交换次数最大为：
$$ \begin{align*} &amp;amp; h+2(h-1)+2^2(h-2)+ \dots + 2^h(0) \newline &amp;amp; =\sum_{k=0}^{h-1} 2^k(h-k) \newline &amp;amp; =h\sum_{k=0}^{h-1}2^k - \sum_{k=0}^{h-1}k2^k \newline \end {align*} $$
第一项为等比数列的和，第二项为等差数列乘以等比数列的和。
于是第一项可以直接通过公式求得，第二项可以利用错位相减法求得。
$$ \begin{align} &amp;amp; h\sum_{k=0}^{h-1}2^k - \sum_{k=0}^{h-1}k2^k \newline &amp;amp; =h2^{h}-h-\sum_{k=0}^{h-1}k2^k \newline &amp;amp; =h2^{h}-h +\sum_{k=0}^{h-1} k2^k - 2\sum_{k=0}^{h-1} k2^k \newline &amp;amp; =h2^{h}-h+2^h - 2-(h-1)2^h \newline &amp;amp; =2^{h+1}-h-2 \newline &amp;amp; =N-h-1 \le N \end{align} $$</description></item><item><title>2.4.21</title><link>https://alg4.ikesnowy.com/2-4-21/</link><pubDate>Mon, 10 Sep 2018 21:48:47 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-21/</guid><description>2.4.21 # 解答 # 给元素添上序号组成结点，按照序号排序即可，每个结点可以用类似于这样的实现：
class ElemType&amp;lt;T&amp;gt; : IComparable&amp;lt;ElemType&amp;lt;T&amp;gt;&amp;gt; { private int _key; private T _element; public ElemType(int key) =&amp;gt; _key = key; public int CompareTo(ElemType&amp;lt;T&amp;gt; other) { return _key.CompareTo(other._key); } } 栈：
用最大元素在最前的优先队列。
每个结点都包含一个元素和一个序号，
插入新元素时序号递增，这样最后插入的元素总在最前。
队列：
用最小元素在最前的优先队列。
每个结点都包含一个元素和一个序号，
插入新元素时序号递增，这样最先插入的元素总在最前。
随机队列：
优先队列的选择任意
每个结点都包含一个元素和一个序号，
插入新元素时随机指定一个序号，这样元素的顺序就是任意的了。</description></item><item><title>2.4.22</title><link>https://alg4.ikesnowy.com/2-4-22/</link><pubDate>Thu, 13 Sep 2018 09:07:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-22/</guid><description>2.4.22 # 解答 # 官方实现中已经包含了调整数组大小的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html
截取如下：
// helper function to double the size of the heap array private void resize(int capacity) { assert capacity &amp;gt; n; Key[] temp = (Key[]) new Object[capacity]; for (int i = 1; i &amp;lt;= n; i++) { temp[i] = pq[i]; } pq = temp; } 只要在队列快满时重新分配空间，再把元素复制进去即可。
在不触发重新分配空间的情况下，
每次队列操作的比较次数上限就等于命题 Q 中给出的 $\lg N+1$（插入） 和 $2\lg N$（删除）。
插入元素最多需要 $\lg N$ 次交换（比较次数-1），
删除元素最多需要 $1 + \lg N - 1 = \lg N$ 次交换 （注意开始时有一次交换）。</description></item><item><title>2.4.23</title><link>https://alg4.ikesnowy.com/2-4-23/</link><pubDate>Tue, 18 Sep 2018 12:51:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-23/</guid><description>2.4.23 # 解答 # 简单的 sink 实现 # sink 方法会在所有的 $t$ 个子结点中寻找最大的结点。 如果找到的结点比当前结点大，那么就进行交换。
否则视为结点已经下沉到了合适的位置，结束循环。
根据题意，在 $t$ 个元素中找最大值需要 $t$ 次比较。
sink 操作需要找到 $t$ 个子结点中的最大值并与当前结点相比较。
于是 sink 操作每次最多需要 $t + 1$ 次比较。
建堆过程，对 2.4.20 的证明进行推广。
设 $t$ 叉树的高度为 $h$ ，叶子结点的高度为 $0$，根结点的高度为 $h$。
根据 sink 操作的定义，高度为 $k$ 的结点最多进行 $k$ 次交换（到达叶子结点）。
于是建堆需要的总交换次数为：
$$ \begin{align*} &amp;amp; h+t(h-1)+t^2(h-2)+ \dots + t^h(0) \newline &amp;amp; =\sum_{k=0}^{h-1} t^k(h-k) \newline &amp;amp; =h\sum_{k=0}^{h-1}t^k - \sum_{k=0}^{h-1}kt^k \newline \end {align*} $$
其中，第一个数列是等比数列，第二个数列是等差数列和等比数列之积，可以利用错位相减法求得，即：</description></item><item><title>2.4.24</title><link>https://alg4.ikesnowy.com/2-4-24/</link><pubDate>Fri, 05 Oct 2018 19:20:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-24/</guid><description>2.4.24 # 解答 # 链式实现，每个结点都包含一个指向父结点的指针和两个指向子结点的指针。
交换结点可以直接用交换两个结点的值来实现（与数组的实现一样），而不是对两个结点的指针进行交换。
于是 Sink() 和 Swim() 操作就比较简单，直接按照定义实现即可。
比较困难的是删除和插入结点，或者更具体的说，
如何找到按照完全二叉树定义下序号向后/向前一位的结点？
我们首先在堆里面维护两个指针，一个指向根结点（root），另一个指向当前最后一个结点（last）。
当需要插入新结点时，我们需要找到 last 的后一位的父结点，然后把新的结点插入为该结点的左子结点。
这段话可能比较绕，下面这个示意图可以帮助理解，有三种情况：
标黄的代表 last 指着的位置。
我们先从简单的说起，中间的第二种情况，新插入的结点应该放在右侧，即作为 last 的父结点的右子结点。
如果 last 已经是右子结点了，那么就考虑第三种情况。
此时应该向上回溯，直到在某一次回溯中，结点是从父结点的左侧回溯上来的 （即图中路径 A-B-B，B-B 这一步是从左子树回溯上来的）。
于是待插入的位置就在该父结点的右子树的最左侧结点（即图中根结点的右子结点 A）。
最后是图中第一种情况，整棵树已经是满二叉树了。
这种情况下会一路回溯到根结点，那么只要一路下沉到最左侧的叶子结点，把新结点插入到其左子树上即可。
删除结点同理，也是这三种情况，只是需要找前一个结点，判断条件中的左右正好相反。
如果已经是右子结点了，只需要把 last 改为其父结点的左子树即可。
如果是左子结点，就需要回溯，直到某一次回溯是从右子树回溯上来的，last 应该指向其左子树的最右侧结点。
如果删除后正好变成满二叉树，那么会一直回溯到根结点，last 应该指向整棵树的最右侧结点。
代码实现中还需要处理只有一个结点以及没有结点时的特殊情况。
根据上面的算法，插入/删除找到相应位置所需的最大耗时为 2lgN （从树的一侧回溯到根结点，再下沉到另一侧的底部）。
Sink 和 Swim 是 O(lgN) 级的，因此整个插入/删除操作是 O(lgN) 的。
代码 # public class MaxPqLinked&amp;lt;TKey&amp;gt; : IMaxPq&amp;lt;TKey&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 二叉堆的根结点。 /// &amp;lt;/summary&amp;gt; private TreeNode&amp;lt;TKey&amp;gt; _root; /// &amp;lt;summary&amp;gt; /// 二叉堆的最后一个结点。 /// &amp;lt;/summary&amp;gt; private TreeNode&amp;lt;TKey&amp;gt; _last; /// &amp;lt;summary&amp;gt; /// 二叉堆中的结点个数。 /// &amp;lt;/summary&amp;gt; private int _nodesCount; /// &amp;lt;summary&amp;gt; /// 删除并返回最大值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;最大值。&amp;lt;/returns&amp;gt; /// &amp;lt;remarks&amp;gt;如果希望获得最大值而不删除它，请使用 &amp;lt;see cref=&amp;#34;Max&amp;#34;/&amp;gt;。&amp;lt;/remarks&amp;gt; public TKey DelMax() { var result = _root.</description></item><item><title>2.4.25</title><link>https://alg4.ikesnowy.com/2-4-25/</link><pubDate>Sun, 07 Oct 2018 16:31:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-25/</guid><description>2.4.25 # 解答 # 官方实现：https://algs4.cs.princeton.edu/24pq/CubeSum.java.html
注意这道题并不是要打印所有的 $a^3+b^3$ 的结果，而是需要找到 $a^3+b^3=c^3+d^3$ 这个丢番图方程的解。
因此在官方实现的基础上，每次取出最小值之后和之前的最小值比较，如果相等则输出对应的组合。
关键代码如下：
CubeSum prev = new CubeSum(-1, -1); long pairCount = 0; while (!pq.IsEmpty()) { CubeSum s = pq.DelMin(); if (s.sum == prev.sum) // 如果与之前的数相等 { Console.WriteLine(s + &amp;#34; = &amp;#34; + prev.i + &amp;#34;^3 + &amp;#34; + prev.j + &amp;#34;^3&amp;#34;); pairCount++; } if (s.j &amp;lt; n) pq.Insert(new CubeSum(s.i, s.j + 1)); prev = s; } 当然，对于 n=10^6 来说结果会非常大，程序的运行时间需要以天为单位计算（约 14 天）。</description></item><item><title>2.4.26</title><link>https://alg4.ikesnowy.com/2-4-26/</link><pubDate>Mon, 15 Oct 2018 18:26:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-26/</guid><description>2.4.26 # 解答 # 用类似于「半交换」的方法避免频繁调用 Exch() 方法。
上浮时，先单独保存待上浮的元素，随后进行比较，
如果当前 k 值对应的父结点（即 k/2 ）小于待上浮的元素，令 pq[k]=pq[k/2]。
否则令当前 k 值等于待上浮的元素，终止循环。 下沉的过程类似。
修改后的 sink 和 swim 方法：
/// &amp;lt;summary&amp;gt; /// 使元素上浮。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;需要上浮的元素。&amp;lt;/param&amp;gt; private void Swim(int k) { var key = _pq[k]; while (k &amp;gt; 1 &amp;amp;&amp;amp; _pq[k / 2].CompareTo(key) &amp;lt; 0) { _pq[k] = _pq[k / 2]; k /= 2; } _pq[k] = key; } /// &amp;lt;summary&amp;gt; /// 使元素下沉。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;需要下沉的元素。&amp;lt;/param&amp;gt; private void Sink(int k) { var key = _pq[k]; while (k * 2 &amp;lt;= _n) { var j = 2 * k; if (Less(j, j + 1)) j++; if (_pq[j].</description></item><item><title>2.4.27</title><link>https://alg4.ikesnowy.com/2-4-27/</link><pubDate>Sat, 20 Oct 2018 11:19:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-27/</guid><description>2.4.27 # 解答 # 官网有解答，只要在 MaxPQ 里面加上一个记录最小值的指针就可以了。
初始状态下这个指针为空。
每次插入新元素的时候先更新一下这个指针。 删除最后一个元素的时候把它重新置空即可。
具体实现见代码。
代码 # public class MaxPqWithMin&amp;lt;TKey&amp;gt; : IMaxPq&amp;lt;TKey&amp;gt;, IEnumerable&amp;lt;TKey&amp;gt; where TKey : class, IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 保存元素的数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;保存元素的数组。&amp;lt;/value&amp;gt; private TKey[] _pq; /// &amp;lt;summary&amp;gt; /// 堆中的元素数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;堆中的元素数量。&amp;lt;/value&amp;gt; private int _n; /// &amp;lt;summary&amp;gt; /// 堆中的最小元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;堆中的最小元素。&amp;lt;/value&amp;gt; private TKey _min; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public MaxPqWithMin() : this(1) { } /// &amp;lt;summary&amp;gt; /// 建立指定容量的最大堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;最大堆的容量。&amp;lt;/param&amp;gt; public MaxPqWithMin(int capacity) { _pq = new TKey[capacity + 1]; _n = 0; _min = null; } /// &amp;lt;summary&amp;gt; /// 从已有元素建立一个最大堆。（O(n)） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;已有元素。&amp;lt;/param&amp;gt; public MaxPqWithMin(TKey[] keys) { _n = keys.</description></item><item><title>2.4.28</title><link>https://alg4.ikesnowy.com/2-4-28/</link><pubDate>Mon, 22 Oct 2018 09:19:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-28/</guid><description>2.4.28 # 解答 # 开始时让 N=10^5，在 M=10^4 不变的情况下令 N 不断翻倍，求出算法增长的数量级。
再根据求出的增长的数量级估计 N=10^8 时所需要的时间。
为了方便比较，需要编写一个欧几里得距离类，
构造时输入一个点的坐标，内部自动计算并保存这个点到原点的欧几里得距离。
欧几里得距离的计算公式如下：
$$ d(x,y)=\sqrt{\sum_{i=1}^{n}(x_i-y_i)^2} $$
其中，x 和 y 分别代表两个点。
在本题中，y 始终是原点，且使用三维坐标系，因此公式可以简化为：
$$ d=\sqrt {x^2+y^2+z^2} $$
同时这个类需要实现 IComparable 接口以作为最小堆的元素。
做测试时，先随机生成 N 个点，再建立一个最小堆。
随后开始计时，把开始的 m 个点插入。
剩余的 n-m 个点则是先删除最小值再插入，这样可以保证最小堆的大小不变。
最后再把堆中的所有元素输出，停止计时。
用不断倍增的的 N 值做上述测试，获得每次的耗时，进而求得算法增长的数量级。
求得的结果如下：
可以推出当 N=10^8 时耗时为 $ 398 \ ms × 1000 = 398 \ s $
代码 # 欧几里得距离类，EuclideanDistance3D
internal class EuclideanDistance3D : IComparable&amp;lt;EuclideanDistance3D&amp;gt; { private readonly int _x, _y, _z; private readonly double _distance; /// &amp;lt;summary&amp;gt; /// 计算点到原点的欧几里得距离。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;x 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;y 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;z&amp;#34;&amp;gt;z 轴坐标。&amp;lt;/param&amp;gt; public EuclideanDistance3D(int x, int y, int z) { _x = x; _y = y; _z = z; _distance = Math.</description></item><item><title>2.4.29</title><link>https://alg4.ikesnowy.com/2-4-29/</link><pubDate>Sat, 27 Oct 2018 12:01:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-29/</guid><description>2.4.29 # 解答 # 算法思想比较简单，但在实现上会有一些复杂。
用一个最大堆和一个最小堆，每个堆中都保存了全部数组元素，且相同的元素之间有指针相连。
插入元素时需要构建两个完全相同的元素分别插入到两个堆中。
找到最小元素和找到最大元素只需要分别返回最大堆和最小堆的堆顶元素即可。
以删除最小元素为例，先对最小堆进行 DelMin() 操作，再通过指针找到对应最大堆的元素并删除。
下面介绍删除堆中任意元素的算法。
首先将待删除元素与堆中最后一个元素交换，让堆的大小减一。
随后对交换后的元素先进行 Swim 再进行 Sink，移动到正确的位置上。
下图是一个例子，当删除最大元素 14 时，最小堆中删除元素 14 需要先 Swim。
如果堆的层数更多一些，就需要先 Swim 再 Sink。
现在来考虑一下实现，我们构建一个结点类，里面存放有当前结点的值、对应数组下标和另一个结点的指针。
private sealed class MinMaxNode : IComparable&amp;lt;MinMaxNode&amp;gt; { /// &amp;lt;summary&amp;gt; /// 结点的值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;结点的值。&amp;lt;/value&amp;gt; public TKey Key { get; set; } /// &amp;lt;summary&amp;gt; /// 结点在当前数组中的下标。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;结点在当前数组中的下标。&amp;lt;/value&amp;gt; public readonly int Index; /// &amp;lt;summary&amp;gt; /// 指向孪生结点的引用。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;指向孪生结点的引用。&amp;lt;/value&amp;gt; public MinMaxNode Pair { get; set; } /// &amp;lt;summary&amp;gt; /// 这个类不能在外部实例化。 /// &amp;lt;/summary&amp;gt; private MinMaxNode(TKey key, int index) { Key = key; Index = index; } /// &amp;lt;summary&amp;gt; /// 工厂方法，建立两个孪生的结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;结点中的元素。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;index&amp;#34;&amp;gt;索引。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;minNode&amp;#34;&amp;gt;准备放到最小堆中的结点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;maxNode&amp;#34;&amp;gt;准备放到最大堆中的结点。&amp;lt;/param&amp;gt; public static void GetNodes(TKey key, int index, out MinMaxNode minNode, out MinMaxNode maxNode) { minNode = new MinMaxNode(key, index); maxNode = new MinMaxNode(key, index); minNode.</description></item><item><title>2.4.30</title><link>https://alg4.ikesnowy.com/2-4-30/</link><pubDate>Sun, 28 Oct 2018 12:27:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-30/</guid><description>2.4.30 # 解答 # 单独用一个变量存放中位数，然后前半部分元素放在一个最大堆中，后半部分元素放在一个最小堆中。
如下图所示，注意 Median 和两个堆并没有直接连接，这里只是方便理解元素顺序。
只要左右两个堆含有元素之差不超过 1，那么 Median 变量中存放的就是整个数组的中位数。
如果元素差大于 1，就需要进行调整，
把 Median 变量中存放的值插入到元素较少的堆，
再从元素较多的堆中取出元素放入 Median 变量，直到元素差不大于 1。
插入元素时，根据插入元素的大小插入到某一个堆中去，再做一次调整。
删除中位数时，去掉中位数，然后从元素较多的一侧堆中取元素补位，再进行一次调整。
编写代码时要注意堆中只有一个元素的情况需要特殊处理。
代码 # 面向中位数的堆（MedianPQ.cs）
public class MedianPq&amp;lt;TKey&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 最大堆（保存前半段元素）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;最大堆（保存前半段元素）。&amp;lt;/value&amp;gt; private readonly MaxPq&amp;lt;TKey&amp;gt; _maxPq; /// &amp;lt;summary&amp;gt; /// 最小堆（保存后半段元素）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;最小堆（保存后半段元素）。&amp;lt;/value&amp;gt; private readonly MinPq&amp;lt;TKey&amp;gt; _minPq; /// &amp;lt;summary&amp;gt; /// 中位数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;中位数。&amp;lt;/value&amp;gt; private TKey _median; /// &amp;lt;summary&amp;gt; /// 堆的大小。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;堆的大小。&amp;lt;/value&amp;gt; private int _n; /// &amp;lt;summary&amp;gt; /// 默认构造函数，构造一个面向中位数的堆。 /// &amp;lt;/summary&amp;gt; public MedianPq() { _maxPq = new MaxPq&amp;lt;TKey&amp;gt;(); _minPq = new MinPq&amp;lt;TKey&amp;gt;(); _median = default; _n = 0; } /// &amp;lt;summary&amp;gt; /// 构造一个指定容量的面向中位数的堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;初始容量。&amp;lt;/param&amp;gt; public MedianPq(int capacity) { _maxPq = new MaxPq&amp;lt;TKey&amp;gt;((capacity - 1) / 2); _minPq = new MinPq&amp;lt;TKey&amp;gt;((capacity - 1) / 2); _n = 0; _median = default; } /// &amp;lt;summary&amp;gt; /// 根据指定数组初始化面向中位数的堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;初始数组。&amp;lt;/param&amp;gt; public MedianPq(TKey[] keys) { _minPq = new MinPq&amp;lt;TKey&amp;gt;(); _maxPq = new MaxPq&amp;lt;TKey&amp;gt;(); if (keys.</description></item><item><title>2.4.31</title><link>https://alg4.ikesnowy.com/2-4-31/</link><pubDate>Fri, 02 Nov 2018 16:05:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-31/</guid><description>2.4.31 # 解答 # 首先可以观察到堆有这样一个性质，从根结点到某一个叶子结点的路径是有序的，满足二分查找的条件。
但是， 从叶子结点到根结点的路径可以通过不断地令 k = k / 2 得到（从下往上只有一条路径）。
但从根结点到叶子结点的路径却不能简单地通过 k = k * 2 得到（从上往下会有两条分支）。
因此只通过堆本身是无法满足二分查找对于随机访问的要求的。
为了达到 ~loglogN 次比较，我们需要对 Swim() 方法做修改，
即，先通过一个数组来保存路径，再对这个数组进行二分查找，从而获得合适的祖先结点。
路径的长度是 ~logN（完全二叉树的性质），于是二分查找的比较次数即为 ~loglogN。
删除操作原本就是 ~2logN 的，不需要修改。
注意这样的方法仅仅只是减少了比较次数，
为了保持堆的有序，即使找到了结点的合适位置也不能直接插入，
仍然需要将路径上的结点依次下移，空出位置后再插入结点，复杂度仍然是 ~logN。
由于增加了保存路径等操作（建立了大量的小数组），实际算法的运行时间是增加的。
也可以用空间换时间，由于在堆中下标为 k 的结点到根结点的路径是唯一确定的。
因此可以提前计算好路径，用一个数组保存起来（数组的数组），在 Swim 中取出对应路径进行二分查找。
当然这样是很不划算的，除非元素比较的开销非常大。
代码 # 修改后的 Swim() 方法，注意输入的路径是从下往上的。
private void Swim(int k) { if (k == 1) return; // 获取路径 var path = new List&amp;lt;int&amp;gt;(); var temp = k; while (temp &amp;gt;= 1) { path.</description></item><item><title>2.4.32</title><link>https://alg4.ikesnowy.com/2-4-32/</link><pubDate>Fri, 02 Nov 2018 16:42:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-32/</guid><description>2.4.32 # 解答 # 官网解答见：https://algs4.cs.princeton.edu/24pq/
如果这样的话，堆排序的只需要 ~nloglogn 次比较即可。
根据 2.3 中的证明，基于比较的排序的下界是 ~nlogn。
因此不存在这样的最小堆。
注意上题的方法不能用于下沉操作，因为我们不能预知下沉的路径。</description></item><item><title>2.4.33</title><link>https://alg4.ikesnowy.com/2-4-33/</link><pubDate>Fri, 02 Nov 2018 20:56:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-33/</guid><description>2.4.33 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/24pq/IndexMaxPQ.java.html
书中算法 2.6 给出的是一个最大堆的实现，但本题给出的部分解答却是最小堆的。
同时官网给出的解答是最大堆的，这里选择和官网保持一致，给出最大堆的实现。
初看起来可能会比较难理解，但其实就是以指针为元素的堆。
堆中存放的只是指向元素的指针（如果元素在数组里那就变成了下标）。
做比较的时候要先根据指针（下标）找到对应元素，再进行比较。
再来看题目中给出的要求，keys[] 数组中用于保存元素（比如 keys[0] = ‘A’;），
而 pq[] 中保存的是元素在 key[] 数组中的下标（比如 pq[1] = 0;)，
而 qp[] 中保存的是某个下标在 pq[]中 的对应位置。 （比如 qp[0] = 1）。
在这三个数组中，pq[]是一个堆，我们的堆操作都作用在这个数组上。
keys[] 数组中的元素不随着 pq[] 中下标的移动而移动，只有当删除或添加元素时才发生变化。
qp[]与pq[]中的索引一一对应，pq[]交换时也需要交换qp[]中的对应元素。
代码 # public class IndexMaxPq&amp;lt;TKey&amp;gt; : IEnumerable&amp;lt;int&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 优先队列中的元素。 /// &amp;lt;/summary&amp;gt; private int _n; /// &amp;lt;summary&amp;gt; /// 索引最大堆。 /// &amp;lt;/summary&amp;gt; private readonly int[] _pq; /// &amp;lt;summary&amp;gt; /// pq 的逆索引，pq[qp[i]]=qp[pq[i]]=i /// &amp;lt;/summary&amp;gt; private readonly int[] _qp; /// &amp;lt;summary&amp;gt; /// 实际元素。 /// &amp;lt;/summary&amp;gt; private readonly TKey[] _keys; /// &amp;lt;summary&amp;gt; /// 建立指定大小的面向索引的最大堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;最大堆的容量。&amp;lt;/param&amp;gt; public IndexMaxPq(int capacity) { if (capacity &amp;lt; 0) throw new ArgumentOutOfRangeException(); _n = 0; _keys = new TKey[capacity + 1]; _pq = new int[capacity + 1]; _qp = new int[capacity + 1]; for (var i = 0; i &amp;lt;= capacity; i++) _qp[i] = -1; } /// &amp;lt;summary&amp;gt; /// 将与索引 &amp;lt;paramref name=&amp;#34;i&amp;#34;/&amp;gt; 相关联的元素换成 &amp;lt;paramref name=&amp;#34;k&amp;#34;/&amp;gt;。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;i&amp;#34;&amp;gt;要修改关联元素的索引。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;用于替换的新元素。&amp;lt;/param&amp;gt; public void ChangeKey(int i, TKey k) { if (!</description></item><item><title>2.4.34</title><link>https://alg4.ikesnowy.com/2-4-34/</link><pubDate>Thu, 27 Dec 2018 19:25:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-34/</guid><description>2.4.34 # 解答 # 这里给出最大堆的实现，原因同 2.4.33。
maxIndex()：pq[1] 就是最小元素的下标。
change()：首先修改 keys 数组中对应的元素，然后对堆中该下标进行重排序。
delete()：先从堆中删除元素，再把 keys 和 qp 数组中的对应元素初始化。
代码 # /// &amp;lt;summary&amp;gt; /// 返回最大元素对应的索引。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;最大元素对应的索引。&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentOutOfRangeException&amp;#34;&amp;gt;当优先队列为空时抛出该异常。&amp;lt;/exception&amp;gt; public int MaxIndex() { if (_n == 0) throw new InvalidOperationException(&amp;#34;Priority Queue Underflow&amp;#34;); return _pq[1]; } /// &amp;lt;summary&amp;gt; /// 将与索引 &amp;lt;paramref name=&amp;#34;i&amp;#34;/&amp;gt; 相关联的元素换成 &amp;lt;paramref name=&amp;#34;k&amp;#34;/&amp;gt;。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;i&amp;#34;&amp;gt;要修改关联元素的索引。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;用于替换的新元素。&amp;lt;/param&amp;gt; public void ChangeKey(int i, TKey k) { if (!</description></item><item><title>2.4.35</title><link>https://alg4.ikesnowy.com/2-4-35/</link><pubDate>Fri, 28 Dec 2018 09:28:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-35/</guid><description>2.4.35 # 解答 # 本题有两个翻译错误。
random() ——返回索引 i 的概率是 p[i]/T，而非返回概率和索引。（return an index i with probability p[i]/T）
最后一句指的是像堆那样使用数组而非显式指针实现二叉树。（Avoid explicit pointers, as we do for heaps.）
提示已经给出了实现方案，我们用一个例子来简单说明一下。
现在给出一个分布 p，总和 T=1，如下图所示：
为了实现这样的随机分布，我们在 0~T 之间随机一个小数，然后根据结果返回不同的值。 现在我们将这个思想应用到完全二叉树上。
每次随机的过程其实构成了一棵选择树，我们把数组 p 当作一棵树，如下图：
为方便起见，我们重新排列一下之前的随机表：
每个值的概率并没有改变，只是每个值对应的区段换了一下。
经过这样的变换后，你会发现，如果从根结点的角度看：
如果随机的值小于 0.1，对应的编号就是 1。
如果随机的值大于 0.5，那么对应编号只能是 3 或 6，即根结点的右子树。
其他情况对应编号在左子树上。
扩展到一般情况，就变成了：
如果随机数小于当前结点，直接返回当前结点的编号。
如果随机数大于左子树权值总和+当前结点的权值，减去它们，移动到右子树。
其他情况减去当前结点的权值并移动到左子树。
思想理解之后，代码实现就比较容易了，做了 100000 次实验的结果如下：
代码 # internal class Sample { public double[] P; public double[] SumP; public double T; private readonly Random _random = new(); /// &amp;lt;summary&amp;gt; /// 构造一个离散取样类。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;取样数据。&amp;lt;/param&amp;gt; public Sample(double[] data) { // 复制权重 P = new double[data.</description></item><item><title>2.4.36</title><link>https://alg4.ikesnowy.com/2-4-36/</link><pubDate>Fri, 28 Dec 2018 18:41:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-36/</guid><description>2.4.36 # 解答 # 测试结果如下：
可以看出增长数量级约为 O(nlogn)。
代码 # var doubleTime = 5; var repeatTime = 5; var n = 100000; for (var i = 0; i &amp;lt; doubleTime; i++) { long totalTime = 0; Console.WriteLine(&amp;#34;count=&amp;#34; + n); for (var j = 0; j &amp;lt; repeatTime; j++) { var pq = new MaxPq&amp;lt;int&amp;gt;(n); var time = Test(pq, n); Console.Write(time + &amp;#34;\t&amp;#34;); totalTime += time; } Console.WriteLine(&amp;#34;平均用时：&amp;#34; + totalTime / repeatTime + &amp;#34;毫秒&amp;#34;); n *= 2; } long Test(MaxPq&amp;lt;int&amp;gt; pq, int count) { var random = new Random(); // 生成数据 var initData = new int[count]; var appendData = new int[count / 2]; for (var i = 0; i &amp;lt; count; i++) initData[i] = random.</description></item><item><title>2.4.37</title><link>https://alg4.ikesnowy.com/2-4-37/</link><pubDate>Fri, 28 Dec 2018 19:23:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-37/</guid><description>2.4.37 # 解答 # 建立一个全局变量 isRunning ，每次 DelMax() 之前都先确认这个值是否为 true，
设立一个 Timer 在 1 秒钟之后自动将 isRunning 置为 false。
测试结果如下：
随着 n 增大，一秒钟之内能执行的 DelMax() 次数会下降。
代码 # var doubleTime = 6; var repeatTime = 6; var n = 1000000; var isRunning = true; for (var i = 0; i &amp;lt; doubleTime; i++) { var totalDelCount = 0; Console.WriteLine(&amp;#34;count=&amp;#34; + n); for (var j = 0; j &amp;lt; repeatTime; j++) { var pq = new MaxPq&amp;lt;int&amp;gt;(n); var delCount = Test(n, pq); totalDelCount += delCount; Console.</description></item><item><title>2.4.38</title><link>https://alg4.ikesnowy.com/2-4-38/</link><pubDate>Fri, 28 Dec 2018 19:49:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-38/</guid><description>2.4.38 # 解答 # 直接构造相应的数组测试即可。
测试结果如下：
最大堆来说顺序时会比较慢，因为每次插入都要一路上升到顶部。
逆序的时候则是删除比较慢，最后一个元素是最小的元素，交换后需要一路下沉到底部。
由于元素相同的时候我们选择不交换（less(i, j) 返回 false），较多的重复元素并不会影响性能。
代码 # var random = new Random(); var n = 200000; var repeatTimes = 5; var doubleTimes = 4; for (var i = 0; i &amp;lt; doubleTimes; i++) { Console.WriteLine(&amp;#34;number=&amp;#34; + n); // 升序数组 long totalTime = 0; Console.Write(&amp;#34;Ascending:\t&amp;#34;); for (var j = 0; j &amp;lt; repeatTimes; j++) { var pq = new MaxPq&amp;lt;int&amp;gt;(n); var data = GetAscending(n); var time = Test(pq, data); Console.</description></item><item><title>2.4.39</title><link>https://alg4.ikesnowy.com/2-4-39/</link><pubDate>Sat, 29 Dec 2018 16:12:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-39/</guid><description>2.4.39 # 解答 # 结果如下，约占总耗时的 2~5%。 代码 # var random = new Random(); Console.WriteLine(&amp;#34;number\tBuild\tSort\tRatio&amp;#34;); var n = 1000; // 当数据量到达 10^9 时会需要 2G 左右的内存 var multiTen = 7; for (var i = 0; i &amp;lt; multiTen; i++) { var data = GetRandomArray(n); var fullSort = new Stopwatch(); var buildHeap = new Stopwatch(); fullSort.Restart(); buildHeap.Restart(); BuildHeap(data); buildHeap.Stop(); HeapSort(data); fullSort.Stop(); var buildTime = buildHeap.ElapsedMilliseconds; var fullTime = fullSort.ElapsedMilliseconds; Console.WriteLine(n + &amp;#34;\t&amp;#34; + buildTime + &amp;#34;\t&amp;#34; + fullTime + &amp;#34;\t&amp;#34; + (double)buildTime / fullTime); n *= 10; } short[] GetRandomArray(int number) { var data = new short[number]; for (var i = 0; i &amp;lt; number; i++) { data[i] = (short)random.</description></item><item><title>2.4.40</title><link>https://alg4.ikesnowy.com/2-4-40/</link><pubDate>Sat, 29 Dec 2018 18:36:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-40/</guid><description>2.4.40 # 解答 # 如同书上所说，可以节省约 50% 的比较次数。 先沉后浮的实现也很简单，将 swim 方法加入，
然后修改 sink 方法，去掉其中检查是否需要下沉的条件（if(!Less(pq, k, j))），
然后在 sink 方法的循环之后调用 swim。
为了获得比较次数，你可以添加一个静态全局变量 compareCount，
然后修改 Less 方法，在作比较的同时使 compareCount++ ，
每次执行 Sort 时先让 compareCount 置零，最后返回 compareCount。
代码 # public static class HeapFloyd { /// &amp;lt;summary&amp;gt; /// 利用堆排序对数组进行排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;pq&amp;#34;&amp;gt;需要排序的数组。&amp;lt;/param&amp;gt; public static void Sort&amp;lt;T&amp;gt;(T[] pq) where T : IComparable&amp;lt;T&amp;gt; { var n = pq.Length; // 建堆 for (var k = n / 2; k &amp;gt;= 1; k--) { Sink(pq, k, n); } // 排序 while (n &amp;gt; 1) { Exch(pq, 1, n--); SinkThenSwim(pq, 1, n); } } /// &amp;lt;summary&amp;gt; /// 令堆中的元素下沉。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;pq&amp;#34;&amp;gt;需要执行操作的堆。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;k&amp;#34;&amp;gt;需要执行下沉的结点下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;堆中元素的数目。&amp;lt;/param&amp;gt; private static void Sink&amp;lt;T&amp;gt;(T[] pq, int k, int n) where T : IComparable&amp;lt;T&amp;gt; { while (2 * k &amp;lt;= n) { var j = 2 * k; if (j &amp;lt; n &amp;amp;&amp;amp; Less(pq, j, j + 1)) j++; if (!</description></item><item><title>2.4.41</title><link>https://alg4.ikesnowy.com/2-4-41/</link><pubDate>Sat, 29 Dec 2018 19:34:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-41/</guid><description>2.4.41 # 解答 # 多叉堆和二叉堆的实现上并没有很大的区别，
只不过下沉（Sink）时需要比较的子结点数量变多了，上浮时父结点的下标不再是 $\lfloor k /2 \rfloor$。
于是只要能推出 $d$ 叉堆的下标换算公式即可解决整个问题。
先考虑 $d$ 叉堆的在数组中的保存方式，
第一层显然只有根结点，第二层显然有 $d$ 个结点，第三层则有 $d \times d=d^2$ 个结点，如下图所示：
不难推出第 $k$ 层有 $d^{k-1}$ 个结点。
接下来我们对其标号，根结点为 1，以此类推，如下图：
现在我们来推导某个结点的子结点的下标公式。
结点 $i$ 的第一个子结点在哪里呢？
首先要加上本层剩下的结点，再加上它前面结点的所有子结点，再下一个就是它的第一个子结点了。
以 2 号结点为例，它是第二层的第一个结点，第二层共有 $d^{2-1}=d$ 个结点，剩下 $d-1$ 个结点。
2 号结点前面没有更多兄弟结点，于是第一个子结点下标即为 $2 + d - 1 + 1= 2 + d$。
3 号结点之后剩余 $d-2$ 个结点，加上前面 2 号结点的 $d$ 个子结点，
它的第一个子结点下标为 $3+d-2+d+1= 2+2d$。
不难发现规律，结点序号加一，子结点的下标就要对应加上 $d$（要加上前一个结点的子结点），
这个规律也可以从图上（$d=3$）看出来：
1号结点的子结点范围是 $[2,d+1]$，每加一个结点子结点就要加上 $d$ 。</description></item><item><title>2.4.42</title><link>https://alg4.ikesnowy.com/2-4-42/</link><pubDate>Mon, 31 Dec 2018 10:26:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-4-42/</guid><description>2.4.42 # 解答 # 前序序列与完全二叉树 # 二叉树前序遍历的顺序是：自身，左子树，右子树。
因此对于一个前序遍历序列，第一个元素是根结点，第二个元素是左子结点。
再把左子结点找到，就可以把数组分成三部分：根结点，左子树，右子树，进而递归的构造出整个二叉树。
现在问题是，右子结点在哪，或者说，左子树有多大？
这里就要用到完全二叉树的性质了，我们先从比较简单的满二叉树入手。
就满二叉树而言，根结点的左子树和右子树是一样大的，即左右子树大小均为 $(n-1)/2$ 。
在这种情形下，右子结点的下标显然是 $(n+1)/2$ ，根结点下标为 0。 完全二叉树可以视为在满二叉树的基础上加了一层叶子结点，现在我们已知结点总数 $n$。
于是可以求得二叉树的高度 $k=\lfloor \log_2(n) \rfloor$ ，注意只有一个结点的树高度为 0。
那么最后一层的叶子结点数目为 $l=n-2^{k}+1$ 个，如下图所示：
如果把最后一层（第 $k$ 层）去掉，剩余部分即为高度为 $k-1$ 的满二叉树，结点总数为 $2^k - 1$ 。
按照之前的说明可以知道左右子树大小都等于 $(2^{k}-2)/2=2^{k-1}-1$。
现在要将第 $k$ 层的 $l$ 个结点分到左右子树里面去。
第 $k$ 层最多能有 $2^k$ 个结点，取半就是 $2^k / 2 = 2^{k-1}$ 个。
于是当 $l&amp;lt;=2^{k-1}$ 时，左右子树大小分别为 $2^{k-1}-1+l$ 和 $2^{k-1}-1$ 。
当 $l &amp;gt; 2^{k-1}$ 时，左右子树大小分别为 $2^{k} - 1$ 和 $2^{k-1} -1 +l -2^{k-1}=l-1$ 。</description></item><item><title>2.5.1</title><link>https://alg4.ikesnowy.com/2-5-1/</link><pubDate>Thu, 03 Jan 2019 16:21:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-1/</guid><description> 2.5.1 # 解答 # 如果比较的两个 String 引用的是同一个对象，那么就直接返回相等，不必再逐字符比较。
一个例子：
string s = &amp;#34;abcabc&amp;#34;; string p = s; Console.WriteLine(s.CompareTo(p));</description></item><item><title>2.5.2</title><link>https://alg4.ikesnowy.com/2-5-2/</link><pubDate>Fri, 04 Jan 2019 11:21:50 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-2/</guid><description>2.5.2 # 解答 # 将字符串数组 keywords 按照长度排序，于是 keywords[0] 就是最短的字符串。
组合词的最短长度 minLength = 最短字符串的长度 * 2 = keywords[0] * 2。
先找到第一个长度大于等于 minLength 的字符串，下标为 canCombine。
我们从 canCombine 开始，一个个检查是否是组合词。 如果 keywords[canCombine] 是一个组合词，那么它一定是由位于它之前的某两个字符串组合而成的。
组合词的长度一定等于被组合词的长度之和，因此我们可以通过长度快速判断有可能的组合词。
现在题目转化为了如何解决 ThreeSum 问题，即求 a + b = c 型问题，根据 1.4.41 中的解法求解。
keywords[canCombine] 的长度已知，i 从 0 到 canCombine 之间循环，
用二分查找确认 i 到 canCombine 之间有没有符合条件的字符串，注意多个字符串可能长度相等。
代码 # var keywords = Console.ReadLine().Split(&amp;#39; &amp;#39;); Array.Sort(keywords, new StringLengthComparer()); var minLength = keywords[0].Length * 2; // 找到第一个大于 minLength 的字符串 var canCombine = 0; while (keywords[canCombine].</description></item><item><title>2.5.3</title><link>https://alg4.ikesnowy.com/2-5-3/</link><pubDate>Fri, 04 Jan 2019 18:56:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-3/</guid><description>2.5.3 # 解答 # 这样会破坏相等的传递性。
例如 a = 0.005, b=0.000, c=-0.005，则 a == b, c == b，但是 a != c。</description></item><item><title>2.5.4</title><link>https://alg4.ikesnowy.com/2-5-4/</link><pubDate>Fri, 04 Jan 2019 19:18:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-4/</guid><description> 2.5.4 # 解答 # 先排序，然后用书中的代码进行去重。
static string[] Dedup(string[] a) { if (a.Length == 0) return a; var sorted = new string[a.Length]; for (var i = 0; i &amp;lt; a.Length; i++) { sorted[i] = a[i]; } Array.Sort(sorted); // sorted = sorted.Distinct().ToArray(); var distinct = new string[sorted.Length]; distinct[0] = sorted[0]; var j = 1; for (var i = 1; i &amp;lt; sorted.Length; i++) { if (sorted[i].CompareTo(sorted[i - 1]) != 0) distinct[j++] = sorted[i]; } return distinct; }</description></item><item><title>2.5.5</title><link>https://alg4.ikesnowy.com/2-5-5/</link><pubDate>Fri, 04 Jan 2019 19:33:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-5/</guid><description>2.5.5 # 解答 # 因为选择排序会交换不相邻的元素。 例如：
B1 B2 A A B2 B1 此时 B1 和 B2 的相对位置被改变，如果将交换限定在相邻元素之间（插入排序）。
B1 B2 A B1 A B2 A B2 B2 此时排序就是稳定的了。</description></item><item><title>2.5.6</title><link>https://alg4.ikesnowy.com/2-5-6/</link><pubDate>Mon, 07 Jan 2019 10:28:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-6/</guid><description>2.5.6 # 解答 # 非递归官网实现见：https://algs4.cs.princeton.edu/23quicksort/QuickPedantic.java.html
原本是和快速排序一块介绍的，将数组重新排列，使得 a[k] 正好是第 k 小的元素，k 从 0 开始。
具体思路类似于二分查找，
先切分，如果切分位置小于 k，那么在右半部分继续切分，否则在左半部分继续切分。
直到切分位置正好等于 k，直接返回 a[k] 。
代码 # // 使 a[k] 变为第 k 小的数，k 从 0 开始。 // a[0] ~ a[k-1] 都小于等于 a[k], a[k+1]~a[n-1] 都大于等于 a[k] static T Select&amp;lt;T&amp;gt;(T[] a, int k, int lo, int hi) where T : IComparable&amp;lt;T&amp;gt; { if (k &amp;gt; a.Length || k &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(k), &amp;#34;select out of bound&amp;#34;); if (lo &amp;gt;= hi) return a[lo]; var i = Partition(a, lo, hi); if (i &amp;gt; k) return Select(a, k, lo, i - 1); if (i &amp;lt; k) return Select(a, k, i + 1, hi); return a[i]; } 另请参阅 # SortApplication 库</description></item><item><title>2.5.7</title><link>https://alg4.ikesnowy.com/2-5-7/</link><pubDate>Mon, 07 Jan 2019 14:50:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-7/</guid><description>2.5.7 # 解答 # 参考书中给出的快速排序性能分析方法（中文版 P186，英文版 P293）。
设 $C_n$ 代表找出 $n$ 个元素中的最小值所需要的比较次数。
一次切分需要 $n+1$ 次比较，下一侧的元素个数从 $0$ 到 $ n-1 ​$ 都有可能，
于是根据全概率公式，有：
$$ \begin{eqnarray} C_n&amp;amp;=&amp;amp;\frac {1}{n} (n+1) +\frac{1}{n} (n+1+C_1)+ \cdots + \frac{1}{n}(n+1+C_{n-1}) \newline C_n&amp;amp;=&amp;amp;n+1+\frac{1}{n}(C_1+C_2+\cdots+C_{n-1}) \newline nC_n&amp;amp;=&amp;amp;n(n+1)+(C_1+C_2+\cdots+C_{n-1}) \newline nC_n-(n-1)C_{n-1}&amp;amp;=&amp;amp;2n+C_{n-1} \newline nC_n&amp;amp;=&amp;amp;2n+nC_{n-1} \newline C_n&amp;amp;=&amp;amp;2+C_{n-1} \newline C_n &amp;amp;=&amp;amp; C_1+2(n-1) \newline C_n &amp;amp;=&amp;amp; 2n-2 &amp;lt; 2n \end{eqnarray} $$
测试结果符合我们的预期。 附加：找出第 $k$ 小的数平均需要的比较次数。
类似的方法也在计算快速排序的平均比较次数时使用，见 {% post_link 2-3-14.md %}。
首先和快速排序类似，select 方法的所有元素比较都发生在切分过程中。
接下来考虑第 $i$ 小和第 $j$ 小的元素（$x_i$ ，$x_j$），</description></item><item><title>2.5.8</title><link>https://alg4.ikesnowy.com/2-5-8/</link><pubDate>Tue, 08 Jan 2019 10:40:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-8/</guid><description>2.5.8 # 解答 # 官网实现见：https://algs4.cs.princeton.edu/25applications/Frequency.java.html
用到的数据来自（右键另存为）：https://introcs.cs.princeton.edu/java/data/tale.txt
先把所有单词读入，然后排序，一样的单词会被放在一起，
接下来遍历一遍记录每个单词出现的次数。
然后按照频率排序，倒序输出即可。
定义了一个嵌套类 Record 来记录单词及出现次数，实现的比较器按照出现次数排序。
class Record : IComparable&amp;lt;Record&amp;gt; { public string Key { get; set; } // 单词 public int Value { get; set; } // 频率 public Record(string key, int value) { this.Key = key; this.Value = value; } public int CompareTo(Record other) { return this.Value.CompareTo(other.Value); } } 测试结果（前 1% 的单词）：
代码 # var filename = &amp;#34;tale.txt&amp;#34;; var sr = new StreamReader(File.</description></item><item><title>2.5.9</title><link>https://alg4.ikesnowy.com/2-5-9/</link><pubDate>Tue, 08 Jan 2019 14:41:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-9/</guid><description> 2.5.9 # 解答 # 右侧给出的是道琼斯指数，官方数据（右键另存为）：DJI
设计一个类保存日期和交易量，然后按照交易量排序即可。
internal class Djia : IComparable&amp;lt;Djia&amp;gt; { public string Date { get; set; } public long Volume { get; set; } public Djia(string date, long vol) { Date = date; Volume = vol; } public int CompareTo(Djia other) { return Volume.CompareTo(other.Volume); } }</description></item><item><title>2.5.10</title><link>https://alg4.ikesnowy.com/2-5-10/</link><pubDate>Tue, 08 Jan 2019 15:39:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-10/</guid><description>2.5.10 # 解答 # 用一个 int 数组来保存版本号，按顺序进行比较。
如果两个版本号不等长且前缀相同，那么较长的版本号比较高，例如：1.2.1 和 1.2。
internal class Version : IComparable&amp;lt;Version&amp;gt; { private readonly int[] _versionNumber; public Version(string version) { var versions = version.Split(&amp;#39;.&amp;#39;); _versionNumber = new int[versions.Length]; for (var i = 0; i &amp;lt; versions.Length; i++) { _versionNumber[i] = int.Parse(versions[i]); } } public int CompareTo(Version other) { for (var i = 0; i &amp;lt; _versionNumber.Length &amp;amp;&amp;amp; i &amp;lt; other._versionNumber.Length; i++) { if (_versionNumber[i].CompareTo(other._versionNumber[i]) != 0) return _versionNumber[i].</description></item><item><title>2.5.11</title><link>https://alg4.ikesnowy.com/2-5-11/</link><pubDate>Tue, 08 Jan 2019 19:08:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-11/</guid><description>2.5.11 # 解答 # 结果如下，其中快速排序去掉了一开始打乱数组的步骤：
只有快速排序和堆排序会进行交换，剩下四种排序都不会进行交换。
插入排序在排序元素完全相同的数组时只会进行一次遍历，不会交换。
选择排序第 i 次找到的最小值就是 a[i] ，只会让 a[i] 和 a[i] 交换，不会影响顺序。
希尔排序和插入排序类似，每轮排序都不会进行交换。
归并排序是稳定的，就本例而言，只会从左到右依次归并，不会发生顺序变化。
快速排序在遇到相同元素时会交换，因此顺序会发生变化，且每次都是对半切分。
堆排序在删除最大元素时会将第一个元素和最后一个元素交换，使元素顺序发生变化。
代码 # // 插入排序 Console.WriteLine(&amp;#34;Insertion Sort&amp;#34;); Test(new InsertionSort(), 7, 1); // 选择排序 Console.WriteLine(&amp;#34;Selection Sort&amp;#34;); Test(new SelectionSort(), 7, 1); // 希尔排序 Console.WriteLine(&amp;#34;Shell Sort&amp;#34;); Test(new ShellSort(), 7, 1); // 归并排序 Console.WriteLine(&amp;#34;Merge Sort&amp;#34;); Test(new MergeSort(), 7, 1); // 快速排序 Console.WriteLine(&amp;#34;Quick Sort&amp;#34;); var quick = new QuickSortAnalyze { NeedShuffle = false, NeedPath = false }; Test(quick, 7, 1); // 堆排序 Console.</description></item><item><title>2.5.12</title><link>https://alg4.ikesnowy.com/2-5-12/</link><pubDate>Wed, 09 Jan 2019 11:29:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-12/</guid><description>2.5.12 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/SPT.java.html
把任务按照处理时间升序排序即可。
建立 Job 类，保存任务的名称和处理时间，并实现了 IConparable&amp;lt;Job&amp;gt; 接口。
internal class Job : IComparable&amp;lt;Job&amp;gt; { public readonly string Name; public readonly double Time; public Job(string name, double time) { Name = name; Time = time; } public int CompareTo(Job other) { return Time.CompareTo(other.Time); } } 代码 # var n = int.Parse(Console.ReadLine()); var jobs = new Job[n]; for (var i = 0; i &amp;lt; n; i++) { var input = Console.</description></item><item><title>2.5.13</title><link>https://alg4.ikesnowy.com/2-5-13/</link><pubDate>Thu, 10 Jan 2019 10:29:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-13/</guid><description>2.5.13 # 解答 # 官方解答见：https://algs4.cs.princeton.edu/25applications/LPT.java.html
使用上题的 Job 类，在本题建立 Processor 类来代表处理器，定义如下：
internal class Processor : IComparable&amp;lt;Processor&amp;gt; { private readonly List&amp;lt;Job&amp;gt; _jobs = new(); private double _busyTime; public void Add(Job job) { _jobs.Add(job); _busyTime += job.Time; } public int CompareTo(Processor other) { return _busyTime.CompareTo(other._busyTime); } public override string ToString() { var sb = new StringBuilder(); var nowList = _jobs.ToArray(); for (var i = 0; i &amp;lt; nowList.Length; i++) { sb.AppendLine(nowList[i].Name + &amp;#34; &amp;#34; + nowList[i].</description></item><item><title>2.5.14</title><link>https://alg4.ikesnowy.com/2-5-14/</link><pubDate>Fri, 11 Jan 2019 13:52:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-14/</guid><description>2.5.14 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/Domain.java.html
按照逆域名排序，例如输入的是 com.google 和 com.apple ，
比较的时候是按照 google.com 和 apple.com 进行比较的。
排序结果自然是 apple.com, google.com。
编写的 Domain 类，CompareTo() 中是按照倒序进行比较的。
internal class Domain : IComparable&amp;lt;Domain&amp;gt; { private readonly string[] _fields; private readonly int _n; /// &amp;lt;summary&amp;gt; /// 构造一个域名。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;url&amp;#34;&amp;gt;域名的 url。&amp;lt;/param&amp;gt; public Domain(string url) { _fields = url.Split(&amp;#39;.&amp;#39;); _n = _fields.Length; } public int CompareTo(Domain other) { var minLength = Math.Min(_n, other._n); for (var i = 0; i &amp;lt; minLength; i++) { var c = _fields[minLength - i - 1].</description></item><item><title>2.5.15</title><link>https://alg4.ikesnowy.com/2-5-15/</link><pubDate>Fri, 11 Jan 2019 18:55:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-15/</guid><description> 2.5.15 # 解答 # 利用上一题的逆域名排序将域名相同的电子邮件分在一起。
代码 # // 利用上一题的逆域名排序，将相同的域名放在一起。 var emails = new Domain[5]; emails[0] = new Domain(&amp;#34;wayne@cs.princeton.edu&amp;#34;); emails[1] = new Domain(&amp;#34;windy@apple.com&amp;#34;); emails[2] = new Domain(&amp;#34;rs@cs.princeton.edu&amp;#34;); emails[3] = new Domain(&amp;#34;ike@ee.princeton.edu&amp;#34;); emails[4] = new Domain(&amp;#34;admin@princeton.edu&amp;#34;); Array.Sort(emails); for (var i = 0; i &amp;lt; emails.Length; i++) { Console.WriteLine(emails[i]); }</description></item><item><title>2.5.16</title><link>https://alg4.ikesnowy.com/2-5-16/</link><pubDate>Sat, 12 Jan 2019 16:07:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-16/</guid><description>2.5.16 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/California.java.html
数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt
建立一个 string 的比较器，按照题目给定的顺序比较。
private class CandidateComparer : IComparer&amp;lt;string&amp;gt; { private static readonly string order = &amp;#34;RWQOJMVAHBSGZXNTCIEKUPDYFL&amp;#34;; public int Compare(string x, string y) { int n = Math.Min(x.Length, y.Length); for (int i = 0; i &amp;lt; n; i++) { int a = order.IndexOf(x[i]); int b = order.IndexOf(y[i]); if (a != b) return a.CompareTo(b); } return x.Length.CompareTo(y.Length); } } 代码 # // 数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt var sr = new StreamReader(File.</description></item><item><title>2.5.17</title><link>https://alg4.ikesnowy.com/2-5-17/</link><pubDate>Sat, 12 Jan 2019 18:05:49 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-17/</guid><description>2.5.17 # 解答 # 用一个 Wrapper 类包装准备排序的元素，在排序前同时记录元素的内容和下标。
随后对 Wrapper 数组排序，相同的元素会被放在一起，检查它们的下标是否是递增的。
如果不是递增的，则排序算法就是不稳定的；否则排序算法就有可能是稳定的。 （不稳定的排序算法也可能不改变相同元素的相对位置，比如用选择排序对有序数组排序）
代码 # var data = new[] { 7, 7, 4, 8, 8, 5, 1, 7, 7 }; var merge = new MergeSort(); var insertion = new InsertionSort(); var shell = new ShellSort(); var selection = new SelectionSort(); var quick = new QuickSort(); Console.WriteLine(&amp;#34;Merge Sort: &amp;#34; + CheckStability(data, merge)); Console.WriteLine(&amp;#34;Insertion Sort: &amp;#34; + CheckStability(data, insertion)); Console.WriteLine(&amp;#34;Shell Sort: &amp;#34; + CheckStability(data, shell)); Console.</description></item><item><title>2.5.18</title><link>https://alg4.ikesnowy.com/2-5-18/</link><pubDate>Mon, 14 Jan 2019 13:05:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-18/</guid><description>2.5.18 # 解答 # 用和上题一样的 Wrapper 类进行排序。
排序之后，相同的元素会被放在一起，形成一个个子数组。
根据事先保存的原始下标对它们进行排序，即可将不稳定的排序稳定化。
结果：
代码 # var data = new[] { 5, 7, 3, 4, 7, 3, 6, 3, 3 }; var quick = new QuickSort(); var shell = new ShellSort(); Console.WriteLine(&amp;#34;Quick Sort&amp;#34;); Stabilize(data, quick); Console.WriteLine(); Console.WriteLine(&amp;#34;Shell Sort&amp;#34;); Stabilize(data, shell); static void Stabilize&amp;lt;T&amp;gt;(T[] data, BaseSort sort) where T : IComparable&amp;lt;T&amp;gt; { var items = new Wrapper&amp;lt;T&amp;gt;[data.Length]; for (var i = 0; i &amp;lt; data.</description></item><item><title>2.5.19</title><link>https://alg4.ikesnowy.com/2-5-19/</link><pubDate>Mon, 14 Jan 2019 17:36:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-19/</guid><description>2.5.19 # 解答 # 官方解答： Kendall Tau：https://algs4.cs.princeton.edu/25applications/KendallTau.java.html
Inversion：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html
由书中 2.5.3.2 节得，两个数组之间的 Kendall Tau 距离即为两数组之间顺序不同的数对数目。
如果能够把其中一个数组变成标准排列（即 1,2,3,4... 这样的数组），
那么此时 Kendall Tau 距离就等于另一个数组中的逆序对数量。
现在我们来解决如何把一个数组 a 变成标准排列的方法。
也就是找到函数 $ f(x) ​$，使得 $ f(a[i])=i ​$ ，这样的函数其实就是数组 a 的逆数组。
如下图所示，逆数组 ainv 即为满足 ainv[a[i]] = i 的数组。
获得逆数组之后，对另一个数组 b 做同样的变换，令数组 bnew[i] = ainv[b[i]] 。
即 ainv[a[i]] = i, ainv[b[i]] = bnew[i] 。
于是问题转化为了 bnew 和标准排列之间的 Kendall Tau 距离，即 bnew 的逆序对数量。
逆序对数量的求法见 2-2-19。
代码 # int[] testA = { 0, 3, 1, 6, 2, 5, 4 }; int[] testB = { 1, 0, 3, 6, 4, 2, 5 }; Console.</description></item><item><title>2.5.20</title><link>https://alg4.ikesnowy.com/2-5-20/</link><pubDate>Mon, 14 Jan 2019 18:18:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-20/</guid><description>2.5.20 # 解答 # 我们以事件为单位进行处理，每个事件包含任务名，记录时刻和开始/结束标记。
随后按照时间从小到大排序，遍历事件数组。
设开始的时候机器空闲，设置计数器，作为当前正在运行的任务数量。
当遇到开始事件时，计数器加一；遇到结束事件时，计数器减一。
如果计数器加一之前计数器为 0，说明空闲状态结束，记录并更新空闲时间，当前时间为忙碌开始的时间。
如果计数器减一之后计数器为 0，说明忙碌状态结束，记录并更新忙碌时间，当前时间为空闲开始的时间。
测试结果：
代码 # var nowRunning = 0; // 正在运行的程序数量 var maxIdle = 0; var maxBusy = 0; var items = int.Parse(Console.ReadLine()); var jobs = new JobEvent[items * 2]; for (var i = 0; i &amp;lt; jobs.Length; i += 2) { jobs[i] = new JobEvent(); jobs[i + 1] = new JobEvent(); jobs[i].IsFinished = false; // 开始事件 jobs[i + 1].</description></item><item><title>2.5.21</title><link>https://alg4.ikesnowy.com/2-5-21/</link><pubDate>Tue, 15 Jan 2019 13:16:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-21/</guid><description>2.5.21 # 解答 # 与之前的版本号比较十分类似，对数组进行包装，然后按照次序依次比较即可。
internal class Vector : IComparable&amp;lt;Vector&amp;gt; { private readonly int[] _data; public int Length { get; set; } public Vector(int[] data) { _data = data; Length = data.Length; } public int CompareTo(Vector other) { var maxN = Math.Max(Length, other.Length); for (var i = 0; i &amp;lt; maxN; i++) { var comp = _data[i].CompareTo(other._data[i]); if (comp != 0) return comp; } return Length.CompareTo(other.Length); } public override string ToString() { var sb = new StringBuilder(); for (var i = 0; i &amp;lt; Length; i++) { if (i !</description></item><item><title>2.5.22</title><link>https://alg4.ikesnowy.com/2-5-22/</link><pubDate>Tue, 15 Jan 2019 13:33:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-22/</guid><description>2.5.22 # 解答 # 建立最小堆和最大堆，最小堆保存卖家的报价，最大堆保存买家的报价。
如果最小堆中的最低卖出价低于最大堆的最高买入价，交易达成，交易份额较大的一方需要重新回到堆内。
测试结果：
代码 # // 输入格式： buy 20.05 100 var buyer = new MaxPq&amp;lt;Ticket&amp;gt;(); var seller = new MinPq&amp;lt;Ticket&amp;gt;(); var n = int.Parse(Console.ReadLine()); for (var i = 0; i &amp;lt; n; i++) { var ticket = new Ticket(); var item = Console.ReadLine().Split(&amp;#39; &amp;#39;); ticket.Price = double.Parse(item[1]); ticket.Share = int.Parse(item[2]); if (item[0] == &amp;#34;buy&amp;#34;) buyer.Insert(ticket); else seller.Insert(ticket); } while (!buyer.IsEmpty() &amp;amp;&amp;amp; !seller.IsEmpty()) { if (buyer.Max().Price &amp;lt; seller.</description></item><item><title>2.5.23</title><link>https://alg4.ikesnowy.com/2-5-23/</link><pubDate>Mon, 21 Jan 2019 19:59:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-23/</guid><description>2.5.23 # 解答 # 这里我们使用 Floyd-Rivest 算法进行优化，大致思想是：
我们期望第 $k$ 大的元素位于 a[k] 附近，因此优先对 a[k] 附近的区域进行选择。
每次切分时枢轴都选择 a[k]，先递归对样本区域选择，再对整个数组进行选择。
运行示意图：
测试结果：
代码 # // Floyd–Rivest 方法优化，令 a[k] 变成第 k 小的元素。 static T SelectInternal&amp;lt;T&amp;gt;(T[] a, int lo, int hi, int k) where T : IComparable&amp;lt;T&amp;gt; { if (k &amp;lt; 0 || k &amp;gt; a.Length) { throw new IndexOutOfRangeException(&amp;#34;SelectInternal elements out of bounds&amp;#34;); } while (hi &amp;gt; lo) { if (hi - lo &amp;gt; 600) { var n = hi - lo + 1; var i = k - lo + 1; var z = (int)Math.</description></item><item><title>2.5.24</title><link>https://alg4.ikesnowy.com/2-5-24/</link><pubDate>Wed, 23 Jan 2019 20:05:47 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-24/</guid><description>2.5.24 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/StableMinPQ.java.html
在元素插入的同时记录插入顺序，比较的时候把插入顺序也纳入比较。
对于值一样的元素，插入顺序在前的的元素比较小。
交换的时候需要同时交换插入次序。
代码 # public class MinPqStable&amp;lt;TKey&amp;gt; : IMinPq&amp;lt;TKey&amp;gt;, IEnumerable&amp;lt;TKey&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 保存元素的数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;保存元素的数组。&amp;lt;/value&amp;gt; protected TKey[] Pq; /// &amp;lt;summary&amp;gt; /// 堆中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;堆中元素的数量。&amp;lt;/value&amp;gt; protected int N; /// &amp;lt;summary&amp;gt; /// 元素的插入次序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;元素的插入次序。&amp;lt;/value&amp;gt; private long[] _time; /// &amp;lt;summary&amp;gt; /// 元素的插入次序计数器。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;元素的插入次序计数器。&amp;lt;/value&amp;gt; private long _timeStamp = 1; // 元素插入次序计数器。 /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public MinPqStable() : this(1) { } /// &amp;lt;summary&amp;gt; /// 建立指定容量的最小堆。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;最小堆的容量。&amp;lt;/param&amp;gt; public MinPqStable(int capacity) { _time = new long[capacity + 1]; Pq = new TKey[capacity + 1]; N = 0; } /// &amp;lt;summary&amp;gt; /// 删除并返回最小元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;最小元素。&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentOutOfRangeException&amp;#34;&amp;gt;如果堆为空则抛出该异常。&amp;lt;/exception&amp;gt; /// &amp;lt;remarks&amp;gt;如果希望获得最小值但不删除它，请使用 &amp;lt;see cref=&amp;#34;Min&amp;#34;/&amp;gt;。&amp;lt;/remarks&amp;gt; public TKey DelMin() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Priority Queue Underflow&amp;#34;); var min = Pq[1]; Exch(1, N--); Sink(1); Pq[N + 1] = default; _time[N + 1] = 0; if ((N &amp;gt; 0) &amp;amp;&amp;amp; (N == Pq.</description></item><item><title>2.5.25</title><link>https://alg4.ikesnowy.com/2-5-25/</link><pubDate>Thu, 24 Jan 2019 13:44:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-25/</guid><description>2.5.25 # 解答 # 官方解答见：https://algs4.cs.princeton.edu/25applications/Point2D.java.html
这些比较器都以嵌套类的形式在 Point2D 中定义。
静态比较器直接在类中以静态成员的方式声明。
非静态比较器则需要提供工厂方法，该方法新建并返回对应的比较器对象。
代码 # /// &amp;lt;summary&amp;gt; /// 按照 X 顺序比较。 /// &amp;lt;/summary&amp;gt; private class XOrderComparer : Comparer&amp;lt;Point2D&amp;gt; { public override int Compare(Point2D x, Point2D y) { if (x.X &amp;lt; y.X) { return -1; } if (x.X &amp;gt; y.X) { return 1; } return 0; } } /// &amp;lt;summary&amp;gt; /// 按照 Y 顺序比较。 /// &amp;lt;/summary&amp;gt; private class YOrderComparer : Comparer&amp;lt;Point2D&amp;gt; { public override int Compare(Point2D x, Point2D y) { if (x.</description></item><item><title>2.5.26</title><link>https://alg4.ikesnowy.com/2-5-26/</link><pubDate>Thu, 24 Jan 2019 16:32:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-26/</guid><description>2.5.26 # 解答 # 提示中已经给出了方法，使用上一题编写的比较器进行排序即可。
效果演示：
代码 # 绘图部分代码：
using System.Collections.Generic; using System.Drawing; using System.Windows.Forms; using SortApplication; namespace _2._5._26 { public partial class Form2 : Form { Graphics panel; List&amp;lt;Point2D&amp;gt; points; Point2D startPoint; double maxX = 0, maxY = 0; public Form2() { InitializeComponent(); } /// &amp;lt;summary&amp;gt; /// 显示并初始化绘图窗口。 /// &amp;lt;/summary&amp;gt; public void Init() { Show(); this.panel = CreateGraphics(); this.points = new List&amp;lt;Point2D&amp;gt;(); this.startPoint = null; } /// &amp;lt;summary&amp;gt; /// 向画板中添加一个点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;point&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Add(Point2D point) { this.</description></item><item><title>2.5.27</title><link>https://alg4.ikesnowy.com/2-5-27/</link><pubDate>Thu, 24 Jan 2019 18:11:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-27/</guid><description>2.5.27 # 解答 # 类似于索引排序的做法，访问数组都通过一层索引来间接实现。
首先创建一个数组 index，令 index[i] = i。
排序时的交换变成 index 数组中元素的交换，
读取元素时使用 a[index[i]] 而非 a[i] 。
代码 # // 间接排序。 static int[] IndirectSort&amp;lt;T&amp;gt;(T[] keys) where T : IComparable&amp;lt;T&amp;gt; { var n = keys.Length; var index = new int[n]; for (var i = 0; i &amp;lt; n; i++) index[i] = i; for (var i = 0; i &amp;lt; n; i++) for (var j = i; j &amp;gt; 0 &amp;amp;&amp;amp; keys[index[j]].</description></item><item><title>2.5.28</title><link>https://alg4.ikesnowy.com/2-5-28/</link><pubDate>Thu, 24 Jan 2019 18:31:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-28/</guid><description> 2.5.28 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/FileSorter.java.html
先获得目录里的所有文件名，然后排序输出即可。
代码 # var directoryName = Console.ReadLine(); if (!Directory.Exists(directoryName)) { Console.WriteLine(directoryName + &amp;#34; doesn&amp;#39;t exist or isn&amp;#39;t a directory&amp;#34;); return; } var directoryFiles = Directory.GetFiles(directoryName); Array.Sort(directoryFiles); for (var i = 0; i &amp;lt; directoryFiles.Length; i++) Console.WriteLine(directoryFiles[i]);</description></item><item><title>2.5.29</title><link>https://alg4.ikesnowy.com/2-5-29/</link><pubDate>Thu, 24 Jan 2019 19:21:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-29/</guid><description>2.5.29 # 解答 # 首先定义一系列比较器，分别根据文件大小、文件名和最后修改日期比较。
然后修改 Less 的实现，接受一个比较器数组，使用数组中的比较器依次比较，直到比较结果为两者不相同。
最后使用插入排序作为稳定排序，传入比较器数组用于 Less 函数。
代码 # var arguments = Console.ReadLine().Split(&amp;#39; &amp;#39;); var directoryPath = arguments[0]; var filenames = Directory.GetFiles(directoryPath); var fileInfos = new FileInfo[filenames.Length]; for (var i = 0; i &amp;lt; filenames.Length; i++) fileInfos[i] = new FileInfo(filenames[i]); var comparers = new List&amp;lt;Comparer&amp;lt;FileInfo&amp;gt;&amp;gt;(); for (var i = 1; i &amp;lt; arguments.Length; i++) { var command = arguments[i]; switch (command) { case &amp;#34;-t&amp;#34;: comparers.Add(new FileTimeStampComparer()); break; case &amp;#34;-s&amp;#34;: comparers.</description></item><item><title>2.5.30</title><link>https://alg4.ikesnowy.com/2-5-30/</link><pubDate>Thu, 24 Jan 2019 20:39:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-30/</guid><description>2.5.30 # 解答 # 不妨按照升序排序，$x_{ij}$ 代表第 $i$ 行第 $j$ 列的元素。
首先保证每列都是有序的。
对第一行排序，对于第一行的元素 $x_{1i}$ ，排序结果无非两种。
要么 $x_{1i}$ 不改变，要么和更小的元素进行交换。
显然，无论哪种情况，第 $i$ 列都是有序的。
因此对第一行排序之后，第一行有序，每一列都分别有序。
之后我们对第二行排序，考虑元素 $x_{11}$。
此时 $x_{11}$ 小于第一列的所有其他元素，也小于第一行的所有其他元素。
又每一列都分别有序，因此 $x_{11}$ 是整个矩阵的最小值，第二行不存在比它小的元素。
考虑使用选择排序，我们把第二行的最小值和 $x_{21}$ 交换，第一列仍然有序。
现在去掉第一列，对剩下的矩阵做一样的操作，可以将第二行依次排序。
同时保证第二行的元素都小于同列的第一行元素。
接下来的行都可以依次类推，最终将整个矩阵的所有行排序，定理得证。</description></item><item><title>2.5.31</title><link>https://alg4.ikesnowy.com/2-5-31/</link><pubDate>Fri, 25 Jan 2019 13:42:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-31/</guid><description>2.5.31 # 解答 # 编写代码进行实验即可，实验结果如下，可以发现十分接近：
代码 # var T = 10; // 重复次数 var n = 1000; // 数组初始大小 var nMultipleBy10 = 4; // 数组大小 ×10 的次数 var mMultipleBy2 = 3; // 数据范围 ×2 的次数 var random = new Random(); for (var i = 0; i &amp;lt; nMultipleBy10; i++) { Console.WriteLine(&amp;#34;n=&amp;#34; + n); Console.WriteLine(&amp;#34;\tm\temprical\ttheoretical&amp;#34;); var m = n / 2; for (var j = 0; j &amp;lt; mMultipleBy2; j++) { var distinctSum = 0; for (var k = 0; k &amp;lt; T; k++) { var data = new int[n]; for (var l = 0; l &amp;lt; n; l++) data[l] = random.</description></item><item><title>2.5.32</title><link>https://alg4.ikesnowy.com/2-5-32/</link><pubDate>Sat, 26 Jan 2019 16:04:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-32/</guid><description>2.5.32 # 解答 # （前置知识：提前了解 Dijkstra 算法能够降低理解 A* 算法的难度。）
A* 算法是 Dijkstra 算法和最佳优先算法的一种结合。
Dijkstra 算法需要遍历所有结点来找到最短路径，唯一的优化条件就是路径长度。
建立队列 queue ，把所有的结点加入 queue 中；建立数组 d，d[v] 代表起点到点 v 的距离。
开始时只有起点到起点的距离为 0，其他都为无穷大，然后重复如下步骤：
从队列中取出已知距离最短的结点 u，检查该结点的所有边。
如果通过这个点能够以更近的距离到达 v，更新起点到 v 的距离 d[v] = d[u] + distance(u, v)。
等到队列为空之后数组 d 中就存放着起点到其他所有结点的最短距离。
Dijkstra 算法会计算起点到所有点的最短路径，因此会均匀的遍历所有结点，效率较低。
很多时候，我们只需要找到起点到某一终点的最短路径即可，为此遍历整个图显然是不必要的。
通过修改算法，使得比较接近终点的结点优先得到搜索，我们就可能在遍历完全部结点之前获得结果。
在 Dijkstra 算法中，离起点最近的点会被优先搜索，记结点离起点的距离为 g[n] 。
现在引入新的条件，用于估计结点和终点的接近程度，记结点离终点的估计距离为 h[n] 。
令 f[n] = g[n] + h[n]，我们按照 f[n] 对等待搜索的结点进行排序。
同时令 h[n] 始终小于 g[n] ，保证离起点的距离 g[n] 权重大于离终点的估计距离 h[n] 。 （h[n]也被称之为容许估计）</description></item><item><title>2.5.33</title><link>https://alg4.ikesnowy.com/2-5-33/</link><pubDate>Sun, 27 Jan 2019 11:35:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/2-5-33/</guid><description>2.5.33 # 解答 # 编写代码实验即可，结果如下：
代码 # 随机交易生成器 TransactionGenerator
internal class TransactionGenerator { private static readonly Random Random = new(); /// &amp;lt;summary&amp;gt; /// 生成 n 条随机交易记录。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;交易记录的数量。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Transaction[] Generate(int n) { var trans = new Transaction[n]; for (var i = 0; i &amp;lt; n; i++) { trans[i] = new Transaction (GenerateName(), GenerateDate(), Random.NextDouble() * 1000); } return trans; } /// &amp;lt;summary&amp;gt; /// 获取随机姓名。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private static string GenerateName() { var nameLength = Random.</description></item><item><title>3.1.1</title><link>https://alg4.ikesnowy.com/3-1-1/</link><pubDate>Tue, 12 Feb 2019 13:49:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-1/</guid><description>3.1.1 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/GPA.java.html
ST.java：https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/ST.java.html
建立一个符号表，然后把键值放进去，读取计算即可。
和上一章节用过的方法类似，先定义了一个接口 IST&amp;lt;Key, Value&amp;gt; ，包含书中提到的基本 API。
然后定义类 ST ，用标准库里面的 Dictionary 实现了 IST 。
代码 # public class St&amp;lt;TKey, TValue&amp;gt; : ISt&amp;lt;TKey, TValue&amp;gt;, IEnumerable&amp;lt;TKey&amp;gt; { private readonly Dictionary&amp;lt;TKey, TValue&amp;gt; _st; /// &amp;lt;summary&amp;gt; /// 新建一个符号表。 /// &amp;lt;/summary&amp;gt; public St() =&amp;gt; _st = new Dictionary&amp;lt;TKey, TValue&amp;gt;(); /// &amp;lt;summary&amp;gt; /// 检查符号表中是否存在与键 &amp;lt;paramref name=&amp;#34;key&amp;#34;/&amp;gt; 对应的值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要检查是否存在的键。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果存在则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public virtual bool Contains(TKey key) =&amp;gt; _st.</description></item><item><title>3.1.2</title><link>https://alg4.ikesnowy.com/3-1-2/</link><pubDate>Tue, 12 Feb 2019 13:54:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-2/</guid><description>3.1.2 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/ArrayST.java.html
建立两个数组，分别存放键和值，一一对应。
添加时直接将新键值对放到数组最后即可。
删除时将待删除的键值对和位于最后的键值对交换，然后将其置空即可。
代码 # public class ArraySt&amp;lt;TKey, TValue&amp;gt; : ISt&amp;lt;TKey, TValue&amp;gt; { /// &amp;lt;summary&amp;gt; /// 键数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;键数组。&amp;lt;/value&amp;gt; private TKey[] _keys; /// &amp;lt;summary&amp;gt; /// 值数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;值数组。&amp;lt;/value&amp;gt; private TValue[] _values; /// &amp;lt;summary&amp;gt; /// 键值对数目。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;键值对数目。&amp;lt;/value&amp;gt; private int _n; /// &amp;lt;summary&amp;gt; /// 建立基于数组实现的符号表。 /// &amp;lt;/summary&amp;gt; public ArraySt() : this(8) { } /// &amp;lt;summary&amp;gt; /// 建立基于数组实现的符号表。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;initCapacity&amp;#34;&amp;gt;初始大小。&amp;lt;/param&amp;gt; public ArraySt(int initCapacity) { _keys = new TKey[initCapacity]; _values = new TValue[initCapacity]; } /// &amp;lt;summary&amp;gt; /// 检查键 &amp;lt;typeparamref name=&amp;#34;TKey&amp;#34;/&amp;gt; 是否存在。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;需要检查是否存在的键。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果存在则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public bool Contains(TKey key) =&amp;gt; Get(key).</description></item><item><title>3.1.3</title><link>https://alg4.ikesnowy.com/3-1-3/</link><pubDate>Tue, 12 Feb 2019 21:41:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-3/</guid><description>3.1.3 # 解答 # 基于无序链表的官方实现：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html
有序符号表的 API 见书中表 3.1.4（中文版 P230，英文版 P366）。
在官方实现的基础上修改 Put 方法，先找到合适位置再插入新的键值对，保证链表有序。
为方便插入操作，可以使用双向链表作为基础进行实现。
表中同时维护开头和末尾引用，加快获得最值的速度。
代码 # public class OrderedSequentialSearchSt&amp;lt;TKey, TValue&amp;gt; : ISt&amp;lt;TKey, TValue&amp;gt;, IOrderedSt&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { /// &amp;lt;summary&amp;gt; /// 符号表结点。 /// &amp;lt;/summary&amp;gt; private class Node { public TKey Key { get; set; } // 键。 public TValue Value { get; set; } // 值。 public Node Next { get; set; } // 后继。 public Node Prev { get; set; } // 前驱。 } private Node _first; // 起始结点。 private Node _tail; // 末尾结点。 private int _n; // 键值对数量。 /// &amp;lt;summary&amp;gt; /// 大于等于 key 的最小值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;大于等于 key 的最小值，不存在则返回 &amp;lt;c&amp;gt;default(Key)&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public TKey Ceiling(TKey key) { var pointer = _first; while (pointer !</description></item><item><title>3.1.4</title><link>https://alg4.ikesnowy.com/3-1-4/</link><pubDate>Wed, 13 Feb 2019 17:22:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-4/</guid><description>3.1.4 # 解答 # 利用 Time 类型记录时间，用 Event 来记录事件内容。
Time 类型包含时分秒三个 int 变量，同时实现 IComparable 接口。
Event 类型只包含事件的名称，相当于对 string 做了一个封装。
随后以 Time 为键类型，Event 为值类型，利用上一题编写的有序符号表进行操作。
代码 # Time 类
public class Time : IComparable&amp;lt;Time&amp;gt; { public int Hour { get; init; } public int Minute { get; init; } public int Second { get; init; } public Time() : this(0, 0, 0) { } public Time(int hour, int minute, int second) { Hour = hour; Minute = minute; Second = second; } public int CompareTo(Time other) { var result = Hour.</description></item><item><title>3.1.5</title><link>https://alg4.ikesnowy.com/3-1-5/</link><pubDate>Fri, 15 Feb 2019 20:32:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-5/</guid><description>3.1.5 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html
size() 方法只需要直接返回当前的 n 值即可。
delete() 方法需要遍历链表，找到对应结点并删除。
keys() 方法只需要根据当前的 n 新建一个数组，把链表中的键值存入即可。
代码 # /// &amp;lt;summary&amp;gt; /// 从表中删去键 &amp;lt;paramref name=&amp;#34;key&amp;#34;/&amp;gt; 及其对应的值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要删除的键。&amp;lt;/param&amp;gt; public void Delete(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), &amp;#34;key can&amp;#39;t be null&amp;#34;); Node before = null, target = _first; while (target != null &amp;amp;&amp;amp; !target.Key.Equals(key)) { before = target; target = target.Next; } if (target != null) Delete(before, target); } /// &amp;lt;summary&amp;gt; /// 从链表中删除指定的结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;before&amp;#34;&amp;gt;&amp;lt;paramref name=&amp;#34;target&amp;#34;/&amp;gt; 的前驱。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;target&amp;#34;&amp;gt;准备删除的结点。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentNullException&amp;#34;&amp;gt;当 &amp;lt;paramref name=&amp;#34;target&amp;#34;/&amp;gt; 为 &amp;lt;c&amp;gt;null&amp;lt;/c&amp;gt; 时抛出此异常。&amp;lt;/exception&amp;gt; private void Delete(Node before, Node target) { if (target == null) throw new ArgumentNullException(nameof(target), &amp;#34;target can&amp;#39;t be null&amp;#34;); if (before == null) _first = target.</description></item><item><title>3.1.6</title><link>https://alg4.ikesnowy.com/3-1-6/</link><pubDate>Sun, 17 Feb 2019 13:56:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-6/</guid><description>3.1.6 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html
每个单词都会被放进符号表一次，
因此 Put 的调用次数就等于单词总数 W +1（注意寻找最大值的时候有一次 Put 调用）
对于重复的单词，输入时会先调用 Get 获得当前计数之后再 Put 回去。
寻找最大值时，对于符号表中的每个键值都会调用两次 Get。
重复的单词数量 = (W - D)。
因此 Get 方法的调用次数 = (W - D) + 2D</description></item><item><title>3.1.7</title><link>https://alg4.ikesnowy.com/3-1-7/</link><pubDate>Sun, 17 Feb 2019 15:00:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-7/</guid><description>3.1.7 # 解答 # 在 FrequencyCounter 中添加一个 CountDistinct 方法，计算不重复的键数。
public static int CountDistinct&amp;lt;TKey&amp;gt;(TKey[] keys, ISt&amp;lt;TKey, int&amp;gt; st) { var distinct = 0; for (var i = 0; i &amp;lt; keys.Length; i++) { if (!st.Contains(keys[i])) st.Put(keys[i], distinct++); } return distinct; } 结果如下：
另请参阅 # SymbolTable 库</description></item><item><title>3.1.8</title><link>https://alg4.ikesnowy.com/3-1-8/</link><pubDate>Sun, 17 Feb 2019 15:20:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-8/</guid><description>3.1.8 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html
《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt
官网给出的数据末尾有完整的版权说明，因此使用频率最高的单词变成了版权方的名字 Gutenberg-tm。
去掉末尾的版权声明之后，获得的单词是：Monseigneur
另请参阅 # SymbolTable 库</description></item><item><title>3.1.9</title><link>https://alg4.ikesnowy.com/3-1-9/</link><pubDate>Tue, 19 Feb 2019 13:11:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-9/</guid><description>3.1.9 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html
《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt
对 FrequencyCounter 做修改，在调用 Put 方法之前，将单词记录在字符串变量 lastPut 中。
在读入单词结束之后输出 lastPut 和 words 变量。
将末尾的版权信息删除后，得到的结果如下：
代码 # public static string MostFrequentlyWord(string filename, int minLength, ISt&amp;lt;string, int&amp;gt; st) { var words = 0; var sr = new StreamReader(File.OpenRead(filename)); var inputs = sr .ReadToEnd() .Split(new[] { &amp;#39; &amp;#39;, &amp;#39;\r&amp;#39;, &amp;#39;\n&amp;#39; }, StringSplitOptions.RemoveEmptyEntries); var lastPut = &amp;#34;&amp;#34;; foreach (var s in inputs) { if (s.Length &amp;lt; minLength) continue; words++; if (st.</description></item><item><title>3.1.10</title><link>https://alg4.ikesnowy.com/3-1-10/</link><pubDate>Tue, 19 Feb 2019 21:05:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-10/</guid><description>3.1.10 # 解答 # 如图所示：
插入新的键值对需要遍历整个链表，比较次数等于链表在插入前的键值对数目。
修改已有的键值对则需要遍历链表直到找到该键值对，比较次数等于该键值对以及它之前所有键值对的数目。
共比较 0 + 1 + 2 + 3 + 4 + 5 + 6 + 4 + 6 + 7 + 8 + 9 = 55 次。</description></item><item><title>3.1.11</title><link>https://alg4.ikesnowy.com/3-1-11/</link><pubDate>Wed, 20 Feb 2019 20:29:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-11/</guid><description>3.1.11 # 解答 # 键的轨迹如下图所示：
键查找使用二分查找优化，插入新的键时不必与每个键都进行比较。
共进行了 0 + 1 + 2 + 2 + 2 + 3 + 3 + 3 + 3 + 3 + 3 + 4 = 29 次比较。</description></item><item><title>3.1.12</title><link>https://alg4.ikesnowy.com/3-1-12/</link><pubDate>Sat, 23 Feb 2019 18:38:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-12/</guid><description>3.1.12 # 解答 # 建立类 Item：
public class Item&amp;lt;TKey, TValue&amp;gt; : IComparable&amp;lt;Item&amp;lt;TKey, TValue&amp;gt;&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { public TKey Key { get; set; } public TValue Value { get; set; } public int CompareTo(Item&amp;lt;TKey, TValue&amp;gt; other) { return Key.CompareTo(other.Key); } } 之后修改 BinarySearchST，将其中的 TKey[] keys 和 TValue[] values 数组用 Item[] items 数组代替。
例如 keys[i] 变为 items[i].Key，values[i] 变为 items[i].Value。
添加一个构造函数，调用之前编写的归并排序实现。
/// &amp;lt;summary&amp;gt; /// 根据已有的键值对构造一个符号表。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;items&amp;#34;&amp;gt;已有的键值对。&amp;lt;/param&amp;gt; public ItemBinarySearchSt(Item&amp;lt;TKey, TValue&amp;gt;[] items) { _items = new Item&amp;lt;TKey, TValue&amp;gt;[items.</description></item><item><title>3.1.13</title><link>https://alg4.ikesnowy.com/3-1-13/</link><pubDate>Sat, 23 Feb 2019 19:55:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-13/</guid><description>3.1.13 # 解答 # Get() 调用次数比 Put() 调用次数多了三个数量级，
BinarySearchST 和 SequentialSearchST 的平均 Put() 开销是一样的，
因此选择平均 Get() 开销更小的 BinarySearchST。</description></item><item><title>3.1.14</title><link>https://alg4.ikesnowy.com/3-1-14/</link><pubDate>Sat, 23 Feb 2019 20:31:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-14/</guid><description>3.1.14 # 解答 # 根据上题给出的结论，选择 BinarySearchST。
由于 BinarySearchST 和 SequentialSearchST 执行 Put() 的开销相同
因此选择 Get() 开销更低的 BinarySearchST。</description></item><item><title>3.1.15</title><link>https://alg4.ikesnowy.com/3-1-15/</link><pubDate>Sat, 23 Feb 2019 21:00:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-15/</guid><description>3.1.15 # 解答 # 假设先全部 Put()，再进行查找操作。
即分别进行 $1$, $10 ^ 3$, $10 ^ 6$ 次插入
$N = 1$ 时，可以直接得出比例 $0.1 %$。
$N = 10 ^ 3$ 时，
插入耗时 $= 1 + 2 + &amp;hellip; + 10 ^ 3 = 500500$，
查询耗时 $= 10 ^ 6 * \lg(10 ^ 3) = 9965784$，
比例为 $4.782 %$。
$N = 10 ^ 6$ 时
插入耗时 $= 1 + 2 + &amp;hellip; + 10 ^ 6 = 500000500000$，</description></item><item><title>3.1.16</title><link>https://alg4.ikesnowy.com/3-1-16/</link><pubDate>Sun, 24 Feb 2019 18:48:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-16/</guid><description>3.1.16 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html
先通过二分查找获得下标，然后后面的元素依次向前移动一位。
public void Delete(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), &amp;#34;argument to Delete() is null&amp;#34;); if (IsEmpty()) return; var i = Rank(key); if (i == _n &amp;amp;&amp;amp; _keys[i].CompareTo(key) != 0) return; for (var j = i; j &amp;lt; _n - 1; j++) { _keys[j] = _keys[j + 1]; _values[j] = _values[j + 1]; } _n--; _keys[_n] = default; _values[_n] = default; if (_n &amp;gt; 0 &amp;amp;&amp;amp; _n == _keys.</description></item><item><title>3.1.17</title><link>https://alg4.ikesnowy.com/3-1-17/</link><pubDate>Sun, 24 Feb 2019 18:48:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-17/</guid><description>3.1.17 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html
先通过二分查找大于等于 key 的键下标 i，
如果 keys[i] 和 key 相等则直接返回 keys[i]， 否则返回 keys[i-1]。
public TKey Floor(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), &amp;#34;argument to Floor() is null&amp;#34;); var i = Rank(key); if (i &amp;lt; _n &amp;amp;&amp;amp; _keys[i].CompareTo(key) == 0) return _keys[i]; if (i == 0) return default; return _keys[i - 1]; } 另请参阅 # SymbolTable 库</description></item><item><title>3.1.18</title><link>https://alg4.ikesnowy.com/3-1-18/</link><pubDate>Sun, 24 Feb 2019 20:36:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-18/</guid><description>3.1.18 # 解答 # 设 key 为目标键。
算法初始时 lo = 0, hi = n - 1，数组已排序。
当找到目标键时，返回的下标 mid 显然是正确的。 （0&amp;hellip;a[mid - 1] 都小于 a[mid]，同时 a[mid] = key）
接下来证明：当目标键不存在时，lo 可以代表小于 key 的键的个数。
由算法内容，当循环退出时，一定有 lo 和 hi 交叉，即 lo &amp;gt; hi。
考虑最后一次循环，必然执行了 lo = mid + 1 或者 hi = mid - 1。
即最后一次循环之后 lo = mid + 1 &amp;gt; hi 或 hi = mid - 1 &amp;lt; lo。
又由于 mid = (lo + hi) / 2，代入有：</description></item><item><title>3.1.19</title><link>https://alg4.ikesnowy.com/3-1-19/</link><pubDate>Mon, 25 Feb 2019 16:30:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-19/</guid><description>3.1.19 # 解答 # 将频率和当前最大频率相同的单词都放到一个队列里即可。
var max = &amp;#34;&amp;#34;; var queue = new Queue&amp;lt;string&amp;gt;(); st.Put(max, 0); foreach (var s in st.Keys()) { if (st.Get(s) &amp;gt; st.Get(max)) { max = s; queue.Clear(); queue.Enqueue(s); } else if (st.Get(s) == st.Get(max)) { queue.Enqueue(s); } } 另请参阅 # SymbolTable 库</description></item><item><title>3.1.20</title><link>https://alg4.ikesnowy.com/3-1-20/</link><pubDate>Tue, 26 Feb 2019 20:52:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-20/</guid><description>3.1.20 # 解答 # 国内的书中关于命题 B 的证明有错误，新版的证明结论已经改为：
$$ C(n)=C(2^k-1) \le k = \lg (n+1) \le \lg n +1 $$
其中 $n=2^k - 1 $ 。 先证单调性，利用数学归纳法： 已知对于 $N=0$，满足 $C(0) \le C(1)$。 假设对于 $N=n$，满足 $C(n) \le C(n+1)$。 根据递归式，有：
$$ \begin{eqnarray*} &amp;amp; C(n) &amp;amp; \le C(\lfloor n/2 \rfloor) + 1 \newline \newline &amp;amp; C(n+1) &amp;amp; \le \begin{cases} C(\lfloor n/2 \rfloor) +1 &amp;amp; \text{$n$ 是偶数} \newline C(\lfloor n/2 \rfloor + 1) + 1 &amp;amp; \text{$n$ 是奇数} \end{cases}\newline \newline &amp;amp; C(n+2) &amp;amp; \le C(\lfloor n/2 \rfloor + 1) + 1 \end{eqnarray*} $$</description></item><item><title>3.1.21</title><link>https://alg4.ikesnowy.com/3-1-21/</link><pubDate>Thu, 28 Feb 2019 19:39:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-21/</guid><description>3.1.21 # 解答 # BinarySearchST
包含一个键数组和一个值数组，以及一个 int 变量。
数组长度变化范围为 N~4N ，故总大小：
从 2 × (24 + 8N) +4 = 52 + 16N 字节 （100 %），
到 2 × (24 + 32N) +4 = 52 + 64N 字节（25 %）之间变动。
SequentialSearchST
包含 N 个结点以及一个 int 变量 (16 + 8 + 8 + 8)N + 4 = 4 + 40N 字节</description></item><item><title>3.1.22</title><link>https://alg4.ikesnowy.com/3-1-22/</link><pubDate>Thu, 28 Feb 2019 20:03:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-22/</guid><description>3.1.22 # 解答 # 对 Get() 做修改，得到 MoveToFrontArrayST。
public TValue Get(TKey key) { int i; for (i = 0; i &amp;lt; _n; i++) if (_keys[i].Equals(key)) break; if (i == _n) return default; var toFrontKey = _keys[i]; var toFrontValue = _values[i]; for (var j = i; j &amp;gt; 0; j--) _keys[j] = _keys[j - 1]; for (var j = i; j &amp;gt; 0; j--) _values[j] = _values[j - 1]; _keys[0] = toFrontKey; _values[0] = toFrontValue; return _values[0]; } 另请参阅 # SymbolTable 库</description></item><item><title>3.1.23</title><link>https://alg4.ikesnowy.com/3-1-23/</link><pubDate>Thu, 28 Feb 2019 20:42:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-23/</guid><description>3.1.23 # 解答 # 这里的右移操作可以理解为 「小数点前移一位」
即数字依次向右退一位，个位上的数字被舍弃。
对于十进制，小数点前移一位会使 $n$ 变为 $\lfloor n / 10 \rfloor$。
同样对于二进制就会使 $n$ 变为 $\lfloor n / 2 \rfloor$。
当需要除以 $2$ 的 $k$ 次幂的时候，可以用右移 $k$ 位代替并减少时间开销。
同理可以用左移 $k$ 位来代替乘以 $2$ 的 $k$ 次幂。
注： 这样会降低程序可读性，
并且某些语言（C / C++）的编译器已经可以自动执行这项优化了。
请充分考虑你的代码受众之后再决定是否采用这种写法。
二分查找的最大查找次数 = $ \lg N + 1$ （见 3.1.20 的证明 {% post_link 3-1-20 %}）
一个数最多被左移的次数也正好等于 $\lfloor \lg N \rfloor + 1$ （任意正整数都能被表示为 $2 ^ k + m$ 的形式，即 $k +1$ 位二进制数）</description></item><item><title>3.1.24</title><link>https://alg4.ikesnowy.com/3-1-24/</link><pubDate>Sat, 02 Mar 2019 14:57:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-24/</guid><description>3.1.24 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html
二分查找总是与中间值进行比较，现在改为与数组中第 x% 位置上的元素比较。
具体而言，$\frac{k_x-k_{lo}}{k_{hi}-k_{lo}}$ 代表数组在均匀情况下目标值 $k_x$ 的相对位置（一个比率，在数组第 x% 的位置上）。
那么相对应的下标就等于 $lo+\frac{k_x-k_{lo}}{k_{hi}-k_{lo}} \times (hi - lo)$。
用这个式子代替原来的 $mid=lo + (hi-lo)/2$ 即可。
不难看出这种方法对于分布相对均匀的数组比较有利，相对于二分查找而言迭代次数会少很多。
但如果数组分布不够均匀，也可能表现出不如二分查找的性能。
实验结果也证实了这一判断，就随机数组而言，插值查找相对于二分查找只有 1% 左右的性能提升。 代码 # SearchCompare 在书中没有出现，但可以简单的实现为调用 FrequencyCounter 并计时的方法：
public static long Time&amp;lt;TKey&amp;gt;(IST&amp;lt;TKey, int&amp;gt; st, TKey[] keys) { Stopwatch sw = new Stopwatch(); sw.Start(); FrequencyCounter.MostFrequentlyKey(st, keys); sw.Stop(); return sw.ElapsedMilliseconds; } 由于这里需要使用数字而非字符串作为键值，需要对官方给出的 FrequencyCounter 做一些修改：
public static TKey MostFrequentlyKey&amp;lt;TKey&amp;gt; (IST&amp;lt;TKey, int&amp;gt; st, TKey[] keys) { foreach (TKey s in keys) { if (st.</description></item><item><title>3.1.25</title><link>https://alg4.ikesnowy.com/3-1-25/</link><pubDate>Sat, 02 Mar 2019 16:10:23 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-25/</guid><description>3.1.25 # 解答 # 英文原文指的是 most recently accessed key，因此指的是最近访问的键。
实现比较简单，先在类中定义一个新的成员 cache 作为缓存，
然后修改 Get 方法，在实际查找之前先检查缓存，如果缓存未命中则在查找之后更新它。
要注意的是缓存指向内容的有效性，在数组中指的是下标是否有效，在链表中指的是结点是否为空。
利用《双城记》测试的结果：
代码 # BinarySearchST # cache 是一个 int 类型的变量，代表下标。 在二分查找前先检查缓存，要注意cache超出数组大小的情况。 如果缓存未命中，则进行二分查找，并在返回结果前更新缓存。
public TValue Get(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), &amp;#34;argument to Get() is null&amp;#34;); if (IsEmpty()) return default; if (_cache &amp;lt; _n &amp;amp;&amp;amp; _keys[_cache].Equals(key)) // 缓存检查 return _values[_cache]; var rank = Rank(key); if (rank &amp;lt; _n &amp;amp;&amp;amp; _keys[rank].Equals(key)) { _cache = rank; // 更新缓存 return _values[rank]; } return default; } SequentialSearchST # cache 是一个结点类型的变量，代表一个键值对。 类似的，在顺序查找前先检查缓存，如果缓存未命中则更新缓存。 要注意的是如果缓存的结点被删除，需要将缓存置为 null。</description></item><item><title>3.1.26</title><link>https://alg4.ikesnowy.com/3-1-26/</link><pubDate>Sun, 03 Mar 2019 10:29:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-26/</guid><description>3.1.26 # 解答 # 字典文件：https://introcs.cs.princeton.edu/java/data/web2.txt
《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt
浏览器可能会直接打开 txt，此时右键链接-目标另存为即可下载。
FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html
我们利用 BinarySearchST 会自动对键排序的性质来实现字典序排序。
首先将字典存到一个符号表中，按照 “单词-序号” 的形式保存。
然后读入文件，如果读入的单词存在于字典中，
则将其以 “序号-单词” 的形式存到 BinarySearchST 中去。
读入完毕后，遍历 BinarySearchST 即可获得字典序的单词列表。
对于按频率排序，我们基于已有的实现修改。
在每次取得最大值之后，输出并删除最大值，如此循环即可获得频率排序的单词序列。
也可以将单词-频率序列全部读出来存放到数组之中，然后用第二章的排序算法排序。
测试结果，取 minLength = 13，只截取了部分。
代码 # public static void LookUpDictionary(string filename, string dictionaryFile, int minLength) { // 初始化字典 var sr = new StreamReader(File.OpenRead(dictionaryFile)); var words = sr.ReadToEnd().Split(new[] { &amp;#39; &amp;#39;, &amp;#39;\r&amp;#39;, &amp;#39;\n&amp;#39; }, StringSplitOptions.RemoveEmptyEntries); var dictionary = new BinarySearchSt&amp;lt;string, int&amp;gt;(); for (var i = 0; i &amp;lt; words.</description></item><item><title>3.1.27</title><link>https://alg4.ikesnowy.com/3-1-27/</link><pubDate>Sun, 03 Mar 2019 19:20:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-27/</guid><description>3.1.27 # 解答 # 事实上就是说，先构造一个包含 N 个不重复键的符号表，然后进行 S 次查找。
给出 S 的增长数量级，使得构造符号表的成本和查找的成本相同。
这里假设一次数组交换和一次比较的成本是相同的。
先考虑构造符号表的成本，一次 Put() 需要调用一次 Rank() 和一次插入操作。
2.1 节插入排序的命题 B 给出了每次插入平均需要移动一半的数组元素的结论。
于是构造符号表所需的成本约为：$n\lg n + \frac{1}{2}\sum_{k=1}^{n} k=n\lg n + \frac{n(n-1)}{4} $ 。
这里查找的成本是这么计算的：$\lg0+\lg1+\cdots+\lg n &amp;lt; n\lg n$
查找所需的成本比较简单，一次二分查找的比较次数约为 $\lg n$，总成本就是 $S\lg n$ 。
令两边相等，解方程即可得到 $S=n+\frac{n(n-1)}{4\lg n}$ 。
如果用大 O 记法，也可以记为 $O(n^2 / \lg n)$，如果要选择一个比较常用的上界则可以选择 $O(n^2)$。
实验结果，两边的成本是很接近的：
另请参阅 # SymbolTable 库</description></item><item><title>3.1.28</title><link>https://alg4.ikesnowy.com/3-1-28/</link><pubDate>Mon, 04 Mar 2019 20:20:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-28/</guid><description>3.1.28 # 解答 # 将重新分配数组空间的代码提前，然后添加判断语句即可。 BinarySearchSTOrderedInsertion：
/* 省略 */ if (_n == _keys.Length) Resize(_n * 2); // 如果插入的键比所有键都大则直接插入末尾。 if (_n == 0 || _keys[_n - 1].CompareTo(key) &amp;lt; 0) { _keys[_n] = key; _values[_n] = value; _n++; return; } var i = Rank(key); /* 省略 */ 另请参阅 # SymbolTable 库</description></item><item><title>3.1.29</title><link>https://alg4.ikesnowy.com/3-1-29/</link><pubDate>Mon, 04 Mar 2019 21:14:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-29/</guid><description>3.1.29 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/TestBinarySearchST.java.html
官方实现中有几处错误，需要做一些修改。
/* 省略 */ Console.WriteLine(&amp;#34;Testing Select()&amp;#34;); Console.WriteLine(&amp;#34;-----------------------------------&amp;#34;); for (var i = 0; i &amp;lt; st.Size(); i++) // 循环条件不能有 &amp;#39;=&amp;#39; Console.WriteLine(i + &amp;#34; &amp;#34; + st.Select(i)); Console.WriteLine(); /* 省略 */ while (!st.IsEmpty()) st.Delete(st.Select(st.Size() / 2)); Console.WriteLine(&amp;#34;After deleting the remaining keys&amp;#34;); Console.WriteLine(&amp;#34;-----------------------------------&amp;#34;); // 异常处理 try { foreach (var s in st.Keys()) Console.WriteLine(s + &amp;#34; &amp;#34; + st.Get(s)); } catch (Exception ex) { Console.WriteLine(&amp;#34;Exception: &amp;#34; + ex.Message); } Console.</description></item><item><title>3.1.30</title><link>https://alg4.ikesnowy.com/3-1-30/</link><pubDate>Tue, 05 Mar 2019 12:57:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-30/</guid><description>3.1.30 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html。
首先在 BinarySearchST 中添加如下方法。
/// &amp;lt;summary&amp;gt; /// 检查符号表结构是否有效。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;检查通过则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; private bool Check() =&amp;gt; IsSorted() &amp;amp;&amp;amp; RankCheck(); /// &amp;lt;summary&amp;gt; /// 检查 &amp;lt;see cref=&amp;#34;_keys&amp;#34;/&amp;gt; 数组是否有序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;如果 &amp;lt;see cref=&amp;#34;_keys&amp;#34;/&amp;gt; 有序则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; private bool IsSorted() { for (var i = 1; i &amp;lt; Size(); i++) if (_keys[i].CompareTo(_keys[i - 1]) &amp;lt; 0) return false; return true; } /// &amp;lt;summary&amp;gt; /// 检查 Rank(Select(i)) = i 是否成立。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;成立则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; private bool RankCheck() { for (var i = 0; i &amp;lt; Size(); i++) if (i !</description></item><item><title>3.1.31</title><link>https://alg4.ikesnowy.com/3-1-31/</link><pubDate>Thu, 07 Mar 2019 13:03:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-31/</guid><description>3.1.31 # 解答 # 性能测试方法构造如下：
先编写一个随机字符串方法，生成一个长度大于 50 的字符串（作为未命中访问）。
然后随机生成符合要求的字符串数组，将它们全部放入符号表中。
然后遍历 10 次生成的字符串数组，对于数组中的每个元素都进行一次命中查询。
同时在每次命中查询的同时都进行一次未命中查询即可。
测试结果：
代码 # 按照要求编写代码，在 SearchCompare 类里添加一个 Random random 成员，并添加如下方法： 随机字符串发生器：
public static string GetRandomString(int minLength, int maxLength) { var length = Random.Next(minLength, maxLength); var sb = new StringBuilder(); for (var i = 0; i &amp;lt; length; i++) { var choice = Random.NextDouble(); if (choice &amp;lt; 0.333) sb.Append((char)Random.Next(&amp;#39;A&amp;#39;, &amp;#39;Z&amp;#39;)); else if (choice &amp;lt; 0.666) sb.Append((char)Random.Next(&amp;#39;a&amp;#39;, &amp;#39;z&amp;#39;)); else sb.</description></item><item><title>3.1.32</title><link>https://alg4.ikesnowy.com/3-1-32/</link><pubDate>Fri, 08 Mar 2019 10:13:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-32/</guid><description>3.1.32 # 解答 # 编码实现即可，实验结果如下：
对于保持键有序的 BinarySearchST 来说，逆序输入是最坏情况，顺序输入则是最好情况。
而对于键无序的 SequentialSearchST 来说，输入顺序对于性能的影响不大。
只有一种键的时候，每次 Put 都只需要比较一次，值一直在被替换。
只有两种值对性能的影响不大，性能主要由输入的键决定。
代码 # 测试方法，IST 代表一个符号表。
static void Test(ISt&amp;lt;string, int&amp;gt;[] sts, int n) { var sw = new Stopwatch(); var data = SearchCompare.GetRandomArrayString(n, 3, 10); var item1 = &amp;#34;item1&amp;#34;; Array.Sort(data); // 有序的数组 Console.Write(&amp;#34;Sorted Array: &amp;#34;); sw.Start(); for (var i = 0; i &amp;lt; n; i++) { sts[0].Put(data[i], i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 逆序的数组 Console.Write(&amp;#34;Sorted Array Reversed: &amp;#34;); sw.</description></item><item><title>3.1.33</title><link>https://alg4.ikesnowy.com/3-1-33/</link><pubDate>Sat, 09 Mar 2019 19:27:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-33/</guid><description>3.1.33 # 解答 # 概率分布的实现方式：
假设存有键的数组为 keys，对 keys 排序。
然后再建立一个长度为 10N 的数组 querys，
前 1/2 置为 keys[0]，1/2 到 3/4 置为 keys[1]，以此类推，直到数组填满。
然后遍历 query 数组，对符号表进行 Get() 操作。
实验结果如下：
代码 # var n = 1000; var multiplyBy10 = 4; for (var i = 0; i &amp;lt; multiplyBy10; i++) { Console.WriteLine(&amp;#34;n=&amp;#34; + n); // 构造表 var bst = new BinarySearchSt&amp;lt;string, int&amp;gt;(n); var mst = new MoveToFrontArraySt&amp;lt;string, int&amp;gt;(n); var keys = SearchCompare.GetRandomArrayString(n, 3, 20); for (var j = 0; j &amp;lt; n; j++) { bst.</description></item><item><title>3.1.34</title><link>https://alg4.ikesnowy.com/3-1-34/</link><pubDate>Sun, 10 Mar 2019 12:55:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-34/</guid><description>3.1.34 # 解答 # 在上一题的基础上进行修改即可。
调和级数 $H_n = 1+\frac{1}{2}+\frac{1}{3} + \cdots+\frac{1}{n}$ 。
查询数组变为前 1/2 为 key[0]，随后的 1/3 为 key[1]，以此类推。
和上一题中的序列进行比较即可，注意删除最后的打乱步骤。
实验结果如下：
代码 # 首先建立一个数组计算调和级数，就像这样：
// 调和级数 var harmonicNumber = new double[n * (int)Math.Pow(10, multiplyBy10)]; harmonicNumber[0] = 1; for (var i = 1; i &amp;lt; harmonicNumber.Length; i++) { harmonicNumber[i] = harmonicNumber[i - 1] + 1 / (i + 1); } 然后修改构造查询的代码：
// 构造查询 Array.Sort(keys); var queryZipf = new string[10 * n]; int queryIndex = 0, keyIndex = 0; while (queryIndex &amp;lt; queryZipf.</description></item><item><title>3.1.35</title><link>https://alg4.ikesnowy.com/3-1-35/</link><pubDate>Sun, 10 Mar 2019 19:02:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-35/</guid><description>3.1.35 # 解答 # 实验结果：
由于包含重复单词，因此结果会比 4 略低一些。
需要对 FrequencyCounter 做一些修改，令其只取前 n 个单词。
代码 # var n = 8000; var multiplyBy2 = 5; var repeatTimes = 5; double lastTime = -1; Console.WriteLine(&amp;#34;n\ttime\tratio&amp;#34;); for (var i = 0; i &amp;lt; multiplyBy2; i++) { Console.Write(n + &amp;#34;\t&amp;#34;); long timeSum = 0; for (var j = 0; j &amp;lt; repeatTimes; j++) { var st = new SequentialSearchSt&amp;lt;string, int&amp;gt;(); var sw = Stopwatch.StartNew(); FrequencyCounter.</description></item><item><title>3.1.36</title><link>https://alg4.ikesnowy.com/3-1-36/</link><pubDate>Sun, 10 Mar 2019 19:05:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-36/</guid><description>3.1.36 # 解答 # 实验结果如下，增长级为 O(N) ，但速度很快。 其实只要列出《双城记》不同长度的单词数目，原因就一目了然了。 大部分单词都集中在中间长度，因此大部分访问也集中在数组中部。
二分查找在访问数组中部的元素时速度很快，因此结果好于预期。
代码 # var n = 8000; var multiplyBy2 = 5; var repeatTimes = 5; double lastTime = -1; Console.WriteLine(&amp;#34;n\ttime\tratio&amp;#34;); for (var i = 0; i &amp;lt; multiplyBy2; i++) { Console.Write(n + &amp;#34;\t&amp;#34;); long timeSum = 0; for (var j = 0; j &amp;lt; repeatTimes; j++) { var st = new BinarySearchSt&amp;lt;string, int&amp;gt;(); var sw = Stopwatch.StartNew(); FrequencyCounter.MostFrequentlyWord(&amp;#34;tale.txt&amp;#34;, n, 0, st); sw.</description></item><item><title>3.1.37</title><link>https://alg4.ikesnowy.com/3-1-37/</link><pubDate>Sun, 10 Mar 2019 19:28:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-37/</guid><description>3.1.37 # 解答 # 实验结果如下：
M=10 的时候随机的数字集中在 1024 到 2048 之间，重复值较多，因此 Put 耗时较少。
随着重复值的减少 Put 的耗时会大幅度提高，和实验结果显示的一样。
M=20 的时候数字在 1048576~2097152 之间随机，基本上没有重复值了。
M=30 的时候和 M=20 的情况类似，都是重复值几乎没有的情况。
随机数可以通过如下的方式产生：
result[i] = min + (long)(random.NextDouble() * (max - min)); 代码 # 这里构造了 BinarySearchSTAnalysis 类，在类中声明了两个 Stopwatch 对象，
一个在 Put 方法的开始和结束部分进行计时，
另一个在 Get 方法的开始和结束部分进行计时。
var n = 1000000; var m = 10; var addBy10 = 3; for (var i = 0; i &amp;lt; addBy10; i++) { var bst = new BinarySearchStAnalysis&amp;lt;long, int&amp;gt;(n); var data = SearchCompare.</description></item><item><title>3.1.38</title><link>https://alg4.ikesnowy.com/3-1-38/</link><pubDate>Mon, 18 Mar 2019 17:57:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-38/</guid><description>3.1.38 # 解答 # 实验结果如下：
BinarySearchST SequentialSearchST 对于 BinarySearchST ，每次比较之后以及移动元素时令 Cost 增加。
对于 SequentialSearchST，统计每次的查找次数即可。 然后绘制成散点图即可。
代码 # 有关绘图的函数，传入的参数为第 i 次 Put() 的开销。
public void Draw(int[] data) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / data.Length; float unitY = (float)this.ClientRectangle.Height / data.Max(); int accumulation = 0; for (int i = 0; i &amp;lt; data.Length; i++) { // Gray panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, this.ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red panel.</description></item><item><title>3.1.39</title><link>https://alg4.ikesnowy.com/3-1-39/</link><pubDate>Tue, 19 Mar 2019 16:53:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-39/</guid><description>3.1.39 # 解答 # 实验结果如下：
BinarySearchST SequentialSearchST 图像分为两段，分别代表不断向符号表中加入单词和寻找频率最大的单词两个部分。
第一段两个图像的形状类似（注意它们的 y 轴比例不同）。
第二段中 BinarySearchST 的表现要比 SequentialSearchST 稳定的多。
代码 # 绘图部分代码：
public void Draw(int[] x, long[] y) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / x.Max(); float unitY = (float)this.ClientRectangle.Height / y.Max(); for (int i = 0; i &amp;lt; x.Length; i++) { panel.FillEllipse( Brushes.Black, x[i] * unitX, this.ClientRectangle.Height - y[i] * unitY, 2, 2); } } 另请参阅 # SymbolTable 库</description></item><item><title>3.1.40</title><link>https://alg4.ikesnowy.com/3-1-40/</link><pubDate>Sun, 24 Mar 2019 19:39:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-40/</guid><description>3.1.40 # 解答 # 顺序查找平均需要进行 $N/2$ 次比较，二分查找则是 $\lg N$ 次。
列出方程可以解出 N 的大小
$$ \begin {eqnarray*} 1000 \log_2 N &amp;amp;=&amp;amp; N / 2 \newline \log_2 N &amp;amp;=&amp;amp; N / 2000\newline \frac{\ln N}{\ln 2} &amp;amp;=&amp;amp; N/2000 \newline N &amp;amp;=&amp;amp; e^{\frac{\ln 2}{2000}N}\newline 1 &amp;amp;=&amp;amp; Ne^{-\frac{\ln 2}{2000}N}\newline N_1 = e^{-W(-\frac{\ln 2}{2000})}=1 &amp;amp;\ &amp;amp; N_2= e^{-W_{-1}(-\frac{\ln 2}{2000})}=29718\newline \newline \end {eqnarray*} $$
这个方程是一个超越方程，最后的结果中出现了朗伯 W 函数。
同理可以求得 10000 倍的 N=369939。
实验结果如下：
由于存在缓存优化，每次比较的耗时并不相同。
因此实际耗时并未达到预期，但比较次数是符合预期的。
另请参阅 # 朗伯 W 函数-维基百科</description></item><item><title>3.1.41</title><link>https://alg4.ikesnowy.com/3-1-41/</link><pubDate>Sun, 24 Mar 2019 21:11:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-1-41/</guid><description>3.1.41 # 解答 # 英文版描述为 1, 2, and 10 times faster。
即一样快，快一倍和快十倍（一个例子）。
和上题类似，也是解超越方程。
插值查找的平均查找次数为 $\lg(\lg(N))$。
可以解得 N = 1, 4, 58。
实验结果如下：
由于 N 太小，可以看到插值查找的运行时间几乎没有变化。</description></item><item><title>3.2.1</title><link>https://alg4.ikesnowy.com/3-2-1/</link><pubDate>Sun, 14 Apr 2019 20:04:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-1/</guid><description>3.2.1 # 解答 # 构造出的树如下图所示：
总比较次数：0 + 1 + 1 + 2 + 2 + 3 + 1 + 2 + 4 + 3 + 4 + 5 = 28 次
另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.2</title><link>https://alg4.ikesnowy.com/3-2-2/</link><pubDate>Fri, 19 Apr 2019 21:07:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-2/</guid><description>3.2.2 # 解答 # 用这样的序列就可以构造出最坏情况：
&amp;#34;A X C S E R H&amp;#34;, &amp;#34;X A S C R E H&amp;#34;, &amp;#34;A C E H R S X&amp;#34;, &amp;#34;X S R H E C A&amp;#34;, &amp;#34;X A S R H E C&amp;#34;, &amp;#34;A X S R H E C&amp;#34; 构造出来的树看起来像这样：</description></item><item><title>3.2.3</title><link>https://alg4.ikesnowy.com/3-2-3/</link><pubDate>Wed, 01 May 2019 20:49:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-3/</guid><description>3.2.3 # 解答 # 官方答案：第一个插入的是 H，且 C 在 A 和 E 之前插入，S 在 R 和 X 之前插入的树。
对序列排序，得到 A C E H R S X 。
最优情况需要树两侧平衡，因此 H 为根结点，C 和 S 分别为 H 的子结点。
同理，A 和 E 为 C 的子结点，R 和 X 为 S 的子结点。</description></item><item><title>3.2.4</title><link>https://alg4.ikesnowy.com/3-2-4/</link><pubDate>Thu, 02 May 2019 18:49:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-4/</guid><description>3.2.4 # 解答 # d 是错误的。
要点是追踪序列中的左右顺序，
如果向右查找，那么后面的树一定都比它大，反之都比它小。
例如 d 选项，2-&amp;gt;7 向右查找，但后面的 8 比 7 大，应该挂在 7 的右子树上，不可能在 7 的左子树里。</description></item><item><title>3.2.5</title><link>https://alg4.ikesnowy.com/3-2-5/</link><pubDate>Sat, 25 May 2019 18:27:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-5/</guid><description>3.2.5 # 解答 # 事实上，这个问题可以归结为，如何根据频率来构造一棵最优的 BST？
如果知道树的形状，逆推插入顺序也就不难了（先序遍历）。
首先我们定义某个结点的查找开销为该结点的深度加一乘以频率， （注意根结点的深度为 0，树的高度等于整棵树中最大的深度值）
所有结点的查找开销加起来就是一整棵树的查找开销了。
$$ cost(n)=\sum_{i=0}^{n} (depth(i)+1) \times frequency(i) $$
对于固定的一组键值和频率，$cost$ 最小的树即为我们要找的树。
这样的树被称为最优化二叉树，或者 Optimal BST。
根据二叉树的性质，我们可以将 $cost$ 的表达式变为：
$$ cost(n)=cost(left)+cost(right)+\sum_{i=1}^{n} frequency(i) $$
即左子树的开销和右子树的开销相加，再加上所有结点的频率之和。 （左子树和右子树开销计算时每个结点的深度都少了 1，因此要加上频率和）
不难得到结论，Optimal BST 的所有子树也都是 Optimal BST。
我们可以利用一种类似于构造哈夫曼树的方法构造 Optimal BST，
哈夫曼树中比较的是频率，而构造 Optimal BST 时比较的则是开销。
由于二叉查找树是有序的，因此我们先对序列排序。
然后计算所有大小为 1 的子树开销，显然就等于各个节点的频率。
再计算大小为 2 的子树，注意这里只能按顺序取结点，不能跳着取（例如取第一个和第三个结点），
每种结点取法都对应有两种根结点选择，计算出最小的开销并记录。
以此类推，直到计算到大小为 n 的树，此时整棵 BST 就被构造出来了。
举个例子，例如给出键值和频率如下表所示：
$$ \begin{array}{l|lllll} key &amp;amp; 1 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 &amp;amp; 5 \\ \hline p &amp;amp; 0.</description></item><item><title>3.2.6</title><link>https://alg4.ikesnowy.com/3-2-6/</link><pubDate>Sun, 26 May 2019 09:45:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-6/</guid><description>3.2.6 # 解答 # 官方 BST 实现见：https://algs4.cs.princeton.edu/32bst/BST.java.html
二叉树的高度=左右子树最大高度+1，叶结点的高度为 0。 于是我们可以构造如下递归方法：
protected virtual int Height(Node x) { return x == null ? -1 : 1 + Math.Max(Height(x.Left), Height(x.Right)); } 当 x 等于 null 时，说明它是叶子结点的左/右子树，应该返回 0-1=-1。
也可以在结点中添加一个 Height 属性，记录当前结点的高度，当插入新结点时重新计算高度。
在 Put 方法中添加计算高度的代码：
protected virtual Node Put(Node x, TKey key, TValue value) { if (x == null) return new Node(key, value, 1); var cmp = key.CompareTo(x.Key); if (cmp &amp;lt; 0) x.Left = Put(x.</description></item><item><title>3.2.7</title><link>https://alg4.ikesnowy.com/3-2-7/</link><pubDate>Thu, 13 Jun 2019 21:45:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-7/</guid><description>3.2.7 # 解答 # 平均查找次数 = 树所有结点的深度之和 / 结点个数 + 1。
只要能够获得深度和，就能构造出如下用于计算平均查找次数的方法：
public int AverageCompares() { return DepthSum(_root) / Size() + 1; } 二叉树的深度之和 = 左子树的深度和 + 右子树的深度和 + 左子树的结点个数 + 右子树的结点个数 （加上根结点会使左右子树所有结点的深度+1）
于是我们可以获得如下递归方法，用于计算一棵树的深度和：
private int DepthSum(Node x) { if (x == null) return 0; return DepthSum(x.Left) + DepthSum(x.Right) + x.Size - 1; } 也可以在结点中直接添加一个 DepthSum 属性，用于记录当前结点的深度和。
需要在每次插入新结点时重新计算查找路径上所有结点的 DepthSum。
private Node Put(Node x, TKey key, TValue value, int depth) { if (x == null) return new Node(key, value, 1, depth); var cmp = key.</description></item><item><title>3.2.8</title><link>https://alg4.ikesnowy.com/3-2-8/</link><pubDate>Fri, 14 Jun 2019 23:03:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-8/</guid><description>3.2.8 # 解答 # 假设输入的完全二叉树结点数目为 $n$。
完全二叉树总是可以分成两部分，一个满二叉树，以及多余的结点。
于是完全二叉树中满二叉树的部分层数为 $l = \lfloor \log_2 (n+1) \rfloor$。（根结点位于第一层）
满二叉树占的结点数量为 $n_1 = 2^l -1$，多余结点数量为 $n_2=n-n_1$。
又因为深度等于层数 - 1，多余结点正好在满二叉树的下一层，因此多余结点的深度即为 $l$。
于是多余结点的深度和 $d_2 = l \times n_2$。
接下来计算满二叉树的深度和。
一个层数为 $l$ 的满二叉树，最后一层正好有 $2^{l-1}$ 个结点。
于是深度和为 $d_1 = 0 \times 1 + 1 \times 2+2 \times 4+\cdots+(l-1)2^{l-1} =\sum_{i=1}^{l-1} i2^i$。
用错位相减法，有：
$$ \begin{eqnarray*} d_1&amp;amp;=&amp;amp;1\times 2^1 + &amp;amp;2 \times 2^2 + \cdots + (l-1)2^{l-1} \newline 2d_1&amp;amp;=&amp;amp; &amp;amp;1\times 2^2 + \cdots+(l-2)2^{l-1} +(l-1)2^{l} \newline d_1-2d_1&amp;amp;=&amp;amp; 1 \times2^1+ &amp;amp;1 \times2^2+\cdots+1\times2^{l-1}-(l-1)2^l \newline d_1 &amp;amp;=&amp;amp;(l-1)2^l &amp;amp;-2^l+2 \newline &amp;amp;=&amp;amp;(l-2)2^l &amp;amp;+2 \end{eqnarray*} $$</description></item><item><title>3.2.9</title><link>https://alg4.ikesnowy.com/3-2-9/</link><pubDate>Thu, 20 Jun 2019 14:06:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-9/</guid><description>3.2.9 # 解答 # 比较简单，可以按照如下步骤解决：
生成 n 个数。 生成这 n 个数的全排列。 生成 n! 棵二叉搜索树，取其中结构不同的部分。 全排列可以通过递归方式生成，方法类似于 DFS。
开始 pool 中存有所有的数，遍历 pool ，每次取一个数放入 path 中，然后递归选择下一个。
void Permutation(List&amp;lt;int&amp;gt; pool, List&amp;lt;int&amp;gt; path, List&amp;lt;int[]&amp;gt; result) { if (pool.Count == 0) { result.Add(path.ToArray()); return; } for (var i = 0; i &amp;lt; pool.Count; i++) { var item = pool[i]; path.Add(item); pool.RemoveAt(i); Permutation(pool, path, result); pool.Insert(i, item); path.Remove(item); } } 有了 n! 棵二叉树之后，我们需要过滤掉结构相同的树。
我们可以把二叉树转换成数组表示（层序遍历即可），然后遍历数组进行比较。
public static bool IsStructureEqual&amp;lt;TKeyA, TValueA, TKeyB, TValueB&amp;gt;(Bst&amp;lt;TKeyA, TValueA&amp;gt; a, Bst&amp;lt;TKeyB, TValueB&amp;gt; b) where TKeyA : IComparable&amp;lt;TKeyA&amp;gt; where TKeyB : IComparable&amp;lt;TKeyB&amp;gt; { var treeA = a.</description></item><item><title>3.2.10</title><link>https://alg4.ikesnowy.com/3-2-10/</link><pubDate>Fri, 28 Jun 2019 21:46:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-10/</guid><description> 3.2.10 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/TestBST.java.html
测试结果：
size = 10 min = A max = X Testing keys() --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 Testing select --------------------------- 0 A 1 C 2 E 3 H 4 L 5 M 6 P 7 R 8 S 9 X key rank floor ceil --------------------------- A 0 A A B 1 A C C 1 C C D 2 C E E 2 E E F 3 E H G 3 E H H 3 H H I 4 H L J 4 H L K 4 H L L 4 L L M 5 M M N 6 M P O 6 M P P 6 P P Q 7 P R R 7 R R S 8 S S T 9 S X U 9 S X V 9 S X W 9 S X X 9 X X Y 10 X Z 10 X range search --------------------------- A-Z (11)A C E H L M P R S X Z-A (0) X-X (1)X 0-Z (11)A C E H L M P R S X B-G (3)C E C-L (4)C E H L After deleting the smallest 3 keys --------------------------- H 5 L 11 M 9 P 10 R 3 S 0 X 7 After deleting the remaining keys --------------------------- After adding back the keys --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7</description></item><item><title>3.2.11</title><link>https://alg4.ikesnowy.com/3-2-11/</link><pubDate>Sat, 29 Jun 2019 18:13:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-11/</guid><description>3.2.11 # 解答 # 树的高度为树中深度最大的点的深度。
因此 N 个结点最多只能构造出高度为 N-1 的树来，并不能构成高度为 N 的树。
如果将题目变为用 N 个结点构造高度为 N-1 的二叉搜索树。
这样的树即为二叉搜索树的最坏情况，除唯一的叶子结点之外，每个结点有且只有一个子树。
于是除根结点外，每个结点都有两种选择，要么在左，要么在右。
因此共有 $2 ^ {n - 1}$ 种形状。
接下来证明，对于某一种确定的最坏情况，在 N 个元素各不相同的情况下，输入顺序是唯一的。
证明：
就 1 2 3 这三个元素而言，构造这样一棵树：
2 1 3 可以有 2 1 3 和 2 3 1 两种序列，因为在插入 2 之后可以选择的位置有两个
但最坏情况下的二叉搜索树不存在具有两个子结点的结点，因此输入顺序是唯一的。
反证：
也可以这样考虑，假设序列 A 可以构造出一棵最坏情况下的二叉树，插入顺序为 $x_1 \dots x_n$
假设存在与 A 顺序不同的序列 B，它构造出的二叉树与 A 的相同。
由于 A 和 B 的元素相同，因此 A 必然可以通过有限次元素交换得到 B。</description></item><item><title>3.2.12</title><link>https://alg4.ikesnowy.com/3-2-12/</link><pubDate>Sat, 06 Jul 2019 22:26:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-12/</guid><description>3.2.12 # 解答 # 二叉树的大小=左子树的大小+右子树的大小+1
根据上述表达式可以构造出一个递归的 Size() 方法，并删除结点中的 Size 。
Rank() 和 Select() 仍然可以正常工作，但最坏情况下的耗时可能会达到 $O(n)$ 和 $O(n^2 )$。</description></item><item><title>3.2.13</title><link>https://alg4.ikesnowy.com/3-2-13/</link><pubDate>Sat, 27 Jul 2019 17:02:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-13/</guid><description>3.2.13 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/NonrecursiveBST.java.html
Get 方法可以很方便的改成非递归形式。
private TValue Get(Node x, TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), &amp;#34;calls get() with a null key&amp;#34;); var cur = x; while (cur != null) { var cmp = key.CompareTo(cur.Key); if (cmp &amp;lt; 0) cur = cur.Left; else if (cmp &amp;gt; 0) cur = cur.Right; else return cur.Value; } return default; } Put 方法结构类似，但需要注意更新路径上各个结点的 Size 属性。
private Node Put(Node x, TKey key, TValue value) { if (x == null) return new Node(key, value, 1); var path = new Stack&amp;lt;Node&amp;gt;(); var cur = x; while (cur !</description></item><item><title>3.2.14</title><link>https://alg4.ikesnowy.com/3-2-14/</link><pubDate>Sun, 28 Jul 2019 21:02:01 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-14/</guid><description>3.2.14 # 解答 # 就 min，max 和 select 而言，它们是尾递归的，可以直接转换成迭代形式。 （简单的说，尾递归就是所有递归操作都出现在 return 语句上，且返回值不需要参与其他运算）
例如 min，递归形式为：
if (x.Left == null) return x; return Min(x.Left); 递归调用获得的值直接返回，不再参与运算，可以直接转换为递推：
while (true) { if (x.Left == null) return x; x = x.Left; } ceiling 和 floor 会略微复杂一些，具体见代码。
代码 # min 和 max 比较简单，用一个 while 循环就可以转换为递推形式，例如 min。
while (x != null) { if (x.Left == null) return x; x = x.Left; } return x; floor 和 ceiling 则要稍微复杂一点，需要记录当前找到的最小/最大值，例如 floor。</description></item><item><title>3.2.15</title><link>https://alg4.ikesnowy.com/3-2-15/</link><pubDate>Sun, 18 Aug 2019 11:14:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-15/</guid><description> 3.2.15 # 解答 # 比较简单，这里比较/取值都算一次访问，因此 keys 的访问序列会出现重复元素。
函数 路径 floor(Q) E Q select(5) E Q ceiling(Q) E Q rank(J) E Q J size(D, T) E Q T E D keys(D, T) E D E Q J J M Q T S S T</description></item><item><title>3.2.16</title><link>https://alg4.ikesnowy.com/3-2-16/</link><pubDate>Thu, 22 Aug 2019 19:58:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-16/</guid><description>3.2.16 # 解答 # 在高德纳的《计算机程序设计艺术》第一卷里出现了这个公式，编号为 $2.3.4.5(3)$。
书中的证明简单直接：
考虑二叉树中的某个叶子结点 $V$，设根结点到它的路径长度为 $k$，现在将 $V$ 删去。 对于二叉树的内部路径长度 $I$ 和外部路径长度 $E$ ：
由于 $V$ 被删去，$E$ 将会减少 $2(k+1)$，$I$ 将会减少 $k$，但此时 $V$ 变成了一个外部结点，$E$ 又会加上 $k$。 因此最后 $E$ 减少了 $k+2$，$I$ 减少了 $k$，重复 $N$ 次操作之后就可以得到 $E = I + 2N$。
另请参阅 # 《计算机程序设计艺术：第一卷 基本算法》（第三版）P400</description></item><item><title>3.2.17</title><link>https://alg4.ikesnowy.com/3-2-17/</link><pubDate>Sun, 25 Aug 2019 22:03:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-17/</guid><description> 3.2.17 # 解答 # 像这样，有一些字母是重复的，因此删除后树形状不变：
|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------T-------| |---Q |---Y |-O U N I---------------| |-------T-------| |---Q U |-O N I-------| |---T---| |-O U N I-------| |---T |-O N I-------| |---T |-O N I-------| |---T |-O N I---| |-O N |-O N N</description></item><item><title>3.2.18</title><link>https://alg4.ikesnowy.com/3-2-18/</link><pubDate>Sun, 25 Aug 2019 22:05:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-18/</guid><description> 3.2.18 # 解答 # 和上一题类似，只是删除顺序不同：
|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N E-------------------------------| |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |-------S-------| |---Q |---Y |-O |-U N T |-------S-------| |---Q |---Y O |-U T |-------S-------| Q |---Y |-U T S-------| |---Y |-U T |---Y |-U T |---Y |-U T |-Y U Y</description></item><item><title>3.2.19</title><link>https://alg4.ikesnowy.com/3-2-19/</link><pubDate>Sun, 25 Aug 2019 22:06:01 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-19/</guid><description> 3.2.19 # 解答 # 类似于这样的序列：
|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T |---------------N---------------| A |-------S-------| |---Q |---Y O |-U T |---------------O---------------| A |-------S-------| Q |---Y |-U T |---------------Q---------------| A S-------| |---Y |-U T |-------S-------| A |---Y |-U T |---T---| A |-Y U |-U-| A Y |-Y A A</description></item><item><title>3.2.20</title><link>https://alg4.ikesnowy.com/3-2-20/</link><pubDate>Sat, 28 Sep 2019 19:58:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-20/</guid><description>3.2.20 # 解答 # 勘误：英文版为 keys() 方法（而非 Size() 方法）。
先来观察一下 keys() 方法的实现：
public IEnumerable&amp;lt;TKey&amp;gt; Keys(TKey lo, TKey hi) { var queue = new Queue&amp;lt;TKey&amp;gt;(); Keys(root, queue, lo, hi); return queue; } private void Keys(Node x, Queue&amp;lt;TKey&amp;gt; queue, TKey lo, TKey hi) { var cmplo = lo.CompareTo(x.Key); var cmphi = hi.CompareTo(x.Key); if (cmplo &amp;lt; 0) Keys(x.Left, queue, lo, hi); if (cmplo &amp;lt;= 0 &amp;amp;&amp;amp; cmphi &amp;gt;= 0) queue.Enqueue(x.Key); if (cmphi &amp;gt; 0) Keys(x.</description></item><item><title>3.2.21</title><link>https://alg4.ikesnowy.com/3-2-21/</link><pubDate>Wed, 02 Oct 2019 18:54:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-21/</guid><description>3.2.21 # 解答 # 要注意保持每个键的出现概率相等，可以先随机一个排名，然后从树中将对应排名的键取出来。
private static readonly Random Random = new Random(); public TKey RandomKey() { var rank = Random.Next(1, Size() + 1); return GetKeyWithRank(root, rank); } private TKey GetKeyWithRank(Node x, int rank) { var left = (x.Left == null ? 0 : x.Left.Size) + 1; if (left &amp;gt; rank) { return GetKeyWithRank(x.Left, rank); } else if (left == rank) { return x.Key; } else { return GetKeyWithRank(x.Right, rank - left); } } 可以观察到每个键的出现概率都是差不多的。</description></item><item><title>3.2.22</title><link>https://alg4.ikesnowy.com/3-2-22/</link><pubDate>Wed, 02 Oct 2019 19:09:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-22/</guid><description>3.2.22 # 解答 # 这里的前驱和后继指的是二叉树中序遍历序列里结点的前驱和后继。
由于二叉搜索树的性质，它的中序遍历序列是递增有序的。
因此一个结点如果有左子树，要么前驱就是左子树中最大的结点（最右侧）；
同理结点如果有右子树，要么后继就是右子树中最小的结点（最左侧）。
于是结点的前驱不会有右子节点，后继不会有左子节点，得证。</description></item><item><title>3.2.23</title><link>https://alg4.ikesnowy.com/3-2-23/</link><pubDate>Thu, 03 Oct 2019 14:56:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-23/</guid><description>3.2.23 # 解答 # 不满足，反例如下：
|-------10 |---5---| 3 |-8-| 6 9 Delete 5 then delete 3 |-------10 6---| 8-| 9 Delete 3 then delete 5 |---10 |-8-| 6 9 这里先删除 3 会使 5 的左子树为空，导致删除 5 的时候采取的策略被改变（尽管 5 的右子树没有任何变化）。
另请参阅 # Deletion procedure for a Binary Search Tree-Stackoverflow</description></item><item><title>3.2.24</title><link>https://alg4.ikesnowy.com/3-2-24/</link><pubDate>Thu, 03 Oct 2019 16:29:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-24/</guid><description>3.2.24 # 解答 # 根据命题 D （英文版 P404，中文版 P255），一次插入所需的比较次数平均为 $ 1.39\lg N$。 (我们这里要求和，因此可以直接使用平均值进行计算）
于是构造一棵二叉查找树所需的比较次数为：
$$ 1.39C= 1.39\sum_{i=0}^N \lg i=1.39 \times(\lg 1 + \lg2+\cdots+\lg N) $$
根据对数恒等式，有：
$$ C=\lg 1 + \lg2+\cdots+\lg N=\lg(1\times2\times3\times\cdots\times N)=\lg(N!) $$
于是有 $ 1.39C=1.39\lg(N!) &amp;gt; \lg(N!)$ ，得证。</description></item><item><title>3.2.25</title><link>https://alg4.ikesnowy.com/3-2-25/</link><pubDate>Thu, 03 Oct 2019 18:05:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-25/</guid><description>3.2.25 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/PerfectBalance.java.html
先排序，然后视其为中序序列，每次取中间的键作为根结点，左半数组是左子树，右半数组是右子树，递归构造。
private Node BuildTree(KeyValuePair&amp;lt;TKey, TValue&amp;gt;[] init, int lo, int hi)// init is sorted { if (lo &amp;gt; hi) { return null; } var mid = (hi - lo) / 2 + lo; var current = new Node(init[mid].Key, init[mid].Value, 1); current.Left = BuildTree(init, lo, mid - 1); current.Right = BuildTree(init, mid + 1, hi); if (current.Left != null) { current.Size += current.Left.Size; } if (current.Right !</description></item><item><title>3.2.26</title><link>https://alg4.ikesnowy.com/3-2-26/</link><pubDate>Thu, 03 Oct 2019 19:54:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-26/</guid><description>3.2.26 # 解答 # 在 {% post_link 3-2-9 3.2.9 %} 的代码基础上进行修改，统计每种形状的出现次数，以此获得准确的概率。
概率如下，基本呈现一个对称的图形。
原始数据：
n=2 50% 50% n=3 16.666666% 16.666666% 33.333332% 16.666666% 16.666666% n=4 8.333333% 16.666666% 37.5% 12.5% 8.333333% 16.666666% n=5 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 5% 5% 5% 5% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.</description></item><item><title>3.2.27</title><link>https://alg4.ikesnowy.com/3-2-27/</link><pubDate>Fri, 04 Oct 2019 15:17:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-27/</guid><description>3.2.27 # 解答 # 二叉查找树的内存开销=对象开销+根结点引用+N个结点 =对象开销+根结点引用+N×(对象开销+父类型引用+左/右子树引用+键/值引用+结点数)
=16+8+N×(16+8+16+16+4+4)=24+64N 字节
BinarySearchST：对象开销+键/值数组引用+键/值数组+计数器（一个 int）。
=16+16+(16+4+4+8N)×2+4+4=88+16N 字节。
SequentialSearchST：对象开销+头结点引用+N个结点+计数器
=对象开销+头结点引用+N×(对象开销+父类型引用+next引用+键/值引用)+计数器
=16+8+N×(16+8+8+16)+4+4=32+48N 字节
示意图如下：
其中，对象开销 16 字节，其他均为引用，各占 8 字节。
《双城记》中不重复的单词有 26436 个（不包括最后的版权声明），全部是原文的子字符串，每个占 40 字节。
一个 Integer 占 24 字节，于是估计的内存消耗为：24+(64+40+24)×26436=3383832 字节。</description></item><item><title>3.2.28</title><link>https://alg4.ikesnowy.com/3-2-28/</link><pubDate>Sat, 05 Oct 2019 21:44:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-28/</guid><description>3.2.28 # 解答 # 修改一下 Put 和 Get 方法，在实际操作之前先检查缓存是否符合要求，然后在操作之后更新缓存。
代码 # private Node _cache; public override TValue Get(TKey key) { if (_cache != null &amp;amp;&amp;amp; _cache.Key.CompareTo(key) == 0) { return _cache.Value; } return Get(root, key).Value; } protected override Node Get(Node x, TKey key) { if (key == null) { throw new ArgumentNullException(&amp;#34;calls get() with a null key&amp;#34;); } if (x == null) { return null; } var cmp = key.</description></item><item><title>3.2.29</title><link>https://alg4.ikesnowy.com/3-2-29/</link><pubDate>Sat, 05 Oct 2019 22:14:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-29/</guid><description>3.2.29 # 解答 # 本题在原书后续印刷中已修改，这里仍采用中文版的题目。
部分解答：https://algs4.cs.princeton.edu/32bst/BST.java.html（isSizeConsistent()）
如果根结点记录的结点数=左子树的结点数+右子树的结点数+1，就符合要求。
按照这个题意编制递归方法即可。
先写边界，当输入为 null 时，显然符合要求。
然后计算左子树的 Size 和右子树的 Size 加起来是否等于根结点的 Size + 1，
以及左子树和右子树是否符合同样的条件。
代码 # protected static bool IsBinaryTree(Node x) { if (x == null) { return true; // 空树显然符合二叉树条件。 } var size = 1; // 包括当前结点本身。 if (x.Left != null) { size += x.Left.Size; } if (x.Right != null) { size += x.Right.Size; } return IsBinaryTree(x.Left) &amp;amp;&amp;amp; IsBinaryTree(x.Right) &amp;amp;&amp;amp; x.Size == size; } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.30</title><link>https://alg4.ikesnowy.com/3-2-30/</link><pubDate>Sat, 05 Oct 2019 22:23:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-30/</guid><description>3.2.30 # 解答 # 本题在原书后续印刷中已修改，这里仍然采用中文版的题目。
与上一题非常类似，条件有：
根结点必须在 min 和 max 范围内，
且左右子树要么不存在，要么小于/大于根结点的键，
左右子树同样满足上述条件。
代码 # protected static bool IsOrdered(Node x, TKey min, TKey max) { if (x == null) { return true; // 空树显然是满足要求的。 } return IsOrdered(x.Left, min, max) &amp;amp;&amp;amp; IsOrdered(x.Right, min, max) &amp;amp;&amp;amp; // 左右子树都满足要求。 x.Key.CompareTo(max) &amp;lt;= 0 &amp;amp;&amp;amp; x.Key.CompareTo(min) &amp;gt;= 0 &amp;amp;&amp;amp; // 当前结点位于范围内。 (x.Left == null || x.Left.Key.CompareTo(x.Key) &amp;lt; 0) &amp;amp;&amp;amp; (x.Right == null || x.Right.Key.CompareTo(x.Key) &amp;gt; 0); // 当前结点与子结点满足大小关系。 } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.31</title><link>https://alg4.ikesnowy.com/3-2-31/</link><pubDate>Sat, 05 Oct 2019 22:52:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-31/</guid><description>3.2.31 # 解答 # 本题在原书后续印刷中已删除，这里仍然采用中文版的题目。
注意这个题并没有递归的要求，直接广度优先搜索即可，随时记录和检查已找到的键。
代码 # protected static bool HasNoDuplicates(Node x) { var keys = new List&amp;lt;TKey&amp;gt;(); // 也可以用 HashSet 之类的数据结构提高效率。 var queue = new Queue&amp;lt;Node&amp;gt;(); queue.Enqueue(x); while (queue.Count &amp;gt; 0) { var node = queue.Dequeue(); if (node == null) { continue; } if (keys.Contains(node.Key)) { return false; } keys.Add(node.Key); queue.Enqueue(node.Left); queue.Enqueue(node.Right); } return true; } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.32</title><link>https://alg4.ikesnowy.com/3-2-32/</link><pubDate>Sat, 05 Oct 2019 23:02:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-32/</guid><description>3.2.32 # 解答 # 本题在原书后续印刷中已修改，这里仍然采用中文版的题目。
官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isBST()）
书中已经给出了答案，当然在 Java 和 C# 里，&amp;amp;&amp;amp; 总是从左向右计算的，而且遇到 false 会直接返回结果。
如果数据结构中存在环，IsOrdered 有可能会陷入无限递归的情况，因此调用顺序比较重要。
代码 # public static bool IsBST(BST&amp;lt;TKey, TValue&amp;gt; bst) { return IsBinaryTree(bst) &amp;amp;&amp;amp; IsOrdered(bst) &amp;amp;&amp;amp; HasNoDuplicates(bst); } 另请参阅 # Boolean logical operators (C# reference)
Equality, Relational, and Conditional Operators
BinarySearchTree 库</description></item><item><title>3.2.33</title><link>https://alg4.ikesnowy.com/3-2-33/</link><pubDate>Sun, 06 Oct 2019 10:21:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-33/</guid><description>3.2.33 # 解答 # 官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isRankConsistent()）
按照题目要求实现即可，分为两步进行测试。
代码 # public static bool IsRankConsistent(BST&amp;lt;TKey, TValue&amp;gt; bst) { for (var i = 0; i &amp;lt; bst.Size(); i++) { if (i != bst.Rank(bst.Select(i))) { return false; } } foreach (var key in bst.Keys()) { if (key.CompareTo(bst.Select(bst.Rank(key))) != 0) { return false; } } return true; } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.34</title><link>https://alg4.ikesnowy.com/3-2-34/</link><pubDate>Sun, 06 Oct 2019 11:57:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-34/</guid><description>3.2.34 # 解答 # 其实就是将所有的结点按照中序序列排成了一个双向链表，对树进行修改时要同时更新这个双向链表。
当插入新结点时，插到左侧的结点会变为父结点的新前驱，同理右侧会变为新后继。
注意要更新父结点原来的前驱和后继结点（如果有）。
删除结点时较为简单，只要更新需要删除结点的前驱和后继结点即可。
原本操作 left 和 right 的代码不需要更改，只需要加上对 prev 和 next 做操作的代码即可。
Prev 方法实现如下（Next 类似），修改了内部的 Get 方法使之返回 Node 而非 TValue。
public TKey Prev(TKey key) { var node = Get(root, key); if (node == null || node.Prev == null) return null; return node.Prev.Key; } 代码 # 处理结点关系的几个方法。
private void DeleteNode(Node x) { if (x.Prev != null) x.Prev.Next = x.Next; if (x.Next != null) x.Next.Prev = x.</description></item><item><title>3.2.35</title><link>https://alg4.ikesnowy.com/3-2-35/</link><pubDate>Sun, 06 Oct 2019 21:17:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-35/</guid><description>3.2.35 # 解答 # 根据书中已经给出的归纳关系式（中文版 P255/英文版 P403）：
$$ C_N=N-1+(C_0+C_{N-1})/N+(C_1+C_{N-2})/N+\cdots+(C_{N-1}+C_0)/N $$
整理得：
$$ C_N=N-1+(C_0+C_1+\cdots+C_{N-1})/N+(C_{N-1}+\cdots+C_1+C_0)/N $$
这和快速排序的式子基本一致，只是 $N+1$ 变成了 $N-1$。
遵循相同的推导过程，我们可以获得类似的结果，两边同乘以 $N$：
$$ NC_N=N(N-1)+2(C_0+C_1+\cdots+C_{N-1}) $$
用 $N+1$ 时的等式减去该式得：
$$ (N+1)C_{N+1}-NC_N=2N+2C_N \newline (N+1)C_{N+1}=2N+(N+2)C_N \newline \frac{C_{N+1}}{N+2}=\frac{2N}{(N+1)(N+2)} + \frac{C_N}{N+1} $$
令 $T_N = \frac{C_N}{N+1}$，得到：
$$ T_{N+1}=\frac{2N}{(N+1)(N+2)} + T_N \newline T_{N+1}-T_{N} = \frac{2N}{(N+1)(N+2)} $$
归纳得：
$$ \begin{aligned} T_N &amp;amp;= 2 \sum_{i=2}^{N} \frac{i-1}{i(i+1)} \newline C_N&amp;amp;=2(N+1)\sum_{i=2}^{N} \frac{i-1}{i(i+1)} \newline C_N&amp;amp;=2(N+1)\sum_{i=2}^{N}(i-1) (\frac{1}{i}-\frac{1}{i+1}) \newline C_N&amp;amp;=-2(N-1)+ 2(N+1)\sum_{i=2}^{N}\frac{1}{i}\newline C_N&amp;amp;=-2(N-1)+ 2(N+1)(-1+\sum_{i=1}^{N}\frac{1}{i})\newline C_N&amp;amp;=-4N+2(N+1)(\ln N+\gamma) \end{aligned} $$</description></item><item><title>3.2.36</title><link>https://alg4.ikesnowy.com/3-2-36/</link><pubDate>Mon, 07 Oct 2019 15:41:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-36/</guid><description>3.2.36 # 解答 # 用一个栈来模拟递归即可，将路径上的结点记录到栈里。
注意 Queue&amp;lt;TKey&amp;gt; 不算额外空间，因为它在keys执行完毕之后不会被回收。
代码 # private void Keys(Node x, Queue&amp;lt;TKey&amp;gt; queue, TKey lo, TKey hi) { var stack = new Stack&amp;lt;Node&amp;gt;(); while (x != null || stack.Count &amp;gt; 0) { if (x != null) { var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpHi &amp;gt;= 0) stack.Push(x); if (cmpLo &amp;lt; 0) x = x.Left; else x = null; } else { x = stack.</description></item><item><title>3.2.37</title><link>https://alg4.ikesnowy.com/3-2-37/</link><pubDate>Tue, 08 Oct 2019 21:08:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-37/</guid><description>3.2.37 # 解答 # 二叉树层序遍历，出队一个结点，打印它，将结点的左右子树入队，循环即可。
代码 # private void PrintLevel(Node x) { var queue = new Queue&amp;lt;Node&amp;gt;(); queue.Enqueue(x); while (queue.Count &amp;gt; 0) { var node = queue.Dequeue(); if (node.Left != null) queue.Enqueue(node.Left); if (node.Right != null) queue.Enqueue(node.Right); Console.Write(node.Key + &amp;#34;, &amp;#34;); } } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.38</title><link>https://alg4.ikesnowy.com/3-2-38/</link><pubDate>Fri, 25 Oct 2019 00:08:47 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-38/</guid><description>3.2.38 # 解答 # 通过层序遍历计算结点的坐标，然后绘制即可。
先算出最大深度，确定每一层的高度 Y，
再将每一层的宽度分成 $2^n-1$ 份，从左到右依次对结点赋值。
效果如下：
代码 # 计算坐标的函数。
public void DrawTree(Graphics pen, RectangleF panel) { var depth = Depth(root); // 确定最大深度。 var layerHeight = panel.Height / depth; var nowLayer = new Queue&amp;lt;Node&amp;gt;(); var nextLayer = new Queue&amp;lt;Node&amp;gt;(); nextLayer.Enqueue(root); for (var layer = 0; layer != depth; layer++) { var unitSizeX = (float)(panel.Width / Math.Pow(2, layer)); var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; var cursorX = 0.</description></item><item><title>3.2.39</title><link>https://alg4.ikesnowy.com/3-2-39/</link><pubDate>Thu, 31 Oct 2019 21:19:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-39/</guid><description>3.2.39 # 解答 # 测试结果：
可以看到和公式给出的结果十分一致。
测试时先生成 0~2n 顺序序列，奇数插入二叉树中，偶数用于测试查找失败的情况。
代码 # static void Main(string[] args) { var n = 10000; var trial = 100; for (var i = 0; i &amp;lt; 3; i++) { var odds = new int[n]; var evens = new int[n]; var bst = new BSTAnalysis&amp;lt;int, int&amp;gt;(); for (var j = 100; j &amp;lt; n; j++) { evens[j] = j; odds[j] = j + 1; } Shuffle(odds); foreach (var item in odds) { bst.</description></item><item><title>3.2.40</title><link>https://alg4.ikesnowy.com/3-2-40/</link><pubDate>Sat, 02 Nov 2019 19:33:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-40/</guid><description>3.2.40 # 解答 # 书中的结论是 1986 年 L. Devroye 给出的，原式为 $H_n \rightarrow c\log(n)$。
其中 $c$ 是方程 $c\log \frac{2e}{c}=1$ 的最大解，约为 $4.31107$。
2002 年 Michael Drmota 给出了一个跟精确的公式：$\mathrm{E}(H_n)=c\log n-\frac{3c}{2(c-1)}\log \log n + O(1)$。
测试结果如下，误差基本稳定在一个常数。
代码 # static void Main(string[] args) { var n = 10000; var trials = 100; for (var i = 0; i &amp;lt; 3; i++) { var items = new int[n]; for (var j = 0; j &amp;lt; n; j++) { items[j] = j; } var aveHeight = 0d; for (var j = 0; j &amp;lt; trials; j++) { var bst = new BST&amp;lt;int, int&amp;gt;(); Shuffle(items); foreach (var item in items) { bst.</description></item><item><title>3.2.41</title><link>https://alg4.ikesnowy.com/3-2-41/</link><pubDate>Mon, 04 Nov 2019 22:11:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-41/</guid><description>3.2.41 # 解答 # 大体上和标准 BST 实现差不多，做如下变换即可：
x.Key =&amp;gt; _nodes[x].Key; x.Value =&amp;gt; _nodes[x].Value; x.Left =&amp;gt; _left[x]; x.Right =&amp;gt; _right[x]; 由于使用了数组，在正常「删除」二叉树结点之后，还需要手工「垃圾回收」，如下图所示：
性能比较：
可见数组实现在删除节点时有巨大的性能差距。
代码 # private readonly Node[] _nodes; private readonly int[] _left; private readonly int[] _right; private int _size; private int _root; /// &amp;lt;summary&amp;gt; /// 二叉搜索树的结点。 /// &amp;lt;/summary&amp;gt; private class Node { public TKey Key { get; set; } public TValue Value { get; set; } } /// &amp;lt;summary&amp;gt; /// 建立一个以数组为基础的二叉搜索树。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;maxSize&amp;#34;&amp;gt;二叉搜索树中的结点数。&amp;lt;/param&amp;gt; public BSTArray(int maxSize) { _nodes = new Node[maxSize]; _left = new int[maxSize]; _right = new int[maxSize]; for (var i = 0; i &amp;lt; maxSize; i++) { _left[i] = -1; _right[i] = -1; } _size = 0; _root = 0; } /// &amp;lt;summary&amp;gt; /// 向符号表插入键值对。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;键。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;value&amp;#34;&amp;gt;值。&amp;lt;/param&amp;gt; public void Put(TKey key, TValue value) { if (_size == _nodes.</description></item><item><title>3.2.42</title><link>https://alg4.ikesnowy.com/3-2-42/</link><pubDate>Sun, 08 Dec 2019 14:36:10 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-42/</guid><description>3.2.42 # 解答 # 按照题意实现即可，关键点有两个：
一是选择前驱的实现方式，只要选择左子树中的最大结点即可。
if (_random.NextDouble() &amp;lt; 0.5) { x = Min(t.Right); x.Right = DeleteMin(t.Right); x.Left = t.Left; } else { x = Max(t.Left); x.Left = DeleteMax(t.Left); x.Right = t.Right; } 二是内部路径长度的计算方式，需要用层序遍历把所有结点的深度加起来。
var internalPath = 0; var nowLayer = new Queue&amp;lt;Node&amp;gt;(); var nextLayer = new Queue&amp;lt;Node&amp;gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.Count &amp;gt; 0) { var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.</description></item><item><title>3.2.43</title><link>https://alg4.ikesnowy.com/3-2-43/</link><pubDate>Sat, 28 Dec 2019 17:01:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-43/</guid><description>3.2.43 # 解答 # 依照题意实现即可，put/get 大约 10 倍差距。
MostFrequentlyKey 的实现：
public static TKey MostFrequentlyKey&amp;lt;TKey&amp;gt;(IST&amp;lt;TKey, int&amp;gt; st, TKey[] keys) { foreach (var s in keys) { if (st.Contains(s)) st.Put(s, st.Get(s) + 1); else st.Put(s, 1); } var max = keys[0]; foreach (var s in st.Keys()) if (st.Get(s) &amp;gt; st.Get(max)) max = s; return max; } 另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.44</title><link>https://alg4.ikesnowy.com/3-2-44/</link><pubDate>Sun, 12 Jan 2020 14:00:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-44/</guid><description>3.2.44 # 解答 # 使用类似于 3.1.38 的方法进行绘图，当 n=10000 时的结果如下：
代码 # 绘图部分：
public void Draw(long[] data) { var panel = CreateGraphics(); var unitX = (float)ClientRectangle.Width / data.Length; var unitY = (float)ClientRectangle.Height / data.Max(); var accumulation = 0f; // f = float for (var i = 0; i &amp;lt; data.Length; i++) { // Gray panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red panel.FillEllipse(Brushes.Red, (i + 1) * unitX, ClientRectangle.</description></item><item><title>3.2.45</title><link>https://alg4.ikesnowy.com/3-2-45/</link><pubDate>Sun, 12 Jan 2020 19:59:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-45/</guid><description>3.2.45 # 解答 # 结果如下，可参考 3.1.39。
SequentialSearchST
BinarySearchST
BST
可以看到 BST 的曲线更为平滑，插入和查找部分耗时十分接近。
另请参阅 # BinarySearchTree 库</description></item><item><title>3.2.46</title><link>https://alg4.ikesnowy.com/3-2-46/</link><pubDate>Sun, 12 Jan 2020 20:40:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-46/</guid><description>3.2.46 # 解答 # 翻译有些问题，其实指的是用 N 个 double 构造一个 BST 和 BinarySearchST 的速度对比。
Get 速度 BST 是不会比 BinarySearchST 快的。（$1.39\lg N$&amp;gt;$\lg N$）
二叉搜索树一次查找平均需要 $1.39\lg N$ 次比较，二分查找则是 $N/2$，于是可以求得开销：
二叉查找树：$1.39 \sum_{i=1}^{N-1} \lg i=1.39 \lg (N-1)!=1.39(N-1)\lg(N-1)$。
二分查找实现的符号表：$1/2+2/2+ \cdots+(N-1)/2=N(N-1)/4$ 。
令两式相等，可以求得快 10 倍，100 倍，1000 倍的 $N$ 值。 例如快 10 倍的方程：
$$ 13.9(N-1)\lg(N-1)=N(N-1)/4 \newline 13.9\lg (N-1)=N/4 $$
这是一个超越方程，可以简单用程序穷举出一个数值解。
for (var i = 0d; i &amp;lt; int.MaxValue; i++) { if (13.9 * Math.Log2(i - 1) &amp;lt; i / 4) { Console.</description></item><item><title>3.2.47</title><link>https://alg4.ikesnowy.com/3-2-47/</link><pubDate>Tue, 28 Jan 2020 20:25:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-2-47/</guid><description>3.2.47 # 解答 # 如下图所示，内部路径平均长度是比较符合规律的：
方差：
代码 # 一次测试：
private int Test(int n) { var data = GetRandomInt(n); var bst = new BST&amp;lt;int, int&amp;gt;(); foreach (var d in data) { bst.Put(d, d); } return bst.AverageInternalPathLength(); } 求解内部路径长度：
public int AverageInternalPathLength() =&amp;gt; InternalPath() / Size() + 1; private int InternalPath() { var internalPath = 0; var nowLayer = new Queue&amp;lt;Node&amp;gt;(); var nextLayer = new Queue&amp;lt;Node&amp;gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.</description></item><item><title>3.3.1</title><link>https://alg4.ikesnowy.com/3-3-1/</link><pubDate>Mon, 06 Sep 2021 00:22:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-1/</guid><description>3.3.1 # 解答 # 结果如下：
E AE |--E--| A S |--E--| A SY |--ES--| A Q Y |--ES--| A Q UY |--------S--------| |--E--| |--U--| A Q T Y |--------S--------| |--E--| |--U--| A IQ T Y |--------S--------| |--EO--| |--U--| A I Q T Y |--------S--------| |--EO--| |--U--| A IN Q T Y 代码 # 2-3 树的实现
using System; using System.Collections.Generic; using System.Linq; using System.Text; // ReSharper disable CognitiveComplexity namespace BalancedSearchTree { /// &amp;lt;summary&amp;gt; /// 2-3 树。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TKey&amp;#34;&amp;gt;键。&amp;lt;/typeparam&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TValue&amp;#34;&amp;gt;值。&amp;lt;/typeparam&amp;gt; public class TwoThreeBst&amp;lt;TKey, TValue&amp;gt; : IOrderedSt&amp;lt;TKey, TValue&amp;gt; where TKey : IComparable&amp;lt;TKey&amp;gt; { private int _count; private Node _root; /// &amp;lt;inheritdoc /&amp;gt; public void Put(TKey key, TValue value) { if (_root == null) { _root = new Node(null); _root.</description></item><item><title>3.3.2</title><link>https://alg4.ikesnowy.com/3-3-2/</link><pubDate>Mon, 06 Sep 2021 20:39:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-2/</guid><description>3.3.2 # 解答 # 和 3.3.1 类似，结果如下：
Y LY |--P--| L Y |--P--| LM Y |--P--| LM XY |--LP--| H M XY |--LP--| CH M XY |--------P--------| |--L--| |--X--| CH M R Y |--------P--------| |--CL--| |--X--| A H M R Y |--------P--------| |--CL--| |--X--| A EH M R Y |--------P--------| |--CL--| |--X--| A EH M RS Y 另请参阅 # BalancedSearchTree 库</description></item><item><title>3.3.3</title><link>https://alg4.ikesnowy.com/3-3-3/</link><pubDate>Mon, 06 Sep 2021 21:29:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-3/</guid><description>3.3.3 # 解答 # 题目给出的序列就可以，如下（只有根结点的 2-3 树的高度是 0，以此类推）：
S ES |--E--| A S |--E--| AC S |--E--| AC HS |--ES--| AC H X |--ES--| AC HM X SEACHXM 排序后是 ACEHMSX，符合条件的一种情况即为 AC 为左子结点，HM 为中间结点，X 为右侧结点，ES 为根节点。
也可以是其他的模式，总共有 2880 种符合条件的组合（result.txt），共三种模式，结果如下：
864 |--CM--| A EH SX 1152 |--EM--| AC H SX 864 |--ES--| AC HM X 可以观察到树的形状是没有变化的，只是键在各结点中的分布有些变化。
代码 # using System; using System.IO; using BalancedSearchTree; var input = &amp;#34;ACEHMSX&amp;#34;; var output = File.</description></item><item><title>3.3.4</title><link>https://alg4.ikesnowy.com/3-3-4/</link><pubDate>Sun, 24 Oct 2021 23:18:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-4/</guid><description>3.3.4 # 解答 # 一棵高度为 $h$ 的完美二叉树有：$1 + 2 + 2^2 + &amp;hellip; + 2^{h}= 2^{h+1} - 1$ 个结点，反向得到 $N$ 个结点的完美二叉树高度为 $\log_2{(N+1)} -1$。
一棵高度为 $h$ 的完美三叉树有：$1+3+3^2+&amp;hellip;+3^h= \frac{3^{h+1} - 1}{2}$ 个结点，反向得到 $N$ 个结点的完美三叉树高度为 $\log_3{(2N+1) - 1}$。
由于 2-3 树本身介于完美二叉树和完美三叉树之间，$N$ 个结点的 2-3 树高度就会介于 $N$ 个结点的完美二叉树和完美三叉树之间，即：$\sim\lfloor log_3N \rfloor \le h \le \sim\lfloor log_2{N} \rfloor$。
另请参阅 # 完美二叉树, 完全二叉树和完满二叉树 - veli - 博客园 (cnblogs.com)</description></item><item><title>3.3.5</title><link>https://alg4.ikesnowy.com/3-3-5/</link><pubDate>Sun, 16 Jan 2022 13:45:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-5/</guid><description>3.3.5 # 解答 # 注：英文版原文使用的是 “ignore the order of the subtrees”，也就是忽略子树的顺序。
我们将 N=6 时的树形简记为 [{3}, {2, 2, 3}]，代表根结点是一个 3-结点，第二层有两个 2-结点和一个 3-结点。
一个 N=6 的示例：
// &amp;#39;D&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;Y&amp;#39; |--GO--| D K SY 考虑插入元素的两种效用，一种是使 2-结点变成 3-结点（当前结点或者它的父结点）；另一种是使树高增加，被插入元素的 3-结点（及其父 3-结点）变回 2-结点。这两种操作的顺序不影响最后的树形。
于是 N=7 时，我们有两种树形。
[{3}, {2, 3, 3}]（插入到某个 2-结点）。
// &amp;#39;D&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;L&amp;#39; // before |--GO--| D K SY // after |--GO--| D KL SY [{2}, {2, 2}, {2, 2, 2, 2}]（插入到 3-结点，变成满二叉树）。</description></item><item><title>3.3.6</title><link>https://alg4.ikesnowy.com/3-3-6/</link><pubDate>Sun, 10 Apr 2022 20:44:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-6/</guid><description>3.3.6 # 解答 # 由 3.3.5 可知，$N=6$ 时的树形只有一种。
因此我们只需要将 $N=6$ 记为概率 1，利用乘法原理（或者说分步计数）计算之后的概率即可。
$N=6$ 的树形，底部共有 7 个位置可以插入：
// &amp;#39;D&amp;#39;, &amp;#39;G&amp;#39;, &amp;#39;K&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;Y&amp;#39; |--GO--| D K SY $N=7$ # 如果向 2-结点插入（示例中的 D 或 K），每个 2-结点有两个子树，概率均等，概率 $2/7 \times 2 = 4/7$，可以得到以下树形（记为 7-1）：
// after |--GO--| D KL SY 如果向 3-结点插入（3-结点有三个子树，概率均等，概率 $3/7$），可以得到以下树形（记为 7-2）：
|--------O--------| |--G--| |--S--| D K Q Y $N=8$ # 向 7-1 的唯一一个 2-结点插入（示例中的 D），概率 $4/7 \times 2/8= 1/7$，可以得到以下树形（记为 8-1）：</description></item><item><title>3.3.7</title><link>https://alg4.ikesnowy.com/3-3-7/</link><pubDate>Wed, 04 May 2022 17:35:37 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-7/</guid><description>3.3.7 # 解答 # 根结点 # 父结点是 2-结点时 # 在左侧插入 # 在右侧插入 # 父结点是 3-结点时 # 在左侧插入 # 在右侧插入 # 在中间插入 # 见书本中文版图 3.3.9，或英文版 P428 插图。</description></item><item><title>3.3.8</title><link>https://alg4.ikesnowy.com/3-3-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-8/</guid><description> 3.3.8 # 解答 # 考虑在一棵表示 3-结点的红黑树中插入元素且不进行平衡操作的所有情况即可。
这个示意图位于中文版图 3.3.20，英文版 P436 插图 Insert into a single 3-node (three cases)
顺序插入（C-&amp;gt;B-&amp;gt;A 或 A-&amp;gt;B-&amp;gt;C） # 先中间，再两边（B-&amp;gt;A-&amp;gt;C 或 B-&amp;gt;C-&amp;gt;A） # 先两边，再中间（C-&amp;gt;A-&amp;gt;B 或 A-&amp;gt;C-&amp;gt;B） #</description></item><item><title>3.3.9</title><link>https://alg4.ikesnowy.com/3-3-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alg4.ikesnowy.com/3-3-9/</guid><description>3.3.8 # 解答 # 官网有答案：https://algs4.cs.princeton.edu/33balanced/
iii 和 iv 是红黑树，i 不平衡，ii 不平衡且 F 不属于 D 和 E 之间的元素。</description></item><item><title>3.3.10</title><link>https://alg4.ikesnowy.com/3-3-10/</link><pubDate>Sun, 15 May 2022 21:07:39 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-10/</guid><description>3.3.10 # 解答 # 按照题意插入即可，以下是步骤图，红链接会显示为红色。</description></item><item><title>3.3.11</title><link>https://alg4.ikesnowy.com/3-3-11/</link><pubDate>Sun, 15 May 2022 21:11:01 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-11/</guid><description>3.3.11 # 解答 # 与上题类似，依次插入元素即可。</description></item><item><title>3.3.12</title><link>https://alg4.ikesnowy.com/3-3-12/</link><pubDate>Sun, 15 May 2022 22:01:06 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-12/</guid><description>3.3.12 # 解答 # 插入 P 时的步骤如图所示，用例是 S E A R C H E X A M P L E，在 3.1 章的 3.1.3 节可以找到它。</description></item><item><title>3.3.13</title><link>https://alg4.ikesnowy.com/3-3-13/</link><pubDate>Sun, 22 May 2022 21:06:41 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-13/</guid><description>3.3.13 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/#:~:text=True%20or%20false%3A%20If%20you%20insert%20keys%20in%20increasing%20order%20into%20a%20red%2Dblack%20BST%2C%20the%20tree%20height%20is%20monotonically%20increasing
是真的。
现在考虑在哪些情况下，红黑树插入元素后高度会变小。
根据红黑树与 2-3 树的对应，红链接其实就是把 2-3 树的 3-结点中的左侧元素变为左子树，并把这个左链接标记为红色。
那么对于一棵 2-3 树，3-结点对应的到红黑树中是带左侧结点的子树，高度会比同位置的 2-结点多 1。
现在把 2-3 树中的 2-结点记为 1，3-结点记为 2，数字最大的路径即为决定对应红黑树高度的路径。
那么只要插入操作后，该路径上的数字和反而减小，对应红黑树的高度不可能变大，只有可能减小或不变。（不变的原因和红黑树的性质有关，见之后的说明）
现在考虑 2-3 树插入的情况。
插入到 2-结点 -&amp;gt; 变为 3-结点，最大数字和增加。
插入到 3-结点 -&amp;gt; 自身变为 2-结点，向上传递 1 个元素
显然插入到 2-结点不可能减小高度，我们来考虑 3-结点向上传递的情况。
父结点是 2-结点 -&amp;gt; 父结点变为 3-结点，总数字和不变，红黑树高度不变。
父结点是 3-结点 -&amp;gt; 父结点变为 2-结点，向上传递一个元素。
不难发现当路径上有连续两个 3-结点时，插入操作最后会有两种情况：
停止在父级的某一个 2-结点。这时两个 3-结点变成了 2-结点（-2），一个 2-结点变成了 3-结点（+1），数字和减少 1 整棵 2-3 树的高度增加。这时两个 3-结点变成了 2-结点（-2），整条路径多了 1 个 2-结点（+1），数字和减少 1。 因此只有当该路径上最后两个元素都是 3-结点时，插入后的数字和必然减少，如果没有其他路径上的数字和比它更大，整个 2-3 树的最大数字和就会减小。</description></item><item><title>3.3.14</title><link>https://alg4.ikesnowy.com/3-3-14/</link><pubDate>Sat, 25 Jun 2022 14:39:32 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-14/</guid><description> 3.3.14 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/#:~:text=True%20or%20false%3A%20If%20you%20insert%20keys%20in%20increasing%20order%20into%20a%20red%2Dblack%20BST%2C%20the%20tree%20height%20is%20monotonically%20increasing
红黑树的构造过程，|| 代表红链接。
递增顺序插入等价于一直向 2-3 树最右侧叶子结点的右侧插入元素，对应红黑树的高度是单调递增的，具体说明见上一题的解答。
A ||-B A |-B-| A C |---B---| A ||-D C ||---D---| |-B-| E A C ||---D---| |-B-| ||-F A C E |---D---| |-B-| |-F-| A C E G |-------D-------| |---B---| |---F---| A C E ||-H G |-------D-------| |---B---| ||---H---| A C |-F-| I E G |-------D-------| |---B---| ||---H---| A C |-F-| ||-J E G I ||-------H-------| |---D---| |---J---| |-B-| |-F-| I K A C E G</description></item><item><title>3.3.15</title><link>https://alg4.ikesnowy.com/3-3-15/</link><pubDate>Thu, 30 Jun 2022 19:23:12 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-15/</guid><description> 3.3.15 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/
红黑树的构造过程，|| 代表红链接。
递减顺序插入等价于一直向 2-3 树最左侧叶子结点的左侧插入元素，对应红黑树的高度不一定是单调递增的（本例中插入 E 的时候红黑树高度反而减小了），具体说明见 3.3.13 的解答。
K ||-K J |-J-| I K |---J---| ||-I K H ||---J---| |-H-| K G I ||-------J-------| |---H---| K ||-G I F |---H---| |-F-| |-J-| E G I K |-------H-------| |---F---| |---J---| ||-E G I K D |-------H-------| ||---F---| |---J---| |-D-| G I K C E |---------------H---------------| ||-------F-------| |-------J-------| |---D---| G I K ||-C E B ||-------H-------| |---D---| |---J---| |-B-| |-F-| I K A C E G</description></item><item><title>3.3.16</title><link>https://alg4.ikesnowy.com/3-3-16/</link><pubDate>Tue, 08 Nov 2022 22:32:18 +0800</pubDate><guid>https://alg4.ikesnowy.com/3-3-16/</guid><description>3.3.16 # 解答 # 这棵红黑树看起来就像这样（||代表红链接）。
||---------------------------------------------------------------t---------------------------------------------------------------| j-------------------------------| u |---------------r---------------| |-------p-------| s |---l---| q k |-n-| m o 如果你的屏幕不够宽，可以试试 Ctrl + 鼠标滚轮调整缩放。</description></item><item><title>如何：运行题解代码</title><link>https://alg4.ikesnowy.com/run-solution-code/</link><pubDate>Mon, 14 May 2018 12:38:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/run-solution-code/</guid><description>本文将介绍如何下载题解项目并运行代码。 在开始之前，请确保你的电脑上已经安装了 Visual Studio 2015（及以上版本）并启用了 .NET Framework 4.7。 下载 Visual Studio：https://visualstudio.microsoft.com/zh-hans/downloads/
下载全部代码 # 点击这个链接，下载 GitHub Extension 并安装。 点击本页底部的 GitHub 图标，进入题解源代码页。 点击右上角的「Clone or Download」，选择「Open in Visual Studio」。 随后 Visual Studio 会自动打开（如果提示是否允许切换应用，请选择允许）。 确保「以递归方式克隆子模块」被选中，点击「克隆」。 耐心等待克隆完毕，视网络情况，可能需要几分钟到十几分钟不等。 在解决方案资源管理器中，双击解决方案「Algorithms 4th Edition.sln」。 右键需要运行的项目，选择「设为启动项目」。 按快捷键「Ctrl」+「F5」运行代码。 下载部分代码 # 控制台应用程序 # 打开 Visual Studio，选择「文件」-「新建」-「项目」，或按「Ctrl」+「Shift」+「N」打开「新建项目」对话框。 在模板中选择「Visual C#」-「Windows 桌面」-「控制台应用」，输入项目名称和位置，点击「确定」。 这里以题 1.3.26 为例，点击本页底部的 GitHub 图标，进入题解源代码页。 依次选择文件夹「1-Fundamental」-「1.3」-「1.3.26」，找到所有后缀为 .cs 的文件。 点击「Program.cs」，随后右键点击「Raw」，选择「目标另存为」，下载代码文件。 依次对所有其他的 .cs 文件做相同操作，下载全部的代码文件。 在解决方案资源管理器中，右键点击项目名称（一般位于解决方案名称的下方），选择「在文件资源管理器中打开文件夹」。 将所有的代码文件复制到该目录下，如果存在重复则直接覆盖。 这时 Visual Studio 可能会提示文件被更改，选择「重新加载」即可。 再次右击项目名称，选择「添加」-「现有项」，或按快捷键「Shift」+「Alt」+「A」，在弹出的窗口中选择刚才复制的所有 .cs 文件。 此时，一些不需要依赖库的题目已经可运行，按快捷键「Ctrl」+「F5」即可运行代码，如果 Visual Studio 提示缺少指令集引用，请通过下面的步骤添加类库。 定位到开头的 using 指令部分，缺失的库文件会被红线标出。 右击解决方案资源管理器中的解决方案名称（一般在最上方），选择「添加」-「新建项目」。 在弹出的「新建项目」对话框中选择「Visual C#」-「Windows 桌面」-「类库」模板，项目名称与缺失的库名称相同。 接下来回到第 3 步中打开的网站，找到缺失的库，在本例中，依次点击「1-Fundamental」-「1.</description></item></channel></rss>