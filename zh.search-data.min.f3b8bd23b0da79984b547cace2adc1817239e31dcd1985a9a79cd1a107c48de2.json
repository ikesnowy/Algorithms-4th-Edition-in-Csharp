[{"id":0,"href":"/thanks/","title":"特别感谢","section":"《算法（第四版）》C# 题解","content":"代码避免不了 bug，题解也避免不了错误，感谢你们对于题解中问题的指出！\n（排名不分先后）\n@杨晗 ，1.3.49 等 。⬅ 他写了一份 Java 版的题解，做的比我多，点此进入\n第一章 # @ljdhhp ，1.3.31 #539\n@ShuXin ，1.4.15 #321\n@雨碎江南 ，1.4.8，1.4.18 #437\n@张越 ，1.4.19\n@5ME，1.1.1 #592\n@Hao Liu, 公式渲染问题 #596, #594\n@Hao Liu, 1.4.15, 1.4.20, #595\n@Heshan, 1.1.25 #615\n第二章 # @雨碎江南 ，2.2.12 #532\n@cx666 , 2.2.12 #588\n@TianDao ，2.3.20 #587\n@wssb ，2.2.16，2.4.13\n@miyuexingchen ，2.4.6 #521\n@玉垒浮云 ，2.4.35 #590\n@Hao Liu, 2.3.22 #614\n第三章 # @雨碎江南 ，3.1.24 #538\n"},{"id":1,"href":"/1-1-1/","title":"1.1.1","section":"《算法（第四版）》C# 题解","content":" 1.1.1 # 解答 # a.7\nb.200.0000002\nc.True\n代码 # var a = (0 + 15) / 2; var b = 2.0e-6 * 100000000.1; var c = true \u0026amp;\u0026amp; false || true \u0026amp;\u0026amp; true; // Console.WriteLine 向控制台窗口输出一行 Console.WriteLine($\u0026#34;a.{a}\u0026#34;); Console.WriteLine($\u0026#34;b.{b}\u0026#34;); Console.WriteLine($\u0026#34;c.{c}\u0026#34;); "},{"id":2,"href":"/1-1-2/","title":"1.1.2","section":"《算法（第四版）》C# 题解","content":" 1.1.2 # 解答 # Name Type Value a System.Double 1.618 b System.Double 10 c System.Boolean True d System.String 33 代码 # // var 变量名 = 初始值 根据初始值自动判断变量类型 var a = (1 + 2.236) / 2; var b = 1 + 2 + 3 + 4.0; var c = 4.1 \u0026gt;= 4; var d = 1 + 2 + \u0026#34;3\u0026#34;; // Console.WriteLine 向控制台输出一行 // 变量名.GetType() 返回变量类型 Console.WriteLine(\u0026#34;\\tName\\tType \\tValue\u0026#34;); Console.WriteLine($\u0026#34;\\ta\\t{a.GetType()}\\t{a}\u0026#34;); Console.WriteLine($\u0026#34;\\tb\\t{b.GetType()}\\t{b}\u0026#34;); Console.WriteLine($\u0026#34;\\tc\\t{c.GetType()}\\t{c}\u0026#34;); Console.WriteLine($\u0026#34;\\td\\t{d.GetType()}\\t{d}\u0026#34;); "},{"id":3,"href":"/1-1-3/","title":"1.1.3","section":"《算法（第四版）》C# 题解","content":" 1.1.3 # 解答 # 简单的 if 判断即可。\n代码 # /* * 输入 * * 用空格隔开的三个整数，例如 * 3 3 3 * * 输出 * * equal 或 not equal */ var input = Console.ReadLine(); var a = int.Parse(input.Split(\u0026#39; \u0026#39;)[0]); var b = int.Parse(input.Split(\u0026#39; \u0026#39;)[1]); var c = int.Parse(input.Split(\u0026#39; \u0026#39;)[2]); if (a == b \u0026amp;\u0026amp; b == c) { Console.WriteLine(\u0026#34;equal\u0026#34;); } else { Console.WriteLine(\u0026#34;not equal\u0026#34;); } "},{"id":4,"href":"/1-1-4/","title":"1.1.4","section":"《算法（第四版）》C# 题解","content":" 1.1.4 # 解答 # a. if 后跟 then 的语法不能在 C# 中使用。\nb. if 后的判断语句需要在括号内。\nc. 正确，只有一条语句时大括号可以省略。\nd. c = 0 后缺少分号。\n代码 # var a = 1; var b = 2; var c = 0; // if (a \u0026gt; b) then c = 0; // if 后不能跟 then // if a \u0026gt; b { c = 0; } // if后必须跟括号 if (a \u0026gt; b) c = 0; // 正确 // if (a \u0026gt; b) c = 0 else b = 0; // c = 0后缺少分号 "},{"id":5,"href":"/1-1-5/","title":"1.1.5","section":"《算法（第四版）》C# 题解","content":" 1.1.5 # 解答 # 比较简单，直接判断即可。\n代码 # // 修改这两个值进行测试 var x = 0.05; var y = 0.01; if (x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt; 1 \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt; 1) { Console.WriteLine(\u0026#34;true\u0026#34;); } else { Console.WriteLine(\u0026#34;false\u0026#34;); } "},{"id":6,"href":"/1-1-6/","title":"1.1.6","section":"《算法（第四版）》C# 题解","content":" 1.1.6 # 解答 # 输出斐波那契数列。\n将书中的代码直接实现即可。\n代码 # //输出斐波那契数列 var f = 0; var g = 1; for (var i = 0; i \u0026lt;= 15; i++) { Console.WriteLine(f); f = f + g; g = f - g; } "},{"id":7,"href":"/1-1-7/","title":"1.1.7","section":"《算法（第四版）》C# 题解","content":" 1.1.7 # 解答 # 同上题，直接实现即可。\na\n3.00009\ndouble计算存在误差，并不精确。\nb\n499500\n1000 + 999 + 998……\nc\n10000\n1000 * 10，外层循环的结束条件为 $2^i \u0026gt;1000$\n代码 # static void A() { Console.WriteLine(\u0026#34;a\u0026#34;); var t = 9.0; while (Math.Abs(t - 9.0 / t) \u0026gt; .001) { t = (9.0 / t + t) / 2.0; } Console.WriteLine($\u0026#34;{t:N5}\u0026#34;); // :N5代表保留5位小数，同理可使用N1、N2…… } static void B() { Console.WriteLine(\u0026#34;\\nb\u0026#34;); var sum = 0; for (var i = 1; i \u0026lt; 1000; i++) { for (var j = 0; j \u0026lt; i; j++) { sum++; } } Console.WriteLine(sum); } static void C() { Console.WriteLine(\u0026#34;\\nc\u0026#34;); var sum = 0; for (var i = 1; i \u0026lt; 1000; i *= 2) { for (var j = 0; j \u0026lt; 1000; j++) { sum++; } } Console.WriteLine(sum); } // A double 计算存在误差 A(); // B 1000+999+998…… B(); // C 由于2^10 = 1024 \u0026gt; 1000，最终sum = 1000 * 10 = 10000 C(); "},{"id":8,"href":"/1-1-8/","title":"1.1.8","section":"《算法（第四版）》C# 题解","content":" 1.1.8 # 解答 # b\n197\ne\n代码 # Console.WriteLine(\u0026#39;b\u0026#39;); Console.WriteLine(\u0026#39;b\u0026#39; + \u0026#39;c\u0026#39;); // char 被隐式转为为 int 类型，取 ascii 码 Console.WriteLine((char)(\u0026#39;a\u0026#39; + 4)); // 强制转换后，ascii 码被转换为相应的字符 "},{"id":9,"href":"/1-1-9/","title":"1.1.9","section":"《算法（第四版）》C# 题解","content":" 1.1.9 # 解答 # 有两种方法，要么直接调用库函数，要么用书中给出的代码转换。\n代码 # var n = 4; // 1.直接转换 Convert.ToString(int, int) 第一个为要转换的数，第二个为要转换的进制 Console.WriteLine($\u0026#34;{Convert.ToString(n, 2)}\u0026#34;); // 2.转换为二进制数 var s = \u0026#34;\u0026#34;; for (var i = n; i \u0026gt; 0; i /= 2) { s = (i % 2) + s; } Console.WriteLine(s); "},{"id":10,"href":"/1-1-10/","title":"1.1.10","section":"《算法（第四版）》C# 题解","content":" 1.1.10 # 解答 # 变量使用前需要先赋值。\n代码 # int[] a; for (var i = 0; i \u0026lt; 10; i++) { // a[i] = i * i; // 不允许使用未赋值的局部变量 } a = new int[10]; for (var i = 0; i \u0026lt; 10; i++) { a[i] = i * i; // 初始化后可用 } "},{"id":11,"href":"/1-1-11/","title":"1.1.11","section":"《算法（第四版）》C# 题解","content":" 1.1.11 # 解答 # 注意，二维数组 bool[M, N] 代表 M 行 N 列的布尔数组。\n使用二重循环即可实现。\n输出使用制表符 ’\\t’ 作为分隔。\n代码 # var array = new[,] { { true, true }, { false, false }, { true, false } }; PrintArray2D(array); // 打印二维数组 static void PrintArray2D(bool[,] array) { var rows = array.GetLength(0); // 获取行数 var columns = array.GetLength(1); // 获取列数 //输出列号 for (var i = 0; i \u0026lt; columns; i++) { Console.Write($\u0026#34;\\t{i + 1}\u0026#34;); } Console.WriteLine(); for (var i = 0; i \u0026lt; rows; i++) { // 输出行号 Console.Write($\u0026#34;{i + 1}\u0026#34;); for (var j = 0; j \u0026lt; columns; j++) { if (array[i, j]) { Console.Write(\u0026#34;\\t*\u0026#34;); } else { Console.Write(\u0026#34;\\t \u0026#34;); } } Console.WriteLine(); } } "},{"id":12,"href":"/1-1-12/","title":"1.1.12","section":"《算法（第四版）》C# 题解","content":" 1.1.12 # 解答 # 第一个循环初始化数组 {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\n第二个循环用相应位置的值作为下标取值，例如：a[0] = a[a[0]] = a[9] = 0\n最后结果为：0,1,2,3,4,4,3,2,1,0\n代码 # var a = new int[10]; for (var i = 0; i \u0026lt; 10; i++) { a[i] = 9 - i; } // a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} for (var i = 0; i \u0026lt; 10; i++) { a[i] = a[a[i]]; } // a[0] = a[9] = 0; a[1] = a[8] = 1; a[2] = a[7] = 2;...... for (var i = 0; i \u0026lt; 10; i++) { Console.WriteLine(a[i]); } "},{"id":13,"href":"/1-1-13/","title":"1.1.13","section":"《算法（第四版）》C# 题解","content":" 1.1.13 # 解答 # 转置输出只需要在二重循环的时候将行、列输出顺序取反即可。\n代码 # var m = 2; var n = 3; var array = new int[m, n]; // 新建一个二维数组 for (var i = 0; i \u0026lt; m; i++) { for (var j = 0; j \u0026lt; n; j++) { array[i, j] = i + j; } } Console.WriteLine(\u0026#34;Origin\u0026#34;); PrintArray2D(array, m, n); Console.WriteLine(\u0026#34;Transposed\u0026#34;); PrintArrayTranspose2D(array, m, n); // 转置输出 static void PrintArrayTranspose2D(int[,] array, int rows, int columns) { // 交换行、列输出顺序 for (var i = 0; i \u0026lt; columns; i++) { for (var j = 0; j \u0026lt; rows; j++) { Console.Write($\u0026#34;\\t{array[j, i]}\u0026#34;); } Console.WriteLine(); } } // 正常输出 static void PrintArray2D(int[,] array, int rows, int columns) { for (var i = 0; i \u0026lt; rows; i++) { for (var j = 0; j \u0026lt; columns; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.WriteLine(); } } "},{"id":14,"href":"/1-1-14/","title":"1.1.14","section":"《算法（第四版）》C# 题解","content":" 1.1.14 # 解答 # 简单使用 log 的定义逼近即可。\n代码 # const int n = 9; Console.WriteLine($\u0026#34;{Lg(n)}\u0026#34;); // 利用循环逼近 n，得到 log2(n) 的值 static int Lg(int n) { const int baseNumber = 2; var pow = 1; var sum = 2; for (pow = 1; sum \u0026lt; n; pow++) { sum *= baseNumber; } return pow - 1; } "},{"id":15,"href":"/1-1-15/","title":"1.1.15","section":"《算法（第四版）》C# 题解","content":" 1.1.15 # 解答 # 利用二重循环，查找每个值在数组中出现的次数。\n代码 # var a = new int[10]; const int m = 10; for (var i = 0; i \u0026lt; 10; i++) { a[i] = i; } var result = Histogram(a, m); Console.WriteLine($\u0026#34;a.length: {a.Length}\u0026#34;); Console.WriteLine($\u0026#34;sum of result array: {result.Sum()}\u0026#34;); static int[] Histogram(int[] a, int m) { var result = new int[m]; for (var i = 0; i \u0026lt; m; i++) { // 初始化 result[i] = 0; // 遍历数组，计算数组中值为 i 的元素个数 for (var j = 0; j \u0026lt; a.Length; j++) { if (a[j] == i) // 值为 i 的元素 { result[i]++; } } } return result; } "},{"id":16,"href":"/1-1-16/","title":"1.1.16","section":"《算法（第四版）》C# 题解","content":" 1.1.16 # 解答 # 填入代码测试即可。\n用字符串拼接的方式展示递归。\n代码 # Console.WriteLine($\u0026#34;{ExR1(6)}\u0026#34;); // ExR1(6) = // ExR1(3) + 6 + ExR1(4) + 6 // ExR1(0) + 3 + ExR1(1) + 3 + 6 + ExR1(4) + 6 // \u0026#34;\u0026#34; + 3 + ExR1(-2) + 1 + ExR1(-1) + 1 + 3 + 6 + ExR1(4) + 6 // \u0026#34;\u0026#34; + 3 + \u0026#34;\u0026#34; + 1 + \u0026#34;\u0026#34; + 1 + 3 + 6 + ExR1(4) + 6 // \u0026#34;31136\u0026#34; + ExR1(4) + 6 // ...... static string ExR1(int n) { if (n \u0026lt;= 0) { return \u0026#34;\u0026#34;; } return ExR1(n - 3) + n + ExR1(n - 2) + n; } "},{"id":17,"href":"/1-1-17/","title":"1.1.17","section":"《算法（第四版）》C# 题解","content":" 1.1.17 # 解答 # 书中已经给出了解释。\n递归时结束条件必须放在递归语句的前面，否则会不断展开而无法结束。\n代码 # Console.WriteLine($\u0026#34;{ExR2(6)}\u0026#34;); // 抛出 StackOverflow Exception static string ExR2(int n) { var s = ExR2(n - 3) + n + ExR2(n - 2) + n; // 运行到 ExR2 即展开，不会再运行下一句 if (n \u0026lt;= 0) { return \u0026#34;\u0026#34;; } return s; } "},{"id":18,"href":"/1-1-18/","title":"1.1.18","section":"《算法（第四版）》C# 题解","content":" 1.1.18 # 解答 # 其实就是一种快速乘法的实现，换成乘号之后就变成了快速乘幂。\n例如对于乘法 $2 \\times 4$ ，可以用 $2 + 2 + 2 + 2$ 做四次加法计算；也可以变为 $(2 + 2) \\times 2 = (2 + 2) + (2 + 2)$ 的形式，用两次加法就可以完成（先计算 $2 + 2$ 的值，再计算 $4 + 4$ 的值）。\n同理对于乘幂 $2^8$ ，既可以用 $2\\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2$ 做 8 次乘法，也可以只用三次乘法就计算出来：\n$$ 2^2 = 2 \\times 2 \\newline 2^4 = 2^2 \\times 2^2\\newline 2^8 = 2^4 \\times 2^4 $$\n这样时间复杂度就从 $O(n)$ 变为了 $O(log n)$ 。\n代码 # using System; Console.WriteLine($\u0026#34;Mystery(2, 25): {Mystery(2, 25)}\u0026#34;); Console.WriteLine($\u0026#34;Mystery(3, 11): {Mystery(3, 11)}\u0026#34;); Console.WriteLine($\u0026#34;mysteryChanged(2, 8): {MysteryChanged(2, 8)}\u0026#34;); Console.WriteLine($\u0026#34;mysteryChanged(3, 2): {MysteryChanged(3, 2)}\u0026#34;); // Mystery(a, b) = a * b // 利用等式：a * b = 2a * b/2 = (2a * (b-1) / 2) + a // 示例： // Mystery(2, 25) = // Mystery(2 + 2, 12) + 2 = // Mystery(4 + 4, 6) + 2 = // Mystery(8 + 8, 3) = // Mystery(16 + 16, 1) + 16 + 2 = // Mystery(32 + 32, 0) + 32 + 16 + 2 = // 0 + 32 + 16 + 2 = // 50 static int Mystery(int a, int b) { if (b == 0) return 0; if (b % 2 == 0) return Mystery(a + a, b / 2); return Mystery(a + a, b / 2) + a; } // mysteryChanged(a, b) = a ^ b // 同理（乘方与乘法，乘法与加法之间具有类似的性质） // a ^ b = (a ^ 2) ^ (b / 2) = (a ^ 2) ^ ((b - 1) / 2) * a static int MysteryChanged(int a, int b) { if (b == 0) return 1; if (b % 2 == 0) return MysteryChanged(a * a, b / 2); return MysteryChanged(a * a, b / 2) * a; } "},{"id":19,"href":"/1-1-19/","title":"1.1.19","section":"《算法（第四版）》C# 题解","content":" 1.1.19 # 解答 # 普通的递归算法效率很低，原因是越到后面重复运算的数目越多。\n比如：\nF(2) = F(1) + F(0)\nF(3) = F(2) + F(1) = F(1) + F(1) + F(0)\n可以看到 F(1) 被重复计算了两次。\n改进的方式是将每次运算的结果保存在数组中，之后计算过的数据直接从数组中提取。\n代码 # // long 类型不够大，换成 UINT64 类型 // 用于保存计算结果的数组，UInt64? 代表可以赋值为普通 UInt64 类型的值以及 null 值 var fibnacciResults = new UInt64?[100]; var timer = Stopwatch.StartNew(); for (var n = 0; n \u0026lt; 100; n++) { // 书本中的代码，非常慢，1小时后 n = 50 // Console.WriteLine($\u0026#34;{n} {F(n)}\u0026#34;); // 利用已知结果加速 // 全部计算完毕耗时 84ms Console.WriteLine($\u0026#34;{n} {BetterF(n)}\u0026#34;); } Console.WriteLine($\u0026#34;{timer.ElapsedMilliseconds} ms\u0026#34;); // 书中提供的代码 // ReSharper disable once UnusedLocalFunction ulong F(int n) { if (n == 0) return 0; if (n == 1) return 1; return F(n - 1) + F(n - 2); } // 更好的实现，将已经计算的结果保存，不必重复计算 ulong? BetterF(int n) { if (n == 0) return 0; if (n == 1) return 1; if (fibnacciResults[n] != null) // 如果已经计算过则直接读取已知值 { return fibnacciResults[n]; } fibnacciResults[n] = BetterF(n - 1) + BetterF(n - 2); return fibnacciResults[n]; } "},{"id":20,"href":"/1-1-20/","title":"1.1.20","section":"《算法（第四版）》C# 题解","content":" 1.1.20 # 解答 # 根据对数的性质可以得到：\n$$ \\ln(N!) = \\ln(N) + \\ln(N – 1) + \\ln(N – 2)… $$\n代码 # const int n = 4; Console.WriteLine($\u0026#34;{FactorialLn(n)}\u0026#34;); // ln(N!) = // ln(N * (N - 1) * ... * 1) = // ln(N) + ln((N - 1)!) static double FactorialLn(int n) { if (n == 1) { return 0; } return Math.Log(n) + FactorialLn(n - 1); } "},{"id":21,"href":"/1-1-21/","title":"1.1.21","section":"《算法（第四版）》C# 题解","content":" 1.1.21 # 解答 # 实现上没什么难度，打印表格的部分可以参考之前打印二位布尔数组的方法。\n注意整型数据之间相除得到的仍然是整型，小数部分会直接舍去，例如 2 / 3 的结果会是 0。\n代码 # /* * 输入示例： * * 3 * hi 1 2 * hey 1 3 * hello 1 4 * */ var columns = 2; var rows = int.Parse(Console.ReadLine()); // 行号 var names = new string[rows]; // 姓名 var array = new int[rows, columns]; // 输入的两个整数 var results = new double[rows]; // 计算结果 for (var i = 0; i \u0026lt; rows; i++) { var temp = Console.ReadLine(); names[i] = temp.Split(\u0026#39; \u0026#39;)[0]; for (var j = 0; j \u0026lt; columns; j++) { array[i, j] = int.Parse(temp.Split(\u0026#39; \u0026#39;)[j + 1]); } results[i] = (double)array[i, 0] / array[i, 1]; } PrintArray2D(names, array, results); static void PrintArray2D(string[] names, int[,] array, double[] results) { var rows = array.GetLength(0); // 获取行数 var columns = array.GetLength(1); // 获取列数 for (var i = 0; i \u0026lt; rows; i++) { Console.Write($\u0026#34;\\t{names[i]}\u0026#34;); for (var j = 0; j \u0026lt; columns - 1; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.Write($\u0026#34;\\t{array[i, columns - 1]}\u0026#34;); Console.Write($\u0026#34;\\t{results[i]:N3}\u0026#34;); // 变量名:N3 保留三位小数 Console.WriteLine(); } } "},{"id":22,"href":"/1-1-22/","title":"1.1.22","section":"《算法（第四版）》C# 题解","content":" 1.1.22 # 解答 # 按照书中的提示增加一个保存深度的参数。\n代码 # var array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; Rank(9, array); static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1, 1); } static int RankInternal(int key, int[] a, int lo, int hi, int number) { for (var i = 0; i \u0026lt; number; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine($\u0026#34;{number}: {lo} {hi}\u0026#34;); if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1, number + 1); } else if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi, number + 1); } else { return mid; } } "},{"id":23,"href":"/1-1-23/","title":"1.1.23","section":"《算法（第四版）》C# 题解","content":" 1.1.23 # 解答 # 在主函数里做一下判断就可以了，加号则输出所有找不到的值，减号则相反。\n代码 # // 从largeW.txt中读取数据 var whiteListLines = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); var whiteList = new int[whiteListLines.Length]; for (var i = 0; i \u0026lt; whiteListLines.Length; i++) { whiteList[i] = int.Parse(whiteListLines[i]); } Array.Sort(whiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); // 输入样例：5 824524 478510 387221 var input = Console.ReadLine(); var query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (var i = 0; i \u0026lt; query.Length; i++) { query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine( \u0026#34;Type \u0026#39;+\u0026#39; to get the numbers that not in the whitelist,\u0026#34; + \u0026#34;\u0026#39;-\u0026#39; to get the numbers that in the whitelist.\u0026#34;); var operation = Console.ReadLine()[0]; foreach (var n in query) { if (Rank(n, whiteList) == -1) { if (operation == \u0026#39;+\u0026#39;) { Console.WriteLine(n); } } else if (operation == \u0026#39;-\u0026#39;) { Console.WriteLine(n); } } static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1); } static int RankInternal(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1); } else if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi); } else { return mid; } } 另请参阅 # LargeW.txt\n"},{"id":24,"href":"/1-1-24/","title":"1.1.24","section":"《算法（第四版）》C# 题解","content":" 1.1.24 # 解答 # 在书本中 GCD 的基础上，在函数开始时增加一条输出语句即可。\n代码 # Gcd(105, 24); Console.WriteLine(); Gcd(111111, 1234567); static int Gcd(int a, int b) { Console.WriteLine($\u0026#34;{a} {b}\u0026#34;); if (b == 0) { return a; } return Gcd(b, a % b); } "},{"id":25,"href":"/1-1-25/","title":"1.1.25","section":"《算法（第四版）》C# 题解","content":" 1.1.25 # 解答 # 已知：$a,b$ 皆为正整数，且 $a\u0026gt;b$。$g$ 是 $a,b$ 的最大公约数.\n设 $\\ r_0=a \\bmod b$，$r_1=b \\bmod r_0$ ，$r_k = r_{k-2} \\bmod\\ r_{k-1}$ 。\n那么有 $\\gcd(a,b)=\\gcd(b,r_0)=\\gcd(r_0,r_1)\u0026hellip;=\\gcd(r_{n-1},r_n)=r_{n-1}$ ，且 $r_n=0$ （此时算法终止），且 $n$ 是有限的。\n令 $q_n=\\lfloor r_{n-2}/r_{n-1} \\rfloor$\n有 $r_{n-2}=q_n\\times r_{n-1} + r_n=q_n\\times r_{n-1}$ （被除数=商✕除数+余数）。\n可得 $r_{n-2}$ 能被 $r_{n-1}$ 整除。\n则有\n$$ \\begin{aligned} r_{n-3} \u0026amp;= q_{n-1} \\times r_{n-2} + r_{n-1}\\newline \u0026amp;=q_{n-1}\\times (q_n \\times r_{n-1})+r_{n-1}\\newline \u0026amp;=q_{n-1}\\times q_n \\times r_{n-1} + r_{n-1} \\newline \u0026amp;=(q_{n-1} \\times q_n +1)\\times r_{n-1} \\end{aligned} $$\n可得 $r_{n-3}$ 也能被 $r_{n-1}$ 整除\n假设对于任意自然数 $n \u0026gt; x \u0026gt; k \\ge 0$, $r_x$ 可以被 $r_{n-1}$ 整除都成立 。\n则对于 $r_k$ 有：\n$$ \\begin{aligned} r_{k} \u0026amp;= q_{k+2} \\times r_{k+1} + r_{k+2} \\end{aligned} $$\n根据假设，$r_{k+1}$ 和 $r_{k+2}$ 都可以被 $r_{n-1}$ 整除，因此 $r_k$ 也可以被 $r_{n-1}$ 整除。\n根据数学归纳法可以得知对于任意 $x\u0026lt;n$，$r_x$ 都可以被 $r_{n-1}$ 整除。（类似于反向使用第二类数学归纳法）\n现在对于 $r_1$ 有：\n$$ \\begin{aligned} r_1 \u0026amp;= b \\bmod r_0 \\newline r_1 \u0026amp;=b-q_1 \\times r_0 \\qquad (q_1=\\lfloor b/r_0\\rfloor) \\newline b \u0026amp;= r_1 + q_1 \\times r_0 \\end{aligned} $$\n由于 $r_0$ 和 $r_1$ 都可以被 $r_{n-1}$ 整除，则 $b$ 也可以被 $r_{n-1}$ 整除。\n类似地，对于 $r_0$ 有：\n$$ \\begin{aligned} r_0 \u0026amp;= a \\bmod b \\newline a \u0026amp;= r_0 + q_0 \\times b \\qquad (q_0 = \\lfloor a/b \\rfloor) \\end{aligned} $$\n由于 $r_0$ 和 $b$ 都可以被 $r_{n-1}$ 整除，因此 $a$ 也可以被 $r_{n-1}$ 整除。\n于是得到 $r_{n-1}$ 是 $a$ 和 $b$ 的一个公约数，必然满足 $r_{n-1} \\le g$。\n因为 $g$ 是 $a,b$ 的最大公约数，由其性质可得： $a=mg,b=ng$ ，其中 $m,n$ 是自然数。\n$$ \\begin{aligned} r_0\u0026amp;=a \\bmod b \\newline \u0026amp;=a-q_0 \\times b\\qquad (q_0=\\lfloor a/b \\rfloor) \\newline \u0026amp;= mg-q_0\\times ng\\newline \u0026amp;=(m-q_0\\times n)g \\end{aligned} $$\n可得 $r_0$ 能够被 $g$ 整除。\n对于 $r_1$ 有：\n$$ \\begin{aligned} r_1 \u0026amp;= b \\bmod r_0 \\newline \u0026amp;=b-q_1 \\times r_0 \\qquad (q_1=\\lfloor b/r_0\\rfloor) \\end{aligned} $$\n由于 $b$ 和 $r_0$ 都能被 $g$ 整除，则 $r_1$ 也能被 $g$ 整除\n对于 $r_2$ 有：\n$$ \\begin{aligned} r_2 \u0026amp;= r_0 \\bmod r_1 \\newline \u0026amp;= r_0 - q_2 \\times r_1 \\qquad (q_2=\\lfloor r_0 / r_1 \\rfloor) \\end{aligned} $$\n由于 $r_0$ 和 $r_1$ 都可以被 $g$ 整除，因此 $r_2$ 也可以被 $g$ 整除。\n假设对于任意自然数 $x \u0026lt; k$， $r_x=r_{x-2} \\bmod r_{x-1}$ 可以被 $g$ 整除。\n则对于 $r_k$ 有：\n$$ \\begin{aligned} r_k \u0026amp;= r_{k-2} \\bmod r_{k-1} \\newline \u0026amp;= r_{k-2} - q_k \\times r_{k-1} \\qquad (q_k=\\lfloor r_{k-2} / r_{k-1} \\rfloor) \\end{aligned} $$\n根据假设， $r_{k-1}$ 和 $r_{k-2}$ 都可以被 $g$ 整除，此时 $r_k$ 也可以被 $g$ 整除。\n由第二类数学归纳法可知对于任意满足 $0 \\le x \\le n$ 的自然数 $x$，$r_x$ 可以被 $g$ 整除都成立。\n因此 $r_{n-1}$ 可以被 $g$ 整除，则 $g\\le r_{n-1}$。\n综上，当且仅当 $g=r_{n-1}$ 时满足关系 $r_{n-1} \\le g \\le r_{n-1}$，于是 $r_{n-1}=g$ 成立，$r_{n-1}$ 是 $a$ 和 $b$ 的最大公约数。\n"},{"id":26,"href":"/1-1-26/","title":"1.1.26","section":"《算法（第四版）》C# 题解","content":" 1.1.26 # 解答 # 见代码部分。\n代码 # var a = 3; var b = 2; var c = 1; var t = 0; if (a \u0026gt; b) { t = a; a = b; b = t; } // 如果 a \u0026gt; b，那么 a, b 交换，保证b \u0026gt;= a if (a \u0026gt; c) { t = a; a = c; c = t; } // 如果 b \u0026gt;= a \u0026gt; c，那么 a, c 交换，保证 c \u0026gt;= a if (b \u0026gt; c) { t = b; b = c; c = t; } // 如果 b \u0026gt; c \u0026gt;= a，那么 b, c 交换，保证 c \u0026gt;= b Console.WriteLine($\u0026#34;{a} {b} {c}\u0026#34;); // 最终结果为 c \u0026gt;= b \u0026gt;= a，保证升序排列 "},{"id":27,"href":"/1-1-27/","title":"1.1.27","section":"《算法（第四版）》C# 题解","content":" 1.1.27 # 解答 # 与之前的斐波那契数列类似，都是重复计算的问题。\n答案是 7751 次。\n代码 # var binomialCalled = 0; // 计算递归调用次数 double?[,] binomialCache; // 保存计算结果的数组 binomialCache = new double?[101, 51]; Console.WriteLine(Binomial(100, 50, 0.25)); Console.WriteLine(binomialCalled); double? Binomial(int n, int k, double p) { binomialCalled++; if (n == 0 \u0026amp;\u0026amp; k == 0) return 1.0; if (n \u0026lt; 0 || k \u0026lt; 0) return 0.0; if (binomialCache[n, k] != null) { return binomialCache[n, k]; } binomialCache[n, k] = (1.0 - p) * Binomial(n - 1, k, p) + p * Binomial(n - 1, k - 1, p); return binomialCache[n, k]; } "},{"id":28,"href":"/1-1-28/","title":"1.1.28","section":"《算法（第四版）》C# 题解","content":" 1.1.28 # 解答 # 实现方法有很多，这里是使用一个 HashSet 做中转，删除所有的重复元素。\n也可以使用 Linq 里的 Distinct() 方法，\n也可以排序后直接遍历一遍，遇到相同的就删除，遇到不同的就保存起来用于之后的比较。\n代码 # // 从largeW.txt中读取数据 // 用 HashSet 的不可重复性去除重复 var hashSet = new HashSet\u0026lt;string\u0026gt;(File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;)); var strings = new string[hashSet.Count]; hashSet.CopyTo(strings); var whiteList = new int[strings.Length]; for (var i = 0; i \u0026lt; strings.Length; i++) { whiteList[i] = int.Parse(strings[i]); } Array.Sort(whiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); // 输入样例：5 824524 478510 387221 var input = Console.ReadLine(); var query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (var i = 0; i \u0026lt; query.Length; i++) { query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine(\u0026#34;Irrelevant:\u0026#34;); foreach (var n in query) { if (Rank(n, whiteList) == -1) { Console.WriteLine(n); } } static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1); } static int RankInternal(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1); } if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi); } return mid; } 另请参阅 # LargeW.txt\n"},{"id":29,"href":"/1-1-29/","title":"1.1.29","section":"《算法（第四版）》C# 题解","content":" 1.1.29 # 解答 # 查找小于指定值的元素数量可以多次使用二分查找实现。\n例如：\n序号：0 1 2 3 4 5 6 7 8\n元素：1 2 2 2 2 2 2 2 3\n二分查找返回 4\n再次在 0~3 之间查找\n二分查找返回 1\n再次在 0~1 之间查找\n二分查找返回 -1，没有指定值了\n因此小于该值的元素数量就是 1 – 0 = 1 个\n用同样的方法可以找到大于指定值的元素个数，\n从总数中减去这两个数值就是等于指定值的元素数量。\n代码 # var whiteList = new[] { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 }; Array.Sort(whiteList); Console.WriteLine(\u0026#34;Type the numbers you want to query: \u0026#34;); var input = Console.ReadLine(); var query = new int[input.Split(\u0026#39; \u0026#39;).Length]; for (var i = 0; i \u0026lt; query.Length; i++) { query[i] = int.Parse(input.Split(\u0026#39; \u0026#39;)[i]); } Console.WriteLine(\u0026#34;Result:\u0026#34;); foreach (var n in query) { var less = Rank(n, whiteList); var equal = Count(n, whiteList); Console.WriteLine($\u0026#34;Less: {less} Equal: {equal}\u0026#34;); } static int Count(int key, int[] a) { var lowerBound = Rank(key, a); var upperBound = lowerBound; if (lowerBound == -1) return 0; while (true) { var result = RankInternal(key, a, upperBound + 1, a.Length - 1); if (result == -1) break; if (result \u0026gt; upperBound) { upperBound = result; } } return upperBound - lowerBound + 1; } static int Rank(int key, int[] a) { var mid = RankInternal(key, a, 0, a.Length - 1); if (mid == -1) return 0; while (true) { var result = RankInternal(key, a, 0, mid - 1); if (result == -1) break; if (result \u0026lt; mid) mid = result; } return mid; } static int RankInternal(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1); } if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi); } return mid; } "},{"id":30,"href":"/1-1-30/","title":"1.1.30","section":"《算法（第四版）》C# 题解","content":" 1.1.30 # 解答 # 互质可以用之前的 GCD 最大公因数算法判断，如果最大公因数是 1 则两数互质。\n代码 # // 互质 = 最大公约数为 1 = gcd(i, j) == 1 var n = int.Parse(Console.ReadLine()); var a = new bool[n, n]; for (var i = 0; i \u0026lt; n; i++) { for (var j = 0; j \u0026lt; n; j++) { a[i, j] = (Gcd(i, j) == 1); } } PrintArray2D(a, n, n); static int Gcd(int a, int b) { if (b == 0) return a; return Gcd(b, a % b); } static void PrintArray2D(bool[,] array, int rows, int columns) { for (var i = 0; i \u0026lt; rows; i++) { for (var j = 0; j \u0026lt; columns; j++) { Console.Write($\u0026#34;\\t{array[i, j]}\u0026#34;); } Console.WriteLine(); } } "},{"id":31,"href":"/1-1-31/","title":"1.1.31","section":"《算法（第四版）》C# 题解","content":" 1.1.31 # 解答 # 概率的实现方法：\n例如概率是 60 %，就在 [0, 100) 之间随机一个值，小于等于 60 则执行操作，反之不执行。\n需要更精确的情况可以增大随机的范围，例如 [0, 1000)。\n绘图结果\nN = 10,p = 0.2, 0.5, 1\n完整项目可以到 Github 上下载。\n代码 # /// \u0026lt;summary\u0026gt; /// 主绘图函数 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;点的总数目\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;每对点之间连接的概率\u0026lt;/param\u0026gt; public static void StartDrawing(int N, double p) { int pointSize = 5;//每个点绘制的大小 int precious = 1000;//概率判断的精度 //新建一个绘图窗口 Form2 DrawPad = new Form2(); //显示绘图窗口 DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.CreateGraphics(); //建立绘图区域（矩形） Rectangle rect = new Rectangle(10, 10, 400, 400); //画圆 graphics.DrawEllipse(Pens.Black, rect); //计算旋转角度 double rotateDgree = 360.0 / N; //计算点的坐标 Point Center = new Point(rect.Top + rect.Height / 2, rect.Top + rect.Height / 2); Point[] points = new Point[N]; points[0].X = rect.Left + rect.Width / 2; points[0].Y = rect.Top; for (int i = 1; i \u0026lt; N; ++i) { points[i] = Rotate(Center, points[i - 1], rotateDgree); } //绘制点 foreach (Point point in points) { graphics.FillEllipse(Brushes.Black, point.X - pointSize, point.Y - pointSize, pointSize, pointSize); } //按照概率绘制直线 Random random = new Random(); for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { //举例：输入概率为 0.6，精度为 1000 //在 0~1000 范围内等概率取值，如果小于等于 600 则视为事件发生 if (random.Next(0, precious) \u0026lt;= p * precious) { graphics.DrawLine(Pens.Gray, points[i], points[j]); } } } //释放资源 graphics.Dispose(); } /// \u0026lt;summary\u0026gt; /// 计算一个点绕某点旋转之后的坐标值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;origin\u0026#34;\u0026gt;旋转的圆心\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;point\u0026#34;\u0026gt;需要旋转的点\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dgree\u0026#34;\u0026gt;旋转的角度（逆时针）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回旋转后的坐标\u0026lt;/returns\u0026gt; public static Point Rotate(Point origin, Point point, double dgree) { Point rotated = new Point(); double dgreePi = dgree / 180 * Math.PI; rotated.X = (int)((point.X - origin.X) * Math.Cos(dgreePi) - (point.Y - origin.Y) * Math.Sin(dgreePi) + origin.X); rotated.Y = (int)((point.X - origin.X) * Math.Sin(dgreePi) + (point.Y - origin.Y) * Math.Cos(dgreePi) + origin.Y); return rotated; } "},{"id":32,"href":"/1-1-32/","title":"1.1.32","section":"《算法（第四版）》C# 题解","content":" 1.1.32 # 解答 # 绘图结果：\n完整的项目代码可以去 Github 上下载。\n代码 # public static void StartDrawing(double[] array, int N, double l, double r) { //创建并显示绘图窗口 Form2 DrawPad = new Form2(); DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, DrawPad.Height); graphics.ScaleTransform(1, -1); //对原始数组排序 Array.Sort(array); //计算各区域的值 int[] counts = new int[N]; int index = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = index; j \u0026lt; array.Length; ++j) { if (array[j] \u0026lt;= (r - l) * (i + 1) / N) { counts[i]++; index++; } else { break; } } } //获取最大值 double max = counts.Max(); //计算间距 double unit = DrawPad.Width / (3.0 * N + 1); //计算直方图的矩形 Rectangle[] rects = new Rectangle[N]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * DrawPad.Height); for (int i = 1; i \u0026lt; N; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * DrawPad.Height); } //绘图 graphics.FillRectangles(Brushes.Black, rects); //释放资源 graphics.Dispose(); } "},{"id":33,"href":"/1-1-33/","title":"1.1.33","section":"《算法（第四版）》C# 题解","content":" 1.1.33 # 解答 # 这里矩阵使用交错数组实现（方便取行向量），不是普通的二维数组。\n矩阵和矩阵、矩阵和向量、向量和矩阵都使用行向量点乘列向量的方式计算。\n代码 # public class Matrix { /// \u0026lt;summary\u0026gt; /// 计算两个向量的点积 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要点乘的向量\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要点乘的另一个向量\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回点乘的结果\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; public static double Dot(double[] x, double[] y) { //确保两向量等长 if (x.Length != y.Length) { throw new FormatException(\u0026#34;the length of two vectors must be equal\u0026#34;); } //点乘 double result = 0; for (int i = 0; i \u0026lt; x.Length; ++i) { result += x[i] * y[i]; } return result; } /// \u0026lt;summary\u0026gt; /// 计算两个矩阵相乘的结果，返回一个矩阵 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用交错数组表示的 m * p 矩阵\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;用交错数组表示的 p * n 矩阵\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回 m * n 的矩阵\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; /// \u0026lt;example\u0026gt; /// a = {(1,2,3),(4,5,6)} /// b = {(1,4),(2,5),(3,6)} /// Mult(a, b) = {(14,32),(32,77)} /// \u0026lt;/example\u0026gt; public static double[][] Mult(double[][] a, double[][] b) { if (a[0].Length != b.GetLength(0)) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to b\u0026#39;s row number\u0026#34;); } int m = a.GetLength(0); int n = b[0].Length; int p = a[0].Length; double[][] result = new double[m][]; for (int i = 0; i \u0026lt; m; ++i) { double[] resultrow = new double[n]; for (int j = 0; j \u0026lt; n; ++j) { //result[i][j] = 行向量 a[i] 与列向量 b[j] 的点积 double[] row = a[i]; double[] col = new double[p]; //取得列向量 for (int k = 0; k \u0026lt; p; ++k) { col[k] = b[k][j]; } //点积 resultrow[j] = Dot(row, col); } result[i] = resultrow; } return result; } /// \u0026lt;summary\u0026gt; /// 将一个矩阵转置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待转置的矩阵\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回转置后的数组\u0026lt;/returns\u0026gt; public static double[][] Transpose(double[][] a) { double[][] trans = new double[a[0].Length][]; for (int i = 0; i \u0026lt; a[0].Length; ++i) { double[] row = new double[a.GetLength(0)]; for (int j = 0; j \u0026lt; a.GetLength(0); ++j) { row[j] = a[j][i]; } trans[i] = row; } return trans; } /// \u0026lt;summary\u0026gt; /// 计算矩阵与向量的乘积 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;左乘的矩阵\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;列向量\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回一个向量\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; public static double[] Mult(double[][] a, double[] x) { if (a[0].Length != x.Length) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to x\u0026#39;s length\u0026#34;); } double[] result = new double[a.GetLength(0)]; for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { result[i] = Dot(a[i], x); } return result; } /// \u0026lt;summary\u0026gt; /// 计算向量与矩阵的乘积 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;行向量\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;矩阵\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回一个向量\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;FormatException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; public static double[] Mult(double[] x, double[][] a) { if (a.GetLength(0) != x.Length) { throw new FormatException(\u0026#34;a\u0026#39;s column number must be equal to x\u0026#39;s length\u0026#34;); } double[] result = new double[a[0].Length]; for (int i = 0; i \u0026lt; a[0].Length; ++i) { double[] colVector = new double[a.GetLength(0)]; for (int j = 0; j \u0026lt; colVector.Length; ++j) { colVector[j] = a[j][i]; } result[i] = Dot(x, colVector); } return result; } /// \u0026lt;summary\u0026gt; /// 在控制台上输出矩阵 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的矩阵\u0026lt;/param\u0026gt; public static void PrintMatrix(double[][] a) { for (int i = 0; i \u0026lt; a.GetLength(0); ++i) { for (int j = 0; j \u0026lt; a[i].Length; ++j) { Console.Write($\u0026#34;\\t{a[i][j]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } /// \u0026lt;summary\u0026gt; /// 在控制台上输出一行向量 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要输出的向量\u0026lt;/param\u0026gt; public static void PrintVector(double[] a) { for (int i = 0; i \u0026lt; a.Length; ++i) { Console.Write($\u0026#34;\\t{a[i]}\u0026#34;); } Console.Write(\u0026#34;\\n\u0026#34;); } } "},{"id":34,"href":"/1-1-34/","title":"1.1.34","section":"《算法（第四版）》C# 题解","content":" 1.1.34 # 解答 # 第二个以及最后三个需要，其他都可以设计成过滤器的模式。\n这里的 largeW.txt 只需要保留前 100 个数字就可以了，太多的话最后两个测试会刷屏。\n代码 # var allNumbers = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); var n = allNumbers.Length; var input = new int[n]; for (var i = 0; i \u0026lt; n; i++) { input[i] = int.Parse(allNumbers[i]); } MinAndMax(input); Console.WriteLine(); MidNumber(input); Console.WriteLine(); NumberK(4, input); Console.WriteLine(); SquareSum(input); Console.WriteLine(); AboveAverage(input); Console.WriteLine(); Ascending(input); Console.WriteLine(); Shuffle(input); Console.WriteLine(); static void MinAndMax(int[] input) { // 只用到了两个变量 var min = input[0]; var max = input[0]; // 只对输入值正向遍历一遍，不需要保存 for (var i = 1; i \u0026lt; input.Length; i++) { if (input[i] \u0026gt; max) { max = input[i]; } if (input[i] \u0026lt; min) { min = input[i]; } } Console.WriteLine(\u0026#34;Min and Max:\u0026#34;); Console.WriteLine($\u0026#34;Min: {min}\\nMax: {max}\u0026#34;); } static int MidNumber(int[] input) { // 需要对输入值进行去重 \u0026amp; 排序，故需要保存 var distinctNumbers = new List\u0026lt;int\u0026gt;(input.Distinct()); distinctNumbers.Sort(); Console.WriteLine(\u0026#34;MidNumber:\u0026#34;); Console.WriteLine(distinctNumbers[distinctNumbers.Count / 2]); return distinctNumbers[distinctNumbers.Count / 2]; } static int NumberK(int k, int[] input) { var temp = new int[101]; // 只正向遍历一遍，不需要保存 for (var i = 0; i \u0026lt; input.Length; i++) { if (i \u0026lt; 100) { temp[i] = input[i]; } else { temp[100] = input[i]; Array.Sort(temp); } } Console.WriteLine(\u0026#34;NumberK\u0026#34;); Console.WriteLine($\u0026#34;No.k: {temp[k - 1]}\u0026#34;); return temp[k - 1]; } static long SquareSum(int[] input) { long sum = 0; // 只正向遍历一遍，不需要保存 for (var i = 0; i \u0026lt; input.Length; i++) { sum += input[i] * input[i]; } Console.WriteLine(\u0026#34;Sum Of Square:\u0026#34;); Console.WriteLine(sum); return sum; } static double Average(int[] input) { long sum = 0; // 只遍历一遍，且不保存整个数组 for (var i = 0; i \u0026lt; input.Length; i++) { sum += input[i]; } var ave = sum / (double)input.Length; Console.WriteLine(\u0026#34;Average:\u0026#34;); Console.WriteLine(ave); return ave; } static double AboveAverage(int[] input) { var ave = Average(input); Console.WriteLine(); double count = 0; for (var i = 0; i \u0026lt; input.Length; i++) { if (input[i] \u0026gt; ave) { count++; } } Console.WriteLine(\u0026#34;AboveAverage:\u0026#34;); Console.WriteLine($\u0026#34;{(count / input.Length) * 100}%\u0026#34;); return count; } static void Ascending(int[] input) { Array.Sort(input); Console.WriteLine(\u0026#34;Ascending:\u0026#34;); for (var i = 0; i \u0026lt; input.Length; i++) { Console.Write($\u0026#34; {input[i]}\u0026#34;); } Console.WriteLine(); } static void Shuffle(int[] input) { var random = new Random(); var all = new List\u0026lt;int\u0026gt;(input); var n = input.Length; Console.WriteLine(\u0026#34;Shuffle:\u0026#34;); for (var i = 0; i \u0026lt; n; i++) { var temp = random.Next(0, all.Count - 1); Console.Write($\u0026#34; {all[temp]}\u0026#34;); all.RemoveAt(temp); } } "},{"id":35,"href":"/1-1-35/","title":"1.1.35","section":"《算法（第四版）》C# 题解","content":" 1.1.35 # 解答 # 这里用 Random 类模拟掷骰子并计算概率，最后和程序得出的比较。\n代码 # // 书中给出的程序 const int sides = 6; var dist = new double[2 * sides + 1]; for (var i = 1; i \u0026lt;= sides; i++) for (var j = 1; j \u0026lt;= sides; j++) dist[i + j] += 1.0; for (var k = 2; k \u0026lt;= 2 * sides; k++) dist[k] /= 36.0; // 不断进行模拟，直至误差小于 0.001 var n = 36; var isAccepted = false; double[] distTemp = null; const double error = 0.001; while (isAccepted == false) { distTemp = PlayDice(n); isAccepted = true; for (var i = 0; i \u0026lt; distTemp.Length; i++) { if (Math.Abs(distTemp[i] - dist[i]) \u0026gt;= error) isAccepted = false; } n++; } Console.WriteLine($\u0026#34;times:{n}\\n\u0026#34;); for (var i = 0; i \u0026lt; dist.Length; i++) { Console.WriteLine($\u0026#34;{i}:\\nStanderd:{dist[i]}\\nSimulated:{distTemp[i]}\\nOffset:{Math.Abs(distTemp[i] - dist[i])}\u0026#34;); } static double[] PlayDice(int times) { var random = new Random(); const int sides = 6; var dist = new double[2 * sides + 1]; // 掷 times 次 for (var i = 0; i \u0026lt; times; i++) { var sumTemp = random.Next(1, 7) + random.Next(1, 7); dist[sumTemp]++; } // 计算概率 for (var i = 0; i \u0026lt; dist.Length; i++) { dist[i] /= times; } return dist; } "},{"id":36,"href":"/1-1-36/","title":"1.1.36","section":"《算法（第四版）》C# 题解","content":" 1.1.36 # 解答 # N 取到 1000 左右数据就比较明显了。\nN = 1000， M = 10\n代码 # const int m = 10; // 数组大小 const int n = 1000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i \u0026lt; n; i++) { // 初始化 for (var j = 0; j \u0026lt; a.Length; j++) { a[j] = j; } // 打乱 Shuffle(a, i); // 记录 for (var j = 0; j \u0026lt; m; j++) { result[a[j], j]++; } } PrintMatrix(result); static void Shuffle(int[] a, int seed) { var n = a.Length; var random = new Random(seed); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); // 等于StdRandom.uniform(N-i) var temp = a[i]; a[i] = a[r]; a[r] = temp; } } static void PrintMatrix(int[,] a) { for (var i = 0; i \u0026lt; a.GetLength(0); i++) { for (var j = 0; j \u0026lt; a.GetLength(1); j++) { Console.Write($\u0026#34;\\t{a[i, j]}\u0026#34;); } Console.WriteLine(); } } "},{"id":37,"href":"/1-1-37/","title":"1.1.37","section":"《算法（第四版）》C# 题解","content":" 1.1.37 # 解答 # 使用 0~N-1 的随机数会导致每次交换的数字可能相同。\n例如：\n原数组： 1 2 3 4。\n第一次： 2 1 3 4\nrandom = 1，第 0 个和第 1 个交换。\n第二次： 1 2 3 4\nrandom = 0，第 1 个和第 0 个交换。\n代码 # // 使用 0~N-1 的随机数会导致每次交换的数字可能相同 // 例如： // 原数组： 1 2 3 4 // 第一次： 2 1 3 4 random = 1，第 0 个和第 1 个交换 // 第二次： 1 2 3 4 random = 0，第 1 个和第 0 个交换 const int m = 10; // 数组大小 const int n = 100000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i \u0026lt; n; i++) { // 初始化 for (var j = 0; j \u0026lt; a.Length; j++) { a[j] = j; } // 打乱 Shuffle(a, i); // 记录 for (var j = 0; j \u0026lt; m; j++) { result[a[j], j]++; } } PrintMatrix(result); static void Shuffle(int[] a, int seed) { var n = a.Length; var random = new Random(seed); for (var i = 0; i \u0026lt; n; i++) { // int r = i + random.Next(N - i); var r = random.Next(n); // 返回的是 0 ~ N-1 之间的随机整数 var temp = a[i]; a[i] = a[r]; a[r] = temp; } } static void PrintMatrix(int[,] a) { for (var i = 0; i \u0026lt; a.GetLength(0); i++) { for (var j = 0; j \u0026lt; a.GetLength(1); j++) { Console.Write($\u0026#34;\\t{a[i, j]}\u0026#34;); } Console.WriteLine(); } } "},{"id":38,"href":"/1-1-38/","title":"1.1.38","section":"《算法（第四版）》C# 题解","content":" 1.1.38 # 解答 # 为了使差距比较明显，故意取了比较靠后的数字。\n代码 # var largeWString = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); var largeW = new int[largeWString.Length]; for (var i = 0; i \u0026lt; largeW.Length; i++) { largeW[i] = int.Parse(largeWString[i]); } var timer = Stopwatch.StartNew(); BruteForceSearch(111111, largeW); Console.WriteLine($\u0026#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms\u0026#34;); timer.Restart(); Rank(111111, largeW); Console.WriteLine($\u0026#34;BinarySearch: {timer.ElapsedMilliseconds} ms\u0026#34;); var largeTString = File.ReadAllLines(\u0026#34;largeT.txt\u0026#34;); var largeT = new int[largeTString.Length]; for (var i = 0; i \u0026lt; largeW.Length; i++) { largeT[i] = int.Parse(largeTString[i]); } timer.Restart(); BruteForceSearch(111111, largeT); Console.WriteLine($\u0026#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms\u0026#34;); timer.Restart(); Rank(111111, largeT); Console.WriteLine($\u0026#34;BinarySearch: {timer.ElapsedMilliseconds} ms\u0026#34;); static int BruteForceSearch(int key, int[] a) { for (var i = 0; i \u0026lt; a.Length; i++) { if (a[i] == key) return i; } return -1; } static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1, 1); } static int RankInternal(int key, int[] a, int lo, int hi, int number) { if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1, number + 1); } if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi, number + 1); } return mid; } 另请参阅 # LargeW.txt LargeT.txt\n"},{"id":39,"href":"/1-1-39/","title":"1.1.39","section":"《算法（第四版）》C# 题解","content":" 1.1.39 # 解答 # 按照要求编程就好，视机器不同需要的时间也不同。\n代码 # // 需要 6 秒左右的运算时间 var r = new Random(); var baseNum = 10; var powNum = 3; var T = 10; var m = 4; var matrix = new double[m, 2]; for (var i = 0; i \u0026lt; m; i++) { var n = (int)Math.Pow(baseNum, powNum + i); double sum = 0; for (var j = 0; j \u0026lt; T; j++) { sum += Test(n, r.Next()); } matrix[i, 0] = n; matrix[i, 1] = sum / T; } PrintMatrix(matrix); static int Test(int n, int seed) { var random = new Random(seed); var a = new int[n]; var b = new int[n]; var count = 0; for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(100000, 1000000); b[i] = random.Next(100000, 1000000); } for (var i = 0; i \u0026lt; n; i++) { if (Rank(a[i], b) != -1) count++; } return count; } // 重载方法，用于启动二分查找 static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1, 1); } // 二分查找 static int RankInternal(int key, int[] a, int lo, int hi, int number) { if (lo \u0026gt; hi) { return -1; } var mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) { return RankInternal(key, a, lo, mid - 1, number + 1); } if (key \u0026gt; a[mid]) { return RankInternal(key, a, mid + 1, hi, number + 1); } return mid; } static void PrintMatrix(double[,] a) { for (var i = 0; i \u0026lt; a.GetLength(0); i++) { for (var j = 0; j \u0026lt; a.GetLength(1); j++) { Console.Write($\u0026#34;\\t{a[i, j]}\u0026#34;); } Console.WriteLine(); } } "},{"id":40,"href":"/1-2-1/","title":"1.2.1","section":"《算法（第四版）》C# 题解","content":" 1.2.1 # 解答 # 这里自己实现了一个 Point2D 类（包含在了 Geometry 库中）。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Point2D.java.html。\n求最近两点只需要反复调用 Point2D 类中的 DistTo() 方法就可以了。\n代码 # Point2D 类 # /// \u0026lt;summary\u0026gt; /// Point2D 二维点类。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;summary\u0026gt; public sealed class Point2D : IComparable\u0026lt;Point2D\u0026gt; { /// 以 X 坐标升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;以 X 坐标升序排序的静态比较器。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Point2D\u0026gt; XOrderComparer = new XOrder(); /// \u0026lt;summary\u0026gt; /// 以 Y 坐标升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;以 Y 坐标升序排序的静态比较器。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Point2D\u0026gt; YOrderComparer = new YOrder(); /// \u0026lt;summary\u0026gt; /// 以极半径升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;以极半径升序排序的静态比较器。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Point2D\u0026gt; ROrderComparer = new ROrder(); /// \u0026lt;summary\u0026gt; /// 二维点的 X 坐标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;X 坐标。\u0026lt;/value\u0026gt; public double X { get; } /// \u0026lt;summary\u0026gt; /// 二维坐标的 Y 坐标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;Y 坐标。\u0026lt;/value\u0026gt; public double Y { get; } /// \u0026lt;summary\u0026gt; /// 绘制时点的半径，以像素为单位，默认值为 2。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;点的半径，以像素为单位。\u0026lt;/value\u0026gt; public int Radius { get; set; } /// \u0026lt;summary\u0026gt; /// 构造一个二维点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;点的 X 轴坐标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;点的 Y 轴坐标。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;当 \u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 或 \u0026lt;paramref name=\u0026#34;y\u0026#34;/\u0026gt; 为±无穷时抛出此异常。\u0026lt;/exception\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentNullException\u0026#34;\u0026gt;当 \u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 或 \u0026lt;paramref name=\u0026#34;y\u0026#34;/\u0026gt; 为 \u0026lt;see cref=\u0026#34;double.NaN\u0026#34;/\u0026gt; 时抛出。\u0026lt;/exception\u0026gt; public Point2D(double x, double y) { if (double.IsInfinity(x) || double.IsInfinity(y)) { throw new ArgumentException(\u0026#34;x, y must be finite\u0026#34;); } if (double.IsNaN(x) || double.IsNaN(y)) { throw new ArgumentNullException(nameof(x), \u0026#34;Coordinate cannot be NaN\u0026#34;); } X = x; Y = y; Radius = 2; } /// \u0026lt;summary\u0026gt; /// 返回极半径。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;极半径。\u0026lt;/returns\u0026gt; public double R() { return Math.Sqrt(X * X + Y * Y); } /// \u0026lt;summary\u0026gt; /// 返回极角。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;极角。\u0026lt;/returns\u0026gt; public double Theta() { return Math.Atan2(Y, X); } /// \u0026lt;summary\u0026gt; /// 返回两个点之间的角度。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;要计算角度的另一个点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回与点 \u0026lt;paramref name=\u0026#34;that\u0026#34;/\u0026gt; 构成的角度。\u0026lt;/returns\u0026gt; private double AngleTo(Point2D that) { var dx = that.X - X; var dy = that.Y - Y; return Math.Atan2(dy, dx); } /// \u0026lt;summary\u0026gt; /// 判断 a,b,c 三个点的关系，如果 {顺时针, 共线, 逆时针} 则返回 {-1, 0, 1}。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;第三个点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 {顺时针, 共线, 逆时针} 则返回 {-1, 0, 1}\u0026lt;/returns\u0026gt; public static int Ccw(Point2D a, Point2D b, Point2D c) { var area2 = (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X); if (area2 \u0026lt; 0) return -1; if (area2 \u0026gt; 0) return 1; return 0; } /// \u0026lt;summary\u0026gt; /// 返回 abc 三个点构成的三角形的面积的平方。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;第三个点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;c\u0026#34;/\u0026gt; 构成的三角形的面积的平方。\u0026lt;/returns\u0026gt; public static double Area2(Point2D a, Point2D b, Point2D c) { return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X); } /// \u0026lt;summary\u0026gt; /// 返回当前点到另一个点之间的距离。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;另一个点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回到 \u0026lt;paramref name=\u0026#34;that\u0026#34;/\u0026gt; 的距离。\u0026lt;/returns\u0026gt; public double DistanceTo(Point2D that) { var dx = X - that.X; var dy = Y - that.Y; return Math.Sqrt(dx * dx + dy * dy); } /// \u0026lt;summary\u0026gt; /// 返回当前点到另一个点之间的距离的平方。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;另一个点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;到 \u0026lt;paramref name=\u0026#34;that\u0026#34;/\u0026gt; 距离的平方。\u0026lt;/returns\u0026gt; public double DistanceSquareTo(Point2D that) { var dx = X - that.X; var dy = Y - that.Y; return dx * dx + dy * dy; } /// \u0026lt;summary\u0026gt; /// 绘制二维点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，y轴向上，x轴向右的画布。\u0026lt;/param\u0026gt; public void Draw(Graphics g) { g.FillEllipse(Brushes.Black, (int)X, (int)Y, Radius, Radius); } /// \u0026lt;summary\u0026gt; /// 优先按照 \u0026lt;see cref=\u0026#34;Y\u0026#34;/\u0026gt; 比较，相同时再按照 \u0026lt;see cref=\u0026#34;X\u0026#34;/\u0026gt; 比较。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的另一个对象。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;other\u0026#34;/\u0026gt; 较小则返回 -1，反之返回 1，相等返回 0。\u0026lt;/returns\u0026gt; public int CompareTo(Point2D other) { if (Y \u0026lt; other.Y) return -1; if (Y \u0026gt; other.Y) return 1; if (X \u0026lt; other.X) return -1; if (X \u0026gt; other.X) return 1; return 0; } /// \u0026lt;summary\u0026gt; /// 按照 X 顺序比较。 /// \u0026lt;/summary\u0026gt; private class XOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.X \u0026lt; y.X) { return -1; } if (x.X \u0026gt; y.X) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 Y 顺序比较。 /// \u0026lt;/summary\u0026gt; private class YOrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.Y \u0026lt; y.Y) { return -1; } if (x.Y \u0026gt; y.Y) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极径顺序比较。 /// \u0026lt;/summary\u0026gt; private class ROrder : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { var delta = (x.X * x.X + x.Y * x.Y) - (y.X * y.X + y.Y * y.Y); if (delta \u0026lt; 0) { return -1; } if (delta \u0026gt; 0) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 atan2 值顺序比较。 /// \u0026lt;/summary\u0026gt; private class Atan2Order : Comparer\u0026lt;Point2D\u0026gt; { private readonly Point2D _parent; public Atan2Order(Point2D parent) { _parent = parent; } public override int Compare(Point2D x, Point2D y) { var angle1 = _parent.AngleTo(x); var angle2 = _parent.AngleTo(y); if (angle1 \u0026lt; angle2) { return -1; } if (angle1 \u0026gt; angle2) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极角顺序比较。 /// \u0026lt;/summary\u0026gt; private class PolarOrder : Comparer\u0026lt;Point2D\u0026gt; { private readonly Point2D _parent; public PolarOrder(Point2D parent) { _parent = parent; } public override int Compare(Point2D q1, Point2D q2) { var dx1 = q1.X - _parent.X; var dy1 = q1.Y - _parent.Y; var dx2 = q2.X - _parent.X; var dy2 = q2.Y - _parent.Y; if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy2 \u0026lt; 0) { return -1; } if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy1 \u0026lt; 0) { return 1; } if (dy1 == 0 \u0026amp;\u0026amp; dy2 == 0) { if (dx1 \u0026gt;= 0 \u0026amp;\u0026amp; dx2 \u0026lt; 0) { return -1; } if (dx2 \u0026gt;= 0 \u0026amp;\u0026amp; dx1 \u0026lt; 0) { return 1; } return 0; } return -Ccw(_parent, q1, q2); } } /// \u0026lt;summary\u0026gt; /// 按照距离顺序比较。 /// \u0026lt;/summary\u0026gt; private class DistanceToOrder : Comparer\u0026lt;Point2D\u0026gt; { private readonly Point2D _parent; public DistanceToOrder(Point2D parent) { _parent = parent; } public override int Compare(Point2D p, Point2D q) { var dist1 = _parent.DistanceSquareTo(p); var dist2 = _parent.DistanceSquareTo(q); if (dist1 \u0026lt; dist2) { return -1; } if (dist1 \u0026gt; dist2) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 构造一个以到当前点的极角为关键字的升序比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;以到当前点的极角为关键字的升序比较器。\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; Polor_Order() { return new PolarOrder(this); } /// \u0026lt;summary\u0026gt; /// 构造一个以到当前点的 Atan2 为关键字的升序比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;以到当前点的 Atan2 为关键字的升序比较器。\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; Atan2_Order() { return new Atan2Order(this); } /// \u0026lt;summary\u0026gt; /// 构造一个以到当前点的距离为关键字的升序比较器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;以到当前点的距离为关键字的升序比较器。\u0026lt;/returns\u0026gt; public Comparer\u0026lt;Point2D\u0026gt; DistanceTo_Order() { return new DistanceToOrder(this); } /// \u0026lt;summary\u0026gt; /// 比较 \u0026lt;paramref name=\u0026#34;obj\u0026#34;/\u0026gt; 是否与自身相等。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;要判别相等的另一个对象，\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;相等则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != GetType()) { return false; } var that = (Point2D)obj; return Math.Abs(X - that.X) \u0026lt; float.Epsilon * 5 \u0026amp;\u0026amp; Math.Abs(Y - that.Y) \u0026lt; float.Epsilon * 5; } /// \u0026lt;summary\u0026gt; /// 获取点的坐标字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;形如 \u0026#34;(\u0026lt;see cref=\u0026#34;X\u0026#34;/\u0026gt;, \u0026lt;see cref=\u0026#34;Y\u0026#34;/\u0026gt;)\u0026#34; 的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { return \u0026#34;(\u0026#34; + X + \u0026#34;, \u0026#34; + Y + \u0026#34;)\u0026#34;; } /// \u0026lt;summary\u0026gt; /// 获得二维点的哈希值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;哈希值。\u0026lt;/returns\u0026gt; public override int GetHashCode() { var hashX = X.GetHashCode(); var hashY = Y.GetHashCode(); return 31 * hashX + hashY; } } Main # Console.WriteLine(\u0026#34;Type the value of N:\u0026#34;); var n = int.Parse(Console.ReadLine()); var pointList = new List\u0026lt;Point2D\u0026gt;(); var random = new Random(); if (n \u0026lt;= 2) { Console.WriteLine(\u0026#34;Make sure there are 2 points at least\u0026#34;); return; } // random.NextDouble() 返回一个 0~1 之间的 double 值 for (var i = 0; i \u0026lt; n; i++) { var x = random.NextDouble(); var y = random.NextDouble(); pointList.Add(new Point2D(x, y)); } var min = pointList[0].DistanceTo(pointList[1]); for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { var temp = pointList[i].DistanceTo(pointList[j]); Console.WriteLine($\u0026#34;Checking Distance({i}, {j}): {temp}\u0026#34;); if (temp \u0026lt; min) { min = temp; } } } Console.WriteLine($\u0026#34;\\nThe minimal distance is {min}\u0026#34;) 另请参阅 # Geometry 库\n"},{"id":41,"href":"/1-2-2/","title":"1.2.2","section":"《算法（第四版）》C# 题解","content":" 1.2.2 # 解答 # 同样实现了一个 Interval1D 类（位于 Geometry 库）。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval1D.java.html。\n直接调用其中的 Intersect() 方法即可\n代码 # Interval1D 类： # /// \u0026lt;summary\u0026gt; /// 一维闭区间。 /// \u0026lt;/summary\u0026gt; public class Interval1D { /// \u0026lt;summary\u0026gt; /// 优先以起点升序排序，起点相同时按照终点升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;优先以起点升序排序，起点相同时按照终点升序排序。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Interval1D\u0026gt; MinOrder = new MinEndpointComparer(); /// \u0026lt;summary\u0026gt; /// 优先以终点升序排序，起点相同时按照起点升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;优先以终点升序排序，起点相同时按照起点升序排序。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Interval1D\u0026gt; MaxOrder = new MaxEndpointComparer(); /// \u0026lt;summary\u0026gt; /// 以区间长度升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;以区间长度升序排序。\u0026lt;/value\u0026gt; public static readonly Comparer\u0026lt;Interval1D\u0026gt; LengthOrder = new LengthComparer(); /// \u0026lt;summary\u0026gt; /// 区间起点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;区间起点。\u0026lt;/value\u0026gt; /// \u0026lt;remarks\u0026gt;这个属性是只读的。\u0026lt;/remarks\u0026gt; public double Min { get; } /// \u0026lt;summary\u0026gt; /// 区间终点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;区间终点。\u0026lt;/value\u0026gt; /// \u0026lt;remarks\u0026gt;这个属性是只读的。\u0026lt;/remarks\u0026gt; public double Max { get; } /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;一维区域的下界。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;一维区域的上界。\u0026lt;/param\u0026gt; public Interval1D(double lo, double hi) { if (double.IsInfinity(lo) || double.IsInfinity(hi)) { throw new ArgumentException(\u0026#34;Endpoints must be finite\u0026#34;); } if (double.IsNaN(lo) || double.IsNaN(hi)) { throw new ArgumentException(\u0026#34;Endpoints cannot be NaN\u0026#34;); } if (lo \u0026lt;= hi) { Min = lo; Max = hi; } else { throw new ArgumentException(\u0026#34;Illegal interval\u0026#34;); } } /// \u0026lt;summary\u0026gt; /// 一维区域的长度。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回长度。\u0026lt;/returns\u0026gt; public double Length() { return Max - Min; } /// \u0026lt;summary\u0026gt; /// 判断目标区间是否被本区间包含。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断是否被包含的区间。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;若 \u0026lt;paramref name=\u0026#34;that\u0026#34;/\u0026gt; 被本区间包含则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(Interval1D that) { return Min \u0026lt; that.Min \u0026amp;\u0026amp; Max \u0026gt; that.Max; } /// \u0026lt;summary\u0026gt; /// 目标值是否处在区域内。如果目标值在区域内则返回 True，否则返回 False。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要判断的值。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;若 \u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 被本区间包含则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(double x) { return x \u0026gt;= Min \u0026amp;\u0026amp; x \u0026lt;= Max; } /// \u0026lt;summary\u0026gt; /// 判断两个区域是否相交。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断相交的另一个区域。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果相交则返回 True，否则返回 False。\u0026lt;/returns\u0026gt; public bool Intersect(Interval1D that) { if (Max \u0026lt; that.Min || that.Max \u0026lt; Min) return false; return true; } /// \u0026lt;summary\u0026gt; /// 绘制一维区间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，y轴向上，x轴向右的画布。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;绘制一维区间的 y轴 坐标。\u0026lt;/param\u0026gt; public void Draw(Graphics g, int y) { var a = new Point((int)Min, y); var b = new Point((int)Max, y); g.DrawLine(Pens.Black, a, b); } /// \u0026lt;summary\u0026gt; /// 将区域转换为 string，返回形如 \u0026#34;[lo, hi]\u0026#34; 的字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;形如 \u0026#34;[\u0026lt;see cref=\u0026#34;Min\u0026#34;/\u0026gt;, \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;]\u0026#34; 的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { var s = \u0026#34;[\u0026#34; + Min + \u0026#34;, \u0026#34; + Max + \u0026#34;]\u0026#34;; return s; } /// \u0026lt;summary\u0026gt; /// 判断两个区间是否相等。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;相比较的区间。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果区间相等则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != GetType()) { return false; } var that = (Interval1D)obj; return Math.Abs(Min - that.Min) \u0026lt; double.Epsilon * 5 \u0026amp;\u0026amp; Math.Abs(Max - that.Max) \u0026lt; double.Epsilon * 5; } /// \u0026lt;summary\u0026gt; /// 返回区间的哈希代码。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回区间的哈希代码。\u0026lt;/returns\u0026gt; public override int GetHashCode() { var hash1 = Min.GetHashCode(); var hash2 = Max.GetHashCode(); return 31 * hash1 + hash2; } private class MinEndpointComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { Debug.Assert(a != null, nameof(a) + \u0026#34; != null\u0026#34;); Debug.Assert(b != null, nameof(b) + \u0026#34; != null\u0026#34;); if (a.Min \u0026lt; b.Min) { return -1; } if (a.Min \u0026gt; b.Min) { return 1; } if (a.Max \u0026lt; b.Max) { return -1; } if (a.Max \u0026gt; b.Max) { return 1; } return 0; } } private class MaxEndpointComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { Debug.Assert(a != null, nameof(a) + \u0026#34; != null\u0026#34;); Debug.Assert(b != null, nameof(b) + \u0026#34; != null\u0026#34;); if (a.Max \u0026lt; b.Max) { return -1; } if (a.Max \u0026gt; b.Max) { return 1; } if (a.Min \u0026lt; b.Min) { return -1; } if (a.Min \u0026gt; b.Min) { return 1; } return 0; } } private class LengthComparer : Comparer\u0026lt;Interval1D\u0026gt; { public override int Compare(Interval1D a, Interval1D b) { Debug.Assert(a != null, nameof(a) + \u0026#34; != null\u0026#34;); var alen = a.Length(); Debug.Assert(b != null, nameof(b) + \u0026#34; != null\u0026#34;); var blen = b.Length(); if (alen \u0026lt; blen) { return -1; } if (alen \u0026gt; blen) { return 1; } return 0; } } } Main # Console.WriteLine(\u0026#34;Type the value of N:\u0026#34;); var n = int.Parse(Console.ReadLine()); var intervalList = new List\u0026lt;Interval1D\u0026gt;(); if (n \u0026lt; 2) { Console.WriteLine(\u0026#34;Make sure there are at least 2 Intervals\u0026#34;); return; } // 读取并建立间隔数组 Console.WriteLine(\u0026#34;Type the data, make sure there is a space between two numbers.\\nExample: 0.5 1\u0026#34;); for (var i = 0; i \u0026lt; n; i++) { var temp = Console.ReadLine(); var lo = double.Parse(temp.Split(\u0026#39; \u0026#39;)[0]); var hi = double.Parse(temp.Split(\u0026#39; \u0026#39;)[1]); if (lo \u0026gt; hi) { var t = lo; lo = hi; hi = t; } intervalList.Add(new Interval1D(lo, hi)); } // 判断是否相交并输出 for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { if (intervalList[i].Intersect(intervalList[j])) { Console.WriteLine($\u0026#34;{intervalList[i]} {intervalList[j]}\u0026#34;); } } } 另请参阅 # Geometry 库\n"},{"id":42,"href":"/1-2-3/","title":"1.2.3","section":"《算法（第四版）》C# 题解","content":" 1.2.3 # 解答 # 首先先实现一个 Interval2D 类（位于 Geometry 库），再使用窗体应用程序绘图。\nJAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval2D.java.html。\n代码 # Interval2D： # /// \u0026lt;summary\u0026gt; /// 二维闭合区间。 /// \u0026lt;/summary\u0026gt; public class Interval2D { private readonly Interval1D _x; private readonly Interval1D _y; /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;x 轴上的范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;y 轴上的范围。\u0026lt;/param\u0026gt; public Interval2D(Interval1D x, Interval1D y) { _x = x; _y = y; } /// \u0026lt;summary\u0026gt; /// 判断两个平面是否相交。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断的另一个平面。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;相交则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Intersects(Interval2D that) { if (!_x.Intersect(that._x)) { return false; } if (!_y.Intersect(that._y)) { return false; } return true; } /// \u0026lt;summary\u0026gt; /// 判断目标区间是否被本区间包含。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;that\u0026#34;\u0026gt;需要判断是否被包含的区间。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;that\u0026#34;/\u0026gt; 被包含，则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(Interval2D that) { return _x.Contains(that._x) \u0026amp;\u0026amp; _y.Contains(that._y); } /// \u0026lt;summary\u0026gt; /// 判断一个二维点是否在该平面范围内。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的二维点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;p\u0026#34;/\u0026gt; 被包含，则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(Point2D p) { return (_x.Contains(p.X) \u0026amp;\u0026amp; _y.Contains(p.Y)); } /// \u0026lt;summary\u0026gt; /// 计算平面范围的面积。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;平面范围的面积。\u0026lt;/returns\u0026gt; public double Area() { return _x.Length() * _y.Length(); } /// \u0026lt;summary\u0026gt; /// 在画布上绘制二维区间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;原点在左下方，x轴向右，y轴向上的画布。\u0026lt;/param\u0026gt; public void Draw(Graphics g) { var rect = new Rectangle((int)_x.Min, (int)_y.Min, (int)_x.Length(), (int)_y.Length()); g.DrawRectangle(Pens.White, rect); g.FillRectangle(Brushes.Black, rect); } /// \u0026lt;summary\u0026gt; /// 返回形如“[xmin, xmax] x [ymin, ymax]”的字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;形如 \u0026#34;[xmin, xmax] x [ymin, ymax]\u0026#34; 的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { return _x + \u0026#34;x\u0026#34; + _y; } /// \u0026lt;summary\u0026gt; /// 判断两个二维区间是否相等。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;需要比较的另一个区间。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;相等则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) { return true; } if (obj == null) { return false; } if (obj.GetType() != GetType()) { return false; } var that = (Interval2D)obj; return _x.Equals(that._x) \u0026amp;\u0026amp; _y.Equals(that._y); } /// \u0026lt;summary\u0026gt; /// 获取哈希值 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;2D 区间的哈希值。\u0026lt;/returns\u0026gt; public override int GetHashCode() { var hash1 = _x.GetHashCode(); var hash2 = _y.GetHashCode(); return 31 * hash1 + hash2; } } 绘图方法 # /// \u0026lt;summary\u0026gt; /// 主绘图函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;N\u0026#34;\u0026gt;2D 间隔的数目。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Min\u0026#34;\u0026gt;分布范围的下界。（大于 0 且小于 1）\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Max\u0026#34;\u0026gt;分布范围的上界。（大于 0 且小于 1）\u0026lt;/param\u0026gt; public static void StartDrawing(int N, double Min, double Max) { Interval2D[] list = new Interval2D[N]; Random random = new Random(); //开始绘图 Form2 drawPad = new Form2(); drawPad.Show(); Graphics graphics = drawPad.CreateGraphics(); //生成随机二维间隔 for (int i = 0; i \u0026lt; N; ++i) { double x = random.NextDouble() * (Max - Min) + Min; double y = random.NextDouble() * (Max - Min) + Min; if (x \u0026gt;= y) { double temp = x; x = y; y = temp; } x *= drawPad.ClientRectangle.Width; y *= drawPad.ClientRectangle.Width; Interval1D tempx = new Interval1D(x, y); x = random.NextDouble() * (Max - Min) + Min; y = random.NextDouble() * (Max - Min) + Min; if (x \u0026gt;= y) { double temp = x; x = y; y = temp; } x *= drawPad.ClientRectangle.Height; y *= drawPad.ClientRectangle.Height; Interval1D tempy = new Interval1D(x, y); list[i] = new Interval2D(tempx, tempy); } //计算相交和包含的数量 int intersectNum = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = i + 1; j \u0026lt; N; ++j) { if (list[i].Intersects(list[j])) { intersectNum++; } } } int containsNum = 0; for (int i = 0; i \u0026lt; N; ++i) { for (int j = 0; j \u0026lt; N; ++j) { if (i == j) continue; if (list[i].Contains(list[j])) { containsNum++; } } } //移动原点至左下方，翻转坐标系 graphics.TranslateTransform(0, drawPad.ClientRectangle.Height); graphics.ScaleTransform(1, -1); //绘制所有区间 foreach (Interval2D n in list) { n.Draw(graphics); } //新建一个窗口，显示计算结果 MessageBox.Show($\u0026#34;相交的区间数：{intersectNum}, 包含的区间数：{containsNum}\u0026#34;); //清理资源 graphics.Dispose(); } 另请参阅 # Geometry 库\n"},{"id":43,"href":"/1-2-4/","title":"1.2.4","section":"《算法（第四版）》C# 题解","content":" 1.2.4 # 解答 # 在 C# 中，这段代码能够完成交换的工作，输出为：\nworld hello 代码 # var string1 = \u0026#34;hello\u0026#34;; var string2 = string1; string1 = \u0026#34;world\u0026#34;; Console.WriteLine(string1); Console.WriteLine(string2); "},{"id":44,"href":"/1-2-5/","title":"1.2.5","section":"《算法（第四版）》C# 题解","content":" 1.2.5 # 解答 # string 类型中的 Uppercase() 以及 Substring() 都不会改变原有字符串，而是新建一个字符串并返回。\n因此输出仍然为 Hello World。\n代码 # var s = \u0026#34;Hello World\u0026#34;; s.ToUpper(); s.Substring(6, 5); // C# 中两个参数分别代表子串起始下标和长度 Console.WriteLine(s); "},{"id":45,"href":"/1-2-6/","title":"1.2.6","section":"《算法（第四版）》C# 题解","content":" 1.2.6 # 解答 # 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） 其回环变位则为 s' = s2 + s1\n显然 s' + s' = s2 + s1 + s2 + s1\n即 s' + s' = s2 + s + s1，其中必定包含 s\n例如 ABC 和 BCA， BCABCA 显然包含 ABC\n代码 # var s1 = \u0026#34;ACTGACG\u0026#34;; var s2 = \u0026#34;TGACGAC\u0026#34;; Console.WriteLine(Circular(s1, s2)); // 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） // 其回环变位则为 s\u0026#39; = s2 + s1 // 显然 s\u0026#39; + s\u0026#39; = s2 + s1 + s2 + s1 // 即 s\u0026#39; + s\u0026#39; = s2 + s + s1，其中必定包含 s // 例如 ABC 和 BCA， BCABCA 显然包含 ABC static bool Circular(string s1, string s2) { return s1.Length == s2.Length \u0026amp;\u0026amp; (s2 + s2).Contains(s1); } "},{"id":46,"href":"/1-2-7/","title":"1.2.7","section":"《算法（第四版）》C# 题解","content":" 1.2.7 # 解答 # 递归交换字符顺序，最后返回反序的字符串。\nMystery(ABCD) = Mystery(CD) + Mystery(AB) = Mystery(D) + Mystery(C) + Mystery(B) + Mystery(A) = DCBA 代码 # Console.WriteLine(Mystery(\u0026#34;Hello1\u0026#34;)); static string Mystery(string s) { var n = s.Length; if (n \u0026lt;= 1) return s; var a = s.Substring(0, n / 2); var b = s.Substring(n / 2, n - n / 2); return Mystery(b) + Mystery(a); } "},{"id":47,"href":"/1-2-8/","title":"1.2.8","section":"《算法（第四版）》C# 题解","content":" 1.2.8 # 解答 # 作用就是交换两个数组。\n但在 C# 或 JAVA 中，数组变量实际是数组的一个引用（类似于指针），交换两个引用的效率与数组大小无关（可以理解为只是交换了数组的名字，数组实际内容在内存中的位置没有改变），都是常数时间的。\n代码 # // 读取 largeW.txt var allNums = File.ReadAllLines(\u0026#34;largeW.txt\u0026#34;); var n = allNums.Length; var a = new int[n]; var b = new int[n]; // 数组 a 与数组 b 数字顺序相反 for (var i = 0; i \u0026lt; n; i++) { a[i] = int.Parse(allNums[i]); b[n - i - 1] = a[i]; } // 输出前5个数字 Console.WriteLine(\u0026#34;Before Swap\u0026#34;); Console.Write(\u0026#34;a:\u0026#34;); for (var i = 0; i \u0026lt; 5; i++) { Console.Write($\u0026#34; {a[i]}\u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;b:\u0026#34;); for (var i = 0; i \u0026lt; 5; i++) { Console.Write($\u0026#34; {b[i]}\u0026#34;); } Console.WriteLine(); // 交换，现在 a 数组改叫 b 数组，而 b 数组改叫 a 数组了。 var t = a; a = b; b = t; // 再次输出，此时通过名称 a 获取到的是原来 b 数组的内容，反之亦然。 Console.WriteLine(\u0026#34;After Swap\u0026#34;); Console.Write(\u0026#34;a:\u0026#34;); for (var i = 0; i \u0026lt; 5; i++) { Console.Write($\u0026#34; {a[i]}\u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;b:\u0026#34;); for (var i = 0; i \u0026lt; 5; i++) { Console.Write($\u0026#34; {b[i]}\u0026#34;); } Console.WriteLine(); "},{"id":48,"href":"/1-2-9/","title":"1.2.9","section":"《算法（第四版）》C# 题解","content":" 1.2.9 # 解答 # 首先实现一个 Counter 类，随后使用非递归版本的 BinarySearch，每进行一次 While 循环就让 Counter 加一。\n代码 # Counter 类 # class Counter { private readonly string _name; private int _count; /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;计数器的名称。\u0026lt;/param\u0026gt; public Counter(string id) { _name = id; } /// \u0026lt;summary\u0026gt; /// 计数器加一。 /// \u0026lt;/summary\u0026gt; public void Increment() { _count++; } /// \u0026lt;summary\u0026gt; /// 获取当前计数值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Tally() { return _count; } /// \u0026lt;summary\u0026gt; /// 输出形如 “1 counter” 的字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return _count + \u0026#34; \u0026#34; + _name; } } Main # // 参考 1.1.10 节的代码 var count = new Counter(\u0026#34;BinarySearch\u0026#34;); // 读取白名单 var whiteListString = File.ReadAllLines(\u0026#34;tinyW.txt\u0026#34;); var whiteList = new int[whiteListString.Length]; for (var i = 0; i \u0026lt; whiteListString.Length; i++) { whiteList[i] = int.Parse(whiteListString[i]); } Array.Sort(whiteList); // 读取查询值 var inputListString = File.ReadAllLines(\u0026#34;tinyT.txt\u0026#34;); var inputList = new int[inputListString.Length]; for (var i = 0; i \u0026lt; inputListString.Length; i++) { inputList[i] = int.Parse(inputListString[i]); } // 对每一个查询值进行二分查找 foreach (var n in inputList) { var result = Rank(n, whiteList, count); // 将不在白名单上的数据输出 if (result == -1) { Console.WriteLine(n); } } Console.WriteLine(); // 输出查询数目 Console.WriteLine(count.Tally()); static int Rank(int key, int[] a, Counter count) { var lo = 0; var hi = a.Length - 1; while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; count.Increment(); if (key \u0026lt; a[mid]) { hi = mid - 1; } else if (key \u0026gt; a[mid]) { lo = mid + 1; } else { return mid; } } return -1; } "},{"id":49,"href":"/1-2-10/","title":"1.2.10","section":"《算法（第四版）》C# 题解","content":" 1.2.10 # 解答 # 在 Counter 类基础上修改即可。\n代码 # VisualCounter 类 # internal class VisualCounter { private readonly string _name; private int _count; private readonly int _max; private int _operatorTimes; /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;计数器的名称。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;max\u0026#34;\u0026gt;计数器的最大值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;operatorTimes\u0026#34;\u0026gt;计数器的最大操作数。\u0026lt;/param\u0026gt; public VisualCounter(string id, int max, int operatorTimes) { _name = id; _max = max; _operatorTimes = operatorTimes; } /// \u0026lt;summary\u0026gt; /// 计数器加一。 /// \u0026lt;/summary\u0026gt; public bool Increment() { if (_operatorTimes \u0026lt;= 0) return false; if (_count \u0026lt; _max) { _count++; _operatorTimes--; } return true; } /// \u0026lt;summary\u0026gt; /// 计数器减一。 /// \u0026lt;/summary\u0026gt; public bool Decreasement() { if (_operatorTimes \u0026lt;= 0) return false; if (_count \u0026gt; 0) { _count--; _operatorTimes--; } return true; } /// \u0026lt;summary\u0026gt; /// 获取当前计数值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回计数值。\u0026lt;/returns\u0026gt; public int Tally() { return _count; } /// \u0026lt;summary\u0026gt; /// 返回形如 “1 counter” 的字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回形如 “1 counter” 的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { return _count + \u0026#34; \u0026#34; + _name; } /// \u0026lt;summary\u0026gt; /// 绘制计数器的图形。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;g\u0026#34;\u0026gt;画布。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;width\u0026#34;\u0026gt;绘图区宽度。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;height\u0026#34;\u0026gt;绘图区高度。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;font\u0026#34;\u0026gt;显示的字体。\u0026lt;/param\u0026gt; public void Draw(Graphics g, int width, int height, Font font) { // 空画布 g.Clear(SystemColors.Control); // 画布分为上 1/3 和下 2/3 var headPart = new RectangleF(0, 0, width, height / 3); var bodyPart = new Rectangle(0, height / 3, (height * 2) / 3, (height * 2) / 3); // 绘图 g.DrawString($\u0026#34;计数：{_count} 剩余操作数：{_operatorTimes} 最大值：{_max}\u0026#34;, font, Brushes.Black, headPart); g.FillPie(Brushes.Blue, bodyPart, 0, 360 * (float)_count / _max); } } Form2\nusing System; using System.Drawing; using System.Windows.Forms; namespace _1._2._10 { public partial class Form2 : Form { VisualCounter counter; Graphics graphics; public Form2(int N, int max) { InitializeComponent(); counter = new VisualCounter(\u0026#34;count\u0026#34;, max, N); graphics = this.PaintArea.CreateGraphics(); } private void button1_Click(object sender, EventArgs e) { if (!counter.Increment()) { this.ErrorLabel.Text = \u0026#34;操作数不足\u0026#34;; } else { this.ErrorLabel.Text = \u0026#34;\u0026#34;; counter.Draw(graphics,this.PaintArea.Width, this.PaintArea.Height, this.Font); } } private void button2_Click(object sender, EventArgs e) { if (!counter.Decreasement()) { this.ErrorLabel.Text = \u0026#34;操作数不足\u0026#34;; } else { this.ErrorLabel.Text = \u0026#34;\u0026#34;; counter.Draw(graphics, this.PaintArea.Width, this.PaintArea.Height, this.Font); } } } } "},{"id":50,"href":"/1-2-11/","title":"1.2.11","section":"《算法（第四版）》C# 题解","content":" 1.2.11 # 解答 # 在构造函数开始时做一次判断，非法时抛出异常。\n首先建立一个数组，数组的第 1 项至第 12 项的值就是每个月的天数。\n再声明一个布尔类型的变量，用于标记是否是闰年。\n代码 # internal class SmartDate { public int Month { get; } // 月 public int Day { get; } // 日 public int Year { get; } // 年 // 每个月对应的天数，第 0 位空出来 private static readonly int[] DayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public SmartDate(int m, int d, int y) { if (Vaildation(m, d, y) == false) throw new FormatException(\u0026#34;Invaild Date\u0026#34;); Month = m; Day = d; Year = y; } private bool Vaildation(int m, int d, int y) { if (y \u0026lt; 0) return false; var isLeapYear = IsLeapYear(y); if (m \u0026gt; 12 || m \u0026lt; 1) return false; if (d \u0026lt; 0) return false; if (m == 2 \u0026amp;\u0026amp; d \u0026gt; 29 \u0026amp;\u0026amp; isLeapYear) return false; if (d \u0026gt; DayOfMonth[m]) return false; return true; } private bool IsLeapYear(int y) { if (y % 400 == 0) return true; if (y % 100 != 0 \u0026amp;\u0026amp; y % 4 == 0) return true; return false; } public override string ToString() { return Month + \u0026#34;/\u0026#34; + Day + \u0026#34;/\u0026#34; + Year; } } "},{"id":51,"href":"/1-2-12/","title":"1.2.12","section":"《算法（第四版）》C# 题解","content":" 1.2.12 # 解答 # 这里使用蔡勒公式来推算星期。\n参考：http://www.cnblogs.com/mq0036/p/3534314.html\n代码 # /// \u0026lt;summary\u0026gt; /// 计算当前日期是星期几，返回对应的星期名称。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string DayOfTheWeek() { var d = Day; var m = Month; var y = Year; if (m \u0026lt; 3) { m += 12; y--; } // 使用蔡勒公式计算，参见 http://www.cnblogs.com/mq0036/p/3534314.html var w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return DayOfWeek[w]; } 另请参阅 # 蔡勒公式-维基百科\n"},{"id":52,"href":"/1-2-13/","title":"1.2.13","section":"《算法（第四版）》C# 题解","content":" 1.2.13 # 解答 # 直接实现即可。\nJAVA 版本可以参考：http://algs4.cs.princeton.edu/12oop/Transaction.java.html。\n代码 # public class Transaction : IComparable\u0026lt;Transaction\u0026gt; { /// \u0026lt;summary\u0026gt; /// 客户姓名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;客户姓名。\u0026lt;/value\u0026gt; public string Who { get; } /// \u0026lt;summary\u0026gt; /// 交易日期。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;交易日期。\u0026lt;/value\u0026gt; /// \u0026lt;seealso cref=\u0026#34;Date\u0026#34;/\u0026gt; public Date When { get; } /// \u0026lt;summary\u0026gt; /// 交易金额。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;交易金额。\u0026lt;/value\u0026gt; public double Amount { get; } /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;transaction\u0026#34;\u0026gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。\u0026lt;/param\u0026gt; public Transaction(string transaction) { var a = transaction.Split(\u0026#39; \u0026#39;); Who = a[0]; When = new Date(a[1]); Amount = double.Parse(a[2]); } /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;who\u0026#34;\u0026gt;客户姓名。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;when\u0026#34;\u0026gt;交易日期。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;amount\u0026#34;\u0026gt;交易金额。\u0026lt;/param\u0026gt; public Transaction(string who, Date when, double amount) { if (double.IsNaN(amount) || double.IsInfinity(amount)) { throw new ArgumentException(\u0026#34;Amount cannot be NaN or Infinity\u0026#34;); } Who = who; When = when; Amount = amount; } /// \u0026lt;summary\u0026gt; /// 返回字符串形式的交易信息。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return string.Format(\u0026#34;{0, -10} {1, 10} {2, 8:F2}\u0026#34;, Who, When, Amount); } /// \u0026lt;summary\u0026gt; /// 默认按照交易金额升序比较。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;比较的另一个对象。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int CompareTo(Transaction other) { if (Amount \u0026lt; other.Amount) return -1; if (Amount \u0026gt; other.Amount) return 1; return 0; } /// \u0026lt;summary\u0026gt; /// 按照客户姓名升序比较。 /// \u0026lt;/summary\u0026gt; public class WhoOrder : IComparer\u0026lt;Transaction\u0026gt; { /// \u0026lt;summary\u0026gt; /// 比较两个 \u0026lt;see cref=\u0026#34;Transaction\u0026#34;/\u0026gt; 的姓名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要比较的第一个记录。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要比较的第二个记录。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 姓名靠后时返回大于 0 的数，反之返回小于 0 的数，相等返回 0。\u0026lt;/returns\u0026gt; int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { return string.Compare(x?.Who, y?.Who, StringComparison.Ordinal); } } /// \u0026lt;summary\u0026gt; /// 按照交易时间升序比较。 /// \u0026lt;/summary\u0026gt; public class WhenOrder : IComparer\u0026lt;Transaction\u0026gt; { /// \u0026lt;summary\u0026gt; /// 比较两个 \u0026lt;see cref=\u0026#34;Transaction\u0026#34;/\u0026gt; 的交易时间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要比较的第一个记录。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要比较的第二个记录。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 时间靠后时返回大于 0 的数，反之返回小于 0 的数，相等返回 0。\u0026lt;/returns\u0026gt; int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { Debug.Assert(x != null, nameof(x) + \u0026#34; != null\u0026#34;); Debug.Assert(y != null, nameof(y) + \u0026#34; != null\u0026#34;); return x.When.CompareTo(y.When); } } /// \u0026lt;summary\u0026gt; /// 按照交易金额升序比较。 /// \u0026lt;/summary\u0026gt; public class HowMuchOrder : IComparer\u0026lt;Transaction\u0026gt; { /// \u0026lt;summary\u0026gt; /// 比较两个 \u0026lt;see cref=\u0026#34;Transaction\u0026#34;/\u0026gt; 的交易金额。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要比较的第一个记录。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要比较的第二个记录。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 金额较大时返回大于 0 的数，反之返回小于 0 的数，相等返回 0。\u0026lt;/returns\u0026gt; int IComparer\u0026lt;Transaction\u0026gt;.Compare(Transaction x, Transaction y) { Debug.Assert(x != null, nameof(x) + \u0026#34; != null\u0026#34;); Debug.Assert(y != null, nameof(y) + \u0026#34; != null\u0026#34;); return x.Amount.CompareTo(y.Amount); } } /// \u0026lt;summary\u0026gt; /// 比较两笔交易是否相同。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;另一个对象。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Transaction)obj; return Math.Abs(that.Amount - Amount) \u0026lt; float.Epsilon * 5 \u0026amp;\u0026amp; that.When.Equals(When) \u0026amp;\u0026amp; that.Who == Who; } /// \u0026lt;summary\u0026gt; /// 返回交易信息的哈希值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;交易信息的哈希值。\u0026lt;/returns\u0026gt; public override int GetHashCode() { var hash = 31 * + Who.GetHashCode(); hash = 31 * hash + When.GetHashCode(); hash = 31 * hash + Amount.GetHashCode(); return hash; } } 另请参阅 # Commercial 库\n"},{"id":53,"href":"/1-2-14/","title":"1.2.14","section":"《算法（第四版）》C# 题解","content":" 1.2.14 # 解答 # 上一题中的代码已经包含了对 Equals() 方法的实现。\n代码 # /// \u0026lt;summary\u0026gt; /// 比较两笔交易是否相同。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;另一个对象。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Transaction)obj; return Math.Abs(that.Amount - Amount) \u0026lt; float.Epsilon * 5 \u0026amp;\u0026amp; that.When.Equals(When) \u0026amp;\u0026amp; that.Who == Who; } 另请参阅 # Commercial 库\n"},{"id":54,"href":"/1-2-15/","title":"1.2.15","section":"《算法（第四版）》C# 题解","content":" 1.2.15 # 解答 # 这里我们基于 File.ReadAllLines() 进行实现。\n代码 # static int[] ReadInts(string path) { var allLines = File.ReadAllLines(path); var result = new int[allLines.Length]; for (var i = 0; i \u0026lt; allLines.Length; i++) { result[i] = int.Parse(allLines[i]); } return result; } "},{"id":55,"href":"/1-2-16/","title":"1.2.16","section":"《算法（第四版）》C# 题解","content":" 1.2.16 # 解答 # JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Rational.java.html\n欧几里得算法仅适用于正整数，使用前需要注意。\n用欧几里得算法找到公因子之后直接化简即可。\n代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNegative; /// \u0026lt;summary\u0026gt; /// 构造一个有理数对象，自动变为最简形式。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;numerator\u0026#34;\u0026gt;分子。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;denominator\u0026#34;\u0026gt;分母。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;分母为 0 时抛出\u0026lt;/exception\u0026gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(\u0026#34;Denominator cannot be 0\u0026#34;); if (numerator \u0026lt; 0 \u0026amp;\u0026amp; denominator \u0026lt; 0) { _isNegative = false; numerator = -numerator; denominator = -denominator; } else if (numerator \u0026lt; 0 || denominator \u0026lt; 0) { _isNegative = true; } else { _isNegative = false; } var gcd = Gcd(Math.Abs(numerator), Math.Abs(denominator)); if (gcd != 1) { numerator /= gcd; denominator /= gcd; } Numerator = numerator; Denominator = denominator; } /// \u0026lt;summary\u0026gt; /// 将两个有理数对象相加，返回一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;加数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Plus(Rational b) { var result = new Rational(Numerator * b.Denominator + b.Numerator * Denominator, Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt; /// 以当前对象为被减数，减去一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;减数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Minus(Rational b) { var result = new Rational(Numerator * b.Denominator - b.Numerator * Denominator, Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt; /// 将两个有理数对象相乘。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;乘数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Multiply(Rational b) { var result = new Rational(Numerator * b.Numerator, Denominator * b.Denominator); return result; } /// \u0026lt;summary\u0026gt; /// 以当前有理数为被除数，除以一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;除数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Divide(Rational b) { var result = new Rational(Numerator * b.Denominator, Denominator * b.Numerator); return result; } /// \u0026lt;summary\u0026gt; /// 求两个正整数的最大公约数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个整数。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个整数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private long Gcd(long a, long b) { if (b == 0) return a; return Gcd(b, a % b); } public override bool Equals(object obj) { if (this == obj) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Rational)obj; return (Numerator == that.Numerator) \u0026amp;\u0026amp; (Denominator == that.Denominator); } public override int GetHashCode() { return 31 * Numerator.GetHashCode() + Denominator.GetHashCode(); } /// \u0026lt;summary\u0026gt; /// 返回形如 “分子/分母” 的字符串 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { var result = \u0026#34;\u0026#34;; if (_isNegative) result += \u0026#34;-\u0026#34;; result += Math.Abs(Numerator) + \u0026#34;/\u0026#34; + Math.Abs(Denominator); return result; } } "},{"id":56,"href":"/1-2-17/","title":"1.2.17","section":"《算法（第四版）》C# 题解","content":" 1.2.17 # 解答 # 在 C# 中使用 checked 关键字包裹整数运算的代码即可自动检查溢出。\n在 JAVA 中可以考虑在运算前控制运算数的大小。\n例如 a + b 之前保证 long.MaxValue – b \u0026gt;= a 等等。\n代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNagative; /// \u0026lt;summary\u0026gt; /// 构造一个有理数对象，自动变为最简形式。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;numerator\u0026#34;\u0026gt;分子。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;denominator\u0026#34;\u0026gt;分母。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;分母为 0 时抛出\u0026lt;/exception\u0026gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(\u0026#34;Denominator cannot be 0\u0026#34;); if (numerator \u0026lt; 0 \u0026amp;\u0026amp; denominator \u0026lt; 0) { _isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator \u0026lt; 0 || denominator \u0026lt; 0) { _isNagative = true; } else { _isNagative = false; } var gcd = Gcd(Math.Abs(numerator), Math.Abs(denominator)); if (gcd != 1) { numerator /= gcd; denominator /= gcd; } Numerator = numerator; Denominator = denominator; } /// \u0026lt;summary\u0026gt; /// 将两个有理数对象相加，返回一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;加数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Plus(Rational b) { checked { var result = new Rational(Numerator * b.Denominator + b.Numerator * Denominator, Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt; /// 以当前对象为被减数，减去一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;减数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Minus(Rational b) { checked { var result = new Rational(Numerator * b.Denominator - b.Numerator * Denominator, Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt; /// 将两个有理数对象相乘。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;乘数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Multiply(Rational b) { checked { var result = new Rational(Numerator * b.Numerator, Denominator * b.Denominator); return result; } } /// \u0026lt;summary\u0026gt; /// 以当前有理数为被除数，除以一个有理数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;除数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Rational Divide(Rational b) { checked { var result = new Rational(Numerator * b.Denominator, Denominator * b.Numerator); return result; } } /// \u0026lt;summary\u0026gt; /// 求两个正整数的最大公约数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个整数。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个整数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private long Gcd(long a, long b) { if (b == 0) return a; return Gcd(b, a % b); } public override bool Equals(object obj) { if (this == obj) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Rational)obj; return (Numerator == that.Numerator) \u0026amp;\u0026amp; (Denominator == that.Denominator); } public override int GetHashCode() { return 31 * Numerator.GetHashCode() + Denominator.GetHashCode(); } /// \u0026lt;summary\u0026gt; /// 返回形如 “分子/分母” 的字符串 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { var result = \u0026#34;\u0026#34;; if (_isNagative) result += \u0026#34;-\u0026#34;; result += Math.Abs(Numerator) + \u0026#34;/\u0026#34; + Math.Abs(Denominator); return result; } } "},{"id":57,"href":"/1-2-18/","title":"1.2.18","section":"《算法（第四版）》C# 题解","content":" 1.2.18 # 解答 # 当数据比较大时—— 例如 10^9 加上随机小数组成的数列，这时 double 的小数精度将受限。\n求和之后整数部分更大，小数部分将自动四舍五入，出现误差\n这时再计算平均值时将会带来较大的误差。\n因此采用另一个递推公式：\nk 为下标。\n$M_k = M_{k-1}+ (x_k – M_{k-1})/k$\n$S_k = S_{k-1} + (x_k – M_{k-1})\\times(x_k – M_k)$.\n方差 $s^2 = S_k/(k – 1)$.\n这种情况下并没有直接对所有输入值求和，小数精度不会过多受到整数部分长度的影响。\n有关这两个公式的证明可以参考这篇论文，或者去查看我的知乎回答。\n代码 # public class Accumulator { private double _m; private double _s; private int _n; public void AddDataValue(double x) { _n++; _s = _s + 1.0 * (_n - 1) / _n * (x - _m) * (x - _m); _m = _m + (x - _m) / _n; } public double Mean() { return _m; } public double Var() { return _s / (_n - 1); } public double Stddev() { return Math.Sqrt(Var()); } public override string ToString() { return \u0026#34;Mean (\u0026#34; + _n + \u0026#34; values): \u0026#34; + string.Format(\u0026#34;{0, 7:F5}\u0026#34;, Mean()); } } "},{"id":58,"href":"/1-2-19/","title":"1.2.19","section":"《算法（第四版）》C# 题解","content":" 1.2.19 # 解答 # 之前的 Date 和 Transaction 已经包含了这些实现。\n代码 # Date # /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;date\u0026#34;\u0026gt;形如 \u0026#34;05/31/2017\u0026#34; 的字符串。\u0026lt;/param\u0026gt; public Date(string date) { string[] a = date.Split(\u0026#39;/\u0026#39;); if (a.Length != 3) throw new ArgumentException(\u0026#34;Illgal Date\u0026#34;); Month = int.Parse(a[0]); Day = int.Parse(a[1]); Year = int.Parse(a[2]); } Transaction # /// \u0026lt;summary\u0026gt; /// 构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;transaction\u0026#34;\u0026gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。\u0026lt;/param\u0026gt; public Transaction(string transaction) { string[] a = transaction.Split(\u0026#39; \u0026#39;); Who = a[0]; When = new Date(a[1]); Amount = double.Parse(a[2]); } 另请参阅 # Commercial 类\n"},{"id":59,"href":"/1-3-1/","title":"1.3.1","section":"《算法（第四版）》C# 题解","content":" 1.3.1 # 解答 # 首先是 FixedCapacityStackOfStrings 类，官方 JAVA 版本参考：FixedCapacityStackOfStrings.java\nIsFull() 的实现比较简单，判断 N 与数组长度是否相等即可。\n代码 # internal class FixedCapacityStackOfStrings : IEnumerable\u0026lt;string\u0026gt; { private readonly string[] _a; private int _n; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt; public FixedCapacityStackOfStrings(int capacity) { _a = new string[capacity]; _n = 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _n == 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否已满。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsFull() { return _n == _a.Length; } /// \u0026lt;summary\u0026gt; /// 将一个元素压入栈中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt; public void Push(string item) { _a[_n] = item; _n++; } /// \u0026lt;summary\u0026gt; /// 从栈中弹出一个元素，返回被弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string Pop() { _n--; return _a[_n]; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string Peek() { return _a[_n - 1]; } public IEnumerator\u0026lt;string\u0026gt; GetEnumerator() { return new ReverseEnmerator(_a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;string\u0026gt; { private int _current; private string[] _a; public ReverseEnmerator(string[] a) { _current = a.Length; _a = a; } string IEnumerator\u0026lt;string\u0026gt;.Current =\u0026gt; _a[_current]; object IEnumerator.Current =\u0026gt; _a[_current]; void IDisposable.Dispose() { _current = -1; _a = null; } bool IEnumerator.MoveNext() { if (_current == 0) return false; _current--; return true; } void IEnumerator.Reset() { _current = _a.Length; } } } "},{"id":60,"href":"/1-3-2/","title":"1.3.2","section":"《算法（第四版）》C# 题解","content":" 1.3.2 # 解答 # 首先是 Stack\u0026lt;\u0026gt; 类的实现，官方 JAVA 版本参考：Stack.java\n输出内容：was best times of the was the it\n代码 # /// \u0026lt;summary\u0026gt; /// 栈类（链表实现）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;栈中存放的元素类型。\u0026lt;/typeparam\u0026gt; public class Stack\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _first; private int _count; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public Stack() { _first = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 复制构造函数，链表中的元素都是浅拷贝。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;用于复制的栈。\u0026lt;/param\u0026gt; public Stack(Stack\u0026lt;TItem\u0026gt; s) { if (s._first != null) { _first = new Node\u0026lt;TItem\u0026gt;(s._first); for (var x = _first; x.Next != null; x = x.Next) { x.Next = new Node\u0026lt;TItem\u0026gt;(x.Next); } } _count = s._count; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;栈为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则而返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _first == null; } /// \u0026lt;summary\u0026gt; /// 返回栈内元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;栈中元素的数量。\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 将一个元素压入栈中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt; public void Push(TItem item) { var oldFirst = _first; _first = new Node\u0026lt;TItem\u0026gt;(); _first.Item = item; _first.Next = oldFirst; _count++; } /// \u0026lt;summary\u0026gt; /// 将一个元素从栈中弹出，返回弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;被弹出的元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;当栈为空的时候抛出此异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果只需要栈顶的元素，请使用 \u0026lt;see cref=\u0026#34;Peek\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TItem Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); var item = _first.Item; _first = _first.Next; _count--; return item; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;栈顶元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得并删除栈顶元素，请使用 \u0026lt;see cref=\u0026#34;Pop\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return _first.Item; } /// \u0026lt;summary\u0026gt; /// 将两个栈连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个栈。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个栈（将被删除）。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;连接后的栈。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;\u0026lt;paramref name=\u0026#34;s2\u0026#34;/\u0026gt; 将被置为 \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;。\u0026lt;/remarks\u0026gt; public static Stack\u0026lt;TItem\u0026gt; Catenation(Stack\u0026lt;TItem\u0026gt; s1, Stack\u0026lt;TItem\u0026gt; s2) { if (s1.IsEmpty()) { s1._first = s2._first; s1._count = s2._count; } else { var last = s1._first; while (last.Next != null) { last = last.Next; } last.Next = s2._first; s1._count += s2._count; } return s1; } /// \u0026lt;summary\u0026gt; /// 创建栈的浅表副本。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;栈的浅表副本。\u0026lt;/returns\u0026gt; public Stack\u0026lt;TItem\u0026gt; Copy() { var temp = new Stack\u0026lt;TItem\u0026gt;(); temp._first = _first; temp._count = _count; return temp; } /// \u0026lt;summary\u0026gt; /// 将栈中元素转化成字符串，用空格隔开。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;将栈中元素用空格分隔后的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { var s = new StringBuilder(); foreach (var n in this) { s.Append(n); s.Append(\u0026#39; \u0026#39;); } return s.ToString(); } /// \u0026lt;summary\u0026gt; /// 获得栈的枚举器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;当前栈的枚举器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new StackEnumerator(_first); } /// \u0026lt;summary\u0026gt; /// 获得栈的枚举器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;当前栈的枚举器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;该方法实际上调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _current; private Node\u0026lt;TItem\u0026gt; _first; public StackEnumerator(Node\u0026lt;TItem\u0026gt; first) { _current = new Node\u0026lt;TItem\u0026gt;(); _current.Next = first; _first = _current; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; void IDisposable.Dispose() { _current = null; _first = null; } bool IEnumerator.MoveNext() { if (_current.Next == null) return false; _current = _current.Next; return true; } void IEnumerator.Reset() { _current = _first; } } } 另请参阅 # Generics 库\n"},{"id":61,"href":"/1-3-3/","title":"1.3.3","section":"《算法（第四版）》C# 题解","content":" 1.3.3 # 解答 # 这个问题的通用解法见习题 1.3.46 的解答。\n第 2、6、7 个不可能产生，可以画个栈模拟一下。\n第 2 个\n​ 输出数 栈内数 4 0~3 6 0~3 + 5 8 0~3 + 5 + 7 7 0~3 + 5 5 0~3 3 0~2 2 0~1 9 0~1 0 Error 第 6 个\n输出数 栈内数 0 null 4 1~3 6 1~3 + 5 5 1~3 3 1~2 8 1~2 + 7 1 Error 第 7 个\n输出数 栈内数 1 0 4 0 + 2~3 7 0 + 2~3 + 5~6 9 0 + 2~3 + 5~6 + 8 8 0 + 2~3 + 5~6 6 0 + 2~3 + 5 5 0 + 2~3 3 0 + 2 0 Error "},{"id":62,"href":"/1-3-4/","title":"1.3.4","section":"《算法（第四版）》C# 题解","content":" 1.3.4 # 解答 # 官方 JAVA 版本参考：Parentheses.java。\n遇到左括号就入栈，遇到右括号就检查是否和栈顶的左括号匹配，如果匹配则弹栈，否则返回 false。\n结束时如果栈不为空则返回 false，否则返回 true。\n代码 # var input = \u0026#34;[()]{}{[()()]()}\u0026#34;; Console.WriteLine(IsBalanced(input)); var input2 = \u0026#34;[(])\u0026#34;; Console.WriteLine(IsBalanced(input2)); static bool IsBalanced(string input) { var stack = new Stack\u0026lt;char\u0026gt;(); foreach (var i in input) { if (i == \u0026#39;(\u0026#39; || i == \u0026#39;[\u0026#39; || i == \u0026#39;{\u0026#39;) stack.Push(i); else { if (stack.Peek() == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;)\u0026#39;) stack.Pop(); else if (stack.Peek() == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;}\u0026#39;) stack.Pop(); else if (stack.Peek() == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; i == \u0026#39;]\u0026#39;) stack.Pop(); else return false; } } return stack.IsEmpty(); } 另请参阅 # Generics 库\n"},{"id":63,"href":"/1-3-5/","title":"1.3.5","section":"《算法（第四版）》C# 题解","content":" 1.3.5 # 解答 # 实际上是用除二取余法求一个十进制数的二进制形式。\n代码 # var n = 50; var stack = new Stack\u0026lt;int\u0026gt;(); while (n \u0026gt; 0) { stack.Push(n % 2); n = n / 2; } foreach (var d in stack) { Console.WriteLine(d); } Console.WriteLine(); 另请参阅 # Generics 库\n"},{"id":64,"href":"/1-3-6/","title":"1.3.6","section":"《算法（第四版）》C# 题解","content":" 1.3.6 # 解答 # 利用一个栈对队列元素进行反序操作。\n先把队列中的元素全部入栈，再依次弹出并加入队列中。\n代码 # var q = new Queue\u0026lt;string\u0026gt;(); q.Enqueue(\u0026#34;first\u0026#34;); q.Enqueue(\u0026#34;second\u0026#34;); q.Enqueue(\u0026#34;third\u0026#34;); q.Enqueue(\u0026#34;fourth\u0026#34;); var stack = new Stack\u0026lt;string\u0026gt;(); while (!q.IsEmpty()) stack.Push(q.Dequeue()); while (!stack.IsEmpty()) q.Enqueue(stack.Pop()); Console.WriteLine(q.ToString()); 另请参阅 # Generics 库\n"},{"id":65,"href":"/1-3-7/","title":"1.3.7","section":"《算法（第四版）》C# 题解","content":" 1.3.7 # 解答 # 链表实现的话就是返回第一个结点 first 的 item 字段。\n数组实现的话就是返回 first 对应的数组元素。\n这里给出链表实现，完整实现见习题 1.3.2 的代码。\n代码 # /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return this.first.item; } "},{"id":66,"href":"/1-3-8/","title":"1.3.8","section":"《算法（第四版）》C# 题解","content":" 1.3.8 # 解答 # 首先是 DoublingStackOfStrings 类，据我猜测应该是用数组实现的栈，扩容时长度增加一倍，缩短时长度减小一半。\n官方 JAVA 代码参考：FixedCapacityStackOfString.java。\n代码 # DoublingStackOfStrings 类 # /// \u0026lt;summary\u0026gt; /// 容量自动加倍的字符串栈。 /// \u0026lt;/summary\u0026gt; internal class DoublingStackOfStrings : IEnumerable\u0026lt;string\u0026gt; { private string[] _items; private int _count; /// \u0026lt;summary\u0026gt; /// 新建一个字符串栈。 /// \u0026lt;/summary\u0026gt; public DoublingStackOfStrings() { _items = new string[2]; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回栈中字符串的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 向栈中压入一个字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Push(string s) { if (_count == _items.Length) Resize(_items.Length * 2); _items[_count] = s; _count++; } /// \u0026lt;summary\u0026gt; /// 从栈中弹出一个字符串，返回被弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack underflow\u0026#34;); _count--; // 缩小长度 if (_count \u0026gt; 0 \u0026amp;\u0026amp; _count \u0026lt;= _items.Length / 4) Resize(_items.Length / 2); return _items[_count]; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack underflow\u0026#34;); return _items[_count - 1]; } /// \u0026lt;summary\u0026gt; /// 为栈重新分配空间，超出空间的元素将被舍弃。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capcity\u0026#34;\u0026gt;重新分配的空间大小。\u0026lt;/param\u0026gt; private void Resize(int capcity) { var temp = new string[capcity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _items[i]; } _items = temp; } public IEnumerator\u0026lt;string\u0026gt; GetEnumerator() { return new StackEnumerator(_items); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;string\u0026gt; { private int _current; private string[] _items; public StackEnumerator(string[] items) { _items = items; _current = -1; } string IEnumerator\u0026lt;string\u0026gt;.Current =\u0026gt; _items[_current]; object IEnumerator.Current =\u0026gt; _items[_current]; void IDisposable.Dispose() { _items = null; _current = -1; } bool IEnumerator.MoveNext() { if (_current == _items.Length - 1) return false; _current++; return true; } void IEnumerator.Reset() { _current = -1; } } } "},{"id":67,"href":"/1-3-9/","title":"1.3.9","section":"《算法（第四版）》C# 题解","content":" 1.3.9 # 解答 # 在计算中序表达式算法的基础上做修改。\n压入数字时将该数字所在的位置也一并压入。\n弹出数字进行运算时在位置靠前的数字前加上左括号。\nA + B ) * C + D ) ) 为例。\nA 压入栈中并记录位置 。\n\u0026lsquo;+\u0026rsquo; 压入栈中。\nB 压入栈中并记录位置。\n) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置。\n\u0026lsquo;*\u0026rsquo; 压入栈中。\nC 压入栈中并记录位置。\n\u0026lsquo;+\u0026rsquo; 压入栈中。\nD 压入栈中并记录位置。\n) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置。\n) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。\n代码 # var input = \u0026#34;1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )\u0026#34;; var operators = new Stack\u0026lt;char\u0026gt;(); var numbers = new Stack\u0026lt;Number\u0026gt;(); var leftBrackets = new int[input.Length]; for (var i = 0; i \u0026lt; input.Length; i++) { if (input[i] == \u0026#39; \u0026#39;) { } else if (input[i] == \u0026#39;+\u0026#39; || input[i] == \u0026#39;-\u0026#39; || input[i] == \u0026#39;*\u0026#39; || input[i] == \u0026#39;/\u0026#39;) { operators.Push(input[i]); } else if (input[i] == \u0026#39;)\u0026#39;) { var b = numbers.Pop(); var a = numbers.Pop(); var operation = operators.Pop(); var c = new Number { Position = a.Position }; leftBrackets[a.Position]++; switch (operation) { case \u0026#39;+\u0026#39;: c.Value = a.Value + b.Value; break; case \u0026#39;-\u0026#39;: c.Value = a.Value - b.Value; break; case \u0026#39;*\u0026#39;: c.Value = a.Value * b.Value; break; case \u0026#39;/\u0026#39;: c.Value = a.Value / b.Value; break; } numbers.Push(c); } else { var num = new Number { Position = i, Value = input[i] - \u0026#39;0\u0026#39; }; numbers.Push(num); } } for (var i = 0; i \u0026lt; input.Length; i++) { while (leftBrackets[i] != 0) { Console.Write(\u0026#34;( \u0026#34;); leftBrackets[i]--; } Console.Write(input[i]); } internal struct Number { public int Value; public int Position; } 另请参阅 # Generics 库\n"},{"id":68,"href":"/1-3-10/","title":"1.3.10","section":"《算法（第四版）》C# 题解","content":" 1.3.10 # 解答 # 官方 JAVA 代码：InfixToPostfix.java。\n其实就是把右括号换成相应运算符\n对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出\n结果 A B +，变成后序表达式\n代码 # // 其实就是把右括号换成相应运算符 // 对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出 // 结果 A B +，变成后序表达式 var stack = new Stack\u0026lt;string\u0026gt;(); var input = \u0026#34;( 1 + ( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) ) )\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (var n in input) { if (n == \u0026#34; \u0026#34;) { continue; } if (n == \u0026#34;+\u0026#34; || n == \u0026#34;-\u0026#34; || n == \u0026#34;*\u0026#34; || n == \u0026#34;/\u0026#34;) { stack.Push(n); } else if (n == \u0026#34;)\u0026#34;) { Console.Write(stack.Pop() + \u0026#34; \u0026#34;); } else if (n == \u0026#34;(\u0026#34;) { continue; } else { Console.Write(n + \u0026#34; \u0026#34;); } } Console.WriteLine(); 另请参阅 # Generics 库\n"},{"id":69,"href":"/1-3-11/","title":"1.3.11","section":"《算法（第四版）》C# 题解","content":" 1.3.11 # 解答 # 官方 JAVA 代码：EvaluatePostfix.java。\n遇到数字就入栈，遇到运算符就弹出两个数字运算，再把结果入栈。\n如果倒着读取的话也可以用递归做，当作前序表达式计算即可。\n代码 # var stack = new Stack\u0026lt;int\u0026gt;(); var input = \u0026#34;7 16 * 5 + 16 * 3 + 16 * 1 +\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (var n in input) { if (n == \u0026#34; \u0026#34;) { continue; } if (n == \u0026#34;+\u0026#34;) { stack.Push(stack.Pop() + stack.Pop()); } else if (n == \u0026#34;-\u0026#34;) { var temp = stack.Pop(); stack.Push(stack.Pop() - temp); } else if (n == \u0026#34;*\u0026#34;) { stack.Push(stack.Pop() * stack.Pop()); } else if (n == \u0026#34;/\u0026#34;) { var temp = stack.Pop(); stack.Push(stack.Pop() / temp); } else { stack.Push(int.Parse(n)); } } Console.WriteLine(stack.Pop()); 另请参阅 # Generics 库\n"},{"id":70,"href":"/1-3-12/","title":"1.3.12","section":"《算法（第四版）》C# 题解","content":" 1.3.12 # 解答 # 先用 foreach 语句遍历一遍栈，把所有元素都压入一个临时栈中。\n此时临时栈变成了源栈的一个倒序副本。\n再将临时栈中的元素依次压入目标栈中，就得到了源栈的一个副本。\n代码 # var src = new Stack\u0026lt;string\u0026gt;(); src.Push(\u0026#34;first\u0026#34;); src.Push(\u0026#34;second\u0026#34;); src.Push(\u0026#34;third\u0026#34;); var des = CopyTo(src); while (!des.IsEmpty()) { Console.WriteLine(des.Pop()); } static Stack\u0026lt;string\u0026gt; CopyTo(Stack\u0026lt;string\u0026gt; src) { var des = new Stack\u0026lt;string\u0026gt;(); var temp = new Stack\u0026lt;string\u0026gt;(); foreach (var s in src) { temp.Push(s); } while (!temp.IsEmpty()) { des.Push(temp.Pop()); } return des; } 另请参阅 # Generics 库\n"},{"id":71,"href":"/1-3-13/","title":"1.3.13","section":"《算法（第四版）》C# 题解","content":" 1.3.13 # 解答 # 除了第一个以外都不可能。\n根据题意，0 一定是最先入列的。\n那么根据队列的特性，0 一定是最先出列的，因此除第一个以外其他几个序列都不可能。\n"},{"id":72,"href":"/1-3-14/","title":"1.3.14","section":"《算法（第四版）》C# 题解","content":" 1.3.14 # 解答 # 对于 ResizingArrayQueueOfStrings 类，给出官方 JAVA 代码参考：ResizingArrayQueue.java。\n代码 # ResizingArrayQueue 类 # /// \u0026lt;summary\u0026gt; /// 可变长度的队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要存放的元素。\u0026lt;/typeparam\u0026gt; internal class ResizingArrayQueueOfStrings\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private TItem[] _q; private int _count; private int _first; private int _last; public ResizingArrayQueueOfStrings() { _q = new TItem[2]; _count = 0; _first = 0; } public bool IsEmpty() { return _count == 0; } public int Size() { return _count; } private void Resize(int capacity) { if (capacity \u0026lt; 0) throw new ArgumentException(\u0026#34;capacity should be above zero\u0026#34;); var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _q[(_first + i) % _q.Length]; } _q = temp; _first = 0; _last = _count; } public void Enqueue(TItem item) { if (_count == _q.Length) { Resize(_count * 2); } _q[_last] = item; _last++; if (_last == _q.Length) _last = 0; _count++; } public TItem Dequeue() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); var item = _q[_first]; _q[_first] = default; _count--; _first++; if (_first == _q.Length) _first = 0; if (_count \u0026gt; 0 \u0026amp;\u0026amp; _count \u0026lt;= _q.Length / 4) Resize(_q.Length / 2); return item; } public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); return _q[_first]; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new QueueEnumerator(_q, _first, _last); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class QueueEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private int _current; private readonly int _first; private readonly int _last; private readonly TItem[] _q; public QueueEnumerator(TItem[] q, int first, int last) { _current = first - 1; _first = first; _last = last; _q = q; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _q[_current]; object IEnumerator.Current =\u0026gt; _q[_current]; void IDisposable.Dispose() { } bool IEnumerator.MoveNext() { if (_current == _last - 1) return false; _current++; return true; } void IEnumerator.Reset() { _current = _first - 1; } } } Program.cs # var queue = new ResizingArrayQueueOfStrings\u0026lt;string\u0026gt;(); var input = \u0026#34;to be or not to - be - - that - - - is\u0026#34;.Split(\u0026#39; \u0026#39;); foreach (var s in input) { if (!s.Equals(\u0026#34;-\u0026#34;)) queue.Enqueue(s); else if (!queue.IsEmpty()) Console.Write(queue.Dequeue() + \u0026#39; \u0026#39;); } Console.WriteLine(\u0026#34;(\u0026#34; + queue.Size() + \u0026#34; left on queue)\u0026#34;); "},{"id":73,"href":"/1-3-15/","title":"1.3.15","section":"《算法（第四版）》C# 题解","content":" 1.3.15 # 解答 # 方法有很多，只要把所有输入保存，之后算出倒数第 k 个是正数第几个就可以了。\n这里先全部入队，之后算出是正数第几个，再把前面的元素全部出队，剩下的第一个就是要求的元素了。\n代码 # var queue = new Queue\u0026lt;string\u0026gt;(); var input = \u0026#34;1 2 3 4 5 6 7 8 9 10\u0026#34;.Split(\u0026#39; \u0026#39;); var k = 4; foreach (var s in input) { queue.Enqueue(s); } var count = queue.Size() - k; for (var i = 0; i \u0026lt; count; i++) { queue.Dequeue(); } Console.WriteLine(queue.Peek()); 另请参阅 # Generics 库\n"},{"id":74,"href":"/1-3-16/","title":"1.3.16","section":"《算法（第四版）》C# 题解","content":" 1.3.16 # 解答 # 在习题 1.2.19 里已经写好了接受字符串作为参数构造函数\n这里只要把所有字符串读入并调用相应构造函数就可以了。\n代码 # /// \u0026lt;summary\u0026gt; /// 从标准输入按行读取所有日期，返回一个日期数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Date[] ReadDates() { char[] split = new char[] { \u0026#39;\\n\u0026#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Date[] d = new Date[input.Length]; for (int i = 0; i \u0026lt; input.Length; ++i) { d[i] = new Date(input[i]); } return d; } "},{"id":75,"href":"/1-3-17/","title":"1.3.17","section":"《算法（第四版）》C# 题解","content":" 1.3.17 # 解答 # 和前一题类似，按行读取输入再调用相应构造函数就可以了。\n代码 # /// \u0026lt;summary\u0026gt; /// 从标准输入中按行读取所有交易信息，返回一个 Transaction 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Transaction[] ReadTransactions() { char[] split = new char[] { \u0026#39;\\n\u0026#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Transaction[] t = new Transaction[input.Length]; for (int i = 0; i \u0026lt; input.Length; ++i) { t[i] = new Transaction(input[i]); } return t; } "},{"id":76,"href":"/1-3-18/","title":"1.3.18","section":"《算法（第四版）》C# 题解","content":" 1.3.18 # 解答 # 删除该结点的下一个结点。\n如下图，没有任何结点指向 y 结点，失去了所有引用的 y 结点会被 GC 清理掉。\n代码 # var x = new Node\u0026lt;string\u0026gt;(); x.Item = \u0026#34;first\u0026#34;; var y = new Node\u0026lt;string\u0026gt;(); y.Item = \u0026#34;second\u0026#34;; x.Next = y; var z = new Node\u0026lt;string\u0026gt;(); z.Item = \u0026#34;third\u0026#34;; y.Next = z; Console.WriteLine(\u0026#34;x: \u0026#34; + x.Item); Console.WriteLine(\u0026#34;x.next: \u0026#34; + x.Next.Item); x.Next = x.Next.Next; Console.WriteLine(); Console.WriteLine(\u0026#34;x: \u0026#34; + x.Item); Console.WriteLine(\u0026#34;x.next: \u0026#34; + x.Next.Item); 另请参阅 # Generics 库\n"},{"id":77,"href":"/1-3-19/","title":"1.3.19","section":"《算法（第四版）》C# 题解","content":" 1.3.19 # 解答 # 建立一个结点引用 Cur，让它移动到尾结点的前一个结点，让那个结点的 next 变为 null。\n代码 # var first = new Node\u0026lt;string\u0026gt; { Item = \u0026#34;first\u0026#34; }; var second = new Node\u0026lt;string\u0026gt; { Item = \u0026#34;second\u0026#34; }; var third = new Node\u0026lt;string\u0026gt; { Item = \u0026#34;third\u0026#34; }; first.Next = second; second.Next = third; third.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } DeleteLast(first); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } Console.WriteLine(); static void DeleteLast(Node\u0026lt;string\u0026gt; first) { var current = first; while (current.Next.Next != null) { current = current.Next; } current.Next = null; } 另请参阅 # Generics 库\n"},{"id":78,"href":"/1-3-20/","title":"1.3.20","section":"《算法（第四版）》C# 题解","content":" 1.3.20 # 解答 # 和上一题类似，只不过这次让 Cur 移动 k – 1 次即可。\n代码 # /// \u0026lt;summary\u0026gt; /// 删除指定位置的元素，返回该元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;需要删除元素的位置。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public Item Delete(int index) { if (index \u0026gt;= this.count) { throw new IndexOutOfRangeException(); } Node\u0026lt;Item\u0026gt; front = this.first; Item temp = this.first.item; if (index == 0) { this.first = this.first.next; return temp; } for (int i = 1; i \u0026lt; index; ++i) { front = front.next; } temp = front.next.item; front.next = front.next.next; this.count--; return temp; } "},{"id":79,"href":"/1-3-21/","title":"1.3.21","section":"《算法（第四版）》C# 题解","content":" 1.3.21 # 解答 # 遍历整条链表，方法和前两题类似，用一个结点引用 Cur 去访问就可以了。\n代码 # var link = new LinkedList\u0026lt;string\u0026gt;(); link.Insert(\u0026#34;first\u0026#34;, 0); link.Insert(\u0026#34;second\u0026#34;, 1); link.Insert(\u0026#34;third\u0026#34;, 2); Console.WriteLine(Find(link, \u0026#34;second\u0026#34;)); Console.WriteLine(Find(link, \u0026#34;fourth\u0026#34;)); static bool Find\u0026lt;TItem\u0026gt;(LinkedList\u0026lt;TItem\u0026gt; link, TItem key) { foreach (var i in link) { if (i.Equals(key)) { return true; } } return false; } 另请参阅 # Generics 库\n"},{"id":80,"href":"/1-3-22/","title":"1.3.22","section":"《算法（第四版）》C# 题解","content":" 1.3.22 # 解答 # 在 x 之后插入 t，如下图所示。\n代码 # // 将 t 插入到 x 之后 var first = new Node\u0026lt;string\u0026gt;(); var second = new Node\u0026lt;string\u0026gt;(); var third = new Node\u0026lt;string\u0026gt;(); var fourth = new Node\u0026lt;string\u0026gt;(); first.Item = \u0026#34;first\u0026#34;; second.Item = \u0026#34;second\u0026#34;; third.Item = \u0026#34;third\u0026#34;; fourth.Item = \u0026#34;fourth\u0026#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } var t = new Node\u0026lt;string\u0026gt;(); t.Item = \u0026#34;t\u0026#34;; t.Next = second.Next; second.Next = t; Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } 另请参阅 # Generics 库\n"},{"id":81,"href":"/1-3-23/","title":"1.3.23","section":"《算法（第四版）》C# 题解","content":" 1.3.23 # 解答 # 由于先后问题，y 在第一句代码执行完毕之后无法访问，t 的 next 会指向自己。\n代码 # // x.next = t x 的下一个是 t // t.next = x.next t 的下一个和 x 的下一个相同（也就是 t） // 于是 t.next = t, 遍历会出现死循环。 var first = new Node\u0026lt;string\u0026gt;(); var second = new Node\u0026lt;string\u0026gt;(); var third = new Node\u0026lt;string\u0026gt;(); var fourth = new Node\u0026lt;string\u0026gt;(); first.Item = \u0026#34;first\u0026#34;; second.Item = \u0026#34;second\u0026#34;; third.Item = \u0026#34;third\u0026#34;; fourth.Item = \u0026#34;fourth\u0026#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } var t = new Node\u0026lt;string\u0026gt;(); t.Item = \u0026#34;t\u0026#34;; second.Next = t; t.Next = second.Next; Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } 另请参阅 # Generics 库\n"},{"id":82,"href":"/1-3-24/","title":"1.3.24","section":"《算法（第四版）》C# 题解","content":" 1.3.24 # 解答 # 直接把该节点的 next 域设为 null，后续元素就会因无法访问而被清理掉。\n代码 # var first = new Node\u0026lt;string\u0026gt;(); var second = new Node\u0026lt;string\u0026gt;(); var third = new Node\u0026lt;string\u0026gt;(); var fourth = new Node\u0026lt;string\u0026gt;(); first.Item = \u0026#34;first\u0026#34;; second.Item = \u0026#34;second\u0026#34;; third.Item = \u0026#34;third\u0026#34;; fourth.Item = \u0026#34;fourth\u0026#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } RemoveAfter(second); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } static void RemoveAfter\u0026lt;TItem\u0026gt;(Node\u0026lt;TItem\u0026gt; i) { i.Next = null; } 另请参阅 # Generics 库\n"},{"id":83,"href":"/1-3-25/","title":"1.3.25","section":"《算法（第四版）》C# 题解","content":" 1.3.25 # 解答 # 见练习 1.3.22，加入一些对边界情况的处理即可。\n代码 # var first = new Node\u0026lt;string\u0026gt;(); var second = new Node\u0026lt;string\u0026gt;(); var third = new Node\u0026lt;string\u0026gt;(); first.Item = \u0026#34;first\u0026#34;; second.Item = \u0026#34;second\u0026#34;; third.Item = \u0026#34;third\u0026#34;; first.Next = second; second.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } InsertAfter(second, third); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } static void InsertAfter\u0026lt;TItem\u0026gt;(Node\u0026lt;TItem\u0026gt; a, Node\u0026lt;TItem\u0026gt; b) { if (a == null || b == null) return; b.Next = a.Next; a.Next = b; } 另请参阅 # Generics 库\n"},{"id":84,"href":"/1-3-26/","title":"1.3.26","section":"《算法（第四版）》C# 题解","content":" 1.3.26 # 解答 # 之前已经写过了删除指定结点（习题 1.3.20）和查找指定结点（习题 1.3.21），结合使用即可。\n代码 # var link = new LinkedList\u0026lt;string\u0026gt;(); link.Insert(\u0026#34;first\u0026#34;, 0); link.Insert(\u0026#34;second\u0026#34;, 1); link.Insert(\u0026#34;third\u0026#34;, 2); link.Insert(\u0026#34;third\u0026#34;, 3); link.Insert(\u0026#34;third\u0026#34;, 4); Console.WriteLine(link); Remove(link, \u0026#34;third\u0026#34;); Console.WriteLine(link); static void Remove(LinkedList\u0026lt;string\u0026gt; link, string key) { for (var i = 0; i \u0026lt; link.Size(); i++) { if (link.Find(i) == key) { link.Delete(i); i--; } } } 另请参阅 # Generics 库\n"},{"id":85,"href":"/1-3-27/","title":"1.3.27","section":"《算法（第四版）》C# 题解","content":" 1.3.27 # 解答 # 遍历一遍即可。\n代码 # var first = new Node\u0026lt;int\u0026gt;(); var second = new Node\u0026lt;int\u0026gt;(); var third = new Node\u0026lt;int\u0026gt;(); var fourth = new Node\u0026lt;int\u0026gt;(); first.Item = 1; second.Item = 2; third.Item = 3; fourth.Item = 4; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; Console.WriteLine(\u0026#34;Max:\u0026#34; + Max(first)); static int Max(Node\u0026lt;int\u0026gt; first) { var max = 0; var current = first; while (current != null) { if (max \u0026lt; current.Item) { max = current.Item; } current = current.Next; } return max; } 另请参阅 # Generics 库\n"},{"id":86,"href":"/1-3-28/","title":"1.3.28","section":"《算法（第四版）》C# 题解","content":" 1.3.28 # 解答 # 其实链表本身就是一个递归结构，链表的定义可以用递归的方式表示：\n链表 = 头结点A + 链表B = 头结点A + 头结点B + 链表C……\n所以 Max() 可以这么写：\nMax(Node\u0026lt;Item\u0026gt; Cur, int nowmax) 如果 Cur 为空，则直接返回 nowmax。 否则检查 Cur 结点的值是否大于目前找到的最大值 nowmax。 如果不大于，继续查找下一个结点，返回 Max(Cur.next, nowmax) 否则，把 nowmax 修改为当前结点的值，继续查找，返回 Max(Cur.next, Cur.item) 代码 # var first = new Node\u0026lt;int\u0026gt;(); var second = new Node\u0026lt;int\u0026gt;(); var third = new Node\u0026lt;int\u0026gt;(); var fourth = new Node\u0026lt;int\u0026gt;(); first.Item = 1; second.Item = 2; third.Item = 3; fourth.Item = 4; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; Console.WriteLine(\u0026#34;Max:\u0026#34; + Max(first)); static int Max(Node\u0026lt;int\u0026gt; first, int max = 0) { if (first == null) return max; if (max \u0026lt; first.Item) return Max(first.Next, first.Item); return Max(first.Next, max); } 另请参阅 # Generics 库\n"},{"id":87,"href":"/1-3-29/","title":"1.3.29","section":"《算法（第四版）》C# 题解","content":" 1.3.29 # 解答 # 其实就是一个长这样的链表：\n显然说 first 和最后一个节点的指针重复了，所以我们只需要保留 last 的指针就行了。\n入队（注意顺序）\n出队\n代码 # Queue.cs # /// \u0026lt;summary\u0026gt; /// 队列类。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中存放的元素。\u0026lt;/typeparam\u0026gt; public class Queue\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _last; private int _count; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public Queue() { _last = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _last == null; } /// \u0026lt;summary\u0026gt; /// 返回队列中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 返回队列中的第一个元素（但不让它出队）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); return _last.Next.Item; } /// \u0026lt;summary\u0026gt; /// 将一个新元素加入队列中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { var oldLast = _last; _last = new Node\u0026lt;TItem\u0026gt;(); _last.Item = item; _last.Next = _last; if (oldLast != null) { _last.Next = oldLast.Next; oldLast.Next = _last; } _count++; } /// \u0026lt;summary\u0026gt; /// 将队列中的第一个元素出队并返回它。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Dequeue() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Queue underflow\u0026#34;); var item = _last.Next.Item; _last.Next = _last.Next.Next; _count--; if (IsEmpty()) _last = null; return item; } public override string ToString() { var s = new StringBuilder(); foreach (var item in this) { s.Append(item); s.Append(\u0026#34; \u0026#34;); } return s.ToString(); } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new QueueEnumerator(_last); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class QueueEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _current; private Node\u0026lt;TItem\u0026gt; _first; public QueueEnumerator(Node\u0026lt;TItem\u0026gt; last) { _current = new Node\u0026lt;TItem\u0026gt;(); _current.Next = last.Next; _first = _current; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; void IDisposable.Dispose() { _first = null; _current = null; } bool IEnumerator.MoveNext() { if (_current.Next == _first.Next) return false; _current = _current.Next; return true; } void IEnumerator.Reset() { _current = _first; } } } public class Node\u0026lt;TItem\u0026gt; { public TItem Item; public Node\u0026lt;TItem\u0026gt; Next; } Program.cs # var input = \u0026#34;to be or not to - be - - that - - - is\u0026#34;; var s = input.Split(\u0026#39; \u0026#39;); var queue = new Queue\u0026lt;string\u0026gt;(); foreach (var n in s) { if (!n.Equals(\u0026#34;-\u0026#34;)) queue.Enqueue(n); else if (!queue.IsEmpty()) Console.WriteLine(queue.Dequeue()); } Console.WriteLine($\u0026#34;({queue.Size()}) left on queue\u0026#34;); Console.WriteLine(queue); "},{"id":88,"href":"/1-3-30/","title":"1.3.30","section":"《算法（第四版）》C# 题解","content":" 1.3.30 # 解答 # 书中给出了代码，这里说一下递归的实现。\n如果说一个链表除了第一个结点剩下的都已经反转了，那么我们就只要把该结点插入到最后就行了（也就是原先的第二个结点之后）。\n像这样：\n代码 # var first = new Node\u0026lt;string\u0026gt;(); var second = new Node\u0026lt;string\u0026gt;(); var third = new Node\u0026lt;string\u0026gt;(); var fourth = new Node\u0026lt;string\u0026gt;(); first.Item = \u0026#34;first\u0026#34;; second.Item = \u0026#34;second\u0026#34;; third.Item = \u0026#34;third\u0026#34;; fourth.Item = \u0026#34;fourth\u0026#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } first = Reverse(first); Console.WriteLine(); current = first; while (current != null) { Console.Write(current.Item + \u0026#34; \u0026#34;); current = current.Next; } // 使用书中的递归方式实现 static Node\u0026lt;TItem\u0026gt; Reverse\u0026lt;TItem\u0026gt;(Node\u0026lt;TItem\u0026gt; first) { if (first == null) return null; if (first.Next == null) return first; var second = first.Next; var rest = Reverse(second); second.Next = first; first.Next = null; return rest; } 另请参阅 # Generics 库\n"},{"id":89,"href":"/1-3-31/","title":"1.3.31","section":"《算法（第四版）》C# 题解","content":" 1.3.31 # 解答 # 双向链表的插入有顺序，务必当心。\n双向链表长这样（似乎有一种画法是把空指针画成“接地”的样子）：\n删除中间那个：\n再插回去：\n原则是不要让有用的结点变得无法访问。\n代码 # DoubleNode\u0026lt;\u0026gt; # /// \u0026lt;summary\u0026gt; /// 双向链表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;链表中要存放的元素。\u0026lt;/typeparam\u0026gt; public class DoubleLinkList\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T Item; public DoubleNode\u0026lt;T\u0026gt; Prev; public DoubleNode\u0026lt;T\u0026gt; Next; } private DoubleNode\u0026lt;TItem\u0026gt; _first; private DoubleNode\u0026lt;TItem\u0026gt; _last; private int _count; /// \u0026lt;summary\u0026gt; /// 建立一条双向链表。 /// \u0026lt;/summary\u0026gt; public DoubleLinkList() { _first = null; _last = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查链表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回链表中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 在表头插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; public void InsertFront(TItem item) { var node = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Next = _first, Prev = null }; if (_first != null) { _first.Prev = node; } else { _last = node; } _first = node; _count++; } /// \u0026lt;summary\u0026gt; /// 在表尾插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入表尾的元素。\u0026lt;/param\u0026gt; public void InsertRear(TItem item) { var node = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Next = null, Prev = _last }; if (_last != null) { _last.Next = node; } else { _first = node; } _last = node; _count++; } /// \u0026lt;summary\u0026gt; /// 检索指定下标的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要检索的下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem At(int index) { if (index \u0026gt;= _count || index \u0026lt; 0) throw new IndexOutOfRangeException(); var current = _first; for (var i = 0; i \u0026lt; index; i++) { current = current.Next; } return current.Item; } /// \u0026lt;summary\u0026gt; /// 返回指定下标的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要查找的下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private DoubleNode\u0026lt;TItem\u0026gt; Find(int index) { if (index \u0026gt;= _count || index \u0026lt; 0) throw new IndexOutOfRangeException(); var current = _first; for (var i = 0; i \u0026lt; index; i++) { current = current.Next; } return current; } /// \u0026lt;summary\u0026gt; /// 在指定位置之前插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;插入位置的下标。\u0026lt;/param\u0026gt; public void InsertBefore(TItem item, int index) { if (index == 0) { InsertFront(item); return; } if (index \u0026gt;= _count || index \u0026lt; 0) throw new IndexOutOfRangeException(); var current = Find(index); var node = new DoubleNode\u0026lt;TItem\u0026gt; { Next = current, Prev = current.Prev, Item = item }; current.Prev.Next = node; current.Prev = node; _count++; } /// \u0026lt;summary\u0026gt; /// 在指定位置之后插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;查找元素的下标。\u0026lt;/param\u0026gt; public void InsertAfter(TItem item, int index) { if (index == _count - 1) { InsertRear(item); return; } if (index \u0026gt;= _count || index \u0026lt; 0) throw new IndexOutOfRangeException(); var current = Find(index); var node = new DoubleNode\u0026lt;TItem\u0026gt; { Prev = current, Next = current.Next, Item = item }; current.Next.Prev = node; current.Next = node; _count++; } /// \u0026lt;summary\u0026gt; /// 删除表头元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem DeleteFront() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;List underflow\u0026#34;); var temp = _first.Item; _first = _first.Next; _count--; if (IsEmpty()) { _last = null; } else { _first.Prev = null; } return temp; } /// \u0026lt;summary\u0026gt; /// 删除表尾的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem DeleteRear() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;List underflow\u0026#34;); var temp = _last.Item; _last = _last.Prev; _count--; if (IsEmpty()) { _first = null; } else { _last.Next = null; } return temp; } /// \u0026lt;summary\u0026gt; /// 删除指定位置的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要删除元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Delete(int index) { if (index \u0026lt; 0 || index \u0026gt;= _count) throw new IndexOutOfRangeException(); if (index == 0) { return DeleteFront(); } if (index == _count - 1) { return DeleteRear(); } var current = Find(index); var temp = current.Item; current.Prev.Next = current.Next; current.Next.Prev = current.Prev; _count--; return temp; } public override string ToString() { var s = new StringBuilder(); foreach (var i in this) { s.Append(i.ToString()); s.Append(\u0026#34; \u0026#34;); } return s.ToString(); } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new DoubleLinkListEnumerator(_first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DoubleLinkListEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private DoubleNode\u0026lt;TItem\u0026gt; _current; private DoubleNode\u0026lt;TItem\u0026gt; _first; public DoubleLinkListEnumerator(DoubleNode\u0026lt;TItem\u0026gt; first) { _current = new DoubleNode\u0026lt;TItem\u0026gt;(); _current.Next = first; _first = _current; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; void IDisposable.Dispose() { _current = null; _first = null; } bool IEnumerator.MoveNext() { if (_current.Next == null) return false; _current = _current.Next; return true; } void IEnumerator.Reset() { _current = _first; } } } Program.cs # var linklist = new DoubleLinkList\u0026lt;string\u0026gt;(); linklist.InsertRear(\u0026#34;fourth\u0026#34;); linklist.InsertFront(\u0026#34;first\u0026#34;); linklist.InsertAfter(\u0026#34;second\u0026#34;, 0); linklist.InsertBefore(\u0026#34;third\u0026#34;, 2); Console.WriteLine(linklist); linklist.DeleteFront(); Console.WriteLine(linklist); linklist.DeleteRear(); Console.WriteLine(linklist); linklist.Delete(1); Console.WriteLine(linklist); Console.WriteLine(linklist.At(0)); "},{"id":90,"href":"/1-3-32/","title":"1.3.32","section":"《算法（第四版）》C# 题解","content":" 1.3.32 # 解答 # 在队列的基础上增加一个在队首插入元素的方法即可。\n代码 # Steque.cs # /// \u0026lt;summary\u0026gt; /// Steque。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;Steque 中要存放的元素。\u0026lt;/typeparam\u0026gt; public class Steque\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _first; private Node\u0026lt;TItem\u0026gt; _last; private int _count; private class Node\u0026lt;T\u0026gt; { public T Item; public Node\u0026lt;T\u0026gt; Next; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public Steque() { _first = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回栈内元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 将一个元素压入栈中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt; public void Push(TItem item) { var oldFirst = _first; _first = new Node\u0026lt;TItem\u0026gt;(); _first.Item = item; _first.Next = oldFirst; if (oldFirst == null) { _last = _first; } _count++; } /// \u0026lt;summary\u0026gt; /// 将一个元素从栈中弹出，返回弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Pop() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); var item = _first.Item; _first = _first.Next; _count--; if (_count == 0) { _last = null; } return item; } /// \u0026lt;summary\u0026gt; /// 将一个元素加入队列中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { var oldLast = _last; _last = new Node\u0026lt;TItem\u0026gt;(); _last.Item = item; _last.Next = null; if (IsEmpty()) _first = _last; else oldLast.Next = _last; _count++; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Stack Underflow\u0026#34;); return _first.Item; } public override string ToString() { var s = new StringBuilder(); foreach (var n in this) { s.Append(n); s.Append(\u0026#39; \u0026#39;); } return s.ToString(); } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new StackEnumerator(_first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class StackEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private Node\u0026lt;TItem\u0026gt; _current; private Node\u0026lt;TItem\u0026gt; _first; public StackEnumerator(Node\u0026lt;TItem\u0026gt; first) { _current = new Node\u0026lt;TItem\u0026gt;(); _current.Next = first; _first = _current; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; void IDisposable.Dispose() { _current = null; _first = null; } bool IEnumerator.MoveNext() { if (_current.Next == null) return false; _current = _current.Next; return true; } void IEnumerator.Reset() { _current = _first; } } } program.cs # // 见 Steque.cs var steque = new Steque\u0026lt;string\u0026gt;(); steque.Push(\u0026#34;first\u0026#34;); steque.Push(\u0026#34;second\u0026#34;); steque.Push(\u0026#34;third\u0026#34;); steque.Enqueue(\u0026#34;fourth\u0026#34;); Console.WriteLine(steque.ToString()); steque.Pop(); steque.Pop(); steque.Pop(); steque.Pop(); Console.WriteLine(steque.ToString()); steque.Enqueue(\u0026#34;first\u0026#34;); steque.Push(\u0026#34;zero\u0026#34;); Console.WriteLine(steque.ToString()); "},{"id":91,"href":"/1-3-33/","title":"1.3.33","section":"《算法（第四版）》C# 题解","content":" 1.3.33 # 解答 # 动态数组这里要注意 first 不要小于零。\n代码 # Deque 类 # /// \u0026lt;summary\u0026gt; /// 双端队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要存放的元素。\u0026lt;/typeparam\u0026gt; public class Deque\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T Item; public DoubleNode\u0026lt;T\u0026gt; Next; public DoubleNode\u0026lt;T\u0026gt; Prev; } private DoubleNode\u0026lt;TItem\u0026gt; _first; private DoubleNode\u0026lt;TItem\u0026gt; _last; private int _count; /// \u0026lt;summary\u0026gt; /// 默认构造函数，建立一个双端队列。 /// \u0026lt;/summary\u0026gt; public Deque() { _first = null; _last = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回队列中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 向左端添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.Prev = _first; } _count++; } /// \u0026lt;summary\u0026gt; /// 向右端添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt; public void PushRight(TItem item) { var oldLast = _last; _last = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Prev = oldLast, Next = null }; if (oldLast == null) { _first = _last; } else { oldLast.Next = _last; } _count++; } /// \u0026lt;summary\u0026gt; /// 从右端删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopRight() { if (IsEmpty()) { throw new InvalidOperationException(); } var temp = _last.Item; _last = _last.Prev; _count--; if (_last == null) { _first = null; } else { _last.Next.Item = default; _last.Next = null; } return temp; } /// \u0026lt;summary\u0026gt; /// 从左端删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopLeft() { if (IsEmpty()) { throw new InvalidOperationException(); } var temp = _first.Item; _first = _first.Next; _count--; if (_first == null) { _last = null; } else { _first.Prev.Item = default; _first.Prev = null; } return temp; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new DequeEnumerator(_first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DequeEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private DoubleNode\u0026lt;TItem\u0026gt; _current; private DoubleNode\u0026lt;TItem\u0026gt; _first; public DequeEnumerator(DoubleNode\u0026lt;TItem\u0026gt; first) { _current = new DoubleNode\u0026lt;TItem\u0026gt;(); _current.Next = first; _current.Prev = null; _first = _current; } public TItem Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; public void Dispose() { _current = null; _first = null; } public bool MoveNext() { if (_current.Next == null) return false; _current = _current.Next; return true; } public void Reset() { _current = _first; } } } ResizingArrayDeque 类 # /// \u0026lt;summary\u0026gt; /// 可自动扩容的双端队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要存放的元素。\u0026lt;/typeparam\u0026gt; public class ResizingArrayDeque\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private TItem[] _deque; private int _first; private int _last; private int _count; /// \u0026lt;summary\u0026gt; /// 默认构造函数，建立一个双向队列。 /// \u0026lt;/summary\u0026gt; public ResizingArrayDeque() { _deque = new TItem[2]; _first = 0; _last = 0; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回队列中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 为队列重新分配空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;需要重新分配的空间大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { if (capacity \u0026lt;= 0) throw new ArgumentException(); var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _deque[(_first + i) % _deque.Length]; } _deque = temp; _first = 0; _last = _count; } /// \u0026lt;summary\u0026gt; /// 在队列左侧添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素\u0026lt;/param\u0026gt; public void PushLeft(TItem item) { if (_count == _deque.Length) { Resize(2 * _count); } _first--; if (_first \u0026lt; 0) { _first += _deque.Length; } _deque[_first] = item; _count++; } public void PushRight (TItem item) { if (_count == _deque.Length) { Resize(2 * _count); } _deque[_last] = item; _last = (_last + 1) % _deque.Length; _count++; } public TItem PopRight() { if (IsEmpty()) { throw new InvalidOperationException(); } _last--; if (_last \u0026lt; 0) { _last += _deque.Length; } var temp = _deque[_last]; _count--; if (_count \u0026gt; 0 \u0026amp;\u0026amp; _count == _deque.Length / 4) Resize(_deque.Length / 2); return temp; } public TItem PopLeft() { if (IsEmpty()) throw new ArgumentException(); var temp = _deque[_first]; _first = (_first + 1) % _deque.Length; _count--; if (_count \u0026gt; 0 \u0026amp;\u0026amp; _count == _deque.Length / 4) { Resize(_deque.Length / 2); } return temp; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new ResizingDequeEnumerator(_deque, _first, _count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ResizingDequeEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private TItem[] _deque; private int _current; private readonly int _first; private readonly int _count; public ResizingDequeEnumerator(TItem[] deque, int first, int count) { _deque = deque; _first = first; _count = count; _current = -1; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _deque[(_first + _current) % _deque.Length]; object IEnumerator.Current =\u0026gt; _deque[(_first + _current) % _deque.Length]; void IDisposable.Dispose() { _deque = null; _current = -1; } bool IEnumerator.MoveNext() { if (_current == _count - 1) { return false; } _current++; return true; } void IEnumerator.Reset() { _current = -1; } } } Program.cs # var a = new Deque\u0026lt;string\u0026gt;(); var b = new ResizingArrayDeque\u0026lt;string\u0026gt;(); a.PushLeft(\u0026#34;first\u0026#34;); b.PushLeft(\u0026#34;first\u0026#34;); a.PushRight(\u0026#34;second\u0026#34;); b.PushRight(\u0026#34;second\u0026#34;); Display(a, b); a.PopLeft(); b.PopLeft(); Display(a, b); a.PopRight(); b.PopRight(); Display(a, b); static void Display(Deque\u0026lt;string\u0026gt; a, ResizingArrayDeque\u0026lt;string\u0026gt; b) { foreach (var s in a) { Console.Write(s + \u0026#34; \u0026#34;); } Console.WriteLine(); foreach (var s in b) { Console.Write(s + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(); } "},{"id":92,"href":"/1-3-34/","title":"1.3.34","section":"《算法（第四版）》C# 题解","content":" 1.3.34 # 解答 # 在初始化迭代器的时候随机生成一个访问序列，\n之后按照这个访问序列进行迭代即可。\n代码 # RandomBag.cs # /// \u0026lt;summary\u0026gt; /// 随机背包。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;背包中要存放的元素。\u0026lt;/typeparam\u0026gt; public class RandomBag\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private TItem[] _bag; private int _count; /// \u0026lt;summary\u0026gt; /// 建立一个随机背包。 /// \u0026lt;/summary\u0026gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查背包是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回背包中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 向背包中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向背包中添加的元素。\u0026lt;/param\u0026gt; public void Add(TItem item) { if (_count == _bag.Length) { Resize(_count * 2); } _bag[_count] = item; _count++; } /// \u0026lt;summary\u0026gt; /// 重新为背包分配内存空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Resize(int capacity) { if (capacity \u0026lt;= 0) throw new ArgumentException(); var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _bag[i]; } _bag = temp; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new RandomBagEnumerator(_bag, _count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class RandomBagEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private TItem[] _bag; private int[] _sequence; private int _current; private readonly int _count; public RandomBagEnumerator(TItem[] bag, int count) { _bag = bag; _current = -1; _count = count; _sequence = new int[count]; for (var i = 0; i \u0026lt; _count; i++) { _sequence[i] = i; } Shuffle(_sequence, DateTime.Now.Millisecond); } /// \u0026lt;summary\u0026gt; /// 随机打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子值。\u0026lt;/param\u0026gt; private void Shuffle(int[] a, int seed) { var n = a.Length; var random = new Random(seed); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _bag[_sequence[_current]]; object IEnumerator.Current =\u0026gt; _bag[_sequence[_current]]; void IDisposable.Dispose() { _bag = null; _sequence = null; _current = -1; } bool IEnumerator.MoveNext() { if (_current == _count - 1) return false; _current++; return true; } void IEnumerator.Reset() { _current = -1; } } } "},{"id":93,"href":"/1-3-35/","title":"1.3.35","section":"《算法（第四版）》C# 题解","content":" 1.3.35 # 解答 # 事实上只需要在普通队列的基础上稍作修改就可以了。\n出队时先随机选择一个元素，之后让它和最开始的元素做交换，之后正常出队即可。\n代码 # RandomQueue.cs # /// \u0026lt;summary\u0026gt; /// 随机队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要存放的元素。\u0026lt;/typeparam\u0026gt; public class RandomQueue\u0026lt;TItem\u0026gt; { private TItem[] _queue; private int _count; /// \u0026lt;summary\u0026gt; /// 新建一个随机队列。 /// \u0026lt;/summary\u0026gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// \u0026lt;summary\u0026gt; /// 判断队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 为队列重新分配内存空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Resize(int capacity) { if (capacity \u0026lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// \u0026lt;summary\u0026gt; /// 向队列中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向队列中添加的元素。\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { if (_queue.Length == _count) { Resize(_count * 2); } _queue[_count] = item; _count++; } /// \u0026lt;summary\u0026gt; /// 从队列中随机删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Dequeue() { if (IsEmpty()) { throw new InvalidOperationException(); } var random = new Random(DateTime.Now.Millisecond); var index = random.Next(_count); var temp = _queue[index]; _queue[index] = _queue[_count - 1]; _queue[_count - 1] = temp; _count--; if (_count \u0026lt; _queue.Length / 4) { Resize(_queue.Length / 2); } return temp; } /// \u0026lt;summary\u0026gt; /// 随机返回一个队列中的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Sample() { if (IsEmpty()) { throw new InvalidOperationException(); } var random = new Random(); var index = random.Next(_count); return _queue[index]; } } "},{"id":94,"href":"/1-3-36/","title":"1.3.36","section":"《算法（第四版）》C# 题解","content":" 1.3.36 # 解答 # 实现方法和 1.3.34 类似，初始化迭代器的时候同时初始化一个随机访问序列。\n代码 # RandomQueue.cs # /// \u0026lt;summary\u0026gt; /// 随机队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要保存的元素。\u0026lt;/typeparam\u0026gt; public class RandomQueue\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private TItem[] _queue; private int _count; /// \u0026lt;summary\u0026gt; /// 新建一个随机队列。 /// \u0026lt;/summary\u0026gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// \u0026lt;summary\u0026gt; /// 判断队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 为队列重新分配内存空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Resize(int capacity) { if (capacity \u0026lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// \u0026lt;summary\u0026gt; /// 向队列中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向队列中添加的元素。\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { if (_queue.Length == _count) { Resize(_count * 2); } _queue[_count] = item; _count++; } /// \u0026lt;summary\u0026gt; /// 从队列中随机删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Dequeue() { if (IsEmpty()) { throw new InvalidOperationException(); } var random = new Random(DateTime.Now.Millisecond); var index = random.Next(_count); var temp = _queue[index]; _queue[index] = _queue[_count - 1]; _queue[_count - 1] = temp; _count--; if (_count \u0026lt; _queue.Length / 4) { Resize(_queue.Length / 2); } return temp; } /// \u0026lt;summary\u0026gt; /// 随机返回一个队列中的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Sample() { if (IsEmpty()) { throw new InvalidOperationException(); } var random = new Random(); var index = random.Next(_count); return _queue[index]; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new RandomQueueEnumerator(_queue, _count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class RandomQueueEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private int _current; private readonly int _count; private TItem[] _queue; private int[] _sequence; public RandomQueueEnumerator(TItem[] queue, int count) { _count = count; _queue = queue; _current = -1; _sequence = new int[_count]; for (var i = 0; i \u0026lt; _count; i++) { _sequence[i] = i; } Shuffle(_sequence, DateTime.Now.Millisecond); } /// \u0026lt;summary\u0026gt; /// 随机打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子值。\u0026lt;/param\u0026gt; private void Shuffle(int[] a, int seed) { var n = a.Length; var random = new Random(seed); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _queue[_sequence[_current]]; object IEnumerator.Current =\u0026gt; _queue[_sequence[_current]]; void IDisposable.Dispose() { _current = -1; _sequence = null; _queue = null; } bool IEnumerator.MoveNext() { if (_current == _count - 1) return false; _current++; return true; } void IEnumerator.Reset() { _current = -1; } } } "},{"id":95,"href":"/1-3-37/","title":"1.3.37","section":"《算法（第四版）》C# 题解","content":" 1.3.37 # 解答 # 也就是约瑟夫问题，官方给出的 JAVA 版答案：Josephus.java。\n报数时将一个人出队然后入队来模拟一个环。\n报到 M 个后将那个人出队但不入队（删除）\n随后继续循环。\n代码 # var numOfPeople = 7; var callForDeath = 2; var queue = new Queue\u0026lt;int\u0026gt;(); for (var i = 0; i \u0026lt; numOfPeople; i++) { queue.Enqueue(i); } while (!queue.IsEmpty()) { for (var i = 0; i \u0026lt; callForDeath - 1; i++) { queue.Enqueue(queue.Dequeue()); } Console.Write(queue.Dequeue() + \u0026#34; \u0026#34;); } Console.WriteLine(); 另请参阅 # Generics 库\n约瑟夫问题-维基百科——给出了约瑟夫问题的数学通解\n"},{"id":96,"href":"/1-3-38/","title":"1.3.38","section":"《算法（第四版）》C# 题解","content":" 1.3.38 # 解答 # 这里采用“假删除”的方式，对要删除的元素不直接删除而是打上标记，这样就可以维持插入的顺序。\n代码 # 数组实现 # /// \u0026lt;summary\u0026gt; /// 以一维数组为基础的队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要保存的元素。\u0026lt;/typeparam\u0026gt; internal class ArrayBasedGeneralizeQueue\u0026lt;TItem\u0026gt; { private TItem[] _queue; private bool[] _isVisited; private int _count; private int _last; /// \u0026lt;summary\u0026gt; /// 建立一个队列。 /// \u0026lt;/summary\u0026gt; public ArrayBasedGeneralizeQueue() { _queue = new TItem[2]; _isVisited = new bool[2]; _last = 0; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 为队列重新分配空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Resize(int capacity) { var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; var t = new bool[capacity]; for (var i = 0; i \u0026lt; _count; i++) { t[i] = _isVisited[i]; } _isVisited = t; } /// \u0026lt;summary\u0026gt; /// 向队列中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入队列的元素。\u0026lt;/param\u0026gt; public void Insert(TItem item) { if (_count == _queue.Length) { Resize(_queue.Length * 2); } _queue[_last] = item; _isVisited[_last] = false; _last++; _count++; } /// \u0026lt;summary\u0026gt; /// 从队列中删除并返回第 k 个插入的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要删除元素的顺序（从 1 开始）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Delete(int k) { if (IsEmpty()) { throw new InvalidOperationException(); } if (k \u0026gt; _last || k \u0026lt; 0) { throw new ArgumentOutOfRangeException(); } if (_isVisited[k - 1]) { throw new ArgumentException(\u0026#34;this node had been already deleted\u0026#34;); } var temp = _queue[k - 1]; _isVisited[k - 1] = true; _count--; return temp; } } 链表实现 # /// \u0026lt;summary\u0026gt; /// 以链表为基础的队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;队列中要保存的元素。\u0026lt;/typeparam\u0026gt; internal class LinkedListBasedGeneralizeQueue\u0026lt;TItem\u0026gt; { private class Node\u0026lt;T\u0026gt; { public T Item; public Node\u0026lt;T\u0026gt; Next; public bool IsVisited; } private Node\u0026lt;TItem\u0026gt; _first; private Node\u0026lt;TItem\u0026gt; _last; private int _count; /// \u0026lt;summary\u0026gt; /// 建立一个队列。 /// \u0026lt;/summary\u0026gt; public LinkedListBasedGeneralizeQueue() { _first = null; _last = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查数组是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _first == null; } /// \u0026lt;summary\u0026gt; /// 在队尾插入元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TItem item) { var oldLast = _last; _last = new Node\u0026lt;TItem\u0026gt; { Item = item, IsVisited = false, Next = null }; if (oldLast == null) { _first = _last; } else { oldLast.Next = _last; } _count++; } /// \u0026lt;summary\u0026gt; /// 删除第 k 个插入的结点 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;结点序号（从 1 开始）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Delete(int k) { if (k \u0026gt; _count || k \u0026lt;= 0) { throw new ArgumentOutOfRangeException(); } k--; // 找到目标结点 var current = _first; for (var i = 0; i \u0026lt; k; i++) { current = current.Next; } if (current.IsVisited) { throw new ArgumentException(\u0026#34;this node had been already deleted\u0026#34;); } current.IsVisited = true; return current.Item; } } "},{"id":97,"href":"/1-3-39/","title":"1.3.39","section":"《算法（第四版）》C# 题解","content":" 1.3.39 # 解答 # 可以直接套用队列的实现方式，在满或空时抛出相应异常。\n代码 # /// \u0026lt;summary\u0026gt; /// 环形缓冲区。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;缓冲区包含的元素类型。\u0026lt;/typeparam\u0026gt; internal class RingBuffer\u0026lt;TItem\u0026gt; { private readonly TItem[] _buffer; private int _count; private int _first; // 读指针 private int _last; // 写指针 /// \u0026lt;summary\u0026gt; /// 建立一个缓冲区。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;缓冲区的大小。\u0026lt;/param\u0026gt; public RingBuffer(int n) { _buffer = new TItem[n]; _count = 0; _first = 0; _last = 0; } /// \u0026lt;summary\u0026gt; /// 检查缓冲区是否已满。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsFull() { return _count == _buffer.Length; } /// \u0026lt;summary\u0026gt; /// 检查缓冲区是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 向缓冲区写入数据。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要写入的数据。\u0026lt;/param\u0026gt; public void Write(TItem item) { if (IsFull()) { throw new OutOfMemoryException(\u0026#34;buffer is full\u0026#34;); } _buffer[_last] = item; _last = (_last + 1) % _buffer.Length; _count++; } /// \u0026lt;summary\u0026gt; /// 从缓冲区读取一个数据。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Read() { if (IsEmpty()) { throw new InvalidOperationException(); } var temp = _buffer[_first]; _first = (_first + 1) % _buffer.Length; _count--; return temp; } } "},{"id":98,"href":"/1-3-40/","title":"1.3.40","section":"《算法（第四版）》C# 题解","content":" 1.3.40 # 解答 # 每次插入时都先搜索一遍链表，再判定相应动作。\n代码 # /// \u0026lt;summary\u0026gt; /// 前移编码队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TItem\u0026#34;\u0026gt;需要前移编码的元素类型。\u0026lt;/typeparam\u0026gt; internal class MoveToFront\u0026lt;TItem\u0026gt; { private class Node\u0026lt;T\u0026gt; { public T Item; public Node\u0026lt;T\u0026gt; Next; } private Node\u0026lt;TItem\u0026gt; _first; private int _count; /// \u0026lt;summary\u0026gt; /// 检查编码组是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _first == null; } /// \u0026lt;summary\u0026gt; /// 建立一个前移编码组。 /// \u0026lt;/summary\u0026gt; public MoveToFront() { _first = null; _count = 0; } /// \u0026lt;summary\u0026gt; /// 找到相应元素的前驱结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要寻找的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private Node\u0026lt;TItem\u0026gt; Find(TItem item) { if (IsEmpty()) { return null; } var current = _first; while (current.Next != null) { if (current.Next.Item.Equals(item)) { return current; } current = current.Next; } return null; } /// \u0026lt;summary\u0026gt; /// 前移编码插入。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TItem item) { var temp = Find(item); if (temp == null) { temp = new Node\u0026lt;TItem\u0026gt; { Item = item, Next = _first }; _first = temp; _count++; } else if (_count != 1) { var target = temp.Next; temp.Next = temp.Next.Next; target.Next = _first; _first = target; } } /// \u0026lt;summary\u0026gt; /// 查看第一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Peek() { if (_first == null) { throw new InvalidOperationException(); } return _first.Item; } public override string ToString() { var s = new StringBuilder(); var current = _first; while (current != null) { s.Append(current.Item.ToString()); s.Append(\u0026#34; \u0026#34;); current = current.Next; } return s.ToString(); } } 另请参阅 # "},{"id":99,"href":"/1-3-41/","title":"1.3.41","section":"《算法（第四版）》C# 题解","content":" 1.3.41 # 解答 # 可以按照书上的提示出队再入队，也可以直接用迭代器访问一遍进行复制。\n代码 # /// \u0026lt;summary\u0026gt; /// 复制构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;r\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public Queue(Queue\u0026lt;Item\u0026gt; r) { foreach (Item i in r) { Enqueue(i); } } "},{"id":100,"href":"/1-3-42/","title":"1.3.42","section":"《算法（第四版）》C# 题解","content":" 1.3.42 # 解答 # 直接把链栈的整个链表复制一份即可。\n代码 # /// \u0026lt;summary\u0026gt; /// 复制构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public Stack(Stack\u0026lt;Item\u0026gt; s) { if (s.first != null) { this.first = new Node\u0026lt;Item\u0026gt;(s.first); for (Node\u0026lt;Item\u0026gt; x = this.first; x.next != null; x = x.next) { x.next = new Node\u0026lt;Item\u0026gt;(x.next); } } this.count = s.count; } "},{"id":101,"href":"/1-3-43/","title":"1.3.43","section":"《算法（第四版）》C# 题解","content":" 1.3.43 # 解答 # C# 中可以用 Directory 类里面的几个方法来获得文件路径和文件名。\n代码 # // 获取当前目录 var path = Directory.GetCurrentDirectory(); path = Directory.GetParent(path).FullName; path = Directory.GetParent(path).FullName; // 获取文件 Console.WriteLine(path + \u0026#34;中的所有文件\u0026#34;); Search(path, 0); static void Search(string path, int tabs) { var dirs = Directory.GetDirectories(path); var files = Directory.GetFiles(path); foreach (var p in dirs) { for (var i = 0; i \u0026lt; tabs; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(p.Split(\u0026#39;\\\\\u0026#39;).Last()); Search(p, tabs + 1); } foreach (var f in files) { for (var i = 0; i \u0026lt; tabs; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(f.Split(\u0026#39;\\\\\u0026#39;).Last()); } } "},{"id":102,"href":"/1-3-44/","title":"1.3.44","section":"《算法（第四版）》C# 题解","content":" 1.3.44 # 解答 # 这里我们使用两个栈来模拟缓冲区。\n向左/向右移动 = 从左/右栈弹出相应数量的元素并压入另外一个栈。\n插入/删除 = 左栈压入/弹出一个元素。\n字符数量 = 左栈数量 + 右栈数量。\n代码 # internal class Buffer { private readonly Stack\u0026lt;char\u0026gt; _leftside; private readonly Stack\u0026lt;char\u0026gt; _rightside; /// \u0026lt;summary\u0026gt; /// 建立一个文本缓冲区。 /// \u0026lt;/summary\u0026gt; public Buffer() { _leftside = new Stack\u0026lt;char\u0026gt;(); _rightside = new Stack\u0026lt;char\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 在光标位置插入字符 c。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;要插入的字符。\u0026lt;/param\u0026gt; public void Insert(char c) { _leftside.Push(c); } /// \u0026lt;summary\u0026gt; /// 删除并返回光标位置的字符。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public char Delete() { return _leftside.Pop(); } /// \u0026lt;summary\u0026gt; /// 将光标向左移动 k 个位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;光标移动的距离。\u0026lt;/param\u0026gt; public void Left(int k) { for (var i = 0; i \u0026lt; k; i++) { _rightside.Push(_leftside.Pop()); } } /// \u0026lt;summary\u0026gt; /// 将光标向右移动 k 个位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;光标移动的距离。\u0026lt;/param\u0026gt; public void Right(int k) { for (var i = 0; i \u0026lt; k; i++) { _leftside.Push(_rightside.Pop()); } } /// \u0026lt;summary\u0026gt; /// 返回缓冲区中的字符数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _leftside.Size() + _rightside.Size(); } /// \u0026lt;summary\u0026gt; /// 将缓冲区的内容输出，这将使光标重置到最左端。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string Getstring() { while (!_leftside.IsEmpty()) { _rightside.Push(_leftside.Pop()); } return _rightside.ToString(); } } 另请参阅 # Generics 库\n"},{"id":103,"href":"/1-3-45/","title":"1.3.45","section":"《算法（第四版）》C# 题解","content":" 1.3.45 # 解答 # 书上已经给出了思路，简单说明一下。\n第一问是给定输入判断是否会下溢出，只要记录栈中元素的数量即可，一旦为负数则返回 true。\n第二问是给定输出判断是否可能。\n对于输出序列中的每一个数，如果栈顶为空或者栈顶数字小于当前输出序列的数，那么就从输入序列中输入数字，直到栈顶数字和当前输出序列中的数字相等。\n如果当前输出序列中的数字和栈顶元素相等，从栈中弹出相应元素。\n最后如果栈为空则可能，否则不可能。\n可以结合习题 1.3.3 的解答查看。\n通用解法见下一题。\n代码 # // 给定输入序列，判断是否会出现下溢出。 var input = \u0026#34;- 0 1 2 3 4 5 6 7 8 9 - - - - - - - - -\u0026#34;; Console.WriteLine(IsUnderflow(input.Split(\u0026#39; \u0026#39;))); //True input = \u0026#34;0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -\u0026#34;; Console.WriteLine(IsUnderflow(input.Split(\u0026#39; \u0026#39;))); //False // 给定输出序列，判定是否可能。 int[] output = { 4, 3, 2, 1, 0, 9, 8, 7, 6, 5 }; Console.WriteLine(IsOutputPossible(output)); //True output = new[] { 4, 6, 8, 7, 5, 3, 2, 9, 0, 1 }; Console.WriteLine(IsOutputPossible(output)); //False static bool IsUnderflow(string[] input) { // 记录栈中元素数量，如果元素数量小于 0 则会出现下溢出。 var count = 0; foreach (var s in input) { if (count \u0026lt; 0) { return true; } if (s.Equals(\u0026#34;-\u0026#34;)) { count--; } else { count++; } } return false; } static bool IsOutputPossible(int[] output) { var input = 0; var n = output.Length; var stack = new Stack\u0026lt;int\u0026gt;(); foreach (var i in output) { // 如果栈为空，则从输入序列中压入一个数。 if (stack.IsEmpty()) { stack.Push(input); input++; } // 如果输入序列中的所有数都已经入栈过了，跳出循环。 if (input == n \u0026amp;\u0026amp; stack.Peek() != i) { break; } // 如果输出序列的下一个数不等于栈顶的数，那么就从输入序列中压入一个数。 while (stack.Peek() != i \u0026amp;\u0026amp; input \u0026lt; n) { stack.Push(input); input++; } // 如果栈顶的数等于输出的数，弹出它。 if (stack.Peek() == i) { stack.Pop(); } } return stack.IsEmpty(); } 另请参阅 # Generics 库\n"},{"id":104,"href":"/1-3-46/","title":"1.3.46","section":"《算法（第四版）》C# 题解","content":" 1.3.46 # 解答 # 这道题的解答参考了这篇博文：http://ceeji.net/blog/forbidden-triple-for-stack-generability/。\n显然书中的解答已经十分明确，这里简单说明一下：\n首先有结论：对于栈顶元素 Sn，栈中所有小于 Sn 的值都以递减形式保存（已经输出的不算）。\n表现在输出序列中，Sn 输出之后，如果有小于 Sn 的值输出，其顺序必定是递减的。\n例如序列 4 3 2 1 0 9 8 7 6 5\n4 输出之后，3 2 1 0 递减输出；9 输出之后，8 7 6 5 递减输出。\n依次验证其中的每个值都能满足结论。\n而对于序列 4 6 8 7 5 3 2 9 0 1\n对于 4，之后的 3 2 1 0 并不是以递减顺序输出的，因此这个序列是不合法的。\n"},{"id":105,"href":"/1-3-47/","title":"1.3.47","section":"《算法（第四版）》C# 题解","content":" 1.3.47 # 解答 # 这里用的都是链式结构，头尾相接即可。\n代码 # Queue # /// \u0026lt;summary\u0026gt; /// 在当前队列之后附加一个队列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;q1\u0026#34;\u0026gt;需要被附加的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q2\u0026#34;\u0026gt;需要附加的队列（将被删除）。\u0026lt;/param\u0026gt; public static Queue\u0026lt;Item\u0026gt; Catenation(Queue\u0026lt;Item\u0026gt; q1, Queue\u0026lt;Item\u0026gt; q2) { if (q1.IsEmpty()) { q1.first = q2.first; q1.last = q2.last; q1.count = q2.count; } else { q1.last.next = q2.first; q1.last = q2.last; q1.count += q2.count; } q2 = null; return q1; } Stack # /// \u0026lt;summary\u0026gt; /// 将两个栈连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个栈。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个栈（将被删除）。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Stack\u0026lt;Item\u0026gt; Catenation(Stack\u0026lt;Item\u0026gt; s1, Stack\u0026lt;Item\u0026gt; s2) { if (s1.IsEmpty()) { s1.first = s2.first; s1.count = s2.count; } else { Node\u0026lt;Item\u0026gt; last = s1.first; while (last.next != null) { last = last.next; } last.next = s2.first; s1.count += s2.count; } s2 = null; return s1; } Steque # /// \u0026lt;summary\u0026gt; /// 将两个 Steque 连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;s1\u0026#34;\u0026gt;第一个 Steque \u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;s2\u0026#34;\u0026gt;第二个 Steque （将被删除）\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Steque\u0026lt;Item\u0026gt; Catenation(Steque\u0026lt;Item\u0026gt; s1, Steque\u0026lt;Item\u0026gt; s2) { if (s1.IsEmpty()) { s1.first = s2.first; s1.last = s2.last; s1.count = s2.count; } else { s1.last.next = s2.first; s1.count += s2.count; } s2 = null; return s1; } "},{"id":106,"href":"/1-3-48/","title":"1.3.48","section":"《算法（第四版）》C# 题解","content":" 1.3.48 # 解答 # 按照双向队列原本的操作就可以实现，需要维护两个栈的长度以防越界。（左侧栈弹出了右侧栈栈底的内容）\n代码 # public class DeStack\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private class DoubleNode\u0026lt;T\u0026gt; { public T Item; public DoubleNode\u0026lt;T\u0026gt; Next; public DoubleNode\u0026lt;T\u0026gt; Prev; } private DoubleNode\u0026lt;TItem\u0026gt; _first; private DoubleNode\u0026lt;TItem\u0026gt; _last; private int _leftCount; private int _rightCount; /// \u0026lt;summary\u0026gt; /// 默认构造函数，建立一个双端栈。 /// \u0026lt;/summary\u0026gt; public DeStack() { _first = null; _last = null; _leftCount = 0; _rightCount = 0; } /// \u0026lt;summary\u0026gt; /// 检查左侧栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsLeftEmpty() { return _leftCount == 0; } /// \u0026lt;summary\u0026gt; /// 检查右侧栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsRightEmpty() { return _rightCount == 0; } /// \u0026lt;summary\u0026gt; /// 返回左侧栈中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int LeftSize() { return _leftCount; } /// \u0026lt;summary\u0026gt; /// 返回右侧栈中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int RightSize() { return _rightCount; } /// \u0026lt;summary\u0026gt; /// 向左端添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.Prev = _first; } _leftCount++; } /// \u0026lt;summary\u0026gt; /// 向右端添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要添加的元素。\u0026lt;/param\u0026gt; public void PushRight(TItem item) { var oldLast = _last; _last = new DoubleNode\u0026lt;TItem\u0026gt; { Item = item, Prev = oldLast, Next = null }; if (oldLast == null) { _first = _last; } else { oldLast.Next = _last; } _rightCount++; } /// \u0026lt;summary\u0026gt; /// 从右端删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopRight() { if (IsRightEmpty()) { throw new InvalidOperationException(); } var temp = _last.Item; _last = _last.Prev; _rightCount--; if (_last == null) { _first = null; } else { _last.Next.Item = default; _last.Next = null; } return temp; } /// \u0026lt;summary\u0026gt; /// 从左端删除并返回一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopLeft() { if (IsLeftEmpty()) { throw new InvalidOperationException(); } var temp = _first.Item; _first = _first.Next; _leftCount--; if (_first == null) { _last = null; } else { _first.Prev.Item = default; _first.Prev = null; } return temp; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new DequeEnumerator(_first); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class DequeEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private DoubleNode\u0026lt;TItem\u0026gt; _current; private DoubleNode\u0026lt;TItem\u0026gt; _first; public DequeEnumerator(DoubleNode\u0026lt;TItem\u0026gt; first) { _current = new DoubleNode\u0026lt;TItem\u0026gt;(); _current.Next = first; _current.Prev = null; _first = _current; } public TItem Current =\u0026gt; _current.Item; object IEnumerator.Current =\u0026gt; _current.Item; public void Dispose() { _current = null; _first = null; } public bool MoveNext() { if (_current.Next == null) return false; _current = _current.Next; return true; } public void Reset() { _current = _first; } } } "},{"id":107,"href":"/1-3-49/","title":"1.3.49","section":"《算法（第四版）》C# 题解","content":" 1.3.49 # 解答 # 那么这里就使用六个栈来解决这个问题。 这个算法来自于这篇论文。\n原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。\n先导知识——用两个栈模拟一个队列 # 如何使用两个栈来模拟一个队列操作？\n这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。\n首先我们有两个栈，H 和 T，分别用作出队和入队用。\n这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。\n如果 H 不为空，出队操作等同于 H 出栈，H 的出栈操作也只需要 O(1) 时间。\n但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。\n下图分别展示了这三种情况。\n显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。\n分摊 O(n) # 那么，怎么解决这个问题呢？\n一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H\u0026rsquo; 中，等到栈 H 为空时，直接交换 H 和 H\u0026rsquo; 即可。\n假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。\n现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H\u0026rsquo; 中。\n每一次出队都执行两个操作，元素出队和元素复制（Pop \u0026amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。\n最后一个元素出队后，栈 H 和栈 T 都为空，此时我们直接交换栈 H 和栈 H\u0026rsquo;（由于是交换引用，因此时间复杂度仍为 O(1)）。\n算法运行如下图所示：\n这就是这个算法基本想法，在栈 H 变为空之前，分步将栈 T 中的内容分步复制到另一个栈中。\n当栈 H 为空时直接用准备好的栈 H\u0026rsquo; 替代 H，保证时间复杂度为常数。\n对复制时 Enqueue 的支持和 T\u0026rsquo; 的引入 # 刚才是一种理想情况，显然我们的队列在复制时不可能只发生出队操作，为了增加对复制时入队操作的支持，我们引入临时栈 T\u0026rsquo;。\n例如我们有队列状态如下，现在启动复制进程，入队操作全部由 T\u0026rsquo; 完成。\n我们进行一次入队操作和两次出队操作，如下所示：\n最后 H 和 T 均为空，下一次操作前（不论入队还是出队），我们先交换 H 和 H\u0026rsquo; 以及 T 和 T\u0026rsquo;，同时让入队操作控制权回到 T。\n这样，我们增加了对复制时入队操作的支持，但还并不完全，只有在理想情况下才可以做到。\nh 与 HR ，对复制时出入队序列支持的扩展 # 在之前的例子中，当复制结束时 H 总是为空的，现在我们来讨论一下复制结束时 H 不为空的情况。\n如果复制结束时 H 不为空，直接交换的结果是我们丢失了原来栈 H 中的数据。\n因此，在翻转 T 的同时，我们还应翻转 H 到 HR，并在最后将 HR 的内容再度翻转并添加到 H\u0026rsquo; 上。\n实现时，每次队列操作（出队或入队）后会分别执行 T-\u0026gt;H' 和 H-\u0026gt;HR 的复制，等 T 和 H 都变为空之后再执行 HR-\u0026gt;H 的复制。\n由于每次队列操作附加的操作次数是固定的，因此单次队列操作的最坏时间复杂度仍是 O(1)。\n初始状态：\n这里我们只进行入队操作（后续使用第六个栈来支持复制时出队操作），示意图如下：\n这样我们就解决了 H 复制结束后不为空的问题，代价是引入了两个额外的问题：\n问题一：操作次数增加到了 2k 次，k 代表栈 T 中的元素数量。（如果当 T 中元素数量大于 H 中元素数量时开始复制）\n问题二：由于 H 被用于复制进程，我们无法在复制过程中支持出队操作。\n第一个问题解决方案比较简单，我们可以在每一次出/入队操作执行时进行两次的复制步骤（对 T 和 H 进行两次的 Pop 操作），时间复杂度仍为 O(1)。\n第二个问题我们通过引入栈 h 来解决。\nh 用于在复制时代替 H 执行出队功能，它会在复制开始时自动变为栈 H 的一个浅拷贝（也就是说，h 和 H 共用同一片内存空间，但它们用于指示栈顶位置的指针相互独立）。\n现在我们有了全部 6 个栈，它们的功能如下图所示（为了方便介绍我将一些栈的位置做了调换）。\n由于我们并不能预知接下来会发生的操作，因此当 H 栈中的元素数量第一次小于 T 栈中的元素数量时，我们就必须启动复制进程了（总是假设接下来全部都是出队操作）。我们引入一个布尔类型变量 isCopying 来指示复制进程。\n如果在复制过程中有出队操作，作为 H 的翻转 HR 中就有一个元素不再需要复制。同样地，我们引入一个变量 needcopy 来记录 HR 中需要复制的元素数量。\n具体执行过程如下图所示：\n有关复制开始时机的证明 # 这里我们选择了在第 k + 1 个元素入队时开始复制，现在证明一定能够在 h 空之前完成复制：\n假设复制开始时 H 有 k 个元素，T 有 k + 1 个元素。\n完成第一轮复制（H-\u0026gt;HR , T-\u0026gt;H\u0026rsquo;）需要 k + 1 次操作，\n完成第二轮复制（H-\u0026gt;H\u0026rsquo;）需要 k 次操作，总共需要 2k + 1 次操作才能完成复制。\n而 h 的长度为 k，能够提供 2k 次的操作机会。第 k + 1 个元素入队时也能提供 2 次操作机会，因此一共是 2k + 2 次操作机会。\n由于 2k + 1 \u0026lt; 2k + 2，我们证明了该算法能够及时完成复制工作。\n程序设计 # 根据之前的内容，我们可以开始设计程序了。主要实现三个功能，Enqueue(), Dequeue() 和 Peek()。\n根据算法要求我们添加一个进行复制时操作的函数 OneStep()，用于执行元素的复制，栈交换等操作。\nPeek() 只需要根据是否在进行复制选择栈 h 或栈 H 进行 Peek()。\nEnqueue()\n1. 如果不处于复制状态 1. 如果 H.Length – T.Length \u0026gt; 0，直接将元素压入栈 T。 2. 否则令 IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。 2. 如果处于复制状态，将元素压入 T\u0026#39;，进行两次的 OneStep Dequeue()\n1. 如果不处于复制状态 1. 如果 H.Length – T.Length \u0026gt; 0，直接从 H 弹出元素。 2. 否则从 H 弹出元素，IsCopying = true，h 进行浅拷贝，进行两次的 OneStep。 2. 如果处于复制状态，从 h 弹出元素，needcopy - 1，进行两次的 OneStep。 OneStep()\n1. 如果不处于复制状态，什么也不做。 2. 如果处于复制状态。 1. 如果 H 和 T 都不为空，从 H 搬运一个元素至 HR ，从 T 搬运一个元素至 H\u0026#39; ，needcopy + 1。 2. 如果 H 为空但 T 不为空，从 T 搬运一个元素至 H\u0026#39; 。 3. 如果 H 和 T 都为空，但 needcopy \u0026gt; 1，从 HR 搬运一个元素至 H\u0026#39; ，needcopy – 1。 4. 如果 H 和 T 都为空，但 needcopy = 1，从 HR 搬运一个元素至 H\u0026#39; ，needcopy – 1，交换 H 和 H\u0026#39; 以及 T 和 T\u0026#39;，其他栈置空，退出复制状态。 5. 如果 H 和 T 都为空，但 needcopy = 0，交换 H 和 H\u0026#39; 以及 T 和 T\u0026#39;，其他栈置空，退出复制状态。 代码 # internal class StackQueue\u0026lt;TItem\u0026gt; { private Stack\u0026lt;TItem\u0026gt; H; private Stack\u0026lt;TItem\u0026gt; T; private Stack\u0026lt;TItem\u0026gt; h; private Stack\u0026lt;TItem\u0026gt; HH; private Stack\u0026lt;TItem\u0026gt; TT; private Stack\u0026lt;TItem\u0026gt; Hr; private bool _isRecopying; private int _nowCopying; public StackQueue() { _isRecopying = false; _nowCopying = 0; H = new Stack\u0026lt;TItem\u0026gt;(); T = new Stack\u0026lt;TItem\u0026gt;(); h = new Stack\u0026lt;TItem\u0026gt;(); HH = new Stack\u0026lt;TItem\u0026gt;(); TT = new Stack\u0026lt;TItem\u0026gt;(); Hr = new Stack\u0026lt;TItem\u0026gt;(); } public TItem Peek() { if (_isRecopying) { return h.Peek(); } return H.Peek(); } public void Enqueue(TItem item) { if (!_isRecopying \u0026amp;\u0026amp; Lendiff() \u0026gt; 0) { _nowCopying = 0; T.Push(item); } else if (!_isRecopying \u0026amp;\u0026amp; Lendiff() == 0) { T.Push(item); _isRecopying = true; h = H.Copy(); OneStep(OneStep(this)); } else if (_isRecopying) { TT.Push(item); OneStep(OneStep(this)); } } public int Lendiff() { return H.Size() - T.Size(); } public TItem Dequeue() { if (!_isRecopying \u0026amp;\u0026amp; Lendiff() \u0026gt; 0) { return H.Pop(); } if (!_isRecopying \u0026amp;\u0026amp; Lendiff() == 0) { var temp = H.Pop(); h = H.Copy(); _isRecopying = true; OneStep(OneStep(this)); return temp; } else { var temp = h.Pop(); _nowCopying--; OneStep(OneStep(this)); return temp; } } private static StackQueue\u0026lt;TItem\u0026gt; OneStep(StackQueue\u0026lt;TItem\u0026gt; q) { if (q._isRecopying \u0026amp;\u0026amp; !q.H.IsEmpty() \u0026amp;\u0026amp; !q.T.IsEmpty()) { q._nowCopying++; q.HH.Push(q.T.Pop()); q.Hr.Push(q.H.Pop()); } else if (q._isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; !q.T.IsEmpty()) { q._isRecopying = true; q.HH.Push(q.T.Pop()); } else if (q._isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q._nowCopying \u0026gt; 1) { q._isRecopying = true; q._nowCopying--; q.HH.Push(q.Hr.Pop()); } else if (q._isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q._nowCopying == 1) { q._isRecopying = false; q._nowCopying--; q.HH.Push(q.Hr.Pop()); q.H = q.HH; q.T = q.TT; q.HH = new Stack\u0026lt;TItem\u0026gt;(); q.TT = new Stack\u0026lt;TItem\u0026gt;(); q.Hr = new Stack\u0026lt;TItem\u0026gt;(); q.h = new Stack\u0026lt;TItem\u0026gt;(); } else if (q._isRecopying \u0026amp;\u0026amp; q.H.IsEmpty() \u0026amp;\u0026amp; q.T.IsEmpty() \u0026amp;\u0026amp; q._nowCopying == 0) { q._isRecopying = false; q.H = q.HH; q.T = q.TT; q.HH = new Stack\u0026lt;TItem\u0026gt;(); q.TT = new Stack\u0026lt;TItem\u0026gt;(); q.Hr = new Stack\u0026lt;TItem\u0026gt;(); q.h = new Stack\u0026lt;TItem\u0026gt;(); } return q; } } 另请参阅 # StackOverflow-How to implement a queue with three stacks?——Stack Overflow 上关于这个问题的讨论。\nReal Time Queue Operation in Pure LISP-Robert Hood, Robert Melville——用六个栈实现常数操作队列的论文。\n动画演示的 PPT 源文件，你可能需要安装 Cascadia Code 和 思源黑体 才能正常显示(Onedrive/GitHub)\n"},{"id":108,"href":"/1-3-50/","title":"1.3.50","section":"《算法（第四版）》C# 题解","content":" 1.3.50 # 解答 # 初始化迭代器的时候记录栈已经进行过的 Pop 和 Push 数，迭代的时候检查这两个值是否改变，一旦改变就抛出异常。\n代码 # private class StackEnumerator : IEnumerator\u0026lt;Item\u0026gt; { private Stack\u0026lt;Item\u0026gt; s; private int popcount; private int pushcount; private Node\u0026lt;Item\u0026gt; current; public StackEnumerator(Stack\u0026lt;Item\u0026gt; s) { this.s = s; this.current = s.first; this.popcount = s.popcount; this.pushcount = s.pushcount; } Item IEnumerator\u0026lt;Item\u0026gt;.Current =\u0026gt; current.item; object IEnumerator.Current =\u0026gt; current.item; void IDisposable.Dispose() { this.current = null; this.s = null; } bool IEnumerator.MoveNext() { if (s.popcount != this.popcount || s.pushcount != this.pushcount) throw new InvalidOperationException(\u0026#34;Stack has been modified\u0026#34;); if (this.current.next == null) return false; this.current = this.current.next; return true; } void IEnumerator.Reset() { this.current = this.s.first; } } "},{"id":109,"href":"/1-4-1/","title":"1.4.1","section":"《算法（第四版）》C# 题解","content":" 1.4.1 # 解答 # 即为证明组合计算公式：\n$C(N, 3)$\n$= N! / [(N - 3)! × 3!]$\n$= [(N - 2) * (N - 1) * N] / 3!$\n$= N(N - 1)(N - 2) / 6$\n显然 N 必须大于等于 3。\n$N = 3$ 时公式正确，只有一种组合。\n$N = 4$ 时公式正确，只有四种组合。\n扩展到 $N+1$ 个数，将 $N = N + 1$ 代入，可得：\n$(N + 1)N(N - 1) / 6$\n$N + 1$ 个数能组成的三位数组合可以这样理解\n前 N 个数中取三个数的所有组合 +多出的一个数和前 N 个数中的任意取两个数的所有组合\n即为 $N(N-1)(N - 2) / 6 + C(N, 2)$\n变形后即为 $(N + 1)N(N - 1) / 6$\n得证。\n"},{"id":110,"href":"/1-4-2/","title":"1.4.2","section":"《算法（第四版）》C# 题解","content":" 1.4.2 # 解答 # 将 a[i] + a[j] + a[k] 改为 (long)a[i] + a[j] + a[k] 即可。\n此时整个式子将按照精度最高（也就是 long）的标准计算。\nlong.MaxValue = 9223372036854775807 \u0026gt; int.MaxValue * 3 = 6442450941 代码 # /// \u0026lt;summary\u0026gt; /// 计算和为零的三元组的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;和为零的三元组的数量。\u0026lt;/returns\u0026gt; public static int Count(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { for (var k = j + 1; k \u0026lt; n; k++) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } return count; } 另请参阅 # Measurement 库\n"},{"id":111,"href":"/1-4-3/","title":"1.4.3","section":"《算法（第四版）》C# 题解","content":" 1.4.3 # 解答 # 见代码，这里贴出绘图函数，窗体只是在得到测试结果之后简单调用以下这两个函数。\n代码 # public static void PaintLinear(double[] testResult) { //新建一个绘图窗口 Form2 linear = new Form2(); linear.Show(); //新建画布 Graphics canvas = linear.CreateGraphics(); //获取窗口区域 Rectangle rect = linear.ClientRectangle; //计算单位长度（十等分） int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补） Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系 canvas.DrawLine(Pens.Black, center.X, center.Y, center.X, center.Y + center.Height); canvas.DrawLine(Pens.Black, center.X, center.Y + center.Height, center.X + center.Width, center.Y + center.Height); //对 X 轴 10 等分，对 Y 轴 10 等分 int xaxisUnit = center.Width / 10; int yaxisUnit = center.Height / 10; //标记 X 轴坐标值 for (int i = 1; i \u0026lt;= 8; i += i) { canvas.DrawString(i + \u0026#34;N\u0026#34;, linear.Font, Brushes.Black, center.X + i * xaxisUnit, center.Y + center.Height); } //反转坐标系 canvas.TranslateTransform(0, linear.ClientRectangle.Height); canvas.ScaleTransform(1, -1); //计算单位长度 double Unit = center.Height / testResult[3]; //标记 PointF[] result = new PointF[4]; for (int i = 0, j = 1; i \u0026lt; 4 \u0026amp;\u0026amp; j \u0026lt;= 8; ++i, j += j) { result[i] = new PointF(center.X + j * xaxisUnit, (float)(center.Y + Unit * testResult[i])); } //链接 canvas.DrawLines(Pens.Black, result); canvas.Dispose(); } public static void PaintLogarithm(double[] testResult) { //新建一个绘图窗口 Form2 log = new Form2(); log.Show(); //新建画布 Graphics canvas = log.CreateGraphics(); //获取窗口区域 Rectangle rect = log.ClientRectangle; //计算单位长度（十等分） int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补） Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系 canvas.DrawLine(Pens.Black, center.X, center.Y, center.X, center.Y + center.Height); canvas.DrawLine(Pens.Black, center.X, center.Y + center.Height, center.X + center.Width, center.Y + center.Height); //对 X 轴 10 等分，对 Y 轴 10 等分 int xaxisUnit = center.Width / 10; int yaxisUnit = center.Height / 10; //标记 X 轴坐标值 for (int i = 1; i \u0026lt;= 8; i += i) { canvas.DrawString(i + \u0026#34;N\u0026#34;, log.Font, Brushes.Black, center.X + i * xaxisUnit, center.Y + center.Height); } //反转坐标系 canvas.TranslateTransform(0, log.ClientRectangle.Height); canvas.ScaleTransform(1, -1); //计算单位长度 double Unit = center.Height / testResult[3]; //标记 PointF[] result = new PointF[4]; for (int i = 0, j = 1; i \u0026lt; 4 \u0026amp;\u0026amp; j \u0026lt;= 8; ++i, j += j) { result[i] = new PointF(center.X + j * xaxisUnit, (float)(center.Y + Unit * testResult[i])); } //链接 canvas.DrawLines(Pens.Black, result); canvas.Dispose(); } "},{"id":112,"href":"/1-4-4/","title":"1.4.4","section":"《算法（第四版）》C# 题解","content":" 1.4.4 # 解答 # "},{"id":113,"href":"/1-4-5/","title":"1.4.5","section":"《算法（第四版）》C# 题解","content":" 1.4.5 # 解答 # 类似于取极限的做法。\na. $N$\nb. $1$\nc. $1$\nd. $2N^3$\ne. $1$\nf. $2$\ng. $\\frac{N^{100}}{2^n}$\n"},{"id":114,"href":"/1-4-6/","title":"1.4.6","section":"《算法（第四版）》C# 题解","content":" 1.4.6 # 解答 # a. N + N/2 + N/4 + … = ~2N，线性。\nb. 1 + 2 + 4 + … = ~2N，线性。\nc. NlogN，线性对数。\n"},{"id":115,"href":"/1-4-7/","title":"1.4.7","section":"《算法（第四版）》C# 题解","content":" 1.4.7 # 解答 # 最外层循环进行了 N 次比较。\n次外层循环进行了 N^2 次比较。\n最里层循环进行了 N^3 次比较。\n内部 if 语句进行了 N^3 次比较。\nif 内部进行了 N(N-1) 次加法。\n加起来，~2N^3。\n"},{"id":116,"href":"/1-4-8/","title":"1.4.8","section":"《算法（第四版）》C# 题解","content":" 1.4.8 # 解答 # 平方级别：直接二层循环遍历一遍。\n线性对数：\n先对数组排序，然后遍历一遍数组，在遍历过程中计算重复元素的数量，\n然后用公式 $1+2+\\cdots+n-1=n(n-1)/2$ 计算重复整数对的数量。\n代码 # /// \u0026lt;summary\u0026gt; /// 暴力查找数组中相等的整数对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int CountEqual(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { if (a[i] == a[j]) count++; } } return count; } /// \u0026lt;summary\u0026gt; /// 利用 Array.Sort 进行优化的查找相等整数对算法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int CountEqualLog(int[] a) { var n = a.Length; var count = 0; Array.Sort(a); var dup = 0; // dup = 重复元素数量-1 for (var i = 1; i \u0026lt; n; i++) { while (a[i - 1] == a[i]) { dup++; i++; } count += dup * (dup + 1) / 2; dup = 0; } return count; } "},{"id":117,"href":"/1-4-9/","title":"1.4.9","section":"《算法（第四版）》C# 题解","content":" 1.4.9 # 解答 # 由题意可得：\n$$ T(2N_0)=2^bT\\newline T(4N_0)=2^b(2^bT)=2^{2b}T\\newline \u0026hellip;\u0026hellip;\\newline T(2^rN_0)=2^{rb}T $$\n设：\n$$ N=2^rN_0 $$\n则：\n$$ r=log_2(\\frac{N}{N_0}) $$\n所以：\n$$ T(N) = 2^{log_2(\\frac{N}{N_0})b}T $$\n"},{"id":118,"href":"/1-4-10/","title":"1.4.10","section":"《算法（第四版）》C# 题解","content":" 1.4.10 # 解答 # 修改二分查找的结束条件，找到后仍然向左侧寻找，如果还能找到更小的，则返回较小的下标；否则返回当前下标。\n代码 # public static int Rank(int key, int[] a, int lo, int hi) { if (hi \u0026lt; lo) return -1; var mid = (hi - lo) / 2 + lo; if (a[mid] == key) { var mini = Rank(key, a, lo, mid - 1); if (mini != -1) return mini; return mid; } if (a[mid] \u0026lt; key) { return Rank(key, a, mid + 1, hi); } return Rank(key, a, lo, mid - 1); } "},{"id":119,"href":"/1-4-11/","title":"1.4.11","section":"《算法（第四版）》C# 题解","content":" 1.4.11 # 解答 # 这里给出官网上的 Java 实现：StaticSETofInts.java。\nhowMany() 可以用二分查找实现，在找到一个值后继续向两侧查找，最后返回找到的次数。\n代码 # /// \u0026lt;summary\u0026gt; /// 有序数组，能够快速查找并自动维护其中的顺序。 /// \u0026lt;/summary\u0026gt; public class StaticSeTofInts { private readonly int[] _a; /// \u0026lt;summary\u0026gt; /// 用一个数组初始化有序数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;源数组。\u0026lt;/param\u0026gt; public StaticSeTofInts(int[] keys) { _a = new int[keys.Length]; for (var i = 0; i \u0026lt; keys.Length; i++) { _a[i] = keys[i]; } Array.Sort(_a); } /// \u0026lt;summary\u0026gt; /// 检查数组中是否存在指定元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的值。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(int key) { return Rank(key, 0, _a.Length - 1) != -1; } /// \u0026lt;summary\u0026gt; /// 返回某个元素在数组中存在的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在数组中存在的数量。\u0026lt;/returns\u0026gt; public int HowMany(int key) { var hi = _a.Length - 1; var lo = 0; return HowMany(key, lo, hi); } /// \u0026lt;summary\u0026gt; /// 返回某个元素在数组某个范围中存在的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在数组中存在的数量。\u0026lt;/returns\u0026gt; private int HowMany(int key, int lo, int hi) { var mid = Rank(key, lo, hi); if (mid == -1) return 0; return 1 + HowMany(key, lo, mid - 1) + HowMany(key, mid + 1, hi); } /// \u0026lt;summary\u0026gt; /// 二分查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回关键值的下标，如果不存在则返回 -1。\u0026lt;/returns\u0026gt; public int Rank(int key, int lo, int hi) { while (lo \u0026lt;= hi) { var mid = (hi - lo) / 2 + lo; if (key \u0026lt; _a[mid]) hi = mid - 1; else if (key \u0026gt; _a[mid]) lo = mid + 1; else return mid; } return -1; } } 另请参阅 # Measurement 库\nStaticSETofInts.java\n"},{"id":120,"href":"/1-4-12/","title":"1.4.12","section":"《算法（第四版）》C# 题解","content":" 1.4.12 # 解答 # 由于两个数组都是有序的，可以同时进行比较。\n设 i, j 分别为两个数组的下标。\n如果 a[i] == a[j]，i 和 j 都向后移动一位。\n如果 a[i] != a[j]，比较小的那个向后移动一位。\n循环直到某个数组遍历完毕。\n这样最后的时间复杂度 ~2N\n代码 # var a = new[] { 2, 3, 4, 10 }; var b = new[] { 1, 3, 3, 5, 10, 11 }; // 2N 次数组访问，数组 a 和数组 b 各遍历一遍 for (int i = 0, j = 0; i \u0026lt; a.Length \u0026amp;\u0026amp; j \u0026lt; b.Length;) { if (a[i] \u0026lt; b[j]) { i++; } else if (a[i] \u0026gt; b[j]) { j++; } else { Console.WriteLine($\u0026#34;Common Element:{a[i]}, First index: (a[{i}], b[{j}])\u0026#34;); i++; j++; } } "},{"id":121,"href":"/1-4-13/","title":"1.4.13","section":"《算法（第四版）》C# 题解","content":" 1.4.13 # 解答 # 对象的固定开销用 Object 表示。\na. Accumulator 使用 1.2.4.3 节给出的实现。\n= int * 1 + double + Object * 1 = 4 * 1 + 8 + 16 * 1 = 32 b. Transaction\n= string * 1 + Date * 1 + double * 1 + Object * 1 = (40 + 16 + 4 + 4 + 2N) * 1 + (8 + 32) * 1 + 8 * 1 + 16 * 1 = 128 + 2N c. FixedCapacityStackOfStrings\n= string[] * 1 + string * N + int * 1 + Object * 1 = 24 * 1 + N * (64 + 2C) + 4 * 1 + 16 * 1 = N * (64 + 2C) + 44 = N * (64 + 2C) + 48（填充） d.Point2D\n= double * 2 + Object * 1 = 8 * 2 + 16 * 1 = 32 e.Interval1D\n= double * 2 + Object * 1 = 8 * 2 + 16 * 1 = 32 f.Interval2D\n= Interval1D * 2 + Object * 1 = (8 + 24) * 2 + 16 * 1 = 80 g.Double\n= double * 1 + Object * 1 = 8 * 1 + 16 * 1 = 24 "},{"id":122,"href":"/1-4-14/","title":"1.4.14","section":"《算法（第四版）》C# 题解","content":" 1.4.14 # 解答 # 这里给出暴力方法，将最内侧循环换成二分查找即为优化版本。\n代码 # public static class FourSum { /// \u0026lt;summary\u0026gt; /// 输出数组中所有和为 0 的四元组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含所有元素的数组。\u0026lt;/param\u0026gt; public static void PrintAll(long[] a) { var n = a.Length; for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { for (var k = j + 1; k \u0026lt; n; k++) { for (var l = k + 1; l \u0026lt; n; l++) { if (a[i] + a[j] + a[k] + a[l] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]} + {a[l]} = 0\u0026#34;); } } } } } } /// \u0026lt;summary\u0026gt; /// 计算和为零的四元组的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含所有元素的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;和为零的四元组的数量。\u0026lt;/returns\u0026gt; public static int Count(long[] a) { var n = a.Length; var cnt = 0; for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { for (var k = j + 1; k \u0026lt; n; k++) { for (var l = k + 1; l \u0026lt; n; l++) { if (a[i] + a[j] + a[k] + a[l] == 0) { cnt++; } } } } } return cnt; } } 另请参阅 # Measurement 库\n"},{"id":123,"href":"/1-4-15/","title":"1.4.15","section":"《算法（第四版）》C# 题解","content":" 1.4.15 # 解答 # 由于数组已经排序（从小到大），负数在左侧，正数在右侧。\nTwoSumFaster\n设最左侧下标为 lo，最右侧下标为 hi。\n如果 a[lo] + a[hi] \u0026gt; 0, 说明正数太大，hi\u0026ndash;。\n如果 a[lo] + a[hi] \u0026lt; 0，说明负数太小，lo++。\n否则就找到了一对和为零的整数对，lo++, hi\u0026ndash;。\nThreeSumFaster\n对于数组中的每一个数 a，ThreeSum 问题就等于求剩余数组中所有和为 -a 的 TwoSum 问题。\n只要在 TwoSumFaster 外层再套一个循环即可。\n代码 # /// \u0026lt;summary\u0026gt; /// TwoSum 的快速实现。（线性级别） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组范围。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;数组中和为零的整数对数量。\u0026lt;/returns\u0026gt; static int TwoSumFaster(int[] a) { var lo = 0; var hi = a.Length - 1; var count = 0; while (lo \u0026lt; hi) { if (a[lo] + a[hi] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] \u0026lt; 0) { lo++; } else { hi--; } } return count; } /// \u0026lt;summary\u0026gt; /// ThreeSum 的快速实现。（平方级别） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要查找的数组范围。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;数组中和为零的三元组数量。\u0026lt;/returns\u0026gt; static int ThreeSumFaster(int[] a) { var count = 0; for (var i = 0; i \u0026lt; a.Length; i++) { var lo = i + 1; var hi = a.Length - 1; while (lo \u0026lt; hi) { if (a[lo] + a[hi] + a[i] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] + a[i] \u0026lt; 0) { lo++; } else { hi--; } } } return count; } "},{"id":124,"href":"/1-4-16/","title":"1.4.16","section":"《算法（第四版）》C# 题解","content":" 1.4.16 # 解答 # 先将数组从小到大排序，再遍历一遍即可得到差距最小的两个数。\n排序算法需要消耗 NlogN，具体见 MSDN：Array.Sort 方法 (Array)。\n代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; Array.Sort(a); // Nlog(N) 具体见 https://msdn.microsoft.com/zh-cn/library/6tf1f0bc(v=vs.110).aspx 备注部分 var minDiff = double.MaxValue; double minA = 0; double minB = 0; for (var i = 0; i \u0026lt; a.Length - 1; i++) //N { if (a[i + 1] - a[i] \u0026lt; minDiff) { minA = a[i]; minB = a[i + 1]; minDiff = a[i + 1] - a[i]; } } Console.WriteLine($\u0026#34;Min Pair: {minA} {minB}, Min Value: {minDiff}\u0026#34;); 另请参阅 # MSDN-Array.Sort 方法 (Array)\n"},{"id":125,"href":"/1-4-17/","title":"1.4.17","section":"《算法（第四版）》C# 题解","content":" 1.4.17 # 解答 # 遍历找到最小值和最大值即可。\n代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; double min = int.MaxValue; double max = int.MinValue; for (var i = 0; i \u0026lt; a.Length; i++) { if (a[i] \u0026gt; max) { max = a[i]; } if (a[i] \u0026lt; min) { min = a[i]; } } Console.WriteLine($\u0026#34;MaxDiff Pair: {min} {max}, Max Difference: {Math.Abs(max - min)}\u0026#34;); "},{"id":126,"href":"/1-4-18/","title":"1.4.18","section":"《算法（第四版）》C# 题解","content":" 1.4.18 # 解答 # 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。\n在三个数中比较得到最小值需要两次比较，因此最坏情况下为 $~2\\lg N$ 次比较。\n代码 # var a = new[] { 1, 2, 5, 3, 5 }; Console.WriteLine(LocalMinimum(a)); static int LocalMinimum(int[] a) { var lo = 0; var hi = a.Length - 1; while (lo \u0026lt;= hi) { var mid = (hi - lo) / 2 + lo; var min = mid; // 取左中右最小值的下标 if (mid != hi \u0026amp;\u0026amp; a[min] \u0026gt;= a[mid + 1]) min = mid + 1; if (mid != lo \u0026amp;\u0026amp; a[min] \u0026gt;= a[mid - 1]) min = mid - 1; if (min == mid) return mid; if (min \u0026gt; mid) lo = min; else hi = min; } return -1; } "},{"id":127,"href":"/1-4-19/","title":"1.4.19","section":"《算法（第四版）》C# 题解","content":" 1.4.19 # 解答 # 问题类似于 POJ 上的一道题「滑雪」，从数值较高的一侧向周围数值较小的一侧移动，直到到达「山谷」（局部最小）。\n首先在中间行搜索最小值，再将最小值与其上下两个元素比较，如果不满足题意，则“滑向”较小的一侧，矩阵被分为了两半（上下两侧）。\n在较小的一侧，找到中间列的最小值，再将最小值与其左右两个元素比较，如果不满足题意，类似的移动到较小的一侧（左右两侧）。\n现在查找范围缩小到了原来矩阵的四分之一，递归的进行上述操作，最后可以得到答案。\n每次查找最小值都是对行/列进行遍历，遍历耗时和 N 成正比。\n代码 # // 先查找 N/2 行中的最小元素，并令其与上下元素比较， // 如果不满足题意，则向相邻的最小元素靠近再次查找 var matrix = new[,] { { 26, 3, 4, 10, 11 }, { 5, 1, 6, 12, 13 }, { 7, 8, 9, 14, 15 }, { 16, 17, 18, 27, 20 }, { 21, 22, 23, 24, 25 } }; Console.WriteLine(MinimumRow(matrix, 0, 5, 0, 5)); static int MinimumRow(int[,] matrix, int rowStart, int rowLength, int colStart, int colLength) { var min = int.MaxValue; if (rowLength \u0026lt; 3) return int.MaxValue; var mid = rowStart + rowLength / 2; var minCol = 0; // 获取矩阵中间行的最小值 for (var i = 0; i \u0026lt; colLength; i++) { if (min \u0026gt; matrix[mid, colStart + i]) { min = matrix[mid, colStart + i]; minCol = i; } } // 检查是否满足条件 if (matrix[mid, minCol] \u0026lt; matrix[mid - 1, minCol] \u0026amp;\u0026amp; matrix[mid, minCol] \u0026lt; matrix[mid + 1, minCol]) { return matrix[mid, minCol]; } // 如果不满足则向较小一侧移动 if (matrix[mid - 1, minCol] \u0026gt; matrix[mid + 1, minCol]) { return MinimumCol(matrix, rowStart, rowLength, mid + 1, colLength / 2 + 1); } return MinimumCol(matrix, rowStart, rowLength, colStart, colLength / 2 + 1); } static int MinimumCol(int[,] matrix, int rowStart, int rowLength, int colStart, int colLength) { var min = int.MaxValue; var n = matrix.GetLength(0); var mid = n / 2; var minRow = 0; // 获取矩阵中间列最小值 for (var i = 0; i \u0026lt; n; i++) { if (min \u0026gt; matrix[i, mid]) { min = matrix[i, mid]; minRow = i; } } // 检查是否满足条件 if (matrix[minRow, mid] \u0026lt; matrix[minRow, mid - 1] \u0026amp;\u0026amp; matrix[minRow, mid] \u0026lt; matrix[minRow, mid + 1]) { return matrix[minRow, mid]; } // 如果不满足则向较小一侧移动 if (matrix[minRow, mid - 1] \u0026gt; matrix[minRow, mid + 1]) { return MinimumRow(matrix, mid + 1, rowLength / 2 + 1, colStart, colLength); } return MinimumRow(matrix, rowStart, rowLength / 2 + 1, colStart, colLength); } 另请参阅 # POJ-滑雪\n"},{"id":128,"href":"/1-4-20/","title":"1.4.20","section":"《算法（第四版）》C# 题解","content":" 1.4.20 # 解答 # 首先给出 BitMax 类的官方 Java 实现：BitonicMax.java。\n我们使用这个类生成双调数组，并使用其中的 Max() 方法找到双调数组的最大值。\n找到最大值之后分别对左右两侧进行二分查找，注意对于升序和降序的数组二分查找的实现有所不同。\n代码 # BitonicMax 类 # public class BitonicMax { /// \u0026lt;summary\u0026gt; /// 生成双调数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组的大小。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static int[] Bitonic(int n) { var random = new Random(); var mid = random.Next(n); var a = new int[n]; for (var i = 1; i \u0026lt; mid; i++) { a[i] = a[i - 1] + 1 + random.Next(9); } if (mid \u0026gt; 0) { a[mid] = a[mid - 1] + random.Next(10) - 5; } for (var i = mid + 1; i \u0026lt; n; i++) { a[i] = a[i - 1] - 1 - random.Next(9); } return a; } /// \u0026lt;summary\u0026gt; /// 寻找数组中的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回数组中最大值的下标。\u0026lt;/returns\u0026gt; public static int Max(int[] a, int lo, int hi) { if (lo == hi) { return hi; } var mid = lo + (hi - lo) / 2; if (a[mid] \u0026lt; a[mid + 1]) { return Max(a, mid + 1, hi); } if (a[mid] \u0026gt; a[mid + 1]) { return Max(a, lo, mid); } return mid; } } 主程序 # var a = BitonicMax.Bitonic(100); var max = BitonicMax.Max(a, 0, a.Length - 1); var key = a[50]; var leftSide = BinarySearchAscending(a, key, 0, max); var rightSide = BinarySearchDescending(a, key, max, a.Length - 1); if (leftSide != -1) { Console.WriteLine(leftSide); } else if (rightSide != -1) { Console.WriteLine(rightSide); } else { Console.WriteLine(\u0026#34;No Result\u0026#34;); } static int BinarySearchAscending(int[] a, int key, int lo, int hi) { while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (a[mid] \u0026lt; key) { lo = mid + 1; } else if (a[mid] \u0026gt; key) { hi = mid - 1; } else { return mid; } } return -1; } static int BinarySearchDescending(int[] a, int key, int lo, int hi) { while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (a[mid] \u0026gt; key) { lo = mid + 1; } else if (a[mid] \u0026lt; key) { hi = mid - 1; } else { return mid; } } return -1; } 另请参阅 # BitonicMax.java\n"},{"id":129,"href":"/1-4-21/","title":"1.4.21","section":"《算法（第四版）》C# 题解","content":" 1.4.21 # 解答 # 直接将 Contains() 实现为二分查找即可。\n代码 # /// \u0026lt;summary\u0026gt; /// 检查数组中是否存在指定元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的值。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;存在则返回 true，否则返回 false。\u0026lt;/returns\u0026gt; public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// \u0026lt;summary\u0026gt; /// 二分查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;查找的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回关键值的下标，如果不存在则返回 -1。\u0026lt;/returns\u0026gt; public int Rank(int key, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key \u0026lt; this.a[mid]) hi = mid - 1; else if (key \u0026gt; this.a[mid]) lo = mid + 1; else return mid; } return -1; } "},{"id":130,"href":"/1-4-22/","title":"1.4.22","section":"《算法（第四版）》C# 题解","content":" 1.4.22 # 解答 # 普通二分查找是通过除法不断减半缩小搜索范围。\n这里我们用斐波那契数列来缩小范围。\n举个例子，例如数组大小是 100，比它大的最小斐波那契数是 144。\n斐波那契数列如下：0 1 1 2 3 5 8 13 21 34 55 89 144\n我们记 F(n) = 144,F(n-1) = 89, F(n-2) = 55。\n我们先查看第 0 + F(n-2) 个数，如果比关键值小则直接将范围缩小到 [55, 100]；否则则在[0, 55]之间查找。\n之后我们令 n = n-1。\n递归上述过程即可完成查找。\n代码 # /// \u0026lt;summary\u0026gt; /// 使用斐波那契数列进行的查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键字。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回查找到的关键值下标，没有结果则返回 -1。\u0026lt;/returns\u0026gt; static int Rank(int[] a, int key) { // 使用斐波那契数列作为缩减范围的依据 var fk = 1; var fk1 = 1; var fk2 = 0; // 获得 Fk，Fk需要大于等于数组的大小，复杂度 lgN while (fk \u0026lt; a.Length) { fk = fk + fk1; fk1 = fk1 + fk2; fk2 = fk - fk1; } var lo = 0; // 按照斐波那契数列缩减查找范围，复杂度 lgN while (fk2 \u0026gt;= 0) { var i = lo + fk2 \u0026gt; a.Length - 1 ? a.Length - 1 : lo + fk2; if (a[i] \u0026lt; key) { lo = lo + fk2; } else if (a[i] == key) { return i; } fk = fk1; fk1 = fk2; fk2 = fk - fk1; } return -1; } "},{"id":131,"href":"/1-4-23/","title":"1.4.23","section":"《算法（第四版）》C# 题解","content":" 1.4.23 # 解答 # 根据书中的提示，将二分查找中判断相等的条件改为两个数的差小于等于 $1/N^2$。\n代码 # // 将二分查找中的相等判定条件修改为差值小于 x，其中 x = 1/N^2。 /// \u0026lt;summary\u0026gt; /// 二分查找。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;查找范围。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;关键字。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结果的下标，没有结果时返回 -1。\u0026lt;/returns\u0026gt; static int BinarySearch(double[] a, double key) { var lo = 0; var hi = a.Length - 1; var threshold = 1.0 / (a.Length * a.Length); while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (Math.Abs(a[mid] - key) \u0026lt;= threshold) { return mid; } if (a[mid] \u0026lt; key) { lo = mid + 1; } else { hi = mid - 1; } } return -1; "},{"id":132,"href":"/1-4-24/","title":"1.4.24","section":"《算法（第四版）》C# 题解","content":" 1.4.24 # 解答 # 第一问：二分查找即可。\n第二问： 按照第 1, 2, 4, 8,\u0026hellip;, 2^k 层顺序查找，一直到 2^k \u0026gt; F， 随后在 [2^(k - 1), 2^k] 范围中二分查找。\n代码 # 这里建立了一个结构体用于返回测试结果：\ninternal struct TestResult { public int F; // 找到的 F 值。 public int BrokenEggs; // 打碎的鸡蛋数。 } 用于测试的方法：\n/// \u0026lt;summary\u0026gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;floor\u0026#34;\u0026gt;扔鸡蛋的高度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static bool ThrowEgg(int floor) { return floor \u0026lt;= f; } /// \u0026lt;summary\u0026gt; /// 第一种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static TestResult PlanA(int[] a) { var lo = 0; var hi = a.Length - 1; var eggs = 0; var result = new TestResult(); while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (ThrowEgg(mid)) { lo = mid + 1; } else { eggs++; hi = mid - 1; } } result.BrokenEggs = eggs; result.F = hi; return result; } /// \u0026lt;summary\u0026gt; /// 第二种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static TestResult PlanB(int[] a) { var lo = 0; var hi = 1; var eggs = 0; var result = new TestResult(); while (ThrowEgg(hi)) { lo = hi; hi *= 2; } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (ThrowEgg(mid)) { lo = mid + 1; } else { eggs++; hi = mid - 1; } } result.BrokenEggs = eggs; result.F = hi; return result; } "},{"id":133,"href":"/1-4-25/","title":"1.4.25","section":"《算法（第四版）》C# 题解","content":" 1.4.25 # 解答 # 第一问：\n第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),\u0026hellip;, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k \u0026lt;= √(N)。\nk-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次。\n第二问：\n按照第 1, 3, 6, 10,\u0026hellip;, 1/2k^2 层顺序查找，一直到 1/2k^2 \u0026gt; F，\n随后在 [1/2k^2 - k, 1/2k^2] 范围中顺序查找。\n代码 # 这里我们同样定义了一个结构体：\ninternal struct TestResult { public int F; // 测试得出的 F 值 public int BrokenEggs; // 碎掉的鸡蛋数。 public int ThrowTimes; // 扔鸡蛋的次数。 } 之后是测试用的方法：\n/// \u0026lt;summary\u0026gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;floor\u0026#34;\u0026gt;扔鸡蛋的高度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static bool ThrowEgg(int floor) { return floor \u0026lt;= f; } /// \u0026lt;summary\u0026gt; /// 第一种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; // 第一种方案。 static TestResult PlanA(int[] a) { var lo = 0; var hi = 0; var eggs = 0; var throwTimes = 0; var result = new TestResult(); while (ThrowEgg(hi)) { throwTimes++; lo = hi; hi += (int)Math.Sqrt(a.Length); } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { if (!ThrowEgg(lo)) { eggs++; break; } throwTimes++; lo++; } result.BrokenEggs = eggs; result.F = lo - 1; result.ThrowTimes = throwTimes; return result; } /// \u0026lt;summary\u0026gt; /// 第二种方案。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;大楼。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static TestResult PlanB(int[] a) { var lo = 0; var hi = 0; var eggs = 0; var throwTimes = 0; var result = new TestResult(); for (var i = 0; ThrowEgg(hi); i++) { throwTimes++; lo = hi; hi += i; } eggs++; if (hi \u0026gt; a.Length - 1) { hi = a.Length - 1; } while (lo \u0026lt;= hi) { if (!ThrowEgg(lo)) { eggs++; break; } lo++; throwTimes++; } result.BrokenEggs = eggs; result.F = lo - 1; result.ThrowTimes = throwTimes; return result; } "},{"id":134,"href":"/1-4-26/","title":"1.4.26","section":"《算法（第四版）》C# 题解","content":" 1.4.26 # 解答 # 首先，我们将问题转化为证明三点\n$$ A(a,a^3),B(b,b^3),C(c,c^3) $$\n共线，当且仅当满足\n$$ a+b+c=0 $$\n证明： 若 $A,B,C$ 三点共线，则直线 $AB$ 和 $BC$ 的斜率必定相等，有方程：\n$$ \\frac{b^3-a^3}{b-a}=\\frac{c^3-b^3}{c-b} $$\n由立方差公式：\n$$ \\frac{(b-a)(b^2+ba+a^2)}{b-a}=\\frac{(c-b)(c^2+cb+b^2)}{c-b} $$\n化简有：\n$$ b^2+ba+a^2=c^2+cb+b^2\\newline ba+a^2=c^2+cb $$\n移项，将 $c$ 视为未知数：\n$$ c^2+cb-ba-a^2=0 $$\n利用十字相乘法进行因式分解：\n$$ (a+b+c)(c-a)=0 $$\n解得：\n$$ c_1=-a-b,c_2=a $$\n显然 $c\\ne a$ ，因此当且仅当 $a+b+c=0$ 时 $A,B,C$ 三点共线。 证毕。\n"},{"id":135,"href":"/1-4-27/","title":"1.4.27","section":"《算法（第四版）》C# 题解","content":" 1.4.27 # 解答 # 实现比较简单，想象两个栈背靠背接在一起，左侧栈负责出队，右侧栈负责入队。\n当左侧栈为空时就把右侧栈中的元素倒到左侧栈，这个过程是 O(n) 的。\n但在这个过程之前必然有 n 个元素入栈，均摊后即为 O(1)。\n代码 # internal class StackQueue\u0026lt;TItem\u0026gt; { private readonly Stack\u0026lt;TItem\u0026gt; _h;// 用于保存出队元素 private readonly Stack\u0026lt;TItem\u0026gt; _;// 用于保存入队元素 /// \u0026lt;summary\u0026gt; /// 构造一个队列。 /// \u0026lt;/summary\u0026gt; public StackQueue() { _h = new Stack\u0026lt;TItem\u0026gt;(); _ = new Stack\u0026lt;TItem\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 将栈 T 中的元素依次弹出并压入栈 H 中。 /// \u0026lt;/summary\u0026gt; private void Reverse() { while (!_.IsEmpty()) { _h.Push(_.Pop()); } } /// \u0026lt;summary\u0026gt; /// 将一个元素出队。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Dequeue() { // 如果没有足够的出队元素，则将 T 中的元素移动过来 if (_h.IsEmpty()) { Reverse(); } return _h.Pop(); } /// \u0026lt;summary\u0026gt; /// 将一个元素入队。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要入队的元素。\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { _.Push(item); } } "},{"id":136,"href":"/1-4-28/","title":"1.4.28","section":"《算法（第四版）》C# 题解","content":" 1.4.28 # 解答 # 每次入队的时候将队列倒转，这样入队的元素就是第一个了。\n代码 # internal class QueueStack\u0026lt;TItem\u0026gt; { private readonly Queue\u0026lt;TItem\u0026gt; _queue; /// \u0026lt;summary\u0026gt; /// 初始化一个栈。 /// \u0026lt;/summary\u0026gt; public QueueStack() { _queue = new Queue\u0026lt;TItem\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 向栈中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Push(TItem item) { _queue.Enqueue(item); var size = _queue.Size(); // 倒转队列 for (var i = 0; i \u0026lt; size - 1; i++) { _queue.Enqueue(_queue.Dequeue()); } } /// \u0026lt;summary\u0026gt; /// 从栈中弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Pop() { return _queue.Dequeue(); } /// \u0026lt;summary\u0026gt; /// 确定栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _queue.IsEmpty(); } } "},{"id":137,"href":"/1-4-29/","title":"1.4.29","section":"《算法（第四版）》C# 题解","content":" 1.4.29 # 解答 # 和用两个栈实现队列的方法类似。\npush 的时候把右侧栈内容倒到左侧栈，之后再入栈。\npop 的时候也做相同操作，右侧栈内容进左侧栈，之后再出栈。\nenqueue 的时候则将左侧栈内容倒到右侧栈，之后再入队。\n代码 # internal class StackSteque\u0026lt;TItem\u0026gt; { private readonly Stack\u0026lt;TItem\u0026gt; _h; private readonly Stack\u0026lt;TItem\u0026gt; _t; /// \u0026lt;summary\u0026gt; /// 初始化一个 Steque /// \u0026lt;/summary\u0026gt; public StackSteque() { _h = new Stack\u0026lt;TItem\u0026gt;(); _t = new Stack\u0026lt;TItem\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 向栈中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Push(TItem item) { ReverseT(); _h.Push(item); } /// \u0026lt;summary\u0026gt; /// 将 T 中的元素弹出并压入到 H 中。 /// \u0026lt;/summary\u0026gt; private void ReverseT() { while (!_t.IsEmpty()) { _h.Push(_t.Pop()); } } /// \u0026lt;summary\u0026gt; /// 将 H 中的元素弹出并压入到 T 中。 /// \u0026lt;/summary\u0026gt; private void ReverseH() { while (!_h.IsEmpty()) { _t.Push(_h.Pop()); } } /// \u0026lt;summary\u0026gt; /// 从 Steque 中弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Pop() { ReverseT(); return _h.Pop(); } /// \u0026lt;summary\u0026gt; /// 在 Steque 尾部添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Enqueue(TItem item) { ReverseH(); _t.Push(item); } /// \u0026lt;summary\u0026gt; /// 检查 Steque 是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _h.IsEmpty() \u0026amp;\u0026amp; _t.IsEmpty(); } } "},{"id":138,"href":"/1-4-30/","title":"1.4.30","section":"《算法（第四版）》C# 题解","content":" 1.4.30 # 解答 # steque 作为队列的头部，stack 作为队列的尾部。\npushLeft：直接 push 到 steque 中即可。\npushRight：如果 stack 为空，则直接 enqueue 到 steque 中，否则就 push 到 stack 中。\npopLeft：如果 steque 为空，则将 stack 中的元素倒到 steque 中去（steque.push(stack.pop())），然后再从 steque 中 pop。\npopRight：如果 stack 为空，则将 steque 中的元素倒到 stack 中去，然后再从 stack 中 pop。\n代码 # internal class Deque\u0026lt;TItem\u0026gt; { private readonly Stack\u0026lt;TItem\u0026gt; _stack; // 代表队列尾部 private readonly Steque\u0026lt;TItem\u0026gt; _steque;// 代表队列头部 /// \u0026lt;summary\u0026gt; /// 创建一条空的双向队列。 /// \u0026lt;/summary\u0026gt; public Deque() { _stack = new Stack\u0026lt;TItem\u0026gt;(); _steque = new Steque\u0026lt;TItem\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 在左侧插入一个新元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; public void PushLeft(TItem item) { _steque.Push(item); } /// \u0026lt;summary\u0026gt; /// 将栈中的内容移动到 Steque 中。 /// \u0026lt;/summary\u0026gt; private void StackToSteque() { while (!_stack.IsEmpty()) { _steque.Push(_stack.Pop()); } } /// \u0026lt;summary\u0026gt; /// 将 Steque 中的内容移动到栈中。 /// \u0026lt;/summary\u0026gt; private void StequeToStack() { while (!_steque.IsEmpty()) { _stack.Push(_steque.Pop()); } } /// \u0026lt;summary\u0026gt; /// 从双向队列左侧弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopLeft() { if (_steque.IsEmpty()) { StackToSteque(); } return _steque.Pop(); } /// \u0026lt;summary\u0026gt; /// 向双向队列右侧添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; public void PushRight(TItem item) { if (_stack.IsEmpty()) { _steque.Enqueue(item); } else { _stack.Push(item); } } /// \u0026lt;summary\u0026gt; /// 从双向队列右侧弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopRight() { if (_stack.IsEmpty()) { StequeToStack(); } return _stack.Pop(); } /// \u0026lt;summary\u0026gt; /// 判断队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _stack.IsEmpty() \u0026amp;\u0026amp; _steque.IsEmpty(); } /// \u0026lt;summary\u0026gt; /// 返回队列中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _stack.Size() + _steque.Size(); } } "},{"id":139,"href":"/1-4-31/","title":"1.4.31","section":"《算法（第四版）》C# 题解","content":" 1.4.31 # 解答 # 三个栈分别命名为左中右。\n左侧栈和右侧栈负责模拟队列，和用两个栈模拟队列的方法类似。\n由于是双向队列，左栈和右栈会频繁的倒来倒去，因此每次都只倒一半的元素可以有效减少开销。\n有一侧栈为空时，另一侧栈中上半部分先移动到中间栈中，下半部分倒到另一侧栈里，再从中间栈拿回上半部分元素。\n这样可以确保接下来的 pop 操作一定是常数级别的。\n代码 # internal class Deque\u0026lt;TItem\u0026gt; { private readonly Stack\u0026lt;TItem\u0026gt; _left; private readonly Stack\u0026lt;TItem\u0026gt; _middle; private readonly Stack\u0026lt;TItem\u0026gt; _right; /// \u0026lt;summary\u0026gt; /// 构造一条新的双向队列。 /// \u0026lt;/summary\u0026gt; public Deque() { _left = new Stack\u0026lt;TItem\u0026gt;(); _middle = new Stack\u0026lt;TItem\u0026gt;(); _right = new Stack\u0026lt;TItem\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 向双向队列左侧插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; public void PushLeft(TItem item) { _left.Push(item); } /// \u0026lt;summary\u0026gt; /// 向双向队列右侧插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要插入的元素。\u0026lt;/param\u0026gt; public void PushRight(TItem item) { _right.Push(item); } /// \u0026lt;summary\u0026gt; /// 当一侧栈为空时，将另一侧的下半部分元素移动过来。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;source\u0026#34;\u0026gt;不为空的栈。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;destination\u0026#34;\u0026gt;空栈。\u0026lt;/param\u0026gt; private void Move(Stack\u0026lt;TItem\u0026gt; source, Stack\u0026lt;TItem\u0026gt; destination) { var n = source.Size(); // 将上半部分元素移动到临时栈 middle for (var i = 0; i \u0026lt; n / 2; i++) { _middle.Push(source.Pop()); } // 将下半部分移动到另一侧栈中 while (!source.IsEmpty()) { destination.Push(source.Pop()); } // 从 middle 取回上半部分元素 while (!_middle.IsEmpty()) { source.Push(_middle.Pop()); } } /// \u0026lt;summary\u0026gt; /// 检查双端队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _right.IsEmpty() \u0026amp;\u0026amp; _middle.IsEmpty() \u0026amp;\u0026amp; _left.IsEmpty(); } /// \u0026lt;summary\u0026gt; /// 从右侧弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopRight() { if (_right.IsEmpty()) { Move(_left, _right); } return _right.Pop(); } /// \u0026lt;summary\u0026gt; /// 从左侧弹出一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem PopLeft() { if (_left.IsEmpty()) { Move(_right, _left); } return _left.Pop(); } /// \u0026lt;summary\u0026gt; /// 返回双端队列的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _left.Size() + _middle.Size() + _right.Size(); } } "},{"id":140,"href":"/1-4-32/","title":"1.4.32","section":"《算法（第四版）》C# 题解","content":" 1.4.32 # 解答 # 首先，不需要扩容数组的的操作都只需访问数组一次，$M$ 次操作就是 $M$ 次访问。\n随后我们有性质， $M$ 次栈操作后额外复制访问数组的次数小于 $2M$。\n这里简单证明，设 $M$ 次操作之后栈的大小为 $n$，那么额外访问数组的次数为：\n$S = \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} +\u0026hellip;+ 2 \u0026lt; n$\n为了能使栈大小达到 $n$，$M$ 必须大于等于 $\\frac{n}{2}$\n因此 $2M \\ge n \u0026gt; S$，得证。\n因此我们可以得到 $M$ 次操作后访问数组次数的总和 $S\u0026rsquo; = S + M \u0026lt; 3M$。\n"},{"id":141,"href":"/1-4-33/","title":"1.4.33","section":"《算法（第四版）》C# 题解","content":" 1.4.33 # 解答 # Integer = 4(int) + 8(对象开销) = 12\nDate = 3 × 4(int × 3) + 8(对象开销) = 20\nCounter = 4(String 的引用) + 4(int) + 8(对象开销) = 16\nint[] = 8(对象开销) + 4(数组长度) + 4N = 12 + 4N\ndouble[] = 8(对象开销) + 4(数组长度) + 8N = 12 + 8N\ndouble[][] = 8(对象开销) + 4(数组长度) + 4M(引用) + M(12 + 8N)(M 个一维数组) = 12 + 16M + 8MN\nString = 8(对象开销) + 3 × 4(int × 3) + 4(字符数组的引用) = 24\nNode = 8(对象开销) + 4 × 2(引用 × 2) = 16\nStack = 8(对象开销) + 4(引用) + 4(int) = 16\n"},{"id":142,"href":"/1-4-34/","title":"1.4.34","section":"《算法（第四版）》C# 题解","content":" 1.4.34 # 解答 # 第一种方案，类似于二分查找，先猜测左边界(lo)，再猜测右边界(hi)，如果边界值猜中的话直接返回，否则：\n如果右边界比较热，那么左边界向右边界靠，lo=mid；否则，右边界向左边界靠，hi=mid。其中，mid = lo + (hi – lo)/2。\n每次二分查找都要猜测两次，~2lgN。\n第二种方案，假设上次猜测值为 $lastGuess$，本次即将要猜测的值为 $nowGuess$，通过方程：\n$(lastGuess + nowGuess)/2 = (lo + hi)/2$\n可以求得 $nowGuess$，具体可以查看示意图：\n数字是猜测顺序，黑色范围是猜测值的范围（$lastGuess$ 和 $nowGuess$），绿色的是实际查找的范围（lo 和 hi）。\n代码 # 首先是 Game 类\ninternal class Game { public int N { get; } // 目标值的最大范围。 public int SecretNumber { get; } // 目标值。 public int LastGuess { get; private set; } // 上次猜测的值 /// \u0026lt;summary\u0026gt; /// 构造函数，新开一局游戏。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;目标值的最大范围。\u0026lt;/param\u0026gt; public Game(int n) { var random = new Random(); N = n; SecretNumber = random.Next(n - 1) + 1; LastGuess = -1; } /// \u0026lt;summary\u0026gt; /// 猜测，根据与上次相比更为接近还是远离目标值返回结果。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;guess\u0026#34;\u0026gt;本次的猜测值\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;接近或不变返回 Hot，远离则返回 Cold，猜中返回 Equal。\u0026lt;/returns\u0026gt; public GuessResult Guess(int guess) { if (guess == SecretNumber) { return GuessResult.Equal; } if (LastGuess == -1) { LastGuess = guess; return GuessResult.FirstGuess; } var lastDiff = Math.Abs(LastGuess - SecretNumber); LastGuess = guess; var nowDiff = Math.Abs(guess - SecretNumber); if (nowDiff \u0026gt; lastDiff) { return GuessResult.Cold; } return GuessResult.Hot; } /// \u0026lt;summary\u0026gt; /// 重置游戏，清空上次猜测的记录。目标值和最大值都不变。 /// \u0026lt;/summary\u0026gt; public void Restart() { LastGuess = -1; } } 之后是实际测试的方法：\nvar game = new Game(1000); var a = PlayGameA(game); game.Restart(); var b = PlayGameB(game); Console.WriteLine($\u0026#34;SecretNumber:{game.SecretNumber}\u0026#34;); Console.WriteLine(\u0026#34;TestResultA:\u0026#34;); Console.WriteLine($\u0026#34;SecretNumber:{a.SecretNumber}, TryTimes:{a.TryTimes}\u0026#34;); Console.WriteLine(); Console.WriteLine(\u0026#34;TestResultB:\u0026#34;); Console.WriteLine($\u0026#34;SecretNumber:{b.SecretNumber}, TryTimes:{b.TryTimes}\u0026#34;); // 方案一，用二分查找实现，需要猜测 2lgN 次。 static TestResult PlayGameA(Game game) { TestResult result; result.TryTimes = 0; result.SecretNumber = 0; var hi = game.N; var lo = 1; // 利用二分查找猜测，2lgN while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; var guessResult = game.Guess(lo); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = lo; return result; } guessResult = game.Guess(hi); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = hi; return result; } if (guessResult == GuessResult.Hot) { lo = mid; } else { hi = mid; } } return result; } // 方案二，根据 (lastGuess + nowGuess)/2 = (lo + hi) / 2 确定每次猜测的值。 static TestResult PlayGameB(Game game) { TestResult result; result.TryTimes = 0; result.SecretNumber = 0; var hi = game.N; var lo = 1; var isRightSide = true; // 第一次猜测 var guessResult = game.Guess(1); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = 1; return result; } while (lo \u0026lt; hi) { var mid = lo + (hi - lo) / 2; var nowGuess = (lo + hi) - game.LastGuess; guessResult = game.Guess(nowGuess); result.TryTimes++; if (guessResult == GuessResult.Equal) { result.SecretNumber = nowGuess; break; } if (guessResult == GuessResult.Hot) { if (isRightSide) { lo = mid; } else { hi = mid; } } else { if (isRightSide) { hi = mid; } else { lo = mid; } } isRightSide = !isRightSide; if (hi - lo \u0026lt;= 1) { break; } } if (game.Guess(lo) == GuessResult.Equal) { result.TryTimes++; result.SecretNumber = lo; } else if (game.Guess(hi) == GuessResult.Equal) { result.TryTimes++; result.SecretNumber = hi; } return result; } /// \u0026lt;summary\u0026gt; /// 某种方案的测试结果，包含猜测结果和尝试次数。 /// \u0026lt;/summary\u0026gt; internal struct TestResult { public int SecretNumber; // 猜测到的数字。 public int TryTimes; // 尝试次数。 } "},{"id":143,"href":"/1-4-35/","title":"1.4.35","section":"《算法（第四版）》C# 题解","content":" 1.4.35 # 解答 # 1. 一个 Node 对象包含一个 int(泛型 Item) 的引用和下一个 Node 对象的引用。push 操作创建新 Node 对象时会创建一个引用。\n因此对于第一种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象，创建了 2N 个引用。\n2. 比起上一种情况，每个 Node 对象多包含了一个指向 Integer 的引用。\n因此对于第二种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象和 N 个 Integer 对象，比起第一种情况多创建了 N 个引用。\n3. 对于数组来说，创建对象只有扩容时重新创建数组对象一种情况，对于 N 次 push 操作只需要 lgN 次扩容，因此创建的对象为 lgN 个。\n每次扩容都需要重新创建引用，(4 + 8 +\u0026hellip;+ 2N)(扩容) + N(每次 push 操作) = 5N - 4 = ~5N\n4. 创建引用和上题一样，创建对象则多出了装箱过程，每次 push 都会新建一个 Integer 对象，N + lgN = ~N。\n"},{"id":144,"href":"/1-4-36/","title":"1.4.36","section":"《算法（第四版）》C# 题解","content":" 1.4.36 # 解答 # 1. N 个 Node 对象的空间开销 = N * (16(对象开销) + 4(int) + 8(下一个 Node 的引用) + 4(填充字节)) = 32N\n2. 比起上一题来说，空间开销变为\n= N * (16(Node 对象开销) + 8(Integer 对象引用) + (16(Integer 对象开销) + 4(int) + 4(填充字节)) + 8(下一个对象的引用) = 32N + 24N = 56N。\n3. 如果不扩容则是 4N，N 个元素最多可以维持 4N 的栈空间（少于四分之一将缩小）。\n4. 比起上一题，数组元素变成了引用每个占用 8 字节，还要额外加上 Integer 对象的每个 24 字节。\n= (8 + 24)N ~ (8 * 4 + 24)N\n"},{"id":145,"href":"/1-4-37/","title":"1.4.37","section":"《算法（第四版）》C# 题解","content":" 1.4.37 # 解答 # 数据量比较大时才会有比较明显的差距。\n代码 # FixedCapacityStackOfInts\n/// \u0026lt;summary\u0026gt; /// 固定大小的整型数据栈。 /// \u0026lt;/summary\u0026gt; internal class FixedCapacityStackOfInts : IEnumerable\u0026lt;int\u0026gt; { private readonly int[] _a; private int _n; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt; public FixedCapacityStackOfInts(int capacity) { _a = new int[capacity]; _n = 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _n == 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否已满。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsFull() { return _n == _a.Length; } /// \u0026lt;summary\u0026gt; /// 将一个元素压入栈中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt; public void Push(int item) { _a[_n] = item; _n++; } /// \u0026lt;summary\u0026gt; /// 从栈中弹出一个元素，返回被弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Pop() { _n--; return _a[_n]; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Peek() { return _a[_n - 1]; } public IEnumerator\u0026lt;int\u0026gt; GetEnumerator() { return new ReverseEnmerator(_a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;int\u0026gt; { private int _current; private int[] _a; public ReverseEnmerator(int[] a) { _current = a.Length; _a = a; } int IEnumerator\u0026lt;int\u0026gt;.Current =\u0026gt; _a[_current]; object IEnumerator.Current =\u0026gt; _a[_current]; void IDisposable.Dispose() { _current = -1; _a = null; } bool IEnumerator.MoveNext() { if (_current == 0) return false; _current--; return true; } void IEnumerator.Reset() { _current = _a.Length; } } } FixedCapacityStack\u0026lt;Item\u0026gt;\ninternal class FixedCapacityStack\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private readonly TItem[] _a; private int _n; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;栈的大小。\u0026lt;/param\u0026gt; public FixedCapacityStack(int capacity) { _a = new TItem[capacity]; _n = 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _n == 0; } /// \u0026lt;summary\u0026gt; /// 检查栈是否已满。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsFull() { return _n == _a.Length; } /// \u0026lt;summary\u0026gt; /// 将一个元素压入栈中。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要压入栈中的元素。\u0026lt;/param\u0026gt; public void Push(TItem item) { _a[_n] = item; _n++; } /// \u0026lt;summary\u0026gt; /// 从栈中弹出一个元素，返回被弹出的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Pop() { _n--; return _a[_n]; } /// \u0026lt;summary\u0026gt; /// 返回栈顶元素（但不弹出它）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public TItem Peek() { return _a[_n - 1]; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new ReverseEnmerator(_a); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class ReverseEnmerator : IEnumerator\u0026lt;TItem\u0026gt; { private int _current; private TItem[] _a; public ReverseEnmerator(TItem[] a) { _current = a.Length; _a = a; } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _a[_current]; object IEnumerator.Current =\u0026gt; _a[_current]; void IDisposable.Dispose() { _current = -1; _a = null; } bool IEnumerator.MoveNext() { if (_current == 0) return false; _current--; return true; } void IEnumerator.Reset() { _current = _a.Length; } } } 测试函数：\npublic static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// \u0026lt;summary\u0026gt; /// 返回对 n 个随机整数的栈进行 n 次 push 和 n 次 pop 所需的时间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static double TimeTrial(int n) { var a = new int[n]; var stack = new FixedCapacityStackOfInts(n); var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(-MaximumInteger, MaximumInteger); } var timer = new Stopwatch(); for (var i = 0; i \u0026lt; n; i++) { stack.Push(a[i]); } for (var i = 0; i \u0026lt; n; i++) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt; /// 返回对 n 个随机整数的栈进行 n 次 push 和 n 次 pop 所需的时间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static double TimeTrialGeneric(int n) { var a = new int[n]; var stack = new FixedCapacityStack\u0026lt;int\u0026gt;(n); var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(-MaximumInteger, MaximumInteger); } var timer = new Stopwatch(); for (var i = 0; i \u0026lt; n; i++) { stack.Push(a[i]); } for (var i = 0; i \u0026lt; n; i++) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } } 主函数\nConsole.WriteLine(\u0026#34;测试量\\t非泛型耗时（毫秒）\\t泛型耗时（毫秒）\\t差值\u0026#34;); for (var n = 250; true; n += n) { var time = DoubleTest.TimeTrial(n); var timeGeneric = DoubleTest.TimeTrialGeneric(n); Console.WriteLine($\u0026#34;{n}\\t{time}\\t{timeGeneric}\\t{Math.Abs(time - timeGeneric)}\u0026#34;); } 另请参阅 # Measurement 库\n"},{"id":146,"href":"/1-4-38/","title":"1.4.38","section":"《算法（第四版）》C# 题解","content":" 1.4.38 # 解答 # 把 DoublingTest 中调用的函数稍作修改即可。\n代码 # ThreeSum 测试类\npublic static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// \u0026lt;summary\u0026gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static double TimeTrial(int n) { var a = new int[n]; var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(-MaximumInteger, MaximumInteger); } var timer = new Measurement.Stopwatch(); ThreeSum.Count(a); return timer.ElapsedTime(); } } ThreeSum\npublic static class ThreeSum { /// \u0026lt;summary\u0026gt; /// 输出所有和为零的三元组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt; public static void PrintAll(int[] a) { var n = a.Length; for (var i = 0; i \u0026lt; n; i++) { for (var j = 0; j \u0026lt; n; j++) { for (var k = 0; k \u0026lt; n; k++) { if (i \u0026lt; j \u0026amp;\u0026amp; j \u0026lt; k) { if ((long)a[i] + a[j] + a[k] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]}\u0026#34;); } } } } } } /// \u0026lt;summary\u0026gt; /// 计算和为零的三元组的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static int Count(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i \u0026lt; n; i++) { for (var j = 0; j \u0026lt; n; j++) { for (var k = 0; k \u0026lt; n; k++) { if (i \u0026lt; j \u0026amp;\u0026amp; j \u0026lt; k) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } } return count; } } "},{"id":147,"href":"/1-4-39/","title":"1.4.39","section":"《算法（第四版）》C# 题解","content":" 1.4.39 # 解答 # 执行 N 次后取平均即可。\n代码 # 修改后的 DoublingTest：\npublic static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// \u0026lt;summary\u0026gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;随机数组的长度。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;repeatTimes\u0026#34;\u0026gt;重复测试的次数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static double TimeTrial(int n, int repeatTimes) { var a = new int[n]; double sum = 0; var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(-MaximumInteger, MaximumInteger); } for (var i = 0; i \u0026lt; repeatTimes; i++) { var timer = new Stopwatch(); ThreeSum.Count(a); sum += timer.ElapsedTime(); } return sum / repeatTimes; } } 另请参阅 # Measurement 库\n"},{"id":148,"href":"/1-4-40/","title":"1.4.40","section":"《算法（第四版）》C# 题解","content":" 1.4.40 # 解答 # N 个数可组成的三元组的总数为：\n$C(N, 3) = N(N-1)(N-2)/3! = ~ (N^3)/6​$ （组合数公式）\n$[-M, M]​$ 中随机 $N​$ 次，有 $(2M+1)^N​$ 种随机序列（每次随机都有 $2M+1​$ 种可能）\n按照分步计数方法，将随机序列分为和为零的三元组和其余 $N-3​$ 个数\n这些序列中，和为零的三元组有 $3M^2 + 3M + 1​$ 种可能。\n其他不为零的 $N-3​$ 个位置有 $(2M+1)^{(N-3)}​$ 种可能。\n总共有 $((N^3)/6) \\times (3M^2 + 3M + 1) \\times (2M+1)^{(N-3)}​$ 种可能性\n平均值为：\n$[((N^3)/6) \\times (3M^2 + 3M + 1) \\times (2M+1)^{(N-3)}] / (2M+1)^N​$ $=N^3/16M​$\n$3M^2 + 3M + 1$ 的推导：\n在 $[-M,M]$ 中取三个数，和为零的序列有几个？ 假设第一个数取 $0$， 取 $(0, 0, 0)$ 的情况最后加上。\n剩下两个数只能以 $0$ 为中心对称配对，总共 $2M / 2$ 种组合。\n换成排列数（例如 (0 ,1 ,-1) 和 (0 ,-1 ,1) 是两种不同的排列）就是 $2M$ 种。\n加上 $(0, 0, 0)$ 就是 $2M+1$ 种序列。\n假设第一个数取 $1$，那么 $M$ 就不能再取（剩下的数不能获得 $M+1$），剩下 $2M$ 个数对称配对。\n总共 $(2M)/2 * 2 = 2M$ 种排列。\n假设第一个数取 $2$，那么 $M$ 和 $M-1$ 就不能再取，剩下 $2M-1$ 个数配对。\n总共 $2M-1$ 种序列。\n以此类推，第一个数取 $M $ 时，只能在 $-M$ 到 $0$ 之间配对，总共 $M+1$ 种序列。\n$-M$ 到 $-1$ 之间的序列数计算完全一样，于是由等差数列求和公式：\n$$ \\frac{(M+1+2M)M}{2} \\times 2 + 2M+1=3M^2+3M+1 $$\n第一项为 $1$ 到 $M$ 之间的序列数，乘上 $2$ 再加上取 $0​$ 时的序列数即为所求的全部序列数。\n代码 # public static class ThreeSum { /// \u0026lt;summary\u0026gt; /// 输出所有和为零的三元组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt; public static void PrintAll(int[] a) { var n = a.Length; for (var i = 0; i \u0026lt; n; i++) { Console.WriteLine($\u0026#34;for number \\\u0026#34;{a[i]}\\\u0026#34;\u0026#34;); var count = 0; for (var j = i + 1; j \u0026lt; n; j++) { for (var k = j + 1; k \u0026lt; n; k++) { if ((long)a[i] + a[j] + a[k] == 0) { Console.WriteLine($\u0026#34;{a[i]} + {a[j]} + {a[k]}\u0026#34;); count++; } } } Console.WriteLine($\u0026#34;Count:{count}\u0026#34;); } } /// \u0026lt;summary\u0026gt; /// 计算和为零的三元组的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;输入数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static int Count(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i \u0026lt; n; i++) { for (var j = i + 1; j \u0026lt; n; j++) { for (var k = j + 1; k \u0026lt; n; k++) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } return count; } } "},{"id":149,"href":"/1-4-41/","title":"1.4.41","section":"《算法（第四版）》C# 题解","content":" 1.4.41 # 解答 # 代码 # 这里使用了委托来简化代码。\nDoublingRatio\npublic delegate int Count(int[] a); internal static class DoublingRatio { /// \u0026lt;summary\u0026gt; /// 从指定字符串中读入按行分割的整型数据。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;inputString\u0026#34;\u0026gt;源字符串。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;读入的整型数组\u0026lt;/returns\u0026gt; private static int[] ReadAllInts(string inputString) { var split = new[] { \u0026#39;\\n\u0026#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i \u0026lt; a.Length; i++) { a[i] = int.Parse(input[i]); } return a; } /// \u0026lt;summary\u0026gt; /// 使用给定的数组进行一次测试，返回耗时（毫秒）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;count\u0026#34;\u0026gt;要测试的方法。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;耗时（秒）。\u0026lt;/returns\u0026gt; public static double TimeTrial(Count count, int[] a) { var timer = new Stopwatch(); count(a); return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt; /// 对 TwoSum、TwoSumFast、ThreeSum 或 ThreeSumFast 的 Count 方法做测试。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;count\u0026#34;\u0026gt;相应类的 Count 方法。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;随着数据量倍增，方法耗时增加的比率。\u0026lt;/returns\u0026gt; public static double Test(Count count) { double ratio = 0; double times = 3; // 1K var a = ReadAllInts(File.ReadAllText(DataFiles._1KInts)); var prevTime = TimeTrial(count, a); Console.WriteLine(\u0026#34;数据量\\t耗时\\t比值\u0026#34;); Console.WriteLine($\u0026#34;1000\\t{prevTime / 1000}\\t\u0026#34;); // 2K a = ReadAllInts(File.ReadAllText(DataFiles._2KInts)); var time = TimeTrial(count, a); Console.WriteLine($\u0026#34;2000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 4K a = ReadAllInts(File.ReadAllText(DataFiles._4KInts)); time = TimeTrial(count, a); Console.WriteLine($\u0026#34;4000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 8K a = ReadAllInts(File.ReadAllText(DataFiles._8KInts)); time = TimeTrial(count, a); Console.WriteLine($\u0026#34;8000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } return ratio / times; } /// \u0026lt;summary\u0026gt; /// 对 TwoSumFast 的 Count 方法做测试。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;count\u0026#34;\u0026gt;TwoSumFast 的 Count 方法\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;随着数据量倍增，方法耗时增加的比率。\u0026lt;/returns\u0026gt; public static double TestTwoSumFast(Count count) { double ratio = 0; double times = 2; // 8K var a = ReadAllInts(File.ReadAllText(DataFiles._8KInts)); var prevTime = TimeTrial(count, a); Console.WriteLine(\u0026#34;数据量\\t耗时\\t比值\u0026#34;); Console.WriteLine($\u0026#34;8000\\t{prevTime / 1000}\\t\u0026#34;); // 16K a = ReadAllInts(File.ReadAllText(DataFiles._16KInts)); var time = TimeTrial(count, a); Console.WriteLine($\u0026#34;16000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } prevTime = time; // 32K a = ReadAllInts(File.ReadAllText(DataFiles._32KInts)); time = TimeTrial(count, a); Console.WriteLine($\u0026#34;32000\\t{time / 1000}\\t{time / prevTime}\u0026#34;); if (prevTime != 0) { ratio += time / prevTime; } else { times--; } return ratio / times; } } 主函数\nvar a = new int[977]; var random = new Random(); for (var i = 0; i \u0026lt; 977; i++) { a[i] = random.Next(977) - 489; } // ThreeSum Console.WriteLine(\u0026#34;ThreeSum\u0026#34;); var time = DoublingRatio.TimeTrial(ThreeSum.Count, a); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); var doubleRatio = DoublingRatio.Test(ThreeSum.Count); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); //// ThreeSumFast Console.WriteLine(\u0026#34;ThreeSumFast\u0026#34;); time = DoublingRatio.TimeTrial(ThreeSumFast.Count, a); doubleRatio = DoublingRatio.Test(ThreeSumFast.Count); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); //// TwoSum Console.WriteLine(\u0026#34;TwoSum\u0026#34;); time = DoublingRatio.TimeTrial(TwoSum.Count, a); doubleRatio = DoublingRatio.Test(TwoSum.Count); Console.WriteLine($\u0026#34;数据量：977 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 1024 / 1000}\u0026#34;); Console.WriteLine(); // TwoSumFast // 速度太快，加大数据量 a = new int[62500]; for (var i = 0; i \u0026lt; 977; i++) { a[i] = random.Next(62500) - 31250; } Console.WriteLine(\u0026#34;TwoSumFast\u0026#34;); time = DoublingRatio.TimeTrial(TwoSumFast.Count, a); doubleRatio = DoublingRatio.TestTwoSumFast(TwoSumFast.Count); Console.WriteLine($\u0026#34;数据量：62500 耗时：{time / 1000}\u0026#34;); Console.WriteLine($\u0026#34;数据量：1000000 估计耗时：{time * doubleRatio * 16 / 1000}\u0026#34;); Console.WriteLine(); 另请参阅 # 委托-C#语言介绍 Measurement 库\n"},{"id":150,"href":"/1-4-42/","title":"1.4.42","section":"《算法（第四版）》C# 题解","content":" 1.4.42 # 解答 # 这里我们把时限设置为一小时，使用上一题的数据估计。\n1.ThreeSum 暴力方法在输入倍增时耗时增加 2^3 = 8 倍。\n1K 数据耗费了 1.15 秒，在一小时内（3600 秒）可以完成 2^3 = 8K 数据。\n2.ThreeSumFast 方法在输入倍增时耗时增加 2^2 = 4 倍。\n1K 数据耗费了 0.05 秒，在一小时内（3600 秒）可以完成 2^8 = 256K 数据。\n3.TwoSum 暴力方法在输入倍增时耗时增加 2^2 = 4 倍。\n8K 数据耗费了 0.14 秒，在一小时内（3600 秒）可以完成 2^10 = 1024K 数据。\n4.TwoSumFast 在输入倍增时耗时增加 2^1 = 2 倍。\n32K 数据耗费了 0.008 秒，在一小时内（3600 秒）可以完成 2^16 = 65536K 数据。\n"},{"id":151,"href":"/1-4-43/","title":"1.4.43","section":"《算法（第四版）》C# 题解","content":" 1.4.43 # 解答 # 代码 # 修改后的 DoublingRatio\ninternal static class DoublingRatio { /// \u0026lt;summary\u0026gt; /// 从指定字符串中读入按行分割的整型数据。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;inputString\u0026#34;\u0026gt;源字符串。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;读入的整型数组\u0026lt;/returns\u0026gt; private static int[] ReadAllInts(string inputString) { var split = new[] { \u0026#39;\\n\u0026#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i \u0026lt; a.Length; i++) { a[i] = int.Parse(input[i]); } return a; } /// \u0026lt;summary\u0026gt; /// 使用给定的数组对链栈进行一次测试，返回耗时（毫秒）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;耗时（毫秒）。\u0026lt;/returns\u0026gt; public static double TimeTrialLinkedStack(int[] a) { var stack = new LinkedStack\u0026lt;int\u0026gt;(); var n = a.Length; var timer = new Stopwatch(); for (var i = 0; i \u0026lt; n; i++) { stack.Push(a[i]); } for (var i = 0; i \u0026lt; n; i++) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt; /// 使用给定的数组对数组栈进行一次测试，返回耗时（毫秒）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;测试用的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;耗时（毫秒）。\u0026lt;/returns\u0026gt; public static double TimeTrialDoublingStack(int[] a) { var stack = new DoublingStack\u0026lt;int\u0026gt;(); var n = a.Length; var timer = new Stopwatch(); for (var i = 0; i \u0026lt; n; i++) { stack.Push(a[i]); } for (var i = 0; i \u0026lt; n; i++) { stack.Pop(); } return timer.ElapsedTimeMillionSeconds(); } /// \u0026lt;summary\u0026gt; /// 对链栈和基于大小可变的数组栈做测试。 /// \u0026lt;/summary\u0026gt; public static void Test() { Console.WriteLine(\u0026#34;数据量\\t链栈\\t数组\\t比值\\t单位：毫秒\u0026#34;); // 16K var a = ReadAllInts(File.ReadAllText(DataFiles._16KInts)); var linkedTime = TimeTrialLinkedStack(a); var arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;16000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); // 32K a = ReadAllInts(File.ReadAllText(DataFiles._32KInts)); linkedTime = TimeTrialLinkedStack(a); arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;32000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); // 1M a = ReadAllInts(File.ReadAllText(DataFiles._1MInts)); linkedTime = TimeTrialLinkedStack(a); arrayTime = TimeTrialDoublingStack(a); Console.WriteLine($\u0026#34;1000000\\t{linkedTime}\\t{arrayTime}\\t{linkedTime / arrayTime}\u0026#34;); } } 另请参阅 # Measurement 库\n"},{"id":152,"href":"/1-4-44/","title":"1.4.44","section":"《算法（第四版）》C# 题解","content":" 1.4.44 # 解答 # 每生成一个随机数都和之前生成过的随机数相比较。\n代码 # var random = new Random(); const int n = 10000; var a = new int[n]; var dupNum = 0; int times; for (times = 0; times \u0026lt; 500; times++) { for (var i = 0; i \u0026lt; n; i++) { a[i] = random.Next(n); if (IsDuplicated(a, i)) { dupNum += i; Console.WriteLine($\u0026#34;生成{i + 1}个数字后发生重复\u0026#34;); break; } } } Console.WriteLine($\u0026#34;√(πN/2)={Math.Sqrt(Math.PI * n / 2.0)}，平均生成{dupNum / times}个数字后出现重复\u0026#34;); // 检查是否有重复的数字出现。 static bool IsDuplicated(int[] a, int i) { for (var j = 0; j \u0026lt; i; j++) { if (a[j] == a[i]) { return true; } } return false; } "},{"id":153,"href":"/1-4-45/","title":"1.4.45","section":"《算法（第四版）》C# 题解","content":" 1.4.45 # 解答 # 建立一个布尔数组，将每次随机出来的数作为下标，将相应位置的布尔值改为 true，每次随机都检查一遍这个数组是否都是 true。\n代码 # // HN 指的是调和级数 var random = new Random(); var n = 10000; var a = new bool[n]; var randomSize = 0; int times; for (times = 0; times \u0026lt; 20; times++) { for (var i = 0; i \u0026lt; n; i++) { a[i] = false; } for (var i = 0; true; i++) { var now = random.Next(n); a[now] = true; if (IsAllGenerated(a)) { randomSize += i; Console.WriteLine($\u0026#34;生成{i}次后所有可能均出现过了\u0026#34;); break; } } } Console.WriteLine($\u0026#34;NHN={n * HarmonicSum(n)}，平均生成{randomSize / times}个数字后所有可能都出现\u0026#34;); // 计算 N 阶调和级数的和。 static double HarmonicSum(int n) { double sum = 0; for (var i = 1; i \u0026lt;= n; i++) { sum += 1.0 / i; } return sum; } // 检查所有数字是否都生成过了。 static bool IsAllGenerated(bool[] a) { foreach (var i in a) { if (!i) return false; } return true; } "},{"id":154,"href":"/1-5-1/","title":"1.5.1","section":"《算法（第四版）》C# 题解","content":" 1.5.1 # 解答 # quick-find 的官方实现：QuickFindUF.java。\n只要实现相应并查集，然后输入内容即可。\n增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。\n样例输出：\n1 2 3 4 5 6 7 8 0 数组访问：13 1 2 4 4 5 6 7 8 0 数组访问：13 1 2 4 4 8 6 7 8 0 数组访问：13 1 2 4 4 8 6 2 8 0 数组访问：13 1 1 4 4 8 6 1 8 0 数组访问：14 1 1 4 4 1 6 1 1 0 数组访问：14 1 1 4 4 1 6 1 1 4 数组访问：14 1 1 1 1 1 6 1 1 1 数组访问：16 代码 # QuickFindUF.cs，这个类继承了 UF.cs，重新实现了 Union() 和 Find() 等方法。\n关于 UF.cs 可以参见原书中文版 P138 或英文版 P221 的算法 1.5。\n/// \u0026lt;summary\u0026gt; /// 用 QuickFind 算法实现的并查集。 /// \u0026lt;/summary\u0026gt; public class QuickFindUf : Uf { /// \u0026lt;summary\u0026gt; /// 记录数组访问次数的计数器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;记录数组访问的计数器。\u0026lt;/value\u0026gt; public int ArrayVisitCount { get; private set; } /// \u0026lt;summary\u0026gt; /// 新建一个使用 quick-find 实现的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt; public QuickFindUf(int n) : base(n) { } /// \u0026lt;summary\u0026gt; /// 重置数组访问计数。 /// \u0026lt;/summary\u0026gt; public void ResetArrayCount() { ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt; /// 寻找 p 所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;p\u0026#34;/\u0026gt; 所在的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { Validate(p); ArrayVisitCount++; return Parent[p]; } /// \u0026lt;summary\u0026gt; /// 判断两个结点是否属于同一个连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要判断的另一个结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果属于同一个连通分量则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public override bool IsConnected(int p, int q) { Validate(p); Validate(q); ArrayVisitCount += 2; return Parent[p] == Parent[q]; } /// \u0026lt;summary\u0026gt; /// 将两个结点所在的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public override void Union(int p, int q) { Validate(p); Validate(q); var pId = Parent[p]; var qId = Parent[q]; ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。 if (pId == qId) { return; } for (var i = 0; i \u0026lt; Parent.Length; i++) { if (Parent[i] == pId) { Parent[i] = qId; ArrayVisitCount++; } } ArrayVisitCount += Parent.Length; TotalCount--; } /// \u0026lt;summary\u0026gt; /// 获得 parent 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;parent 数组。\u0026lt;/returns\u0026gt; public int[] GetParent() { return Parent; } } 另请参阅 # UnionFind 库\n"},{"id":155,"href":"/1-5-2/","title":"1.5.2","section":"《算法（第四版）》C# 题解","content":" 1.5.2 # 解答 # quick-union 的官方实现：QuickUnionUF.java。\n和上题一样的方式，增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。\n程序输出的森林，用缩进表示子树：\n|---- 0 |---- 9 |---- 1 |---- 2 |---- 3 |---- 4 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 6 |---- 7 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 3 |---- 6 数组访问：7 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 0 |---- 9 |---- 3 |---- 6 数组访问：3 |---- 1 |---- 2 |---- 7 |---- 4 |---- 0 |---- 9 |---- 3 |---- 8 |---- 5 |---- 6 数组访问：3 代码 # QuickUnionUF.cs，这个类继承了 UF.cs，重新实现了 Union() 和 Find() 等方法。 关于 UF.cs 可以参见原书中文版 P138 或英文版 P221 的算法 1.5。\npublic class QuickUnionUf : Uf { /// \u0026lt;summary\u0026gt; /// 数组访问次数的计数器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;当前数组访问次数。\u0026lt;/value\u0026gt; public int ArrayVisitCount { get; private set; } /// \u0026lt;summary\u0026gt; /// 建立使用 QuickUnion 的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt; public QuickUnionUf(int n) : base(n) { } /// \u0026lt;summary\u0026gt; /// 重置数组访问计数。 /// \u0026lt;/summary\u0026gt; public virtual void ResetArrayCount() { ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt; /// 获得 parent 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回 parent 数组。\u0026lt;/returns\u0026gt; public int[] GetParent() { return Parent; } /// \u0026lt;summary\u0026gt; /// 寻找一个结点所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { Validate(p); while (p != Parent[p]) { p = Parent[p]; ArrayVisitCount += 2; } return p; } /// \u0026lt;summary\u0026gt; /// 将两个结点所属的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public override void Union(int p, int q) { var rootP = Find(p); var rootQ = Find(q); if (rootP == rootQ) { return; } Parent[rootP] = rootQ; ArrayVisitCount++; TotalCount--; } } Main 方法\nvar input = \u0026#34;9-0 3-4 5-8 7-2 2-1 5-7 0-3 4-2\u0026#34;.Split(\u0026#39; \u0026#39;); var quickUnion = new QuickUnionUf(10); foreach (var s in input) { quickUnion.ResetArrayCount(); var numbers = s.Split(\u0026#39;-\u0026#39;); var p = int.Parse(numbers[0]); var q = int.Parse(numbers[1]); quickUnion.Union(p, q); var parent = quickUnion.GetParent(); for (var i = 0; i \u0026lt; parent.Length; i++) { if (parent[i] == i) { Console.WriteLine(\u0026#34;|---- \u0026#34; + i); Dfs(parent, i, 1); } } Console.WriteLine(\u0026#34;数组访问：\u0026#34; + quickUnion.ArrayVisitCount); } static void Dfs(int[] parent, int root, int level) { for (var i = 0; i \u0026lt; parent.Length; i++) { if (parent[i] == root \u0026amp;\u0026amp; i != root) { for (var j = 0; j \u0026lt; level; j++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;|---- \u0026#34; + i); Dfs(parent, i, level + 1); } } } 另请参阅 # UnionFind 库\n"},{"id":156,"href":"/1-5-3/","title":"1.5.3","section":"《算法（第四版）》C# 题解","content":" 1.5.3 # 解答 # 加权 quick-union 的官方实现：WeightedQuickUnionUF.java。\n样例输出：\n1 2 3 4 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 5 9 数组访问：3 1 7 3 3 5 6 7 5 9 数组访问：3 7 7 3 3 5 6 7 5 9 数组访问：5 7 7 3 3 7 6 7 5 9 数组访问：3 7 7 9 3 7 6 7 5 9 数组访问：5 7 7 9 3 7 6 7 5 7 数组访问：9 代码 # WeightedQuickUnionUF.cs，这个类继承了 QuickUnion.cs，重新实现了 Union() 和 Find() 等方法。\n关于 QuickUnion.cs 可以参见 1.5.2 的代码部分。\npublic class WeightedQuickUnionUf : QuickUnionUf { /// \u0026lt;summary\u0026gt; /// 记录各个树大小的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;记录各个树大小的数组。\u0026lt;/value\u0026gt; protected int[] Size; /// \u0026lt;summary\u0026gt; /// 记录 parent 数组的访问次数的计数器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;parent 数组的访问次数。\u0026lt;/value\u0026gt; public int ArrayParentVisitCount { get; private set; } /// \u0026lt;summary\u0026gt; /// 记录 size 数组的访问次数的计数器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;size 数组的访问次数。\u0026lt;/value\u0026gt; public int ArraySizeVisitCount { get; private set; } /// \u0026lt;summary\u0026gt; /// 建立使用加权 quick-union 的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt; public WeightedQuickUnionUf(int n) : base(n) { Size = new int[n]; for (var i = 0; i \u0026lt; n; i++) { Size[i] = 1; } ArrayParentVisitCount = 0; ArraySizeVisitCount = 0; } /// \u0026lt;summary\u0026gt; /// 清零数组访问计数。 /// \u0026lt;/summary\u0026gt; public override void ResetArrayCount() { ArrayParentVisitCount = 0; ArraySizeVisitCount = 0; } /// \u0026lt;summary\u0026gt; /// 获取 size 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回 size 数组。\u0026lt;/returns\u0026gt; public int[] GetSize() { return Size; } /// \u0026lt;summary\u0026gt; /// 寻找一个结点所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { Validate(p); while (p != Parent[p]) { p = Parent[p]; ArrayParentVisitCount += 2; } ArrayParentVisitCount++; return p; } /// \u0026lt;summary\u0026gt; /// 将两个结点所属的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public override void Union(int p, int q) { var rootP = Find(p); var rootQ = Find(q); if (rootP == rootQ) { return; } if (Size[rootP] \u0026lt; Size[rootQ]) { Parent[rootP] = rootQ; Size[rootQ] += Size[rootP]; } else { Parent[rootQ] = rootP; Size[rootP] += Size[rootQ]; } ArrayParentVisitCount++; ArraySizeVisitCount += 4; TotalCount--; } } Main 方法\nvar input = \u0026#34;9-0 3-4 5-8 7-2 2-1 5-7 0-3 4-2\u0026#34;.Split(\u0026#39; \u0026#39;); var weightedQuickUnion = new WeightedQuickUnionUf(10); foreach (var s in input) { weightedQuickUnion.ResetArrayCount(); var numbers = s.Split(\u0026#39;-\u0026#39;); var p = int.Parse(numbers[0]); var q = int.Parse(numbers[1]); weightedQuickUnion.Union(p, q); var parent = weightedQuickUnion.GetParent(); for (var i = 0; i \u0026lt; parent.Length; i++) { Console.Write(parent[i] + \u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;数组访问：\u0026#34; + weightedQuickUnion.ArrayParentVisitCount); } 另请参阅 # UnionFind 库\n"},{"id":157,"href":"/1-5-4/","title":"1.5.4","section":"《算法（第四版）》C# 题解","content":" 1.5.4 # 解答 # 对照输入和最坏输入均在书中出现，中文版见：P146，英文版见：P229。\n样例输出：\n3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 8 9 size: 1 1 1 1 2 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 4 9 size: 1 1 1 1 3 1 1 1 1 1 parent visit count:5 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 9 size: 1 1 1 1 3 1 2 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 4 size: 1 1 1 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:6 size visit count:0 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 3 1 1 1 parent visit count:5 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 3 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:5 size visit count:4 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:8 size visit count:0 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:6 size visit count:0 ------------------------------------- 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 2 3 4 5 6 7 8 9 size: 2 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 3 4 5 6 7 8 9 size: 3 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 4 5 6 7 8 9 size: 4 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 5 6 7 8 9 size: 5 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 6 7 8 9 size: 6 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 6 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 7 8 9 size: 7 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 8 9 size: 8 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 9 size: 9 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 0 size: 10 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 代码 # Main 方法：\nchar[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; var inputReference = File.ReadAllText(DataFiles.TinyUf).Split(split, StringSplitOptions.RemoveEmptyEntries); var inputWorst = File.ReadAllText(DataFiles.WorstUf).Split(split, StringSplitOptions.RemoveEmptyEntries); RunTest(inputReference); Console.WriteLine(\u0026#34;-------------------------------------\u0026#34;); RunTest(inputWorst); static void RunTest(string[] input) { var weightedQuickUnion = new WeightedQuickUnionUf(10); var parent = weightedQuickUnion.GetParent(); var size = weightedQuickUnion.GetSize(); for (var i = 1; i \u0026lt; input.Length; i++) { var unit = input[i].Split(\u0026#39; \u0026#39;); var p = int.Parse(unit[0]); var q = int.Parse(unit[1]); Console.WriteLine($\u0026#34;{p} {q}\u0026#34;); weightedQuickUnion.Union(p, q); Console.Write(\u0026#34;index:\\t\u0026#34;); for (var j = 0; j \u0026lt; 10; j++) { Console.Write(j + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;parent:\\t\u0026#34;); foreach (var m in parent) { Console.Write(m + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;size:\\t\u0026#34;); foreach (var m in size) { Console.Write(m + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;parent visit count:\u0026#34; + weightedQuickUnion.ArrayParentVisitCount); Console.WriteLine(\u0026#34;size visit count:\u0026#34; + weightedQuickUnion.ArraySizeVisitCount); Console.WriteLine(); weightedQuickUnion.ResetArrayCount(); } } 另请参阅 # UnionFind 库\n"},{"id":158,"href":"/1-5-5/","title":"1.5.5","section":"《算法（第四版）》C# 题解","content":" 1.5.5 # 解答 # $10^6$ 条连接 = $10^6$ 组输入。\n对于 quick-find 算法，每次 union() 都要遍历整个数组。\n因此总共进行了 $10^9 \\times 10^6 = 10^{15}$ 次 for 循环迭代。\n每次 for 循环迭代都需要 $10$ 条机器指令，\n因此总共执行了 $10 \\times10^{15} = 10^{16}$ 条机器指令。\n已知计算机每秒能够执行 $10^9$ 条机器指令，\n因此执行完所有指令需要 $10^{16} / 10^9 = 10^7$ 秒 = $115.74$ 天。\n"},{"id":159,"href":"/1-5-6/","title":"1.5.6","section":"《算法（第四版）》C# 题解","content":" 1.5.6 # 解答 # 加权 quick-union 算法最多只需要 $lgN $次迭代就可以完成一次 union()。\n因此按照上题思路，总共需要 $(lg(10^9) \\times 10^6 \\times 10) / 10^9 = 0.299$ 秒。\n"},{"id":160,"href":"/1-5-7/","title":"1.5.7","section":"《算法（第四版）》C# 题解","content":" 1.5.7 # 解答 # 见 1.5.1 和 1.5.2 的解答。\n"},{"id":161,"href":"/1-5-8/","title":"1.5.8","section":"《算法（第四版）》C# 题解","content":" 1.5.8 # 解答 # 当有多个元素需要修改的时候，这个直观算法可能会出现错误。\n例如如下情况：\nindex 0 1 2 3 4 5 6 7 8 9 id 0 0 0 0 0 5 5 5 5 5 输入 0, 5\ni = 0 时，id[i] == id[p]，此时 id[i] = id[q]。\n数组变为 5 0 0 0 0 5 5 5 5 5\ni = 1 时，id[i] != id[p]，算法出现错误。\n只要在 id[p] 之后还有需要修改的元素，那么这个算法就会出现错误。\n"},{"id":162,"href":"/1-5-9/","title":"1.5.9","section":"《算法（第四版）》C# 题解","content":" 1.5.9 # 解答 # 不可能。 树如下所示。\n由于加权 quick-union 算法任意节点的最大深度为 lgN （节点总数为 N）。\n（这个结论可以在中文版 P146，或者英文版 P228 找到）\n上面这个树的最大深度为 4 \u0026gt; lg10\n因此这棵树不可能是通过加权 quick-union 算法得到的。\n"},{"id":163,"href":"/1-5-10/","title":"1.5.10","section":"《算法（第四版）》C# 题解","content":" 1.5.10 # 解答 # 本题答案已经给出，也很好理解。\n如果合并时只是把子树挂到结点 q 上而非其根节点，\n树的高度会明显增加，进而增加每次 Find() 操作的开销。\n"},{"id":164,"href":"/1-5-11/","title":"1.5.11","section":"《算法（第四版）》C# 题解","content":" 1.5.11 # 解答 # 类似于加权 quick-union 的做法，新增一个 size[] 数组以记录各个根节点的大小。\n每次合并时先比较一下两棵树的大小，再进行合并。\n这样会略微减少赋值语句的执行次数，提升性能。\n代码 # WeightedQuickFindUF.cs\n/// \u0026lt;summary\u0026gt; /// 用加权 QuickFind 算法实现的并查集。 /// \u0026lt;/summary\u0026gt; public class WeightedQuickFindUf { private readonly int[] _size; // 记录每个连通分量的大小。 private readonly int[] _id; // 记录每个结点的连通分量。 private int _count;// 连通分量总数。 public int ArrayVisitCount { get; private set; } //记录数组访问的次数。 /// \u0026lt;summary\u0026gt; /// 新建一个使用加权 quick-find 实现的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集的大小。\u0026lt;/param\u0026gt; public WeightedQuickFindUf(int n) { _count = n; _id = new int[n]; _size = new int[n]; for (var i = 0; i \u0026lt; n; i++) { _id[i] = i; _size[i] = 1; } } /// \u0026lt;summary\u0026gt; /// 重置数组访问计数。 /// \u0026lt;/summary\u0026gt; public void ResetArrayCount() { ArrayVisitCount = 0; } /// \u0026lt;summary\u0026gt; /// 表示并查集中连通分量的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回并查集中连通分量的数量。\u0026lt;/returns\u0026gt; public int Count() { return _count; } /// \u0026lt;summary\u0026gt; /// 寻找 p 所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;返回 p 所在的连通分量。\u0026lt;/returns\u0026gt; public int Find(int p) { Validate(p); ArrayVisitCount++; return _id[p]; } /// \u0026lt;summary\u0026gt; /// 判断两个结点是否属于同一个连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要判断的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要判断的另一个结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果属于同一个连通分量则返回 true，否则返回 false。\u0026lt;/returns\u0026gt; public bool IsConnected(int p, int q) { Validate(p); Validate(q); ArrayVisitCount += 2; return _id[p] == _id[q]; } /// \u0026lt;summary\u0026gt; /// 将两个结点所在的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public void Union(int p, int q) { Validate(p); Validate(q); var pId = _id[p]; var qId = _id[q]; ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。 if (pId == qId) { return; } // 判断较大的连通分量和较小的连通分量。 int larger; int smaller; if (_size[pId] \u0026gt; _size[qId]) { larger = pId; smaller = qId; _size[pId] += _size[qId]; } else { larger = qId; smaller = pId; _size[qId] += _size[pId]; } // 将较小的连通分量连接到较大的连通分量上， // 这会减少赋值语句的执行次数，略微减少数组访问。 for (var i = 0; i \u0026lt; _id.Length; i++) { if (_id[i] == smaller) { _id[i] = larger; ArrayVisitCount++; } } ArrayVisitCount += _id.Length; _count--; } /// \u0026lt;summary\u0026gt; /// 获得 id 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;id 数组。\u0026lt;/returns\u0026gt; public int[] GetId() { return _id; } /// \u0026lt;summary\u0026gt; /// 验证输入的结点是否有效。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要验证的结点。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;输入的 p 值无效。\u0026lt;/exception\u0026gt; private void Validate(int p) { var n = _id.Length; if (p \u0026lt; 0 || p \u0026gt; n) { throw new ArgumentException(\u0026#34;index \u0026#34; + p + \u0026#34; is not between 0 and \u0026#34; + (n - 1)); } } } Main 方法\nchar[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; var input = File.ReadAllText(DataFiles.MediumUf).Split(split, StringSplitOptions.RemoveEmptyEntries); var size = int.Parse(input[0]); var quickFind = new QuickFindUf(size); var weightedQuickFind = new WeightedQuickFindUf(size); for (var i = 1; i \u0026lt; size; i++) { var pair = input[i].Split(\u0026#39; \u0026#39;); var p = int.Parse(pair[0]); var q = int.Parse(pair[1]); quickFind.Union(p, q); weightedQuickFind.Union(p, q); } Console.WriteLine(\u0026#34;quick-find: \u0026#34; + quickFind.ArrayVisitCount); Console.WriteLine(\u0026#34;weighted quick-find: \u0026#34; + weightedQuickFind.ArrayVisitCount); 另请参阅 # UnionFind 库\n"},{"id":165,"href":"/1-5-12/","title":"1.5.12","section":"《算法（第四版）》C# 题解","content":" 1.5.12 # 解答 # QuickUnionPathCompression 的官方实现：QuickUnionPathCompressionUF.java\n在找到根节点之后，再访问一遍 p 到根节点这条路径上的所有结点，将它们直接和根节点相连。\n重写过后的 Find() 方法：\n/// \u0026lt;summary\u0026gt; /// 寻找结点所属的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } 由于路径压缩是在 Find() 方法中实现的，\n只要输入保证是根节点两两相连即可构造较长的路径。\n代码 # QuickUnionPathCompressionUF.cs 直接从 QuickUnionUF.cs 继承而来。\n关于 QuickUnionUF.cs，参见 1.5.2 的解答。\npublic class QuickUnionPathCompressionUf : QuickFindUf { /// \u0026lt;summary\u0026gt; /// 新建一个大小为 n 的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt; public QuickUnionPathCompressionUf(int n) : base(n) { } /// \u0026lt;summary\u0026gt; /// 寻找结点所属的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { var root = p; while (root != Parent[root]) { root = Parent[root]; } while (p != root) { var newp = Parent[p]; Parent[p] = root; p = newp; } return p; } } Main 方法\nvar uf = new QuickUnionPathCompressionUf(10); // 使用书中提到的最坏情况，0 连 1，1 连 2，2 连 3…… for (var i = 0; i \u0026lt; 4; i++) { uf.Union(i, i + 1); } var id = uf.GetParent(); for (var i = 0; i \u0026lt; id.Length; i++) { Console.Write(id[i]); } Console.WriteLine(); 另请参阅 # UnionFind 库\n"},{"id":166,"href":"/1-5-13/","title":"1.5.13","section":"《算法（第四版）》C# 题解","content":" 1.5.13 # 解答 # 官方实现：WeightedQuickUnionPathCompressionUF。\n加权 quick-union 中，两个大小相等的树合并可以有效增加高度，同时输入必须保证是根节点以规避路径压缩。\n代码 # WeightedQuickUnionPathCompressionUF.cs 从 WeightedQuickUnionUF.cs 继承，详情参见 1.5.3 的解答。\npublic class WeightedQuickUnionPathCompressionUf : WeightedQuickUnionUf { /// \u0026lt;summary\u0026gt; /// 新建一个大小为 n 的并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt; public WeightedQuickUnionPathCompressionUf(int n) : base(n) { Size = new int[n]; for (var i = 0; i \u0026lt; n; i++) { Size[i] = 1; } } /// \u0026lt;summary\u0026gt; /// 寻找一个结点所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt; public override int Find(int p) { Validate(p); var root = p; while (root != Parent[p]) { root = Parent[p]; } while (p != root) { var newP = Parent[p]; Parent[p] = root; p = newP; } return root; } } Main 方法\nvar uf = new WeightedQuickUnionPathCompressionUf(10); // 见中文版 P146 或英文版 P229 中加权 quick-union 的最坏输入。 uf.Union(0, 1); uf.Union(2, 3); uf.Union(4, 5); uf.Union(6, 7); uf.Union(0, 2); uf.Union(4, 6); uf.Union(0, 4); var id = uf.GetParent(); for (var i = 0; i \u0026lt; id.Length; i++) { Console.Write(id[i]); } Console.WriteLine(); 另请参阅 # UnionFind 库\n"},{"id":167,"href":"/1-5-14/","title":"1.5.14","section":"《算法（第四版）》C# 题解","content":" 1.5.14 # 解答 # WeightedQuickUnionByHeight 的官方实现：WeightedQuickUnionByHeightUF.java。\n证明： 一次 Union 操作只可能发生如下两种情况。\n两棵树的高度相同，这样合并后的新树的高度等于较大那棵树的高度 + 1。\n两棵树的高度不同，这样合并后的新树高度等于较大那棵树的高度。\n现在证明通过加权 quick-union 算法构造的高度为 h 的树至少包含 2h 个结点。\n基础情况，高度 h = 0, 结点数 k = 1。\n为了使高度增加，必须用一棵高度相同的树合并，而 h = 0 时结点数一定是 1，则：\nh = 1, k = 2\n由于两棵大小不同的树合并，最大高度不会增加，只会增加结点数。\n因此，每次都使用相同高度的最小树进行合并，有：\nh = 2, k = 4 h = 3, k = 8 h = 4, k = 16 ...... 递推即可得到结论，k ≥ 2^h\n因此 h \u0026lt;= lgk\n代码 # public class WeightedQuickUnionByHeightUf : QuickUnionUf { private readonly int[] _height; /// \u0026lt;summary\u0026gt; /// 新建一个以高度作为判断依据的加权 quick-union 并查集。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;新建并查集的大小。\u0026lt;/param\u0026gt; public WeightedQuickUnionByHeightUf(int n) : base(n) { _height = new int[n]; for (var i = 0; i \u0026lt; n; i++) { _height[i] = 0; } } /// \u0026lt;summary\u0026gt; /// 将两个结点所属的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public override void Union(int p, int q) { var rootP = Find(p); var rootQ = Find(q); if (rootP == rootQ) { return; } if (_height[rootP] \u0026lt; _height[rootQ]) { Parent[rootP] = rootQ; } else if (_height[rootP] \u0026gt; _height[rootQ]) { Parent[rootQ] = rootP; } else { Parent[rootQ] = rootP; _height[rootP]++; } TotalCount--; } } 另请参阅 # UnionFind 库\n"},{"id":168,"href":"/1-5-15/","title":"1.5.15","section":"《算法（第四版）》C# 题解","content":" 1.5.15 # 解答 # 首先证明在最坏情况下加权 quick-union 算法生成的树中的每一层结点数均为二项式系数。\n最坏情况下，每次 union 操作都是合并相同大小的树，如下图所示：\n设第 i 层的结点数为 ki，那么最坏情况下每次合并后的 ki’ = ki + ki-1 。\n这符合二项式系数的构造特点（详情可以搜索杨辉三角），\n第一个结论证明完毕。\n接下来求平均深度，首先根据二项式的求和公式，一棵深度为 n 的树（根结点的深度为零）结点总数为：\n$$ \\sum_{k=0}^{n} \\begin{pmatrix} n \\newline k \\end{pmatrix} =2^n $$\n每层结点数 × 该层深度后的和为：\n$$ \\sum_{k=0}^{n}k \\cdot \\begin{pmatrix} n \\newline k \\end{pmatrix}=n\\sum_{k=1}^{n} \\begin{pmatrix} n-1 \\newline k-1 \\end{pmatrix}=n\\sum_{s=0}^{n-1} \\begin{pmatrix} n-1 \\newline s \\end{pmatrix}=n2^{n-1} $$\n这里用到了这个公式化简：\n$$ \\begin{pmatrix} n \\newline k \\end{pmatrix}=\\frac{n}{k} \\begin{pmatrix} n-1 \\newline k-1 \\end{pmatrix} $$\n相除可以求得平均深度：\n$$ \\bar{D} = \\frac{\\sum_{k=0}^{n}k\\cdot\\begin{pmatrix}n\\newline k\\end{pmatrix}}{\\sum_{k=0}^{n}\\begin{pmatrix}n\\newline k\\end{pmatrix}}=\\frac{n2^{n-1}}{2^n}=\\frac{n}{2} $$\n"},{"id":169,"href":"/1-5-16/","title":"1.5.16","section":"《算法（第四版）》C# 题解","content":" 1.5.16 # 解答 # 给出绘图结果样例：\n代码 # 仅给出绘图相关的代码，窗体部分见 github 上的代码：\nusing System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._16 { static class Program { [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { char[] split = { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }; string[] input = TestCase.Properties.Resources.mediumUF.Split(split, StringSplitOptions.RemoveEmptyEntries); int size = int.Parse(input[0]); QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); string[] pair; int p, q; int[] quickFindResult = new int[size]; int[] quickUnionResult = new int[size]; for (int i = 1; i \u0026lt; size; ++i) { pair = input[i].Split(\u0026#39; \u0026#39;); p = int.Parse(pair[0]); q = int.Parse(pair[1]); quickFind.Union(p, q); quickUnion.Union(p, q); quickFindResult[i - 1] = quickFind.ArrayVisitCount; quickUnionResult[i - 1] = quickUnion.ArrayVisitCount; quickFind.ResetArrayCount(); quickUnion.ResetArrayCount(); } Draw(quickFindResult); Draw(quickUnionResult); } static void Draw(int[] cost) { // 构建 total 数组。 int[] total = new int[cost.Length]; total[0] = cost[0]; for (int i = 1; i \u0026lt; cost.Length; ++i) { total[i] = total[i - 1] + cost[i]; } // 获得最大值。 int costMax = cost.Max(); // 新建绘图窗口。 Form2 plot = new Form2(); plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。 RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。 RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。 graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(costMax.ToString(), plot.Font, Brushes.Black, rect.Location); graphics.DrawString(cost.Length.ToString(), plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。 PointF[] grayPoints = new PointF[cost.Length]; PointF[] redPoints = new PointF[cost.Length]; unitX = center.Width / cost.Length; unitY = center.Width / costMax; for (int i = 0; i \u0026lt; cost.Length; ++i) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (cost[i] * unitY)); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - ((total[i] / (i + 1)) * unitY)); } // 绘制点。 for (int i = 0; i \u0026lt; cost.Length; ++i) { graphics.DrawEllipse(Pens.Gray, new RectangleF(grayPoints[i], new SizeF(2, 2))); graphics.DrawEllipse(Pens.Red, new RectangleF(redPoints[i], new SizeF(2, 2))); } graphics.Dispose(); } } } "},{"id":170,"href":"/1-5-17/","title":"1.5.17","section":"《算法（第四版）》C# 题解","content":" 1.5.17 # 解答 # 官方给出的 ErdosRenyi：ErdosRenyi.java。\n为了方便之后做题，除了 Count() 之外，这个类还包含其他方法，具体可以查看注释。\n代码 # ErdosRenyi.cs\npublic class ErdosRenyi { /// \u0026lt;summary\u0026gt; /// 随机生成一组能让并查集只剩一个连通分量的连接。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;并查集大小。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;一组能让并查集只剩一个连通分量的连接。\u0026lt;/returns\u0026gt; public static Connection[] Generate(int n) { var random = new Random(); var connections = new List\u0026lt;Connection\u0026gt;(); var uf = new WeightedQuickUnionPathCompressionUf(n); while (uf.Count() \u0026gt; 1) { var p = random.Next(n); var q = random.Next(n); uf.Union(p, q); connections.Add(new Connection(p, q)); } return connections.ToArray(); } /// \u0026lt;summary\u0026gt; /// 随机生成连接，返回令并查集中只剩一个连通分量所需的连接总数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;用于测试的并查集。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;需要的连接总数。\u0026lt;/returns\u0026gt; public static int Count(Uf uf) { var random = new Random(); var size = uf.Count(); var edges = 0; while (uf.Count() \u0026gt; 1) { var p = random.Next(size); var q = random.Next(size); uf.Union(p, q); edges++; } return edges; } /// \u0026lt;summary\u0026gt; /// 使用指定的连接按顺序合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;uf\u0026#34;\u0026gt;需要测试的并查集。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;connections\u0026#34;\u0026gt;用于输入的连接集合。\u0026lt;/param\u0026gt; public static void Count(Uf uf, Connection[] connections) { foreach (var c in connections) { uf.Union(c.P, c.Q); } } } Main 方法：\nvar n = 10; for (var i = 0; i \u0026lt; 5; i++) { var uf = new Uf(n); Console.WriteLine(n + \u0026#34;\\t\u0026#34; + ErdosRenyi.Count(uf)); n *= 10; } 另请参阅 # UnionFind 库\n"},{"id":171,"href":"/1-5-18/","title":"1.5.18","section":"《算法（第四版）》C# 题解","content":" 1.5.18 # 解答 # 具体生成的连接样式见下题，这里给出 RandomGrid 的实现，需要使用 1.3 节中的随机背包辅助。\n代码 # RandomGrid.cs\npublic class RandomBag\u0026lt;TItem\u0026gt; : IEnumerable\u0026lt;TItem\u0026gt; { private TItem[] _bag; private int _count; /// \u0026lt;summary\u0026gt; /// 建立一个随机背包。 /// \u0026lt;/summary\u0026gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// \u0026lt;summary\u0026gt; /// 检查背包是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _count == 0; } /// \u0026lt;summary\u0026gt; /// 返回背包中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Size() { return _count; } /// \u0026lt;summary\u0026gt; /// 向背包中添加一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;item\u0026#34;\u0026gt;要向背包中添加的元素。\u0026lt;/param\u0026gt; public void Add(TItem item) { if (_count == _bag.Length) { Resize(_count * 2); } _bag[_count] = item; _count++; } /// \u0026lt;summary\u0026gt; /// 重新为背包分配内存空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Resize(int capacity) { if (capacity \u0026lt;= 0) throw new ArgumentException(); var temp = new TItem[capacity]; for (var i = 0; i \u0026lt; _count; i++) { temp[i] = _bag[i]; } _bag = temp; } public IEnumerator\u0026lt;TItem\u0026gt; GetEnumerator() { return new RandomBagEnumerator(_bag, _count); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private class RandomBagEnumerator : IEnumerator\u0026lt;TItem\u0026gt; { private TItem[] _bag; private int[] _sequence; private int _current; private readonly int _count; public RandomBagEnumerator(TItem[] bag, int count) { _bag = bag; _current = -1; _count = count; _sequence = new int[count]; for (var i = 0; i \u0026lt; _count; i++) { _sequence[i] = i; } Shuffle(_sequence, DateTime.Now.Millisecond); } /// \u0026lt;summary\u0026gt; /// 随机打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;seed\u0026#34;\u0026gt;随机种子值。\u0026lt;/param\u0026gt; private void Shuffle(int[] a, int seed) { var n = a.Length; var random = new Random(seed); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } TItem IEnumerator\u0026lt;TItem\u0026gt;.Current =\u0026gt; _bag[_sequence[_current]]; object IEnumerator.Current =\u0026gt; _bag[_sequence[_current]]; void IDisposable.Dispose() { _bag = null; _sequence = null; _current = -1; } bool IEnumerator.MoveNext() { if (_current == _count - 1) return false; _current++; return true; } void IEnumerator.Reset() { _current = -1; } } } 另请参阅 # UnionFind 库\nGenerics 库\n"},{"id":172,"href":"/1-5-19/","title":"1.5.19","section":"《算法（第四版）》C# 题解","content":" 1.5.19 # 解答 # 最后绘出的图像：\n代码 # 给出绘图部分的代码，窗体部分见 GitHub。\nusing System; using System.Drawing; using System.Collections.Generic; using System.Windows.Forms; using UnionFind; namespace _1._5._19 { /* * 1.5.19 * * 动画。 * 编写一个 RandomGrid（请见练习 1.5.18）的用例， * 和我们开发用例一样使用 UnionFind 来检查触点的连通性并在处理时用 StdDraw 将它们绘出。 * */ static class Program { static RandomBag\u0026lt;Connection\u0026gt; bag; static Graphics graphics; static TextBox logBox; static PointF[] points; static Timer timer; static List\u0026lt;Connection\u0026gt; connections; static int count = 0; /// \u0026lt;summary\u0026gt; /// 应用程序的主入口点。 /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } /// \u0026lt;summary\u0026gt; /// 绘制连接图像。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;矩阵边长。\u0026lt;/param\u0026gt; public static void Draw(int n, TextBox log, Log WinBox) { logBox = log; // 生成路径。 log.AppendText(\u0026#34;\\r\\n开始生成连接……\u0026#34;); bag = RandomGrid.Generate(n); log.AppendText(\u0026#34;\\r\\n生成连接完成\u0026#34;); // 新建画布窗口。 log.AppendText(\u0026#34;\\r\\n启动画布……\u0026#34;); Form2 matrix = new Form2(); matrix.StartPosition = FormStartPosition.Manual; matrix.Location = new Point(WinBox.Left - matrix.ClientRectangle.Width, WinBox.Top); matrix.Show(); log.AppendText(\u0026#34;\\r\\n画布已启动，开始绘图……\u0026#34;); graphics = matrix.CreateGraphics(); // 获取绘图区域。 RectangleF rect = matrix.ClientRectangle; float unitX = rect.Width / (n + 1); float unitY = rect.Height / (n + 1); // 绘制点。 log.AppendText(\u0026#34;\\r\\n绘制点……\u0026#34;); points = new PointF[n * n]; for (int row = 0; row \u0026lt; n; ++row) { for (int col = 0; col \u0026lt; n; ++col) { points[row * n + col] = new PointF(unitX * (col + 1), unitY * (row + 1)); graphics.FillEllipse(Brushes.Black, unitX * (col + 1), unitY * (row + 1), 5, 5); } } log.AppendText(\u0026#34;\\r\\n绘制点完成\u0026#34;); // 绘制连接。 log.AppendText(\u0026#34;\\r\\n开始绘制连接……\u0026#34;); connections = new List\u0026lt;Connection\u0026gt;(); foreach (Connection c in bag) { connections.Add(c); } timer = new Timer { Interval = 500 }; timer.Tick += DrawOneLine; timer.Start(); } private static void DrawOneLine(object sender, EventArgs e) { Connection c = connections[count]; count++; graphics.DrawLine(Pens.Black, points[c.P], points[c.Q]); logBox.AppendText(\u0026#34;\\r\\n绘制\u0026#34; + \u0026#34;(\u0026#34; + c.P + \u0026#34;, \u0026#34; + c.Q + \u0026#34;)\u0026#34;); if (count == bag.Size()) { timer.Stop(); logBox.AppendText(\u0026#34;\\r\\n绘制结束\u0026#34;); count = 0; } } } } 另请参阅 # UnionFind 库\n"},{"id":173,"href":"/1-5-20/","title":"1.5.20","section":"《算法（第四版）》C# 题解","content":" 1.5.20 # 解答 # 将 parent 数组和 size 数组用链表代替即可，很容易实现。\n代码 # 修改后的 WeightedQuickUnionUF.cs\npublic class WeightedQuickUnionUf { protected LinkedList\u0026lt;int\u0026gt; Parent; // 记录各个结点的父级。 protected LinkedList\u0026lt;int\u0026gt; Size; // 记录各个树的大小。 protected int Count; // 分量数目。 /// \u0026lt;summary\u0026gt; /// 建立使用加权 quick-union 的并查集。 /// \u0026lt;/summary\u0026gt; public WeightedQuickUnionUf() { Parent = new LinkedList\u0026lt;int\u0026gt;(); Size = new LinkedList\u0026lt;int\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 获取 parent 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;parent 数组。\u0026lt;/returns\u0026gt; public LinkedList\u0026lt;int\u0026gt; GetParent() { return Parent; } /// \u0026lt;summary\u0026gt; /// 获取 size 数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;返回 size 数组。\u0026lt;/returns\u0026gt; public LinkedList\u0026lt;int\u0026gt; GetSize() { return Size; } /// \u0026lt;summary\u0026gt; /// 在并查集中增加一个新的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;新结点的下标。\u0026lt;/returns\u0026gt; public int NewSite() { Parent.Insert(Parent.Size(), Parent.Size()); Size.Insert(1, Size.Size()); Count++; return Parent.Size() - 1; } /// \u0026lt;summary\u0026gt; /// 寻找一个结点所在的连通分量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要寻找的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;该结点所属的连通分量。\u0026lt;/returns\u0026gt; public int Find(int p) { Validate(p); while (p != Parent.Find(p)) { p = Parent.Find(p); } return p; } /// \u0026lt;summary\u0026gt; /// 将两个结点所属的连通分量合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要合并的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;q\u0026#34;\u0026gt;需要合并的另一个结点。\u0026lt;/param\u0026gt; public void Union(int p, int q) { var rootP = Find(p); var rootQ = Find(q); if (rootP == rootQ) { return; } if (Size.Find(rootP) \u0026lt; Size.Find(rootQ)) { Parent.Motify(rootP, rootQ); Size.Motify(rootQ, Size.Find(rootQ) + Size.Find(rootP)); } else { Parent.Motify(rootQ, rootP); Size.Motify(rootP, Size.Find(rootQ) + Size.Find(rootP)); } Count--; } /// \u0026lt;summary\u0026gt; /// 检查输入的 p 是否符合条件。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;输入的 p 值。\u0026lt;/param\u0026gt; protected void Validate(int p) { var n = Parent.Size(); if (p \u0026lt; 0 || p \u0026gt;= n) { throw new ArgumentException(\u0026#34;index\u0026#34; + p + \u0026#34; is not between 0 and \u0026#34; + (n - 1)); } } } "},{"id":174,"href":"/1-5-21/","title":"1.5.21","section":"《算法（第四版）》C# 题解","content":" 1.5.21 # 解答 # 给出我电脑上的结果：\n实验结果：16 1/2NlnN：11.51292546497023 实验结果：38 1/2NlnN：29.957322735539908 实验结果：89 1/2NlnN：73.77758908227872 实验结果：194 1/2NlnN：175.28106538695525 实验结果：455 1/2NlnN：406.0139052187061 实验结果：1050 1/2NlnN：922.9313593270035 实验结果：2300 1/2NlnN：2067.6698164331897 实验结果：4918 1/2NlnN：4578.953828424745 实验结果：10812 1/2NlnN：10045.136047966218 实验结果：23478 1/2NlnN：21864.728878165897 代码 # for (var n = 10; n \u0026lt; 10000; n *= 2) { var total = 0; for (var i = 0; i \u0026lt; 100; i++) { var uf = new Uf(n); total += ErdosRenyi.Count(uf); } Console.WriteLine(\u0026#34;实验结果：\u0026#34; + total / 100); Console.WriteLine(\u0026#34;1/2NlnN：\u0026#34; + Math.Log(n) * n * 0.5); Console.WriteLine(); } 另请参阅 # UnionFind 库\n"},{"id":175,"href":"/1-5-22/","title":"1.5.22","section":"《算法（第四版）》C# 题解","content":" 1.5.22 # 解答 # 平方级别算法在输入加倍后耗时应该增加四倍，线性则是两倍。\n下面给出我电脑上的结果，数据量较大时比较明显：\nN:16000 quick-find 平均次数：8452 用时：143 比值：4.46875 quick-union 平均次数：7325 用时：202 比值：3.25806451612903 weighted-quick-union 平均次数：6889 用时：1 N:32000 quick-find 平均次数：15747 用时：510 比值：3.56643356643357 quick-union 平均次数：15108 用时：801 比值：3.96534653465347 weighted-quick-union 平均次数：17575 用时：3 比值：3 N:64000 quick-find 平均次数：33116 用时：2069 比值：4.05686274509804 quick-union 平均次数：38608 用时：4635 比值：5.78651685393258 weighted-quick-union 平均次数：34850 用时：6 比值：2 代码 # long lastTimeQuickFind = 0; long lastTimeQuickUnion = 0; long lastTimeWeightedQuickUnion = 0; for (var n = 2000; n \u0026lt; 100000; n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n); var quickFindUf = new QuickFindUf(n); var quickUnionUf = new QuickUnionUf(n); var weightedQuickUnionUf = new WeightedQuickUnionUf(n); // quick-find Console.WriteLine(\u0026#34;quick-find\u0026#34;); var nowTime = RunTest(quickFindUf); if (lastTimeQuickFind == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeQuickFind = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeQuickFind); lastTimeQuickFind = nowTime; } Console.WriteLine(); // quick-union Console.WriteLine(\u0026#34;quick-union\u0026#34;); nowTime = RunTest(quickUnionUf); if (lastTimeQuickUnion == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeQuickUnion = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeQuickUnion); lastTimeQuickUnion = nowTime; } Console.WriteLine(); // weighted-quick-union Console.WriteLine(\u0026#34;weighted-quick-union\u0026#34;); nowTime = RunTest(weightedQuickUnionUf); if (lastTimeWeightedQuickUnion == 0) { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime); lastTimeWeightedQuickUnion = nowTime; } else { Console.WriteLine(\u0026#34;用时：\u0026#34; + nowTime + \u0026#34; 比值：\u0026#34; + (double)nowTime / lastTimeWeightedQuickUnion); lastTimeWeightedQuickUnion = nowTime; } Console.WriteLine(); Console.WriteLine(); } // 进行若干次随机试验，输出平均 union 次数，返回平均耗时。 static long RunTest(Uf uf) { var timer = new Stopwatch(); var total = 0; var repeatTime = 10; timer.Start(); for (var i = 0; i \u0026lt; repeatTime; i++) { total += ErdosRenyi.Count(uf); } timer.Stop(); Console.WriteLine(\u0026#34;平均次数：\u0026#34; + total / repeatTime); return timer.ElapsedMilliseconds / repeatTime; } 另请参阅 # UnionFind 库\n"},{"id":176,"href":"/1-5-23/","title":"1.5.23","section":"《算法（第四版）》C# 题解","content":" 1.5.23 # 解答 # 先用速度最快的 WeightedQuickUnionUF 生成一系列连接，\n保存后用这些连接进行测试，生成连接的方法见 1.5.17 的解答。\n下面给出我电脑上的结果：\nN:2000 quick-find 耗时（毫秒）：4 quick-union 耗时（毫秒）：5 比值：0.8 N:4000 quick-find 耗时（毫秒）：19 quick-union 耗时（毫秒）：24 比值：0.791666666666667 N:8000 quick-find 耗时（毫秒）：57 quick-union 耗时（毫秒）：74 比值：0.77027027027027 N:16000 quick-find 耗时（毫秒）：204 quick-union 耗时（毫秒）：307 比值：0.664495114006515 N:32000 quick-find 耗时（毫秒）：1127 quick-union 耗时（毫秒）：1609 比值：0.700435052827843 代码 # var n = 2000; for (var t = 0; t \u0026lt; 5; t++) { var input = ErdosRenyi.Generate(n); var quickFind = new QuickFindUf(n); var quickUnion = new QuickUnionUf(n); Console.WriteLine(\u0026#34;N:\u0026#34; + n); var quickFindTime = RunTest(quickFind, input); var quickUnionTime = RunTest(quickUnion, input); Console.WriteLine(\u0026#34;quick-find 耗时（毫秒）：\u0026#34; + quickFindTime); Console.WriteLine(\u0026#34;quick-union 耗时（毫秒）：\u0026#34; + quickUnionTime); Console.WriteLine(\u0026#34;比值：\u0026#34; + (double)quickFindTime / quickUnionTime); Console.WriteLine(); n *= 2; } // 进行若干次随机试验，输出平均 union 次数，返回平均耗时。 static long RunTest(Uf uf, Connection[] connections) { var timer = new Stopwatch(); var repeatTime = 5; timer.Start(); for (var i = 0; i \u0026lt; repeatTime; i++) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } 另请参阅 # UnionFind 库\n"},{"id":177,"href":"/1-5-24/","title":"1.5.24","section":"《算法（第四版）》C# 题解","content":" 1.5.24 # 解答 # 根据上题的代码略作修改即可，路径压缩大概可以快 1/3。\nN:10000 加权 quick-find 耗时（毫秒）：9 带路径压缩的加权 quick-union 耗时（毫秒）：6 比值：1.5 N:20000 加权 quick-find 耗时（毫秒）：12 带路径压缩的加权 quick-union 耗时（毫秒）：8 比值：1.5 N:40000 加权 quick-find 耗时（毫秒）：18 带路径压缩的加权 quick-union 耗时（毫秒）：12 比值：1.5 N:80000 加权 quick-find 耗时（毫秒）：36 带路径压缩的加权 quick-union 耗时（毫秒）：30 比值：1.2 N:160000 加权 quick-find 耗时（毫秒）：67 带路径压缩的加权 quick-union 耗时（毫秒）：41 比值：1.63414634146341 代码 # var n = 10000; for (var t = 0; t \u0026lt; 5; t++) { var input = ErdosRenyi.Generate(n); var weightedQuickUnionUf = new WeightedQuickUnionUf(n); var weightedQuickUnionPathCompressionUf = new WeightedQuickUnionPathCompressionUf(n); Console.WriteLine(\u0026#34;N:\u0026#34; + n); var weightedQuickUnionTime = RunTest(weightedQuickUnionUf, input); var weightedQuickUnionPathCompressionTime = RunTest(weightedQuickUnionPathCompressionUf, input); Console.WriteLine(\u0026#34;加权 quick-find 耗时（毫秒）：\u0026#34; + weightedQuickUnionTime); Console.WriteLine(\u0026#34;带路径压缩的加权 quick-union 耗时（毫秒）：\u0026#34; + weightedQuickUnionPathCompressionTime); Console.WriteLine(\u0026#34;比值：\u0026#34; + (double)weightedQuickUnionTime / weightedQuickUnionPathCompressionTime); Console.WriteLine(); n *= 2; } // 进行若干次随机试验，输出平均 union 次数，返回平均耗时。 static long RunTest(Uf uf, Connection[] connections) { var timer = new Stopwatch(); var repeatTime = 5; timer.Start(); for (var i = 0; i \u0026lt; repeatTime; i++) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } 另请参阅 # UnionFind 库\n"},{"id":178,"href":"/1-5-25/","title":"1.5.25","section":"《算法（第四版）》C# 题解","content":" 1.5.25 # 解答 # 略微修改 1.5.22 的代码即可。 我电脑上的结果：\nQuick-Find N:1600 平均用时（毫秒）：4 N:6400 平均用时（毫秒）：67 比值：16.75 N:25600 平均用时（毫秒）：1268 比值：18.9253731343284 N:102400 平均用时（毫秒）：20554 比值：16.2097791798107 Quick-Union N:1600 平均用时（毫秒）：5 比值：0.000243261652233142 N:6400 平均用时（毫秒）：66 比值：13.2 N:25600 平均用时（毫秒）：1067 比值：16.1666666666667 N:102400 平均用时（毫秒）：18637 比值：17.4667291471415 Weighted Quick-Union N:1600 平均用时（毫秒）：0 比值：0 N:6400 平均用时（毫秒）：2 N:25600 平均用时（毫秒）：12 比值：6 N:102400 平均用时（毫秒）：64 比值：5.33333333333333 代码 # var n = 40; var t = 4; // quick-find Console.WriteLine(\u0026#34;Quick-Find\u0026#34;); long last = 0; long now; for (var i = 0; i \u0026lt; t; i++, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); var quickFind = new QuickFindUf(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } // quick-union Console.WriteLine(\u0026#34;Quick-Union\u0026#34;); n = 40; for (var i = 0; i \u0026lt; t; i++, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); var quickFind = new QuickUnionUf(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } // 加权 quick-union Console.WriteLine(\u0026#34;Weighted Quick-Union\u0026#34;); n = 40; for (var i = 0; i \u0026lt; t; i++, n *= 2) { Console.WriteLine(\u0026#34;N:\u0026#34; + n * n); var connections = RandomGrid.GetConnections(n); var quickFind = new WeightedQuickUnionUf(n * n); now = RunTest(quickFind, connections); if (last == 0) { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now); last = now; } else { Console.WriteLine(\u0026#34;平均用时（毫秒）：\u0026#34; + now + \u0026#34;\\t比值：\u0026#34; + (double)now / last); last = now; } } // 进行若干次随机试验，输出平均 union 次数，返回平均耗时。 static long RunTest(Uf uf, Connection[] connections) { var timer = new Stopwatch(); long repeatTime = 3; timer.Start(); for (var i = 0; i \u0026lt; repeatTime; i++) { ErdosRenyi.Count(uf, connections); } timer.Stop(); return timer.ElapsedMilliseconds / repeatTime; } 另请参阅 # UnionFind 库\n"},{"id":179,"href":"/1-5-26/","title":"1.5.26","section":"《算法（第四版）》C# 题解","content":" 1.5.26 # 解答 # 和 1.5.16 的程序类似，将测试的内容改为 Erdos-Renyi 即可。\n样例输出：\n代码 # using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._26 { static class Program { /// \u0026lt;summary\u0026gt; /// 应用程序的主入口点。 /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { int size = 200; QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); WeightedQuickUnionUF weightedQuickUnion = new WeightedQuickUnionUF(size); Connection[] connections = ErdosRenyi.Generate(size); int[] quickFindResult = new int[size]; int[] quickUnionResult = new int[size]; int[] weightedQuickUnionResult = new int[size]; int p, q; for (int i = 0; i \u0026lt; size; ++i) { p = connections[i].P; q = connections[i].Q; quickFind.Union(p, q); quickUnion.Union(p, q); weightedQuickUnion.Union(p, q); quickFindResult[i] = quickFind.ArrayVisitCount; quickUnionResult[i] = quickUnion.ArrayVisitCount; weightedQuickUnionResult[i] = weightedQuickUnion.ArrayParentVisitCount + weightedQuickUnion.ArraySizeVisitCount; quickFind.ResetArrayCount(); quickUnion.ResetArrayCount(); weightedQuickUnion.ResetArrayCount(); } Draw(quickFindResult, \u0026#34;Quick-Find\u0026#34;); Draw(quickUnionResult, \u0026#34;Quick-Union\u0026#34;); Draw(weightedQuickUnionResult, \u0026#34;Weighted Quick-Union\u0026#34;); } static void Draw(int[] cost, string title) { // 构建 total 数组。 int[] total = new int[cost.Length]; total[0] = cost[0]; for (int i = 1; i \u0026lt; cost.Length; ++i) { total[i] = total[i - 1] + cost[i]; } // 获得最大值。 int costMax = cost.Max(); // 新建绘图窗口。 Form2 plot = new Form2(); plot.Text = title; plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。 RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。 RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。 graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(costMax.ToString(), plot.Font, Brushes.Black, rect.Location); graphics.DrawString(cost.Length.ToString(), plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。 PointF[] grayPoints = new PointF[cost.Length]; PointF[] redPoints = new PointF[cost.Length]; unitX = center.Width / cost.Length; unitY = center.Width / costMax; for (int i = 0; i \u0026lt; cost.Length; ++i) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (cost[i] * unitY)); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - ((total[i] / (i + 1)) * unitY)); } // 绘制点。 for (int i = 0; i \u0026lt; cost.Length; ++i) { graphics.FillEllipse(Brushes.Gray, new RectangleF(grayPoints[i], new SizeF(5, 5))); graphics.FillEllipse(Brushes.Red, new RectangleF(redPoints[i], new SizeF(5, 5))); } graphics.Dispose(); } } } 另请参阅 # UnionFind 库\n"},{"id":180,"href":"/2-1-1/","title":"2.1.1","section":"《算法（第四版）》C# 题解","content":" 2.1.1 # 解答 # "},{"id":181,"href":"/2-1-2/","title":"2.1.2","section":"《算法（第四版）》C# 题解","content":" 2.1.2 # 解答 # 最多会被交换 n 次，只要将一个有序数列循环右移一位就可以构造这样的情况。\n例如：\n平均每个元素被交换了 N/N=1 次。（总共 N 个元素，总共发生了 N 次交换）。\n"},{"id":182,"href":"/2-1-3/","title":"2.1.3","section":"《算法（第四版）》C# 题解","content":" 2.1.3 # 解答 # 你需要一个逆序的数组。\n例如： 9 8 7 6 5 4 3 2 1 i=0 条件满足 8 次，1 和 9 交换，1 8 7 6 5 4 3 2 9。\ni=1 条件满足 6 次，2 和 8 交换，1 2 7 6 5 4 3 8 9。\ni=2 条件满足 4 次，3 和 7 交换，1 2 3 6 5 4 7 8 9。\ni=3 条件满足 2 次，4 和 6 交换。1 2 3 4 5 6 7 8 9。\n一共满足了 8+6+4+2=20 次\n"},{"id":183,"href":"/2-1-4/","title":"2.1.4","section":"《算法（第四版）》C# 题解","content":" 2.1.4 # 解答 # "},{"id":184,"href":"/2-1-5/","title":"2.1.5","section":"《算法（第四版）》C# 题解","content":" 2.1.5 # 解答 # 条件是：\nj \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]) 第一个条件属于循环计数用的条件，与数组元素无关；\n第二个条件当 a[j] 和 a[j - 1] 是一组逆序对时满足，因此这个条件总是为假 = 数组没有逆序对 = 数组有序。\n因此只要输入已经排好序的数组即可。\n逆序对：指序列中顺序相反的两个数，例如 1 2 3 4 5 7 6 8 9 中的 7 6。\n另请参阅 # 逆序对-维基百科\n"},{"id":185,"href":"/2-1-6/","title":"2.1.6","section":"《算法（第四版）》C# 题解","content":" 2.1.6 # 解答 # 插入排序更快。\n选择排序无论如何都需要 $n + (n-1) + (n-2) + … + 1 = \\frac{n^2}{2}$ 次比较。\n插入排序在这种情况下只需要 n 次比较。（所有主键相同 = 数组已排序）\n"},{"id":186,"href":"/2-1-7/","title":"2.1.7","section":"《算法（第四版）》C# 题解","content":" 2.1.7 # 解答 # 假设比较的开销小于等于交换的开销，此时选择排序更快，具体比较见下表。\n排序方法 比较次数 交换次数 插入排序 ~N^2/2 ~N^2/2 选择排序 ~N^2/2 N "},{"id":187,"href":"/2-1-8/","title":"2.1.8","section":"《算法（第四版）》C# 题解","content":" 2.1.8 # 解答 # 平方级别。\n如果数组中元素各不相同，那么这个结论很容易证明（一般的插入排序）。\n接下来我们证明有重复元素的情况下，这个结论仍然成立：\n首先对于插入排序过程中的某一时刻，我们有下图这样的一般情况：\n$$ \\underbrace{11\u0026hellip;1}{a} \\ \\underbrace{22\u0026hellip;2}{b} \\ \\underbrace{33\u0026hellip;3}{c} \\ \\underbrace{13121123}{unsorted} $$\n其中，1，2，3 分别代表三种不同的取值及其先后顺序。\n假设这是第 i 次插入前，如果第 i 次插入的是 1，我们需要交换 b+c 次，插入 2 则需要交换 c 次，插入 3 则不需要交换。\n根据题意，这是一个随机数组，我们假设其为均匀分布，那么三种取值的出现几率相等。\n第 i 次插入所需要的平均交换次数即为：\n$$ \\frac{b+c+c}{3}=\\frac{b+2c}{3} $$\n第 i 次插入后，b + 2c 视插入的元素不同会出现不同的变化：\n如果插入的是 1，那么 b+2c 的值不会变化。\n如果插入的是 2，那么 b+2c 的值增加 1。\n如果插入的是 3，那么 b+2c 的值增加 2。\n同样由于三种取值的概率相等，我们得出第 i + 1 次插入平均需要交换的次数为：\n$$ \\frac{b+2c+\\frac{0+1+2}{3}}{3}=\\frac{b+2c+1}{3} $$\n也就是说，平均每次插入都会使下一次插入的交换次数增加 1/3。\n令 i=0，此时交换次数为 0，i+1 的交换次数即为 1/3，i+2 的交换次数即为 2/3，以此类推。\n我们可以得出总交换次数：\n$$ \\frac{1+2+3+4+\u0026hellip;+N}{3}=\\frac{N(N-1)}{6} $$\n由此证明，在元素取值为 3 种且出现概率相等时，插入排序的交换开销时平方级别的。\n比较开销和交换开销类似，一般情况下比较次数=交换次数+1，除非插入的数是已知最小的数（移动到最左侧），这个时候比较次数和交换次数相等。\n因此比较次数=交换次数+N-e，e 是一个不大于 N 的数，代表插入的数是已知最小的数这种情况发生的次数。\n根据上式可以得出结论：在元素取值为 3 种且出现概率相等时，插入排序的比较开销也是平方级别的。\n综合两个结论即可证明插入排序的开销在题目描述的情况下是平方级别的。\n证明完毕。\n"},{"id":188,"href":"/2-1-9/","title":"2.1.9","section":"《算法（第四版）》C# 题解","content":" 2.1.9 # 解答 # "},{"id":189,"href":"/2-1-10/","title":"2.1.10","section":"《算法（第四版）》C# 题解","content":" 2.1.10 # 解答 # 对于部分有序的数组，插入排序比选择排序快。\n这个结论可以在中文版 P158， 英文版 P252 找到。\n"},{"id":190,"href":"/2-1-11/","title":"2.1.11","section":"《算法（第四版）》C# 题解","content":" 2.1.11 # 解答 # 希尔排序的官方实现：https://algs4.cs.princeton.edu/21elementary/Shell.java.html\n只要稍作修改即可，详情见代码。\n代码 # public override void Sort\u0026lt;T\u0026gt;(T[] a) { var n = a.Length; var h = new int[2]; // 预先准备好的 h 值数组 var hTemp = 1; int sequenceSize; for (sequenceSize = 0; hTemp \u0026lt; n; sequenceSize++) { if (sequenceSize \u0026gt;= h.Length) // 如果数组不够大则双倍扩容 { var expand = new int[h.Length * 2]; for (var j = 0; j \u0026lt; h.Length; j++) { expand[j] = h[j]; } h = expand; } h[sequenceSize] = hTemp; hTemp = hTemp * 3 + 1; } for (var t = sequenceSize - 1; t \u0026gt;= 0; t--) { for (var i = h[t]; i \u0026lt; n; i++) { for (var j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } 另请参阅 # Sort 库\n"},{"id":191,"href":"/2-1-12/","title":"2.1.12","section":"《算法（第四版）》C# 题解","content":" 2.1.12 # 解答 # 结果截图如下，同一个 h 值对应的比值在数组大小不同时保持为一个小常数：\n代码 # // 查看最后结果 // 可以发现相同的 h 在数组大小不同时所产生的比值十分接近。 var random = new Random(); var sort = new ShellSort(); var size = 100; for (var i = 0; i \u0026lt; 5; i++) { var a = new double[size]; for (var j = 0; j \u0026lt; size; j++) { a[j] = random.NextDouble() * 100; } Console.WriteLine(\u0026#34;ArraySize:\u0026#34; + size); sort.Sort(a); size *= 10; } 另请参阅 # Sort 库\n"},{"id":192,"href":"/2-1-13/","title":"2.1.13","section":"《算法（第四版）》C# 题解","content":" 2.1.13 # 解答 # 可以用冒泡排序做，具体方法如下：\n翻一二两张，是逆序对就交换，否则什么也不做\n翻二三两张，是逆序对就交换，否则什么也不做\n一直到最后，可以保证最右侧的是最大花色的牌\n然后不断重复上述过程，就可以完全排序\n"},{"id":193,"href":"/2-1-14/","title":"2.1.14","section":"《算法（第四版）》C# 题解","content":" 2.1.14 # 解答 # 用一种类似于冒泡的方法做，具体步骤为：\n重复以下步骤，直到全部完成一遍之后没有发生交换 重复以下步骤 n-1 次 如果顶端两张牌逆序，那么交换它们。 将第一张牌放到牌堆底部。 具体步骤图：\n我们将牌排成一个环，用一支笔隔开，这里我们标记笔的左侧是牌堆顶部，右侧是牌堆底部。\n那么我们能做的三个操作在这里即为：\n查看最上面两张牌 = 从笔的位置开始，逆时针查看两张牌。\n交换最上面两张牌 = 从笔的位置开始，逆时针选择两张牌并交换。\n将最上面的一张牌放到最下面 = 将笔的位置逆时针移动一位。\n下面我们开始执行开始说过的操作，目标顺序是自顶向下从小到大排列。\n初始情况如图所示：\n梅花7 和 红桃4 不是逆序对，直接将笔逆时针移动一位。\n红桃4 和 黑桃6 不是逆序对，我们将笔逆时针移动一位。\n再看 黑桃6 和 方片A，是逆序对，我们交换并将笔逆时针移动一位。\n再看 黑桃6 和 红桃J，是逆序对，我们交换并将笔逆时针移动一位。\n现在我们已经操作了 4 次，内部循环结束，我们将笔放回初始位置。\n这样一次循环之后，我们就把最大的牌放在了最下面，依次类推即可完全排序。\n另请参阅 # Sorting a deque using limited operations?-Stock Overflow\n"},{"id":194,"href":"/2-1-15/","title":"2.1.15","section":"《算法（第四版）》C# 题解","content":" 2.1.15 # 解答 # 选择排序\n交换（也就是 Exch() 方法）需要一个额外空间，这里的条件满足。\n现在我们应该使交换次数最少，选择排序只需要 N 次交换，比插入排序平均 N^2/4 少（N \u0026gt; 2）。\n"},{"id":195,"href":"/2-1-16/","title":"2.1.16","section":"《算法（第四版）》C# 题解","content":" 2.1.16 # 解答 # 如果移动数据时新建了对象，那么虽然值没有改变，但是数组中的对象被修改了。\n代码 # 插入排序中的 Exch() 换成了如下方式：\nstring temp = new string(s[i].ToCharArray()); s[i] = s[min]; s[min] = temp; 全部程序代码如下：\nvar test = new[] { \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;e\u0026#34; }; Console.WriteLine(CheckArraySort(test)); Console.WriteLine(CheckSelectionSort(test)); // 测试 Array.Sort() 方法。 static bool CheckArraySort(string[] a) { var backup = new string[a.Length]; a.CopyTo(backup, 0); Array.Sort(a); foreach (var n in a) { var isFind = false; for (var i = 0; i \u0026lt; a.Length; i++) { if (ReferenceEquals(n, backup[i])) { isFind = true; break; } } if (!isFind) { return false; } } return true; } // 测试选择排序。 static bool CheckSelectionSort(string[] a) { var backup = new string[a.Length]; a.CopyTo(backup, 0); SelectionSort(a); foreach (var n in a) { var isFind = false; for (var i = 0; i \u0026lt; a.Length; i++) { if (ReferenceEquals(n, backup[i])) { isFind = true; break; } } if (!isFind) { return false; } } return true; } // 选择排序，其中的交换部分使用新建对象并复制的方法。 static void SelectionSort(string[] s) { for (var i = 0; i \u0026lt; s.Length; i++) { var min = i; for (var j = i + 1; j \u0026lt; s.Length; j++) { if (s[j].CompareTo(s[min]) \u0026lt; 0) { min = j; } } var temp = new string(s[i].ToCharArray()); s[i] = s[min]; s[min] = temp; } } "},{"id":196,"href":"/2-1-17/","title":"2.1.17","section":"《算法（第四版）》C# 题解","content":" 2.1.17 # 解答 # 选择排序：\n插入排序：\n代码 # 使用一个 timer 按一定时间重绘数组，排序算法里面一次循环后等待一段时间再进行下一次循环。（这并不是一个很好的方法，但对于演示来说足够了）\n这里排序算法是另开线程运行的，防止 Sleep 的时候让程序无响应。\n选择排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._17 { public partial class Form2 : Form { double[] randomDoubles; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } drawPanel(); this.timer1.Interval = 60; this.timer1.Start(); Thread thread = new Thread(new ThreadStart(this.SelectionSort)); thread.IsBackground = true; thread.Start(); } /// \u0026lt;summary\u0026gt; /// 选择排序。 /// \u0026lt;/summary\u0026gt; private void SelectionSort() { for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { int min = i; for (int j = i; j \u0026lt; this.randomDoubles.Length; j++) { if (this.randomDoubles[min] \u0026gt; this.randomDoubles[j]) { min = j; } } double temp = this.randomDoubles[i]; this.randomDoubles[i] = this.randomDoubles[min]; this.randomDoubles[min] = temp; Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt; /// 在屏幕上用柱形图绘制数组。 /// \u0026lt;/summary\u0026gt; private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } graphics.FillRectangles(Brushes.Black, bars); graphics.Dispose(); } private void timer1_Tick(object sender, EventArgs e) { drawPanel(); } } } 插入排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._17 { public partial class Form3 : Form { double[] randomDoubles; public Form3(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } drawPanel(); this.timer1.Interval = 60; this.timer1.Start(); Thread thread = new Thread(new ThreadStart(this.InsertionSort)); thread.IsBackground = true; thread.Start(); } /// \u0026lt;summary\u0026gt; /// 插入排序。 /// \u0026lt;/summary\u0026gt; private void InsertionSort() { for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; this.randomDoubles[j] \u0026lt; this.randomDoubles[j - 1]; j--) { double temp = this.randomDoubles[j]; this.randomDoubles[j] = this.randomDoubles[j - 1]; this.randomDoubles[j - 1] = temp; Thread.Sleep(500); } } } /// \u0026lt;summary\u0026gt; /// 在屏幕上用柱形图绘制数组。 /// \u0026lt;/summary\u0026gt; private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } graphics.FillRectangles(Brushes.Black, bars); graphics.Dispose(); } private void timer1_Tick(object sender, EventArgs e) { drawPanel(); } } } "},{"id":197,"href":"/2-1-18/","title":"2.1.18","section":"《算法（第四版）》C# 题解","content":" 2.1.18 # 解答 # 选择排序\n插入排序\n代码 # 与上题类似，但要特别标出移动的元素。 选择排序：\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._18 { public partial class Form2 : Form { double[] randomDoubles; int sortI; int sortJ; int sortMin; public Form2(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } } /// \u0026lt;summary\u0026gt; /// 选择排序。 /// \u0026lt;/summary\u0026gt; private void SelectionSort() { for (this.sortI = 0; this.sortI \u0026lt; this.randomDoubles.Length; this.sortI++) { this.sortMin = this.sortI; for (this.sortJ = this.sortI; this.sortJ \u0026lt; this.randomDoubles.Length; this.sortJ++) { if (this.randomDoubles[this.sortMin] \u0026gt; this.randomDoubles[this.sortJ]) { this.sortMin = this.sortJ; } } drawPanel(); double temp = this.randomDoubles[this.sortI]; this.randomDoubles[this.sortI] = this.randomDoubles[this.sortMin]; this.randomDoubles[this.sortMin] = temp; Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt; /// 绘制柱形图。 /// \u0026lt;/summary\u0026gt; private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } for (int i = 0; i \u0026lt; bars.Length; i++) { if (i == this.sortMin) { graphics.FillRectangle(Brushes.Red, bars[i]); } else if (i \u0026lt; this.sortI) { graphics.FillRectangle(Brushes.Gray, bars[i]); } else { graphics.FillRectangle(Brushes.Black, bars[i]); } } graphics.Dispose(); } private void Form2_Shown(object sender, EventArgs e) { SelectionSort(); } } } 插入排序\nusing System; using System.Drawing; using System.Windows.Forms; using System.Threading; namespace _2._1._18 { public partial class Form3 : Form { double[] randomDoubles; int sortI; int sortJ; int n = 0; public Form3(int N) { InitializeComponent(); this.randomDoubles = new double[N]; Random random = new Random(); for (int i = 0; i \u0026lt; N; i++) { this.randomDoubles[i] = random.NextDouble() * 0.8 + 0.2; } } /// \u0026lt;summary\u0026gt; /// 插入排序。 /// \u0026lt;/summary\u0026gt; private void InsertionSort() { for (this.sortI = 0; this.sortI \u0026lt; this.randomDoubles.Length; this.sortI++) { for (this.sortJ = this.sortI; this.sortJ \u0026gt; 0 \u0026amp;\u0026amp; this.randomDoubles[this.sortJ] \u0026lt; this.randomDoubles[this.sortJ - 1]; this.sortJ--) { double temp = this.randomDoubles[this.sortJ]; this.randomDoubles[this.sortJ] = this.randomDoubles[this.sortJ - 1]; this.randomDoubles[this.sortJ - 1] = temp; } drawPanel(); Thread.Sleep(1000); } } /// \u0026lt;summary\u0026gt; /// 绘制柱形图。 /// \u0026lt;/summary\u0026gt; private void drawPanel() { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] barX = new PointF[this.randomDoubles.Length]; float unitX = (float)drawRect.Width / this.randomDoubles.Length; unitX -= 4; barX[0] = new PointF(4, drawRect.Top); for (int i = 1; i \u0026lt; this.randomDoubles.Length; i++) { barX[i] = new PointF(2 + unitX + barX[i - 1].X, drawRect.Top); } RectangleF[] bars = new RectangleF[this.randomDoubles.Length]; for (int i = 0; i \u0026lt; this.randomDoubles.Length; i++) { SizeF size = new SizeF(unitX, (float)this.randomDoubles[i] * drawRect.Height); bars[i] = new RectangleF(barX[i], size); } for (int i = 0; i \u0026lt; bars.Length; i++) { if (i == this.sortJ) { graphics.FillRectangle(Brushes.Red, bars[i]); } else if (i \u0026lt;= this.sortI \u0026amp;\u0026amp; i \u0026gt; this.sortJ) { graphics.FillRectangle(Brushes.Black, bars[i]); } else { graphics.FillRectangle(Brushes.Gray, bars[i]); } } graphics.Dispose(); } private void Form3_Shown(object sender, EventArgs e) { InsertionSort(); } } } "},{"id":198,"href":"/2-1-19/","title":"2.1.19","section":"《算法（第四版）》C# 题解","content":" 2.1.19 # 解答 # 不得不说这道题意外的难。\n放上论文链接：Shellsort and Sorting Networks (Outstanding Dissertations in the Computer Sciences)\n这篇论文的第二章给出了一种构造最坏序列的方法，当然理想最坏（n^(3/2)）是达不到的了。\n最后结果是 793 次。\n@杨晗 通过随机输入获得了一个理论最坏的输入序列，见：https://github.com/YangXiaoHei/Algorithms/blob/master/Ch_2_1_Elementary_Sorts/Practise_2_1_19.java\n这个序列是：\n48, 46, 54, 97, 83, 69, 76, 25, 10, 5, 87, 12, 21, 99, 61, 33, 30, 47, 57, 4, 36, 42, 98, 66, 100, 17, 94, 81, 11, 77, 24, 89, 73, 53, 38, 7, 29, 8, 27, 23, 56, 70, 60, 85, 39, 65, 9, 75, 15, 67, 64, 22, 51, 82, 43, 3, 37, 91, 45, 13, 34, 63, 74, 71, 95, 55, 80, 92, 2, 19, 62, 40, 84, 41, 50, 88, 86, 59, 28, 44, 72, 68, 14, 35, 93, 26, 18, 78, 31, 58, 96, 6, 1, 90, 49, 16, 52, 79, 32, 20 会比较 999 次。\n代码 # 构造最坏情况的类\ninternal class ShellSortWorstCase { /// \u0026lt;summary\u0026gt; /// 获得最坏情况的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组大小。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;希尔排序最坏情况的数组。\u0026lt;/returns\u0026gt; public static int[] GetWorst(int n) { var l = 0; var a = new int?[n + 1]; for (var i = 0; i \u0026lt; a.Length; i++) { a[i] = null; } var p = 40; var pAddition = p; while (l \u0026lt; 100) { for (var j = 1; j \u0026lt;= n; j++) { if (a[j] == null \u0026amp;\u0026amp; IsVisible(j, p)) { l++; a[j] = l; } } p += pAddition; } var b = new int[n]; for (var i = 0; i \u0026lt; n; i++) { b[i] = (int)a[i + 1]; } return b; } /// \u0026lt;summary\u0026gt; /// 确认 j - i 是不是在排序样板（Sorting Template）上。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static bool IsVisible(int i, int j) { var k = 0; while (k \u0026lt;= 100) { if (j - i \u0026gt;= k * 40 \u0026amp;\u0026amp; j - i \u0026lt;= k * 41) return true; k++; } return false; } } 会显示比较次数的 ShellSort 类\npublic class ShellSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用希尔排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var n = a.Length; var compareTime = 0; var h = 1; while (h \u0026lt; n / 3) { h = 3 * h + 1; } while (h \u0026gt;= 1) { for (var i = h; i \u0026lt; n; i++) { for (var j = i; j \u0026gt;= h \u0026amp;\u0026amp; LessAndCount(a[j], a[j - h], ref compareTime); j -= h) { Exch(a, j, j - h); } } Debug.Assert(IsHSorted(a, h)); h /= 3; } Console.WriteLine(\u0026#34;CompareTime:\u0026#34; + compareTime); Debug.Assert(IsSorted(a)); } private bool LessAndCount\u0026lt;T\u0026gt;(T a, T b, ref int count) where T : IComparable\u0026lt;T\u0026gt; { count++; return Less(a, b); } /// \u0026lt;summary\u0026gt; /// 检查一次希尔排序后的子数组是否有序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;排序后的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;子数组间隔。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;是否有序。\u0026lt;/returns\u0026gt; private bool IsHSorted\u0026lt;T\u0026gt;(T[] a, int h) where T : IComparable\u0026lt;T\u0026gt; { for (var i = h; i \u0026lt; a.Length; i++) { if (Less(a[i], a[i - h])) { return false; } } return true; } } main 方法\n// 开放题，没有标准答案 // 共参考的最差情况为 n^(3/2) // 本例共 761 次 int[] b; var sort = new ShellSort(); b = ShellSortWorstCase.GetWorst(100); for (var i = 0; i \u0026lt; b.Length; i++) { Console.Write(b[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); sort.Sort(b); 另请参阅 # Sort 库\n"},{"id":199,"href":"/2-1-20/","title":"2.1.20","section":"《算法（第四版）》C# 题解","content":" 2.1.20 # 解答 # 由于每次 h 排序都是插入排序，希尔排序最好情况就是插入排序的最好情况，也就是已排序的数组。\n"},{"id":200,"href":"/2-1-21/","title":"2.1.21","section":"《算法（第四版）》C# 题解","content":" 2.1.21 # 解答 # 事实上官方给出来的 Date 类以及 Transaction 类都已经实现了这些接口。\nDate 类：Date.java\nTransaction 类：Transaction.java\n代码 # var a = new Transaction[4]; a[0] = new Transaction(\u0026#34;Turing 6/17/1990 644.08\u0026#34;); a[1] = new Transaction(\u0026#34;Tarjan 3/26/2002 4121.85\u0026#34;); a[2] = new Transaction(\u0026#34;Knuth 6/14/1999 288.34\u0026#34;); a[3] = new Transaction(\u0026#34;Dijkstra 8/22/2007 2678.40\u0026#34;); Console.WriteLine(\u0026#34;Unsorted\u0026#34;); for (var i = 0; i \u0026lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by amount\u0026#34;); var insertionSort = new InsertionSort(); insertionSort.Sort(a, new Transaction.HowMuchOrder()); for (var i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); 另请参阅 # Sort 库\n"},{"id":201,"href":"/2-1-22/","title":"2.1.22","section":"《算法（第四版）》C# 题解","content":" 2.1.22 # 解答 # 和上题类似，只要传入事先写好的比较器就可以了。\n代码 # var a = new Transaction[4]; // 样例输入 // Turing 6/17/1990 644.08 // Tarjan 3/26/2002 4121.85 // Knuth 6/14/1999 288.34 // Dijkstra 8/22/2007 2678.40 for (var i = 0; i \u0026lt; a.Length; i++) { var input = Console.ReadLine(); a[i] = new Transaction(input); } var insertionSort = new InsertionSort(); Console.WriteLine(\u0026#34;Unsorted\u0026#34;); for (var i = 0; i \u0026lt; a.Length; i++) { Console.WriteLine(a[i]); } Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by date\u0026#34;); insertionSort.Sort(a, new Transaction.WhenOrder()); for (var i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by customer\u0026#34;); insertionSort.Sort(a, new Transaction.WhoOrder()); for (var i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); Console.WriteLine(\u0026#34;Sort by amount\u0026#34;); insertionSort.Sort(a, new Transaction.HowMuchOrder()); for (var i = 0; i \u0026lt; a.Length; i++) Console.WriteLine(a[i]); Console.WriteLine(); 另请参阅 # Sort 库\n"},{"id":202,"href":"/2-1-23/","title":"2.1.23","section":"《算法（第四版）》C# 题解","content":" 2.1.23 # 解答 # 方法多种多样。\n首先是冒泡，见习题 2.1.13\n插入排序也可以，如下：\n从前往后不断翻牌，\n对于翻到的每张牌，一直和之前的牌交换，\n直至前面的牌比它小或者它已经是第一张了。\n也可以用基数排序\n从前向后依次翻开牌，\n按照花色分成四堆，\n然后按花色从大到小重新排列。\n比较符合直觉的是选择排序\n寻找最小的牌并放到第一位，\n寻找范围向右缩减一位，重复上一步，直到最后一张。\n还有其他方法，这里不再赘述。\n"},{"id":203,"href":"/2-1-24/","title":"2.1.24","section":"《算法（第四版）》C# 题解","content":" 2.1.24 # 解答 # 如果使用官方的实现（InsertionX.java），最后结果可能会比一般插入排序慢，因为它是用冒泡的方法找最小值的。\n一般做法是在待排序数组的最前端插入一个很小的值（比如 int.MinValue），然后对 a[1]~a[n] 排序。\n代码 # 参考官方实现的插入排序：\npublic class InsertionSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用插入排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 1; i \u0026lt; n; i++) { for (var j = i; Less(a[j], a[j - 1]); --j) { Exch(a, j, j - 1); } Debug.Assert(IsSorted(a, 0, i)); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 利用插入排序将数组排序。（使用指定比较器） /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;比较器。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(T[] a, IComparer\u0026lt;T\u0026gt; c) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1], c)) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 1; i \u0026lt; n; i++) { for (var j = i; Less(a[j], a[j - 1], c); --j) { Exch(a, j, j - 1); } Debug.Assert(IsSorted(a, 0, i, c)); } Debug.Assert(IsSorted(a, c)); } } 另请参阅 # Sort 库\n"},{"id":204,"href":"/2-1-25/","title":"2.1.25","section":"《算法（第四版）》C# 题解","content":" 2.1.25 # 解答 # 使用依次赋值的方式腾出空间，到达指定位置之后再把元素插入。\n看代码会方便理解一点。\n官方实现：InsertionX.java。\n代码 # public class InsertionSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用插入排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i \u0026gt; 0 ; i--) { if (Less(a[i], a[i - 1])) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 2; i \u0026lt; n; i++) { var j = i; var v = a[i]; while (Less(v, a[j - 1])) { a[j] = a[j - 1]; j--; } a[j] = v; Debug.Assert(IsSorted(a, 0, i)); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 利用插入排序将数组排序。（使用指定比较器） /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;比较器。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(T[] a, IComparer\u0026lt;T\u0026gt; c) { var n = a.Length; var exchanges = 0; for (var i = n - 1; i \u0026gt; 0; i--) { if (Less(a[i], a[i - 1], c)) { Exch(a, i, i - 1); exchanges++; } } if (exchanges == 0) return; for (var i = 2; i \u0026lt; n; i++) { var j = i; var v = a[i]; while (Less(v, a[j - 1], c)) { a[j] = a[j - 1]; j--; } a[j] = v; Debug.Assert(IsSorted(a, 0, i, c)); } Debug.Assert(IsSorted(a, c)); } } 另请参阅 # Sort 库\n"},{"id":205,"href":"/2-1-26/","title":"2.1.26","section":"《算法（第四版）》C# 题解","content":" 2.1.26 # 解答 # 直接针对特殊值的话显然会快很多。\n代码 # 直接把泛型改成 int 即可。\npublic class InsertionSort { /// \u0026lt;summary\u0026gt; /// 利用插入排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public void Sort(int[] a) { var n = a.Length; for (var i = 0; i \u0026lt; n; i++) { for (var j = i; j \u0026gt; 0 \u0026amp;\u0026amp; a[j] \u0026lt; a[j - 1]; --j) { var t = a[j]; a[j] = a[j - 1]; a[j - 1] = t; } } } } 另请参阅 # Sort 库\n"},{"id":206,"href":"/2-1-27/","title":"2.1.27","section":"《算法（第四版）》C# 题解","content":" 2.1.27 # 解答 # 数据比较大的时候会比较明显。\n代码 # var n = 128; var random = new Random(); double shellPrev = 1; double insertionPrev = 1; double selectionPrev = 1; while (n \u0026lt; 65538) { var testShell = new int[n]; var testInsertion = new int[n]; var testSelection = new int[n]; for (var i = 0; i \u0026lt; n; i++) { testShell[i] = random.Next(); testInsertion[i] = testShell[i]; testSelection[i] = testShell[i]; } Console.WriteLine(\u0026#34;数组大小：\u0026#34; + n); Console.Write(\u0026#34;Shell Sort:\u0026#34;); var shellNow = SortCompare.Time(new ShellSort(), testShell); Console.WriteLine(shellNow + \u0026#34;\\t\\tNow/Prev=\u0026#34; + shellNow / shellPrev); Console.Write(\u0026#34;Insertion Sort:\u0026#34;); var insertionNow = SortCompare.Time(new InsertionSort(), testInsertion); Console.WriteLine(insertionNow + \u0026#34;\\tNow/Prev=\u0026#34; + insertionNow / insertionPrev); Console.Write(\u0026#34;Selection Sort:\u0026#34;); var selectionNow = SortCompare.Time(new SelectionSort(), testSelection); Console.WriteLine(selectionNow + \u0026#34;\\tNow/Prev=\u0026#34; + selectionNow / selectionPrev); Console.WriteLine(); shellPrev = shellNow; insertionPrev = insertionNow; selectionPrev = selectionNow; n *= 2; } 另请参阅 # Sort 库\n"},{"id":207,"href":"/2-1-28/","title":"2.1.28","section":"《算法（第四版）》C# 题解","content":" 2.1.28 # 解答 # 插入排序会比选择排序快上许多，当然增长级别不变。\n代码 # var n = 1024; var random = new Random(); double insertionPrev = 1; double selectionPrev = 1; while (n \u0026lt; 65538) { var testInsertion = new int[n]; var testSelection = new int[n]; for (var i = 0; i \u0026lt; n; i++) { testInsertion[i] = random.Next(2); testSelection[i] = testInsertion[i]; } Console.WriteLine(\u0026#34;数组大小：\u0026#34; + n); Console.Write(\u0026#34;Insertion Sort:\u0026#34;); var insertionNow = SortCompare.Time(new InsertionSort(), testInsertion); Console.WriteLine(insertionNow + \u0026#34;\\tNow/Prev=\u0026#34; + insertionNow / insertionPrev); Console.Write(\u0026#34;Selection Sort:\u0026#34;); var selectionNow = SortCompare.Time(new SelectionSort(), testSelection); Console.WriteLine(selectionNow + \u0026#34;\\tNow/Prev=\u0026#34; + selectionNow / selectionPrev); Console.WriteLine(); insertionPrev = insertionNow; selectionPrev = selectionNow; n *= 2; } 另请参阅 # Sort 库\n"},{"id":208,"href":"/2-1-29/","title":"2.1.29","section":"《算法（第四版）》C# 题解","content":" 2.1.29 # 解答 # 当然是题目给出的递增序列更快啦，因为这个序列就是作者提出来的嘛。\n（论文链接： http://linkinghub.elsevier.com/retrieve/pii/0196677486900015）\n代码 # 修改了一下 shellsort，让它按照给定的 h 序列排序。\npublic class ShellSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用希尔排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;待排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;需要使用的递增序列。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(T[] a, int[] h) where T : IComparable\u0026lt;T\u0026gt; { var n = a.Length; var t = 0; while (h[t] \u0026lt; a.Length) { t++; if (t \u0026gt;= h.Length) break; } t--; for ( ; t \u0026gt;= 0; t--) { for (var i = h[t]; i \u0026lt; n; i++) { for (var j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 利用希尔排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var n = a.Length; var h = new int[2]; // 预先准备好的 h 值数组 var hTemp = 1; int sequenceSize; for (sequenceSize = 0; hTemp \u0026lt; n; sequenceSize++) { if (sequenceSize \u0026gt;= h.Length) // 如果数组不够大则双倍扩容 { var expand = new int[h.Length * 2]; for (var j = 0; j \u0026lt; h.Length; j++) { expand[j] = h[j]; } h = expand; } h[sequenceSize] = hTemp; hTemp = hTemp * 3 + 1; } for (var t = sequenceSize - 1; t \u0026gt;= 0; t--) { for (var i = h[t]; i \u0026lt; n; i++) { for (var j = i; j \u0026gt;= h[t] \u0026amp;\u0026amp; Less(a[j], a[j - h[t]]); j -= h[t]) { Exch(a, j, j - h[t]); } } Debug.Assert(IsHSorted(a, h[t])); } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 检查一次希尔排序后的子数组是否有序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;排序后的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;h\u0026#34;\u0026gt;子数组间隔。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;是否有序。\u0026lt;/returns\u0026gt; private bool IsHSorted\u0026lt;T\u0026gt;(T[] a, int h) where T : IComparable\u0026lt;T\u0026gt; { for (var i = h; i \u0026lt; a.Length; i++) { if (Less(a[i], a[i - h])) { return false; } } return true; } } 另请参阅 # Sort 库\n"},{"id":209,"href":"/2-1-30/","title":"2.1.30","section":"《算法（第四版）》C# 题解","content":" 2.1.30 # 解答 # 2，3，4\nt 越大的话，按照这个递增序列，10^6 次能够满足的 h 也就越少。\n代码 # // t = 2, 3, 4 // t 大于 10 之后，由于每次排序 h 缩减的太快， // 时间会越来越近似于直接插入排序。 var array = SortCompare.GetRandomArrayInt(1000000); var array2 = new int[array.Length]; array.CopyTo(array2, 0); var timer = new Stopwatch(); var bestTimes = new long[3]; var bestTs = new long[3]; for (var i = 0; i \u0026lt; bestTimes.Length; i++) { bestTimes[i] = long.MaxValue; bestTs[i] = int.MaxValue; } var shellSort = new ShellSort(); for (var t = 2; t \u0026lt;= 1000000; t++) { Console.WriteLine(t); timer.Restart(); shellSort.Sort(array, t); var nowTime = timer.ElapsedMilliseconds; timer.Stop(); Console.WriteLine(\u0026#34;Elapsed Time:\u0026#34; + nowTime); for (var i = 0; i \u0026lt; bestTimes.Length; i++) { Console.Write(\u0026#34;t:\u0026#34; + bestTs[i]); Console.WriteLine(\u0026#34;\\tTime:\u0026#34; + bestTimes[i]); } if (bestTimes[2] \u0026gt; nowTime) { bestTimes[2] = nowTime; bestTs[2] = t; Array.Sort(bestTimes, bestTs); } array2.CopyTo(array, 0); } for (var i = 0; i \u0026lt; bestTimes.Length; i++) { Console.Write(\u0026#34;t:\u0026#34; + bestTs[i]); Console.Write(\u0026#34;\\tTime:\u0026#34; + bestTimes[i]); } 另请参阅 # Sort 库\n"},{"id":210,"href":"/2-1-31/","title":"2.1.31","section":"《算法（第四版）》C# 题解","content":" 2.1.31 # 解答 # 这里截取数据量比较大的时候的数据。\n插入排序和选择排序显然都是平方级别的。\n希尔排序猜测是线性的，实际上要比线性大一点（次平方级）。\n代码 # var n = 1000; var insertion = new InsertionSort(); var selection = new SelectionSort(); var shell = new ShellSort(); double prevInsertion = 0; double prevSelection = 0; double prevShell = 0; for (var i = 0; i \u0026lt; 10; i++) { Console.WriteLine(\u0026#34;N:\u0026#34; + n); var array = SortCompare.GetRandomArrayInt(n); var arrayBak = new int[n]; array.CopyTo(arrayBak, 0); Console.WriteLine(\u0026#34;\\tInsertion Sort\u0026#34;); var now = SortCompare.Time(insertion, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevInsertion * 4); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevInsertion); } prevInsertion = now; arrayBak.CopyTo(array, 0); Console.WriteLine(\u0026#34;\\tSelection Sort\u0026#34;); now = SortCompare.Time(selection, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevSelection * 4); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevSelection); } prevSelection = now; arrayBak.CopyTo(array, 0); Console.WriteLine(\u0026#34;\\tShell Sort\u0026#34;); now = SortCompare.Time(shell, array); Console.WriteLine(\u0026#34;\\t\\tActual Time(ms):\u0026#34; + now); if (i != 0) { Console.WriteLine(\u0026#34;\\t\\tEstimate Time(ms):\u0026#34; + prevShell * 2); Console.WriteLine(\u0026#34;\\t\\tRatio:\u0026#34; + now / prevShell); } prevShell = now; n *= 2; } 另请参阅 # Sort 库\n"},{"id":211,"href":"/2-1-32/","title":"2.1.32","section":"《算法（第四版）》C# 题解","content":" 2.1.32 # 解答 # 基本上都是这么个样子：\n代码 # using System; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._32 { public partial class Form2 : Form { BaseSort sort; int n; double[] result; /// \u0026lt;summary\u0026gt; /// 构造一个绘图结果窗口。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;用于做测试的排序算法。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;用于测试的初始数据量。\u0026lt;/param\u0026gt; public Form2(BaseSort sort, int n) { InitializeComponent(); this.sort = sort; this.n = n; this.result = Test(n); this.timer1.Interval = 1000; this.timer1.Start(); } /// \u0026lt;summary\u0026gt; /// 执行八次耗时测试，每次数据量翻倍。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;初始数据量。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;测试结果数据。\u0026lt;/returns\u0026gt; public double[] Test(int n) { double[] result = new double[8]; for (int i = 0; i \u0026lt; result.Length; i++) { result[i] = SortCompare.TimeRandomInput(this.sort, n, 3); n *= 2; } return result; } /// \u0026lt;summary\u0026gt; /// 绘制曲线图。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;结果数组。\u0026lt;/param\u0026gt; public void DrawPanel(double[] result) { Graphics graphics = this.CreateGraphics(); graphics.TranslateTransform(0, this.ClientRectangle.Height); graphics.ScaleTransform(1, -1); Rectangle clientRect = this.ClientRectangle; Rectangle drawRect = new Rectangle(clientRect.X + 10, clientRect.Y + 10, clientRect.Width - 10, clientRect.Height - 10); PointF[] dataPoints = new PointF[result.Length]; float unitX = (float)drawRect.Width / result.Length; float unitY = (float)(drawRect.Height / result.Max()); SizeF pointSize = new SizeF(8, 8); for (int i = 0; i \u0026lt; result.Length; i++) { dataPoints[i] = new PointF(drawRect.Left + unitX * i, (float)(unitY * result[i])); graphics.FillEllipse(Brushes.Black, new RectangleF(dataPoints[i], pointSize)); } } private void timer1_Tick(object sender, EventArgs e) { DrawPanel(this.result); this.timer1.Stop(); } } } 另请参阅 # Sort 库\n"},{"id":212,"href":"/2-1-33/","title":"2.1.33","section":"《算法（第四版）》C# 题解","content":" 2.1.33 # 解答 # 这里每次结果的 Y 轴位置都是随机生成的，这样图像会好看点。\nX 轴代表消耗的时间。\n选择排序：\n插入排序：\n希尔排序：\n代码 # using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Windows.Forms; using Sort; namespace _2._1._33 { public partial class Form2 : Form { List\u0026lt;double\u0026gt; resultList; List\u0026lt;float\u0026gt; resultYList; Rectangle clientRect; Rectangle drawRect; BaseSort sort; int n; /// \u0026lt;summary\u0026gt; /// 构造一个绘制结果窗口。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sort\u0026#34;\u0026gt;用于测试的排序算法。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;测试算法是生成的数据量。\u0026lt;/param\u0026gt; public Form2(BaseSort sort, int n) { InitializeComponent(); this.resultList = new List\u0026lt;double\u0026gt;(); this.resultYList = new List\u0026lt;float\u0026gt;(); this.clientRect = this.ClientRectangle; this.drawRect = new Rectangle(this.clientRect.X + 10, this.clientRect.Y + 10, this.clientRect.Width - 10, this.clientRect.Height - 10); this.sort = sort; this.n = n; this.timer1.Interval = 500; this.timer1.Start(); } /// \u0026lt;summary\u0026gt; /// 执行一次测试并绘制图像。 /// \u0026lt;/summary\u0026gt; public void Test() { Random random = new Random(); double[] array = SortCompare.GetRandomArrayDouble(this.n); double time = SortCompare.Time(this.sort, array); this.resultList.Add(time); this.resultYList.Add((float)(random.NextDouble() * this.drawRect.Height)); DrawPanel(this.resultList.ToArray(), this.resultYList.ToArray()); } /// \u0026lt;summary\u0026gt; /// 根据已有的数据绘制图像。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;耗时数据（X 轴）\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;resultY\u0026#34;\u0026gt;Y 轴数据\u0026lt;/param\u0026gt; public void DrawPanel(double[] result, float[] resultY) { Graphics graphics = this.CreateGraphics(); graphics.Clear(this.BackColor); graphics.TranslateTransform(0, this.ClientRectangle.Height); graphics.ScaleTransform(1, -1); PointF[] dataPoints = new PointF[result.Length]; float unitX = (float)(this.drawRect.Width / (result.Max() - result.Min())); double min = result.Min(); SizeF pointSize = new SizeF(8, 8); for (int i = 0; i \u0026lt; result.Length; i++) { dataPoints[i] = new PointF((float)(unitX * (result[i] - min)), resultY[i]); graphics.FillEllipse(Brushes.Black, new RectangleF(dataPoints[i], pointSize)); } } private void timer1_Tick(object sender, EventArgs e) { Test(); } } } 另请参阅 # Sort 库\n"},{"id":213,"href":"/2-1-34/","title":"2.1.34","section":"《算法（第四版）》C# 题解","content":" 2.1.34 # 解答 # 代码 # var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); // 逆序 Console.WriteLine(\u0026#34;逆序\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + ReverseSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + ReverseSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + ReverseSortTest(shellSort)); // 顺序 Console.WriteLine(\u0026#34;顺序\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + SortedSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + SortedSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + SortedSortTest(shellSort)); // 主键相同 Console.WriteLine(\u0026#34;主键相同\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + EqualSortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + EqualSortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + EqualSortTest(shellSort)); // 二元数组 Console.WriteLine(\u0026#34;二元数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + BinarySortTest(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + BinarySortTest(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + BinarySortTest(shellSort)); // 空数组 Console.WriteLine(\u0026#34;空数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + ZeroArraySizeSort(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + ZeroArraySizeSort(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + ZeroArraySizeSort(shellSort)); // 只有一个元素的数组 Console.WriteLine(\u0026#34;只有一个元素的数组\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort Time: \u0026#34; + OneArraySizeSort(insertionSort)); Console.WriteLine(\u0026#34;Selection Sort Time: \u0026#34; + OneArraySizeSort(selectionSort)); Console.WriteLine(\u0026#34;Shell Sort Time: \u0026#34; + OneArraySizeSort(shellSort)); // 构造逆序数组并用其对指定输入算法进行测试。 static double ReverseSortTest(BaseSort sort) { var array = new int[10000]; for (var i = 0; i \u0026lt; array.Length; i++) { array[i] = array.Length - i; } return SortCompare.Time(sort, array); } // 构造已排序的数组并用其对指定排序算法测试。 static double SortedSortTest(BaseSort sort) { return SortCompare.TimeSortedInput(sort, 10000, 1); } // 构造只有一个值的数组并用其对指定排序算法做测试。 static double EqualSortTest(BaseSort sort) { var array = new int[10000]; var random = new Random(); var num = random.Next(); for (var i = 0; i \u0026lt; array.Length; i++) { array[i] = num; } return SortCompare.Time(sort, array); } // 构造只有两种取值的数组并用其对指定排序算法做测试。 static double BinarySortTest(BaseSort sort) { var array = new int[10000]; var random = new Random(); for (var i = 0; i \u0026lt; array.Length; i++) { array[i] = random.Next(2); } return SortCompare.Time(sort, array); } // 构造空数组并用其对指定排序算法做测试。 static double ZeroArraySizeSort(BaseSort sort) { var array = new int[0]; return SortCompare.Time(sort, array); } // 构造只有一个元素的数组并用其对指定排序算法做测试。 static double OneArraySizeSort(BaseSort sort) { var array = new int[1]; var random = new Random(); array[0] = random.Next(); return SortCompare.Time(sort, array); } 另请参阅 # Sort 库\n"},{"id":214,"href":"/2-1-35/","title":"2.1.35","section":"《算法（第四版）》C# 题解","content":" 2.1.35 # 解答 # 难点是如何生成符合这些分布的随机数。\nJava 的话官方给的 stdRandom 里面都有相应的实现。\n结果：\n代码 # 几种随机数的实现：\npublic static class SortUtil { /// \u0026lt;summary\u0026gt; /// 随机数发生器，所有对象共享同一个随机数发生器。 /// \u0026lt;/summary\u0026gt; public static Random UniformGenerator = new(); /// \u0026lt;summary\u0026gt; /// 产生符合正态分布的随机数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;average\u0026#34;\u0026gt;正态分布的期望值 μ。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;standardDeviation\u0026#34;\u0026gt;正态分布的标准差 σ。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符合正态分布的随机数。\u0026lt;/returns\u0026gt; public static double Normal(double average, double standardDeviation) { var u1 = UniformGenerator.NextDouble(); var u2 = UniformGenerator.NextDouble(); var z0 = Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Cos(Math.PI * 2 * u2); return z0 * standardDeviation + average; } /// \u0026lt;summary\u0026gt; /// 生成符合泊松分布的随机数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;average\u0026#34;\u0026gt;泊松分布的期望值 λ。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;一个符合泊松分布的随机数。\u0026lt;/returns\u0026gt; public static double Poission(double average) { double x = 0; var p = Math.Pow(Math.E, -average); var s = p; var u = UniformGenerator.NextDouble(); do { x++; p *= average / x; s += p; } while (u \u0026gt; s); return x; } /// \u0026lt;summary\u0026gt; /// 生成符合几何分布的随机数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;几何分布的概率 p，这应该是一个小于 1 的非负数。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;概率不能大于 1.\u0026lt;/exception\u0026gt; /// \u0026lt;returns\u0026gt;符合几何分布的随机数。\u0026lt;/returns\u0026gt; public static double Geometry(double p) { if (p \u0026gt; 1) { throw new ArgumentOutOfRangeException(\u0026#34;p\u0026#34;, \u0026#34;概率不能大于 1\u0026#34;); } double result; result = Math.Ceiling(Math.Log(1 - UniformGenerator.NextDouble()) / Math.Log(1 - p)); return result; } /// \u0026lt;summary\u0026gt; /// 根据指定的几率数组产生符合离散分布的随机数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;probabilities\u0026#34;\u0026gt;各取值的可能性。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentNullException\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;probabilities\u0026#34;/\u0026gt; 为 \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt; 时抛出。\u0026lt;/exception\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;probabilities\u0026#34;/\u0026gt; 中存在大于 1 或 小于 0 的数，或者总和不为 1 时抛出。\u0026lt;/exception\u0026gt; /// \u0026lt;returns\u0026gt;符合随机分布的随机整数。\u0026lt;/returns\u0026gt; public static double Discrete(double[] probabilities) { if (probabilities == null) { throw new ArgumentNullException(nameof(probabilities), \u0026#34;Argument array is null\u0026#34;); } var epsion = 1E-14; double sum = 0; for (var i = 0; i \u0026lt; probabilities.Length; i++) { if (probabilities[i] \u0026lt;= 0) { throw new ArgumentException(\u0026#34;array entry \u0026#34; + i + \u0026#34; must be nonnegative:\u0026#34; + probabilities[i]); } sum += probabilities[i]; } if (sum \u0026gt; 1.0 + epsion || sum \u0026lt; 1.0 - epsion) { throw new ArgumentException(\u0026#34;sum of array entries does not equal 1.0:\u0026#34; + sum); } while (true) { var r = UniformGenerator.NextDouble(); sum = 0.0; for (var i = 0; i \u0026lt; probabilities.Length; i++) { sum += probabilities[i]; if (sum \u0026gt; r) { return i; } } } } } Main 方法：\nvar insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var n = 10000; // 高斯分布（正态分布） var arrayInsertion = SortCompare.GetNormalDistributionArray(n); var arraySelection = new double[n]; var arrayShell = new double[n]; arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Normal Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 泊松分布 arrayInsertion = SortCompare.GetPossionDistributionArray(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Poission Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 几何分布 arrayInsertion = SortCompare.GetGeometricDistributionArray(n, 0.3); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Geometric Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 离散分布 arrayInsertion = SortCompare.GetDiscreteDistributionArray(n, new[] { 0.1, 0.2, 0.3, 0.1, 0.1, 0.1, 0.1 }); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;Discret Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection: \u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell: \u0026#34; + SortCompare.Time(shellSort, arrayShell)); 另请参阅 # Sort 库\n"},{"id":215,"href":"/2-1-36/","title":"2.1.36","section":"《算法（第四版）》C# 题解","content":" 2.1.36 # 解答 # 最后结果：\n代码 # // 选择排序的耗时与输入值的内容无关，不受影响。 // 对于插入排序，以上几种情况都是重复值较多的情况，插入排序的速度会加快。 // 希尔排序本质上也是插入排序，因此也会更快一些。 var n = 10000; var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var arraySelection = new int[n]; var arrayShell = new int[n]; // 对照，完全随机 var arrayInsertion = HalfZeroHalfOne(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;totally random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.TimeRandomInput(shellSort, n, 1)); Console.WriteLine(); // 一半是 0 一半是 1 arrayInsertion = HalfZeroHalfOne(n); arrayInsertion.CopyTo(arraySelection, 0); arrayInsertion.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half 0 and half 1\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); Console.WriteLine(); // 一半是 0， 1/4 是 1， 1/8 是 2…… arrayInsertion = HalfAndHalf(n); arrayInsertion.CopyTo(arraySelection, 0); arrayShell.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half and half and half ...\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); Console.WriteLine(); // 一半是 0，一半是随机 int 值 arrayInsertion = HalfZeroHalfRandom(n); arrayInsertion.CopyTo(arraySelection, 0); arrayShell.CopyTo(arrayShell, 0); Console.WriteLine(\u0026#34;half 0 half random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, arraySelection)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, arrayShell)); // 获取一半是 0 一半是 1 的随机 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfZeroHalfOne(int n) { var result = new int[n]; var random = new Random(); for (var i = 0; i \u0026lt; n; i++) { if (random.NextDouble() \u0026gt;= 0.5) { result[i] = 0; } else { result[i] = 1; } } return result; } // 生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfAndHalf(int n) { var array = new int[n]; HalfIt(0, 0, n / 2, array); Shuffle(array); return array; } // 递归生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfIt(int start, int number, int length, int[] array) { if (length == 0) return array; for (var i = 0; i \u0026lt; length; i++) { array[start + i] = number; } return HalfIt(start + length, number + 1, length / 2, array); } // 生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfZeroHalfRandom(int n) { var array = new int[n]; var random = new Random(); for (var i = 0; i \u0026lt; n / 2; i++) { array[i] = 0; } for (var i = n / 2; i \u0026lt; n; i++) { array[i] = random.Next(); } Shuffle(array); return array; } // 打乱数组。 static void Shuffle(int[] a) { var n = a.Length; var random = new Random(); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); // 等于StdRandom.uniform(N-i) var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # Sort 库\n"},{"id":216,"href":"/2-1-37/","title":"2.1.37","section":"《算法（第四版）》C# 题解","content":" 2.1.37 # 解答 # 主要说一下第二个的实现，把一个数组按 10 位进行打乱即可。\n代码 # // 选择排序的性能只与数组大小有关，以上三种情况耗时都是近似的。 // 插入排序的性能与逆序对数量有关，部分有序的情况下耗时会小于完全随机。 // 希尔排序与插入排序类似。 var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var n = 100000; var insertionArray = new int[n]; var shellArray = new int[n]; // 完全随机的对照 Console.WriteLine(\u0026#34;totally random\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.TimeRandomInput(selectionSort, n, 1)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.TimeRandomInput(insertionSort, n, 1)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.TimeRandomInput(shellSort, n, 1)); // 95% 有序，其余部分为随机值。 var selectionArray = Sorted95Random5(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;95% sorted + 5% random\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); // 所有元素和它们的正确位置的距离都不超过 10。 selectionArray = RandomIn10(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;all elements placed randomly in range of 10\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); // 5% 的元素随机分布在整个数组中，剩下的数据都是有序的。 selectionArray = Shuffle5Percent(n); selectionArray.CopyTo(insertionArray, 0); selectionArray.CopyTo(shellArray, 0); Console.WriteLine(\u0026#34;95% elements is sorted while 5% elements are placed randomly\u0026#34;); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + SortCompare.Time(selectionSort, selectionArray)); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, insertionArray)); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + SortCompare.Time(shellSort, shellArray)); // 生成 95% 有序，最后 5% 随机的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] Sorted95Random5(int n) { var array = new int[n]; var randomStart = (int)(n * 0.05); var random = new Random(); for (var i = 0; i \u0026lt; n - randomStart; i++) { array[i] = i; } for (var i = n - randomStart; i \u0026lt; n; i++) { array[i] = random.Next(); } return array; } // 返回一个 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组，其中的每个元素和它的正确位置的距离都不超过 10。 static int[] RandomIn10(int n) { var array = new int[n]; for (var i = 0; i \u0026lt; n; i++) { array[i] = i; } for (var i = 0; i \u0026lt; n; i += 10) { var max = Math.Min(n, i + 10); ShuffleRange(array, i, max); } return array; } // 生成 5% 元素随机分布，剩余有序的 int 数组。 static int[] Shuffle5Percent(int n) { var random = new Random(); var percent5 = (int)(n * 0.05); var randomIndex = new int[percent5]; for (var i = 0; i \u0026lt; percent5; i++) { randomIndex[i] = random.Next(percent5); } var randomValue = new int[percent5]; for (var i = 0; i \u0026lt; percent5; i++) { randomValue[i] = randomIndex[i]; } Shuffle(randomValue); var array = new int[n]; for (var i = 0; i \u0026lt; n; i++) { array[i] = i; } for (var i = 0; i \u0026lt; percent5; i++) { array[randomIndex[i]] = randomValue[i]; } return array; } static void ShuffleRange(int[] a, int lo, int hi) { var random = new Random(); for (var i = lo; i \u0026lt; hi; i++) { var r = i + random.Next(hi - i); // 等于StdRandom.uniform(N-i) var temp = a[i]; a[i] = a[r]; a[r] = temp; } } // 打乱数组。 static void Shuffle(int[] a) { ShuffleRange(a, 0, a.Length); } 另请参阅 # Sort 库\n"},{"id":217,"href":"/2-1-38/","title":"2.1.38","section":"《算法（第四版）》C# 题解","content":" 2.1.38 # 解答 # 这里实现了一个 Pair 类，用来排序。\n每一个元素都有相应的 key 值和 value 值，排序时只使用 key 值进行排序。\n代码 # var n = 10000; var results = TestA(n); Console.WriteLine(\u0026#34;string + double\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); results = TestB(n); Console.WriteLine(\u0026#34;double + 10 string\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); results = TestC(n); Console.WriteLine(\u0026#34;int + int[]\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + results[0]); Console.WriteLine(\u0026#34;Selection Sort:\u0026#34; + results[1]); Console.WriteLine(\u0026#34;Shell Sort:\u0026#34; + results[2]); // 第一个测试，测试结果按照 Insertion, Selection, Shell 排序。 static double[] TestA(int n) { var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var random = new Random(); // 每个元素的主键均为 String 类型（至少长 10 个字符），并含有一个 double 值。 var array = new Pair\u0026lt;string, double\u0026gt;[n]; var arrayBak = new Pair\u0026lt;string, double\u0026gt;[n]; for (var i = 0; i \u0026lt; n; i++) { array[i] = new Pair\u0026lt;string, double\u0026gt;(RandomString(20, random), random.NextDouble()); } array.CopyTo(arrayBak, 0); var results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } // 第二个测试，测试结果按照 Insertion, Selection, Shell 排序。 static double[] TestB(int n) { var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var random = new Random(); // 每个元素的主键均为 double 类型，并含有 10 个 String 值（每个都至少长 10 个字符）。 var array = new Pair\u0026lt;double, string[]\u0026gt;[n]; var arrayBak = new Pair\u0026lt;double, string[]\u0026gt;[n]; for (var i = 0; i \u0026lt; n; i++) { var temp = new string[10]; for (var j = 0; j \u0026lt; 10; j++) { temp[j] = RandomString(12, random); } array[i] = new Pair\u0026lt;double, string[]\u0026gt;(random.NextDouble(), temp); } array.CopyTo(arrayBak, 0); var results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } // 第三个测试，测试结果按照 Insertion, Selection, Shell 排序。 static double[] TestC(int n) { var insertionSort = new InsertionSort(); var selectionSort = new SelectionSort(); var shellSort = new ShellSort(); var random = new Random(); // 每个元素的主键均为 int 类型，并含有一个 int[20] 值。 var array = new Pair\u0026lt;int, int[]\u0026gt;[n]; var arrayBak = new Pair\u0026lt;int, int[]\u0026gt;[n]; for (var i = 0; i \u0026lt; n; i++) { var temp = new int[20]; for (var j = 0; j \u0026lt; 20; j++) { temp[j] = random.Next(); } array[i] = new Pair\u0026lt;int, int[]\u0026gt;(random.Next(), temp); } array.CopyTo(arrayBak, 0); var results = new double[3]; results[0] = SortCompare.Time(insertionSort, array); arrayBak.CopyTo(array, 0); results[1] = SortCompare.Time(selectionSort, array); arrayBak.CopyTo(array, 0); results[2] = SortCompare.Time(shellSort, array); return results; } // 获取一个随机 string static string RandomString(int n, Random random) { var value = new char[n]; for (var i = 0; i \u0026lt; n; i++) { value[i] = (char)random.Next(char.MinValue + 10, char.MaxValue - 10); } return new string(value); } 另请参阅 # Sort 库\n"},{"id":218,"href":"/2-2-1/","title":"2.2.1","section":"《算法（第四版）》C# 题解","content":" 2.2.1 # 解答 # "},{"id":219,"href":"/2-2-2/","title":"2.2.2","section":"《算法（第四版）》C# 题解","content":" 2.2.2 # 解答 # "},{"id":220,"href":"/2-2-3/","title":"2.2.3","section":"《算法（第四版）》C# 题解","content":" 2.2.3 # 解答 # "},{"id":221,"href":"/2-2-4/","title":"2.2.4","section":"《算法（第四版）》C# 题解","content":" 2.2.4 # 解答 # 是的，必须要两个子数组都有序时归并才能得到正确结果。\n如果说数组不有序的话，那么最后只能得到两个数组的混合。\n合并后的数组中，属于原有数组的元素的相对顺序不会被改变。\n例如子数组 1 3 1 和 2 8 5 原地归并。\n结果是 1 2 3 1 8 5，其中 1 3 1 和 2 8 5 的相对顺序不变。\n"},{"id":222,"href":"/2-2-5/","title":"2.2.5","section":"《算法（第四版）》C# 题解","content":" 2.2.5 # 解答 # 每次归并子数组的大小和顺序如下：\n自顶向下\n2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39\n自底向上\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39\n"},{"id":223,"href":"/2-2-6/","title":"2.2.6","section":"《算法（第四版）》C# 题解","content":" 2.2.6 # 解答 # 灰色是上限，蓝点是自顶向下，红点是自底向上。\n由于两种排序访问数组的次数是一样的，因此蓝点和红点重合。\n代码 # 给出绘图部分的代码：\nusing System; using System.Windows.Forms; using System.Drawing; using Merge; namespace _2._2._6 { static class Program { /// \u0026lt;summary\u0026gt; /// 应用程序的主入口点。 /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { MergeSort mergeSort = new MergeSort(); MergeSortBU mergeSortBU = new MergeSortBU(); int[] mergeResult = new int[10]; int[] mergeResultBU = new int[10]; int[] upperBound = new int[10]; // 进行计算 int dataSize = 1; for (int i = 0; i \u0026lt; 10; i++) { int[] dataMerge = SortCompare.GetRandomArrayInt(dataSize); int[] dataMergeBU = new int[dataSize]; dataMerge.CopyTo(dataMergeBU, 0); mergeSort.ClearArrayVisitCount(); mergeSortBU.ClearArrayVisitCount(); mergeSort.Sort(dataMerge); mergeSortBU.Sort(dataMergeBU); mergeResult[i] = mergeSort.GetArrayVisitCount(); mergeResultBU[i] = mergeSortBU.GetArrayVisitCount(); upperBound[i] = (int)(6 * dataSize * Math.Log(dataSize, 2)); dataSize *= 2; } // 绘图 Form2 plot = new Form2(); plot.Show(); Graphics graphics = plot.CreateGraphics(); // 获得绘图区矩形。 RectangleF rect = plot.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。 RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。 graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(\u0026#34;28000\u0026#34;, plot.Font, Brushes.Black, rect.Location); graphics.DrawString(\u0026#34;1024\u0026#34;, plot.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, plot.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。 PointF[] grayPoints = new PointF[10]; // 上限 PointF[] redPoints = new PointF[10]; // 自顶向下 PointF[] bluePoints = new PointF[10]; // 自底向上 unitX = center.Width / 11.0f; unitY = center.Height / 28000.0f; for (int i = 0; i \u0026lt; 10; i++) { grayPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (upperBound[i] * unitY) - 10); redPoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (mergeResult[i] * unitY) - 10); bluePoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (mergeResultBU[i] * unitY) - 10); } // 绘制点。 for (int i = 0; i \u0026lt; 10; i++) { graphics.FillEllipse(Brushes.Gray, new RectangleF(grayPoints[i], new SizeF(10, 10))); graphics.FillEllipse(Brushes.Red, new RectangleF(redPoints[i], new SizeF(10, 10))); graphics.FillEllipse(Brushes.Blue, new RectangleF(bluePoints[i], new Size(10, 10))); } graphics.Dispose(); } } } 另请参阅 # Merge 库\n"},{"id":224,"href":"/2-2-7/","title":"2.2.7","section":"《算法（第四版）》C# 题解","content":" 2.2.7 # 解答 # 根据书本给出的命题 G 和命题 H（中文版 P173/176，英文版 P275/279），\n比较次数的下限 $C(N) = 1/2 \\times NlgN$\n$N$ 和 $lgN$ 都是单调递增且大于零的($N\u0026gt;1$)，\n因此 $C(N)$ 也是单调递增的。\n"},{"id":225,"href":"/2-2-8/","title":"2.2.8","section":"《算法（第四版）》C# 题解","content":" 2.2.8 # 解答 # 修改后的算法对已经有序的情况做了优化\n数组对半切分并排序后，\n如果 a[mid] \u0026lt; a[mid + 1](左半部分的最后一个元素小于右半部分的第一个元素)\n那么我们可以直接合并数组，不需要再做多余的操作\n现在的输入是一个已经排序的数组\n算法唯一的比较发生在判断 a[mid] \u0026lt; a[mid + 1] 这个条件时\n假定数组有 $N$ 个元素\n比较次数满足 $T(N) = 2 T(N / 2) + 1, T(1) = 0$\n转化为非递归形式即为：$T(N) = cN / 2 + N - 1$\n其中 $c$ 为任意正整数。\n"},{"id":226,"href":"/2-2-9/","title":"2.2.9","section":"《算法（第四版）》C# 题解","content":" 2.2.9 # 解答 # 官方给出的归并排序实现中在 Sort 方法里初始化了 aux 数组。\n源码见：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\nC#实现和官方的实现非常类似，\n首先定义只接受一个参数的公开 Sort 方法，在这个方法里面初始化 aux 数组。\n/// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { T[] aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } 然后建立一个私有的递归 Sort 方法做实际的排序操作。\n/// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } 代码 # public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; var mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } } 另请参阅 # Merge 库\n"},{"id":227,"href":"/2-2-10/","title":"2.2.10","section":"《算法（第四版）》C# 题解","content":" 2.2.10 # 解答 # 官方同样给出了 java 实现，如下：\nprivate static void merge(Comparable[] a, int lo, int mid, int hi) { for (int i = lo; i \u0026lt;= mid; i++) aux[i] = a[i]; for (int j = mid+1; j \u0026lt;= hi; j++) aux[j] = a[hi-j+mid+1]; int i = lo, j = hi; for (int k = lo; k \u0026lt;= hi; k++) if (less(aux[j], aux[i])) a[k] = aux[j--]; else a[k] = aux[i++]; } C# 实现见代码部分。\n代码 # public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; var mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { // 前半部分升序复制 for (var k = lo; k \u0026lt;= mid; k++) { aux[k] = a[k]; } // 后半部分降序复制 for (var k = mid + 1; k \u0026lt;= hi; k++) { aux[k] = a[hi - k + mid + 1]; } // i 指向最左端，j 指向最右端 int i = lo, j = hi; for (var k = lo; k \u0026lt;= hi; k++) { if (Less(aux[j], aux[i])) { a[k] = aux[j]; j--; } else { a[k] = aux[i]; i++; } } } } 另请参阅 # Merge 库\n"},{"id":228,"href":"/2-2-11/","title":"2.2.11","section":"《算法（第四版）》C# 题解","content":" 2.2.11 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/22mergesort/MergeX.java.html\n在 MergeSortX 类里添加一个 CUTOFF 字段，排序时如果数组长度小于它则直接调用插入排序进行排序。\n在调用归并方法前判断第一个有序数组的最后一个元素是否大于第二个有序数组的第一个元素，\n如果大于的话就不需要调用归并了，直接首尾相接即可。\n归并的空间优化类似于左手倒右手，从一个数组读数据写到另一个数组中去，下一次归并的时候就可以反过来操作，从而节省数组空间。\n每次归并都需要两个数组，一个用于存放归并结果，这个数组中的内容是无关紧要的（Merge() 方法中的 dst 数组）\n另一个则保存了归并前的数组，用于实际的归并过程（src 数组）。\n归并结束后，前一个数组变成归并后的有序结果（也就是下一次归并时的「归并前数组」），后一个数组中的内容则不再有用。\n我们可以看到这两个数组的角色在下一次归并时正好可以互换。\n要注意的是，交换次数总是一个奇数（左侧排序+右侧排序+总归并），因此在第一次调用 Sort 方法时应该把 aux 和 a 互换传入。\n代码 # public class MergeSortX : BaseSort { /// \u0026lt;summary\u0026gt; /// 对小于 CUTOFF 的数组使用插入排序。 /// \u0026lt;/summary\u0026gt; private static int _cutoff = 7; /// \u0026lt;summary\u0026gt; /// 设置启用插入排序的阈值，小于该阈值的数组将采用插入排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;cutoff\u0026#34;\u0026gt;新的阈值。\u0026lt;/param\u0026gt; public void SetCutOff(int cutoff) =\u0026gt; _cutoff = cutoff; /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;src\u0026#34;\u0026gt;原始数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dst\u0026#34;\u0026gt;目标数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] src, T[] dst, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) dst[k] = src[j++]; else if (j \u0026gt; hi) dst[k] = src[i++]; else if (Less(src[j], src[i])) dst[k] = src[j++]; else dst[k] = src[i++]; } } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;src\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;dst\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] src, T[] dst, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { // 小于 CUTOFF 的数组调用插入排序 if (hi \u0026lt;= lo + _cutoff) { var insertion = new InsertionSort(); insertion.Sort(dst, lo, hi); return; } var mid = lo + (hi - lo) / 2; // 交换辅助数组和原数组 Sort(dst, src, lo, mid); Sort(dst, src, mid + 1, hi); // 已排序的数组直接合并 if (!Less(src[mid + 1], src[mid])) { Array.Copy(src, lo, dst, lo, hi - lo + 1); return; } Merge(src, dst, lo, mid, hi); } /// \u0026lt;summary\u0026gt; /// 利用优化后的归并排序对数组 a 排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组中的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; a.CopyTo(aux, 0); // aux 和 a 需要交换 Sort(aux, a, 0, a.Length - 1); } } 另请参阅 # Merge 库\nGithub 上的讨论\n"},{"id":229,"href":"/2-2-12/","title":"2.2.12","section":"《算法（第四版）》C# 题解","content":" 2.2.12 # 解答 # 中文版的翻译比较难理解。\n实际上就是另一种归并排序的实现方式。\n先把数组分成若干个大小为 M 的块 。\n对于每个块，用选择排序进行排序 。\n随后遍历数组，将各个块归并起来。\n归并时仅复制右侧数组就够了，然后倒着归并（从右到左），可以将额外空间降到 M。\n具体归并流程如下：\n复制右侧数组到 aux，现在右侧数组a[hi]~a[mid+1]中的元素可以被安全覆盖。 设定指针i,j,k，将数组 a[mid]~a[0] 和 aux[hi-mid-1]~aux[mid + 1] 归并到 a[hi - 1]~a[0]。 在这个流程中左侧数组的指针i是不会大于归并的写入指针k的。\n最坏情况下，aux用尽时 i == k，左侧数组可以直接并上去。\n代码 # public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 1); } /// \u0026lt;summary\u0026gt; /// 利用分块法进行归并排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;待排序的数组内容。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;m\u0026#34;\u0026gt;分块大小。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(T[] a, int m) where T : IComparable\u0026lt;T\u0026gt; { var blockNum = (a.Length + m - 1) / m; var selection = new SelectionSort(); // 对块进行选择排序。 for (var i = 0; i \u0026lt; blockNum; i++) { var lo = i * m; var hi = Math.Min((i + 1) * m - 1, a.Length - 1); selection.Sort(a, lo, hi); } // 将各个块合并。 for (var i = 0; i \u0026lt; blockNum - 1; i++) { Merge(a, 0, (i + 1) * m - 1, Math.Min((i + 2) * m - 1, a.Length - 1)); } } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { var aux = new T[hi - lo + 1]; for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } } 另请参阅 # Merge 库\n"},{"id":230,"href":"/2-2-13/","title":"2.2.13","section":"《算法（第四版）》C# 题解","content":" 2.2.13 # 解答 # 假设对三个数进行排序，\n这三个数是：35，10，17\n三个数排序的决策树如下，\n结点代表比较对应位置上的数。\n对于 35,10,17 来说，路径遵循右、左、左，最后得到的结果就是 2 3 1（10,17,35）。\n我们可以发现决策树上的每一个叶子节点都代表一种排列顺序，对于 N 个数，叶子节点就有 $N!$ 个\n根据二叉树的性质，高度为 $h$ 的二叉树最多有 $2^h$ 个叶子节点\n那么，对于 $N$ 个数，决策树的高度 $h$ 的最小值可以通过下面这个式子得出来\n$2^h \u0026gt;= n!$\n$h \\ge log(n!)$\n因此可以得到决策树高度 $h$ 的最小值是 $log(n!)$\n接下来我们来计算平均路径长度\n我们令函数 $H(k)$ 代表有 $k$ 个叶子节点的平衡决策树的所有路径长度之和\n上例中 $H(6) = 2 + 2 + 3 + 3 + 3 + 3 = 16$\n由于平衡决策树的性质，$H(k) = 2H(k / 2) + k$ （加上 $k$ 的原因：左右子树的高度比整个树的高度小 $1$，因此每条路径的长度都必须加 $1$，总共多加了 $k$ 次）\n因此 $H(k) = klogk$\n现在令 $k = n!$\n$H(n!) = n!log(n!)$\n由于每次排序时我们只经过某一条路径（上例中我们只经过了右、左、左这条路径）\n而且每种路径的出现概率相等\n因此平均比较次数应该为 $H(n!) / n! = log(n!) = nlog(n)$\n证明完毕\n另请参阅 # 排序算法的下界-Data Selection. Lower bound for sorting-PDF\n"},{"id":231,"href":"/2-2-14/","title":"2.2.14","section":"《算法（第四版）》C# 题解","content":" 2.2.14 # 解答 # 比较两个有序队列的第一个元素，取较小的一个出队并放入额外建立的队列中。\n重复上述步骤直到两个队列都为空。\n代码 # // 归并两个有序队列。输入队列将被清空。 static Queue\u0026lt;T\u0026gt; Merge\u0026lt;T\u0026gt;(Queue\u0026lt;T\u0026gt; a, Queue\u0026lt;T\u0026gt; b) where T : IComparable\u0026lt;T\u0026gt; { var sortedQueue = new Queue\u0026lt;T\u0026gt;(); while (!a.IsEmpty() \u0026amp;\u0026amp; !b.IsEmpty()) { if (a.Peek().CompareTo(b.Peek()) \u0026lt; 0) sortedQueue.Enqueue(a.Dequeue()); else sortedQueue.Enqueue(b.Dequeue()); } while (!a.IsEmpty()) sortedQueue.Enqueue(a.Dequeue()); while (!b.IsEmpty()) sortedQueue.Enqueue(b.Dequeue()); return sortedQueue; } "},{"id":232,"href":"/2-2-15/","title":"2.2.15","section":"《算法（第四版）》C# 题解","content":" 2.2.15 # 解答 # 程序思路题目已经给出，按照题意实现即可。\nMerge 方法可以直接使用前一题的实现。\n代码 # internal class MergeSortQueue { /// \u0026lt;summary\u0026gt; /// 利用队列归并进行自底向上的归并排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;array\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(T[] array) where T : IComparable\u0026lt;T\u0026gt; { var queueList = new Queue\u0026lt;Queue\u0026lt;T\u0026gt;\u0026gt;(); for (var i = 0; i \u0026lt; array.Length; i++) { var temp = new Queue\u0026lt;T\u0026gt;(); temp.Enqueue(array[i]); queueList.Enqueue(temp); } while (queueList.Size() != 1) { var times = queueList.Size() / 2; for (var i = 0; i \u0026lt; times; i++) { var a = queueList.Dequeue(); var b = queueList.Dequeue(); queueList.Enqueue(Merge(a, b)); } } var result = queueList.Dequeue(); for (var i = 0; i \u0026lt; array.Length; i++) { array[i] = result.Dequeue(); } } /// \u0026lt;summary\u0026gt; /// 归并两个有序队列。输入队列将被清空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;有序队列的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要归并的队列。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;归并后的新队列。\u0026lt;/returns\u0026gt; public static Queue\u0026lt;T\u0026gt; Merge\u0026lt;T\u0026gt;(Queue\u0026lt;T\u0026gt; a, Queue\u0026lt;T\u0026gt; b) where T : IComparable\u0026lt;T\u0026gt; { var sortedQueue = new Queue\u0026lt;T\u0026gt;(); while (!a.IsEmpty() \u0026amp;\u0026amp; !b.IsEmpty()) { if (a.Peek().CompareTo(b.Peek()) \u0026lt; 0) sortedQueue.Enqueue(a.Dequeue()); else sortedQueue.Enqueue(b.Dequeue()); } while (!a.IsEmpty()) sortedQueue.Enqueue(a.Dequeue()); while (!b.IsEmpty()) sortedQueue.Enqueue(b.Dequeue()); return sortedQueue; } } "},{"id":233,"href":"/2-2-16/","title":"2.2.16","section":"《算法（第四版）》C# 题解","content":" 2.2.16 # 解答 # 自然归并排序的一个示例如下图所示：\n基本过程和自底向上的归并排序类似，只是每次归并的块大小不一定相同。\n时间分析\n随着有序块的变大，排序速度会加快，但增长的数量级也会变高（平均分块大小变大了）。\n代码 # public class MergeSortNatural : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用自然的归并排序进行自底向上的排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; while (true) { // 找到第一个块 var lo = 0; var mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid \u0026lt; a.Length - 1) { var hi = FindBlock(mid + 1, a) + mid; Merge(lo, mid, hi, a, aux); lo = hi + 1; mid = FindBlock(lo, a) + lo - 1; } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 将两个块归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块的开始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块的结束下标（第二个块的开始下标 - 1）。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(int lo, int mid, int hi, T[] a, T[] aux) where T : IComparable\u0026lt;T\u0026gt; { for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } /// \u0026lt;summary\u0026gt; /// 获取下一个有序块。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;块的大小。\u0026lt;/returns\u0026gt; private int FindBlock\u0026lt;T\u0026gt;(int lo, T[] a) where T : IComparable\u0026lt;T\u0026gt; { var size = 1; for (var i = lo; i \u0026lt; a.Length - 1; i++) { if (Less(a[i], a[i + 1]) || a[i].Equals(a[i + 1])) size++; else break; } return size; } } 另请参阅 # Merge 库\n"},{"id":234,"href":"/2-2-17/","title":"2.2.17","section":"《算法（第四版）》C# 题解","content":" 2.2.17 # 解答 # 排序方式和 2.2.16 十分类似，不再赘述，这里介绍一下归并方法。\n如 gif 图所示，先把要归并的两个链表拆出来，随后确定表头位置，然后进行归并即可。 归并结束后返回 first。\n结果分析如下图所示：\n随着有序部分的增加，对于相同大小的数组自然归并排序的耗时会缩短。\n对于有序部分相同的情况，随着数组大小的倍增，耗时呈现了O(nlogn)的趋势。\n代码 # public class MergeSortNatural : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用自然的归并排序进行自底向上的排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; while (true) { // 找到第一个块 var lo = 0; var mid = FindBlock(lo, a) - 1; if (mid == a.Length - 1) break; while (mid \u0026lt; a.Length - 1) { var hi = FindBlock(mid + 1, a) + mid; Merge(lo, mid, hi, a, aux); lo = hi + 1; mid = FindBlock(lo, a) + lo - 1; } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 将两个块归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块的开始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块的结束下标（第二个块的开始下标 - 1）。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要归并的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(int lo, int mid, int hi, T[] a, T[] aux) where T : IComparable\u0026lt;T\u0026gt; { for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; j++; } else { a[k] = aux[i]; i++; } } } /// \u0026lt;summary\u0026gt; /// 获取下一个有序块。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;查找起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于查找的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;块的大小。\u0026lt;/returns\u0026gt; private int FindBlock\u0026lt;T\u0026gt;(int lo, T[] a) where T : IComparable\u0026lt;T\u0026gt; { var size = 1; for (var i = lo; i \u0026lt; a.Length - 1; i++) { if (Less(a[i], a[i + 1]) || a[i].Equals(a[i + 1])) size++; else break; } return size; } } 另请参阅 # Merge 库\n"},{"id":235,"href":"/2-2-18/","title":"2.2.18","section":"《算法（第四版）》C# 题解","content":" 2.2.18 # 解答 # 可以在用归并排序的方法做。\n将归并时取两边较小的元素改为随机取一侧的值，即可实现打乱的效果。\n算法的分析和普通归并排序一致，满足题目要求。\n代码 # 分治法打乱链表的实现。\n/// \u0026lt;summary\u0026gt; /// 分治法打乱链表。 /// \u0026lt;/summary\u0026gt; public class MergeShuffle { /// \u0026lt;summary\u0026gt; /// 利用分治法打乱链表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;等待打乱的链表。\u0026lt;/param\u0026gt; public void Shuffle\u0026lt;T\u0026gt;(LinkedList\u0026lt;T\u0026gt; a) { var blockLen = 1; var random = new Random(); while (blockLen \u0026lt;= a.Size()) { // 找到第一个块 var lo = a.GetFirst(); var mid = FindBlock(lo, blockLen); if (mid.Next == null) break; while (mid.Next != null) { var hi = FindBlock(mid.Next, blockLen); Node\u0026lt;T\u0026gt;[] result; if (lo == a.GetFirst()) { result = Merge(lo, mid, hi, random); a.SetFirst(result[0]); } else { result = Merge(lo.Next, mid, hi, random); lo.Next = result[0]; } // 跳到表尾 lo = result[1]; if (lo.Next != null) mid = FindBlock(lo.Next, blockLen); else mid = lo; } blockLen *= 2; } } /// \u0026lt;summary\u0026gt; /// 将两个有序链表块随机归并，返回新的表头。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;第一个块起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;第一个块终点（第二个块起点的前驱）。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;第二个块的终点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;random\u0026#34;\u0026gt;随机数生成器。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;新的表头。\u0026lt;/returns\u0026gt; private Node\u0026lt;T\u0026gt;[] Merge\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo, Node\u0026lt;T\u0026gt; mid, Node\u0026lt;T\u0026gt; hi, Random random) { var after = hi.Next; // 要合并的两个块之后的元素 var result = new Node\u0026lt;T\u0026gt;[2]; var i = lo; // 链表1 var j = mid.Next; // 链表2 // 切割链表 mid.Next = null; hi.Next = null; Node\u0026lt;T\u0026gt; current; // 决定新的表头 if (random.NextDouble() \u0026gt;= 0.5) { current = i; i = i.Next; } else { current = j; j = j.Next; } var first = current; // 归并表 while (i != null \u0026amp;\u0026amp; j != null) { if (random.NextDouble() \u0026gt;= 0.5) { current.Next = i; i = i.Next; current = current.Next; } else { current.Next = j; j = j.Next; current = current.Next; } } if (i == null) current.Next = j; else current.Next = i; // 连接表尾（链表 1 的尾部或者链表 2 的尾部） if (mid.Next == null) { mid.Next = after; result[1] = mid; } else { hi.Next = after; result[1] = hi; } result[0] = first; return result; } /// \u0026lt;summary\u0026gt; /// 获取从指定位置开始定长的链表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;链表的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;链表的起始结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;length\u0026#34;\u0026gt;需要获取的链表长度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;结果链表的最后一个元素结点。\u0026lt;/returns\u0026gt; private Node\u0026lt;T\u0026gt; FindBlock\u0026lt;T\u0026gt;(Node\u0026lt;T\u0026gt; lo, int length) { var hi = lo; for (var i = 0; i \u0026lt; length - 1 \u0026amp;\u0026amp; hi.Next != null; i++) { hi = hi.Next; } return hi; } } 另请参阅 # Merge 库\n"},{"id":236,"href":"/2-2-19/","title":"2.2.19","section":"《算法（第四版）》C# 题解","content":" 2.2.19 # 解答 # 官方实现：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html\n事实上只要在归并排序的时候统计 Less(aux[j], aux[i]) 满足的次数即可，这个次数就是我们要的值。\n代码 # /// \u0026lt;summary\u0026gt; /// 归并排序类。 /// \u0026lt;/summary\u0026gt; public class MergeSort : BaseSort { public int Counter; /// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; var mid = lo + (hi - lo) / 2; Sort(a, aux, lo, mid); Sort(a, aux, mid + 1, hi); Merge(a, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = a[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { a[k] = aux[j]; j++; } else if (j \u0026gt; hi) { a[k] = aux[i]; i++; } else if (Less(aux[j], aux[i])) { a[k] = aux[j]; Counter += mid - i + 1; // 统计逆序对数 j++; } else { a[k] = aux[i]; i++; } } } } 另请参阅 # Merge 库\n"},{"id":237,"href":"/2-2-20/","title":"2.2.20","section":"《算法（第四版）》C# 题解","content":" 2.2.20 # 解答 # 官方实现：https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n把 Sort 方法中传入的 a 数组换成一个 index 数组，将 Merge 方法中的判断改为 Less(a[aux[j]], a[aux[i]]) 即可。\n代码 # public class MergeSort : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public int[] IndexSort\u0026lt;T\u0026gt;(T[] a) where T : IComparable\u0026lt;T\u0026gt; { var aux = new int[a.Length]; var index = new int[a.Length]; for (var i = 0; i \u0026lt; a.Length; i++) { index[i] = i; } Sort(a, index, aux, 0, a.Length - 1); return index; } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;排序索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int[] index, int[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; var mid = lo + (hi - lo) / 2; Sort(a, index, aux, lo, mid); Sort(a, index, aux, mid + 1, hi); Merge(a, index, aux, lo, mid, hi); } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;排序索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mid\u0026#34;\u0026gt;范围中点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, int[] index, int[] aux, int lo, int mid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var k = lo; k \u0026lt;= hi; k++) { aux[k] = index[k]; } int i = lo, j = mid + 1; for (var k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) { index[k] = aux[j]; j++; } else if (j \u0026gt; hi) { index[k] = aux[i]; i++; } else if (Less(a[aux[j]], a[aux[i]])) { index[k] = aux[j]; j++; } else { index[k] = aux[i]; i++; } } } public override void Sort\u0026lt;T\u0026gt;(T[] a) { throw new NotImplementedException(); } } 另请参阅 # Merge 库\n"},{"id":238,"href":"/2-2-21/","title":"2.2.21","section":"《算法（第四版）》C# 题解","content":" 2.2.21 # 解答 # 对三份列表进行归并排序（$O(nlogn)$），随后遍历一遍其中的一份表， 用二分查找检查在其余两个表中是否存在相同的姓名（$O(nlogn)$）。\n代码 # var name1 = new[] { \u0026#34;Noah\u0026#34;, \u0026#34;Liam\u0026#34;, \u0026#34;Jacob\u0026#34;, \u0026#34;Mason\u0026#34; }; var name2 = new[] { \u0026#34;Sophia\u0026#34;, \u0026#34;Emma\u0026#34;, \u0026#34;Mason\u0026#34;, \u0026#34;Ava\u0026#34; }; var name3 = new[] { \u0026#34;Mason\u0026#34;, \u0026#34;Marcus\u0026#34;, \u0026#34;Alexander\u0026#34;, \u0026#34;Ava\u0026#34; }; var mergeSort = new MergeSort(); mergeSort.Sort(name1); mergeSort.Sort(name2); mergeSort.Sort(name3); for (var i = 0; i \u0026lt; name1.Length; i++) { if (BinarySearch(name1[i], name2, 0, name1.Length) != -1 \u0026amp;\u0026amp; BinarySearch(name1[i], name3, 0, name1.Length) != -1) { Console.WriteLine(name1[i]); break; } } // 二分查找，返回目标元素的下标，没有结果则返回 -1。 static int BinarySearch\u0026lt;T\u0026gt;(T key, T[] array, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (array[mid].Equals(key)) return mid; if (array[mid].CompareTo(key) \u0026lt; 0) lo = mid + 1; else hi = mid - 1; } return -1; } 另请参阅 # Merge 库\n"},{"id":239,"href":"/2-2-22/","title":"2.2.22","section":"《算法（第四版）》C# 题解","content":" 2.2.22 # 解答 # 增长数量级为$O(nlogn)$。\n代码 # /// \u0026lt;summary\u0026gt; /// 三向归并排序。 /// \u0026lt;/summary\u0026gt; public class MergeSortThreeWay : BaseSort { /// \u0026lt;summary\u0026gt; /// 利用三项归并排序将数组按升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组中的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;待排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行三向归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 小于或等于一个元素 return; var lmid = lo + (hi - lo) / 3; var rmid = hi - (hi - lo) / 3; Sort(a, aux, lo, lmid); Sort(a, aux, lmid + 1, rmid); Sort(a, aux, rmid + 1, hi); Merge(a, aux, lo, lmid, rmid, hi); } /// \u0026lt;summary\u0026gt; /// 返回两个元素中较小的那个。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;比较的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;用于比较的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;用于比较的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;较小的元素。\u0026lt;/returns\u0026gt; private T Min\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { if (Less(a, b)) return a; return b; } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lmid\u0026#34;\u0026gt;范围三分之一点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;rmid\u0026#34;\u0026gt;范围三分之二点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int lmid, int rmid, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var l = lo; l \u0026lt;= hi; l++) { aux[l] = a[l]; } int i = lo, j = lmid + 1, k = rmid + 1; for (var l = lo; l \u0026lt;= hi; l++) { var flag = 0; if (i \u0026gt; lmid) flag += 1; if (j \u0026gt; rmid) flag += 10; if (k \u0026gt; hi) flag += 100; switch (flag) { case 0: // 三个数组都还没有取完 var min = Min(aux[i], Min(aux[j], aux[k])); if (min.Equals(aux[i])) a[l] = aux[i++]; else if (min.Equals(aux[j])) a[l] = aux[j++]; else a[l] = aux[k++]; break; case 1: // 只有第一个数组取完了 if (Less(aux[j], aux[k])) a[l] = aux[j++]; else a[l] = aux[k++]; break; case 10: // 只有第二个数组取完了 if (Less(aux[i], aux[k])) a[l] = aux[i++]; else a[l] = aux[k++]; break; case 100: // 只有第三个数组取完了 if (Less(aux[i], aux[j])) a[l] = aux[i++]; else a[l] = aux[j++]; break; case 11: // 第一、二个数组取完了 a[l] = aux[k++]; break; case 101: // 第一、三个数组取完了 a[l] = aux[j++]; break; case 110: // 第二、三个数组取完了 a[l] = aux[i++]; break; } } } } 另请参阅 # Merge 库\n"},{"id":240,"href":"/2-2-23/","title":"2.2.23","section":"《算法（第四版）》C# 题解","content":" 2.2.23 # 解答 # 阈值合适时，大约会有10%的性能提升。\n阈值在 10 以下都是比较合适的。\n代码 # var mergeSort = new MergeSort(); var mergeSortX = new MergeSortX(); var mergeSortUnstable = new MergeSortUnstable(); var n = 1000000; var cutoff = 2; var trialTime = 4; Console.WriteLine(\u0026#34;归并排序改进前与改进后的比较：\u0026#34;); Console.WriteLine(\u0026#34;数组\\t耗时1\\t耗时2\\t阈值\\t比率\u0026#34;); for (var i = 0; i \u0026lt; 20; i++) { double mergeSortTime = 0; double mergeSortXTime = 0; mergeSortX.SetCutOff(cutoff); for (var j = 0; j \u0026lt; trialTime; j++) { var a = SortCompare.GetRandomArrayInt(n); var b = new int[a.Length]; a.CopyTo(b, 0); mergeSortTime += SortCompare.Time(mergeSort, a); mergeSortXTime += SortCompare.Time(mergeSortX, b); } mergeSortTime /= trialTime; mergeSortXTime /= trialTime; Console.WriteLine( n + \u0026#34;\\t\u0026#34; + mergeSortTime + \u0026#34;\\t\u0026#34; + mergeSortXTime + \u0026#34;\\t\u0026#34; + cutoff + \u0026#34;\\t\u0026#34; + mergeSortTime / mergeSortXTime); cutoff++; } n = 100000; Console.WriteLine(\u0026#34;稳定归并排序与不稳定版本的比较：\u0026#34;); Console.WriteLine(\u0026#34;数组\\t耗时1\\t耗时2\\t比率\u0026#34;); for (var i = 0; i \u0026lt; 6; i++) { double mergeSortTime = 0; double mergeSortUnstableTime = 0; for (var j = 0; j \u0026lt; trialTime; j++) { var a = SortCompare.GetRandomArrayInt(n); var b = new int[a.Length]; a.CopyTo(b, 0); mergeSortTime += SortCompare.Time(mergeSort, a); mergeSortUnstableTime += SortCompare.Time(mergeSortUnstable, b); } mergeSortTime /= trialTime; mergeSortUnstableTime /= trialTime; Console.WriteLine( n + \u0026#34;\\t\u0026#34; + mergeSortTime + \u0026#34;\\t\u0026#34; + mergeSortUnstableTime + \u0026#34;\\t\u0026#34; + mergeSortTime / mergeSortUnstableTime); n *= 2; } 另请参阅 # Merge 库\n"},{"id":241,"href":"/2-2-24/","title":"2.2.24","section":"《算法（第四版）》C# 题解","content":" 2.2.24 # 解答 # 约为 $lgN$ 次\n代码 # var mergeSortX = new MergeSortX(); var n = 10000; var trialTimes = 10; Console.WriteLine(\u0026#34;数组\\t平均命中次数\u0026#34;); for (var i = 0; i \u0026lt; 4; i++) { var avgHit = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { mergeSortX.ResetHitTime(); var a = SortCompare.GetRandomArrayInt(n); mergeSortX.Sort(a); avgHit += mergeSortX.GetHitTime(); } Console.WriteLine(n + \u0026#34;\\t\u0026#34; + avgHit / trialTimes); n *= 10; } 另请参阅 # Merge 库\n"},{"id":242,"href":"/2-2-25/","title":"2.2.25","section":"《算法（第四版）》C# 题解","content":" 2.2.25 # 解答 # 事实上 k 的取值无关紧要，实验也证明了这一点。\n算法大致可以分为以下几个步骤 首先将数组划为 k 份，\n用一个数组 mids 记录这 k 个子数组的分割位置\n随后递归的调用 Sort 方法，将这 k 个子数组排序 随后将这 k 个子数组归并，\n每次归并时遍历取 k 个子数组中值最小的一个，\n然后对应子数组的指示器 + 1 上面这一步是 $O(k)$ 的，\n可以用堆或者败者树优化为对数级别\n代码 # /// \u0026lt;summary\u0026gt; /// k 路归并排序。 /// \u0026lt;/summary\u0026gt; public class MergeSortKWay : BaseSort { /// \u0026lt;summary\u0026gt; /// 同时归并的数组数目。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;同时归并的数组数目。\u0026lt;/value\u0026gt; public int K { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public MergeSortKWay() { K = 2; } /// \u0026lt;summary\u0026gt; /// 用 k 向归并排序对数组 a 进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;数组长度小于 K 值时抛出异常。\u0026lt;/exception\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { if (K \u0026gt; a.Length) throw new ArgumentOutOfRangeException(nameof(a), \u0026#34;数组长度不能小于 K 值！\u0026#34;); var aux = new T[a.Length]; Sort(a, aux, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 自顶向下地对数组指定范围内进行 k 向归并排序，需要辅助数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围终点。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 小于或等于一个元素 return; var mids = new int[K - 1]; var steps = (hi - lo) / K; mids[0] = lo + steps; for (var i = 1; i \u0026lt; K - 1; i++) { mids[i] = mids[i - 1] + steps; if (mids[i] \u0026gt; hi) // 防止溢出 mids[i] = hi; } Sort(a, aux, lo, mids[0]); for (var i = 1; i \u0026lt; K - 1; i++) { Sort(a, aux, mids[i - 1] + 1, mids[i]); } Sort(a, aux, mids[K - 2] + 1, hi); Merge(a, aux, lo, mids, hi); } /// \u0026lt;summary\u0026gt; /// 将指定范围内的元素归并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;原数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;aux\u0026#34;\u0026gt;辅助数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mids\u0026#34;\u0026gt;范围中间点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; private void Merge\u0026lt;T\u0026gt;(T[] a, T[] aux, int lo, int[] mids, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var l = lo; l \u0026lt;= hi; l++) { aux[l] = a[l]; } var pointers = new int[K]; // 标记每个数组的当前归并位置 pointers[0] = lo; // 开始时归并位置处于每个子数组的起始 for (var i = 1; i \u0026lt; K; i++) { pointers[i] = mids[i - 1] + 1; } // 开始归并 for (var i = lo; i \u0026lt;= hi; i++) { // 找到最小值 T min; var minPointerIndex = 0; var isInit = true; if (pointers[K - 1] \u0026gt; hi) { min = default; // 初始化以避免编译错误 } else { min = aux[pointers[K - 1]]; minPointerIndex = K - 1; isInit = false; } for (var j = 0; j \u0026lt; K - 1; j++) { if (pointers[j] \u0026gt; mids[j]) // 当前数组已经用完 continue; if (isInit) // 第一次赋值 { isInit = false; min = aux[pointers[j]]; minPointerIndex = j; continue; } if (Less(aux[pointers[j]], min)) { min = aux[pointers[j]]; minPointerIndex = j; } } // 将最小值赋给归并数组，对应子数组的归并位置+1 a[i] = min; pointers[minPointerIndex]++; } } } 另请参阅 # Merge 库\n"},{"id":243,"href":"/2-2-26/","title":"2.2.26","section":"《算法（第四版）》C# 题解","content":" 2.2.26 # 解答 # 差距还是比较明显的，由于 Merge 会调用多次，而用于启动递归的 Sort 方法只会调用一次。\n代码 # var auxInSort = new AuxInSortMergeSort(); var auxInMerge = new AuxInMergeMergeSort(); var data1 = SortCompare.GetRandomArrayInt(100000); var data2 = new int[data1.Length]; data1.CopyTo(data2, 0); Console.WriteLine(\u0026#34;在Sort中创建aux[]\\t\u0026#34; + SortCompare.Time(auxInSort, data1) + \u0026#34;ms\u0026#34;); Console.WriteLine(\u0026#34;在Merge中创建aux[]\\t\u0026#34; + SortCompare.Time(auxInMerge, data2) + \u0026#34;ms\u0026#34;); 另请参阅 # Merge 库\n"},{"id":244,"href":"/2-2-27/","title":"2.2.27","section":"《算法（第四版）》C# 题解","content":" 2.2.27 # 解答 # 大致上会是一个对数函数，用 Excel 做了简单的拟合。\n原始数据：\n表中的 n 代表某一个子数组用尽时两个子数组之和，rest 是另一个未用尽的子数组平均剩余长度，times 代表出现次数，表中删去了出现次数小于 100 次的数据。\nn rest times 2 0.331378 48576 3 0.333894 213568 6 0.603899 48576 7 0.596223 82496 14 0.773263 48576 15 0.796285 16960 29 0.879808 15808 30 0.883432 16960 60 0.950848 15808 61 0.935764 576 121 0.985163 7616 122 0.96875 576 243 0.93608 3520 244 1.147569 576 487 0.942255 1472 488 1.020833 576 975 1.078125 448 976 1.024306 576 1952 1.129464 448 代码 # var arraySize = 1000000; var sort = new NotifiedMergeSort(arraySize); for (var i = 0; i \u0026lt; 100; i++) { var data = SortCompare.GetRandomArrayInt(arraySize); sort.Sort(data); } Console.WriteLine(\u0026#34;n\\trest\\ttimes\u0026#34;); for (var i = 0; i \u0026lt; sort.NArraySize.Length; i++) { if (sort.NArraySize[i] != 0) Console.WriteLine(i + \u0026#34;\\t\u0026#34; + sort.NArraySize[i] / sort.NArraySizeTime[i] + \u0026#34;\\t\u0026#34; + sort.NArraySizeTime[i]); } // 大致上是一个对数函数 另请参阅 # Merge 库\n"},{"id":245,"href":"/2-2-28/","title":"2.2.28","section":"《算法（第四版）》C# 题解","content":" 2.2.28 # 解答 # 自底向上会快一些，省去了递归过程中函数重复调用的时间。\n代码 # var n = 1000; var topBottomMergeSort = new MergeSort(); var bottomUpMergeSort = new MergeSortBu(); var trialTimes = 100; for (var i = 0; i \u0026lt; 4; i++) { Console.Write(\u0026#34;数组大小：\u0026#34; + n + \u0026#34;\\t\u0026#34;); int time1 = 0, time2 = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { var data1 = SortCompare.GetRandomArrayDouble(n); var data2 = new double[n]; data1.CopyTo(data2, 0); time1 += (int)SortCompare.Time(topBottomMergeSort, data1); time2 += (int)SortCompare.Time(bottomUpMergeSort, data2); } Console.WriteLine(\u0026#34;自顶向下：\u0026#34; + time1 / trialTimes + \u0026#34;ms\\t自底向上：\u0026#34; + time2 / trialTimes + \u0026#34;ms\u0026#34;); n *= 10; } 另请参阅 # Merge 库\n"},{"id":246,"href":"/2-2-29/","title":"2.2.29","section":"《算法（第四版）》C# 题解","content":" 2.2.29 # 解答 # 完全有序时只需要一次归并（直接输出），\n逆序时需要 n - 1 次归并（退化为插入排序），\n平均需要 n/2 次归并。\n所以分别需要 500，500000，500000000 次归并。\n"},{"id":247,"href":"/2-3-1/","title":"2.3.1","section":"《算法（第四版）》C# 题解","content":" 2.3.1 # 解答 # "},{"id":248,"href":"/2-3-2/","title":"2.3.2","section":"《算法（第四版）》C# 题解","content":" 2.3.2 # 解答 # "},{"id":249,"href":"/2-3-3/","title":"2.3.3","section":"《算法（第四版）》C# 题解","content":" 2.3.3 # 解答 # N / 2\n在快速排序中，一个元素要被交换，有以下两种情况\n该元素是枢轴，在切分的最后一步被交换 该元素位于枢轴错误的一侧，需要被交换到另一侧去 注意，以上两种情况在一次切分中只会出现一次\n首先来看第一种情况，如果一个元素变成了枢轴\n那么在之后的切分中该元素会被排除，不存在后续的交换。\n因此我们的目标应该是：\n最大的元素总是出现在错误的一侧，同时切分的次数尽可能多。\n接下来我们来思考如何构造这样的数组\n由于我们针对的是最大的元素，因此「错误的一侧」就是枢轴的左侧。\n为了使切分的次数尽可能多，我们需要保持最大值移动的距离尽量短。\n但如果每次只移动一位的话，下一次切分时最大值就会变成枢轴\n例如 4 10 3 5 6，枢轴为 4，交换后数组变为：\n4 3 10 5 6\n随后 4 和 3 交换\n3 4 10 5 6\n下一次切分时 10 会变成枢轴，不再参与后续的切分。\n因此我们需要让最大值每次移动两个元素。\n考虑下面的数组：\n2 10 4 1 6 3 8 5 7 9\n第一次切分的时候，枢轴为 2，10 和 1 进行交换\n数组变为：\n2 1 4 10 6 3 8 5 7 9\n随后枢轴交换，数组变为：\n1 2 4 10 6 3 8 5 7 9\n第二次切分，枢轴为 4，10 和 3 进行交换。\n1 2 4 3 6 10 8 5 7 9\n随后枢轴交换 数组变为：\n1 2 3 4 6 10 8 5 7 9\n第三次切分，枢轴为 6，10 和 5 交换\n1 2 3 4 6 5 8 10 7 9\n随后枢轴交换，数组变为：\n1 2 3 4 5 6 8 10 7 9\n第四次切分，枢轴为 8，10 和 7 交换\n1 2 3 4 5 6 8 7 10 9\n枢轴交换，数组变为\n1 2 3 4 5 6 7 8 10 9\n最后一次切分，枢轴为 10，直接交换\n1 2 3 4 5 6 7 8 9 10\n我们可以总结出要构造这样的数组的模板\na2 max a3 a1\n其中 a1 \u0026lt; a2 \u0026lt; a3 \u0026lt; max\nmax 每轮切分移动两格，总共切分 N / 2 次。\n另请参阅 # Number of largest element exchanges for quicksort-Stack Overflow\n"},{"id":250,"href":"/2-3-4/","title":"2.3.4","section":"《算法（第四版）》C# 题解","content":" 2.3.4 # 解答 # 每次只让枢轴变为已排序，这就是最坏情况。\n这种时候枢轴是当前子数组的最大值 / 最小值。\n由于在我们的实现中总是取子数组的第一个元素作为枢轴。\n因此一个已排序的数组可以达到最坏情况，比较次数达到 O(n^ 2)。\n如果换作取最后一个元素，最坏情况会变成逆序数组。\n我们的实现中如果碰到与枢轴相等的元素也会停止循环，\n因此如果数组中有重复的元素会减少比较次数。\n例如：\n1 2 3 4 5 6 7 8 9 10 2 3 4 5 6 7 8 9 10 11 3 4 5 6 7 8 9 10 11 12 4 5 6 7 8 9 10 11 12 13 5 6 7 8 9 10 11 12 13 14 6 7 8 9 10 11 12 13 14 15 另请参阅 # Analysis of Quicksort-khanacademy Worst case for QuickSort - When can it occur?-Stack Overflow\n"},{"id":251,"href":"/2-3-5/","title":"2.3.5","section":"《算法（第四版）》C# 题解","content":" 2.3.5 # 解答 # 官方实现：https://algs4.cs.princeton.edu/23quicksort/Sort2distinct.java.html\n算法 gif 动图\n代码 # public class Sort2Distinct : BaseSort { /// \u0026lt;summary\u0026gt; /// 对数组 a 进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组 a 的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { int lt = 0, gt = a.Length - 1; var i = 0; while (i \u0026lt;= gt) { var cmp = a[i].CompareTo(a[lt]); if (cmp \u0026lt; 0) Exch(a, lt++, i++); else if (cmp \u0026gt; 0) Exch(a, i, gt--); else i++; } } } 另请参阅 # Quick 库\n"},{"id":252,"href":"/2-3-6/","title":"2.3.6","section":"《算法（第四版）》C# 题解","content":" 2.3.6 # 解答 # 运行结果如下：\n代码 # 新建一个 QuickSortAnalyze 类，在 QuickSort 的基础上添加一个 CompareCount 属性，用于记录比较次数。重写 Less 方法，每调用一次就让 CompareCount 增加 1 。\n/// \u0026lt;summary\u0026gt; /// 自动记录比较次数以及子数组数量的快速排序类。 /// \u0026lt;/summary\u0026gt; public class QuickSortAnalyze : BaseSort { /// \u0026lt;summary\u0026gt; /// 比较次数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;排序用的比较次数。\u0026lt;/value\u0026gt; public int CompareCount { get; set; } /// \u0026lt;summary\u0026gt; /// 是否启用打乱。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;list type=\u0026#34;bullet\u0026#34;\u0026gt; /// \u0026lt;item\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;: 启用排序前打乱。\u0026lt;/item\u0026gt; /// \u0026lt;item\u0026gt;\u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;: 禁用排序前打乱。\u0026lt;/item\u0026gt; /// \u0026lt;/list\u0026gt; /// \u0026lt;/value\u0026gt; public bool NeedShuffle { get; set; } /// \u0026lt;summary\u0026gt; /// 是否显示轨迹。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt; /// \u0026lt;list type=\u0026#34;bullet\u0026#34;\u0026gt; /// \u0026lt;item\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;: 输出排序轨迹。\u0026lt;/item\u0026gt; /// \u0026lt;item\u0026gt;\u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;: 不输出排序轨迹。\u0026lt;/item\u0026gt; /// \u0026lt;/list\u0026gt; /// \u0026lt;/value\u0026gt; public bool NeedPath { get; set; } /// \u0026lt;summary\u0026gt; /// 大小为 0 的子数组数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;大小为 0 的子数组数量。\u0026lt;/value\u0026gt; public int Array0Num { get; set; } /// \u0026lt;summary\u0026gt; /// 大小为 1 的子数组数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;大小为 1 的子数组数量。\u0026lt;/value\u0026gt; public int Array1Num { get; set; } /// \u0026lt;summary\u0026gt; /// 大小为 2 的子数组数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;大小为 2 的子数组数量。\u0026lt;/value\u0026gt; public int Array2Num { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortAnalyze() { CompareCount = 0; NeedShuffle = true; NeedPath = false; Array0Num = 0; Array1Num = 0; Array2Num = 0; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Array0Num = 0; Array1Num = 0; Array2Num = 0; CompareCount = 0; if (NeedShuffle) Shuffle(a); if (NeedPath) { for (var i = 0; i \u0026lt; a.Length; i++) { Console.Write(\u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\tlo\\tj\\thi\u0026#34;); } Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi - lo == 1) Array2Num++; else if (hi == lo) Array1Num++; else if (hi \u0026lt; lo) Array0Num++; if (hi \u0026lt;= lo) // 别越界 return; var j = Partition(a, lo, hi); if (NeedPath) { for (var i = 0; i \u0026lt; a.Length; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(\u0026#34;\\t\u0026#34; + lo + \u0026#34;\\t\u0026#34; + j + \u0026#34;\\t\u0026#34; + hi); } Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt; /// 比较第一个元素是否小于第二个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;要比较的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; protected new bool Less\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { CompareCount++; return a.CompareTo(b) \u0026lt; 0; } } 主方法\nConsole.WriteLine(\u0026#34;N\\t准确值\\t估计值\\t比值\u0026#34;); var sort = new QuickSortAnalyze(); var n = 100; var trialTime = 500; for (var i = 0; i \u0026lt; 3; i++) { var sumOfCompare = 0; var a = new int[n]; for (var j = 0; j \u0026lt; trialTime; j++) { for (var k = 0; k \u0026lt; n; k++) { a[k] = k; } SortCompare.Shuffle(a); sort.Sort(a); sumOfCompare += sort.CompareCount; } var averageCompare = sumOfCompare / trialTime; var estimatedCompare = 2 * n * Math.Log(n); Console.WriteLine( n + \u0026#34;\\t\u0026#34; + averageCompare + \u0026#34;\\t\u0026#34; + (int)estimatedCompare + \u0026#34;\\t\u0026#34; + averageCompare / estimatedCompare); n *= 10; } 另请参阅 # Quick 库\n"},{"id":253,"href":"/2-3-7/","title":"2.3.7","section":"《算法（第四版）》C# 题解","content":" 2.3.7 # 解答 # 我讨厌数学= =\n证明：\n我们设 $C_0(n)$ 代表将 $n$ 个不重复元素排序时大小为 0 的数组的数量。\n同理有 $C_1(n)$ 和 $C_2(n)$ 代表大小为 1 的数组的数量以及大小为 2 的数组的数量。\n设 k 代表切分位置，显然切分位置随机且概率相等，在 1~n 之间均匀分布。\n根据条件，$C_0(n), C_1(n),C_2(n)$ 都满足下式：\n$$ C(n)= \\frac{\\sum_{k=1}^{n}(C(k-1)+C(n-k))}{n} $$\n根据快速排序算法， $\\sum_{k=1}^{n}C(k-1)=\\sum_{k=1}^{n}C(n-k)$ ，因此\n$$ C(n)=\\frac{2\\sum_{k=1}^{n}C(k-1)}{n}\\newline nC(n)=2\\sum_{k-1}^{n}C(k-1) $$\n同理代入 $n-1$ 有\n$$ (n-1)C(n-1)=2\\sum_{k-1}^{n-1}C(k-1) $$\n相减\n$$ nC(n)-(n-1)C(n-1)=2C(n-1)\\newline C(n)=\\frac{n+1}{n}C(n-1) $$\n利用累乘法求到通项公式\n$$ \\frac{C(n)}{C(n-1)}=\\frac{n+1}{n} \\newline \\frac{C(n)}{C(n-1)}\\times\\frac{C(n-1)}{C(n-2)}\\times\\dots\\times\\frac{C(m+1)}{C(m)}= \\frac{n+1}{n}\\times\\frac{n}{n-1}\\times\\dots\\times\\frac{m+2}{m+1}\\newline \\frac{C(n)}{C(m)}=\\frac{n+1}{m+1}\\newline C(n)=C(m)\\frac{n+1}{m+1}，n\u0026gt;m $$\n对于 $C_0(n)$ ，我们有初始条件 $C_0(0)=1, C_0(1)=0,C_0(2)=C_0(0)+C_0(1)=1$\n$$ C_0(n)=\\frac{n+1}{3}, n\u0026gt;2 $$\n对于 $C_1(n)$ ，我们有初始条件 $C_1(0)=0,C_1(1)=1,C_1(2)=C_1(0)+C_1(1)=1$\n$$ C_1(n)=\\frac{n+1}{3},n\u0026gt;2 $$\n对于 $C_2(n)$ ，我们有初始条件 $C_2(0)=C_2(1)=0,C_2(2)=1,C_2(3)=\\frac{2\\times(C_2(0)+C_2(1)+C_2(2))}{3}=\\frac{2}{3}$\n$$ C_2(n)=\\frac{n+1}{6},n\u0026gt;3 $$\n结论\n$$ C_0(n)=C_1(n)=\\frac{n+1}{3},n\u0026gt;2 \\newline C_2(n)=\\frac{n+1}{6},n\u0026gt;3 $$\n实验结果：\n另请参阅 # Quick 库 What is the expected number of subarrays of size 0, 1 and 2 when quicksort is used to sort an array of N items with distinct keys?-Stack Overflow\n"},{"id":254,"href":"/2-3-8/","title":"2.3.8","section":"《算法（第四版）》C# 题解","content":" 2.3.8 # 解答 # 每次切分都会把数组平分，共切分 logN 次（二分法），每次切分比较 N 次（i 和 j 会一位一位地从两边向中间靠拢）。\n共比较 NlogN 次。\n"},{"id":255,"href":"/2-3-9/","title":"2.3.9","section":"《算法（第四版）》C# 题解","content":" 2.3.9 # 解答 # 切分时，枢轴左侧都是小于（或等于）枢轴的，\n右侧都是大于（或等于）枢轴的\n只有两种主键值时，\n第一次切分之后，某一侧的元素将全部相同\n（如果枢轴选了较大的，那么右侧将全部相同，反之则左侧全部相同）\n只有三种主键值时，和一般快速排序并无不同。\n但如果第一次切分时选择了中间值作为枢轴，且中间值只有一个\n那么只需要一次切分数组便会有序。\n"},{"id":256,"href":"/2-3-10/","title":"2.3.10","section":"《算法（第四版）》C# 题解","content":" 2.3.10 # 解答 # 切比雪夫不等式（Chebyshev’s inequality）\n$$ P(|X-\\mu|\\geq k\\sigma)\\leq \\frac{1}{k^2} $$\n其中，$\\mu$ 代表期望，$\\sigma$ 代表标准差。\n对于快速排序的比较次数来说，$\\mu = 2N\\ln N$ ，$\\sigma=0.65N$。\n（这两个结论见 2.3 节的命题 K 和命题 L）\n题目中要求比较次数大于 $0.1N^2$ ，可以求得 $k$ 的值。\n$$ 0.65kN=0.1N^2 \\newline k=\\frac{2N}{13} $$\n将 $N=1,000,000$ 代入\n$$ P(|X-27,631,021|\\geq 100,000,000,000)\\leq 0.00000000004225 $$\n另请参阅 # 切比雪夫不等式到底是个什么概念? - 马同学的回答 - 知乎\n"},{"id":257,"href":"/2-3-11/","title":"2.3.11","section":"《算法（第四版）》C# 题解","content":" 2.3.11 # 解答 # 只有若干种元素值意味着大量的连续重复。\n（由于存在打乱这一步骤，不存在连续重复的可能性是很低的）\n接下来我们考虑这样的连续重复在修改后的快排下的性能。\n1 1 1 1 1 1 1\n对于这样的数组，枢轴选为 1，j 将会在 j = lo 处终止。\n因此最后的结果将是每次只有数组的第一个元素被排序\n已知每次切分都是 O(k - 1) 的（i 和 j 都将走完整个子数组）\n因此这样的快速排序所需时间 = $2 (N - 1 + N - 2 + \\cdots + 1) = (N - 1)N$\n因此对于值相同的子数组，这样的快排运行时间是平方级别的\n那么当数组中这样的连续重复内容越多，运行时间就越接近平方级别。\n"},{"id":258,"href":"/2-3-12/","title":"2.3.12","section":"《算法（第四版）》C# 题解","content":" 2.3.12 # 解答 # "},{"id":259,"href":"/2-3-13/","title":"2.3.13","section":"《算法（第四版）》C# 题解","content":" 2.3.13 # 解答 # 快速排序先将数组分为 （小于枢轴）枢轴（大于枢轴）三部分，然后再分别递归的排序左右两部分数组。\n在这里，我们可以将快速排序的递归树看作是一棵二叉搜索树（BST, Binary Search Tree）。\n枢轴作为根结点，左子树即为左数组构造的 BST，右子树即为右数组构造的 BST。\n这样题目中所求的递归深度即为所构造的 BST 的高度。\n最坏情况，每次都只有枢轴和大于枢轴两部分，BST 退化为链表，高度为 $n-1$。\n最好情况，每次枢轴都正好平分数组，构造一棵完全二叉树，高度为 $\\log n$。\n平均情况，问题转化为：一个由 $n$ 个元素随机构造的 BST 的平均高度是多少？\n《算法导论》给出的结论是 $\\log n$ ，具体证明如下：\n设由 $n$ 个结点随机构成的 BST 的高度为 $h_n$，那么有：\n$$ h_n=1+\\max(h_{l}+h_{r}) $$\n其中，$h_l$ 和 $h_r$ 分别代表左数组和右数组构造的 BST 的高度。\n设枢轴位置为 $i$，上式可简化为：\n$$ h_n=1+\\max(h_{i-1}, h_{n-i}) $$\n由于枢轴位置可以在 1~n 之间任意取值且概率相等，因此 BST 的平均高度（即高度的期望）为：\n$$ E(h_n)=\\frac{1}{n}\\sum_{i=1}^{n}\\lbrack 1+\\max(h_{i-1}, h_{n-i}) \\rbrack $$\n我们令 $Y_n=2^{h_n}$，可得：\n$$ Y_n=2\\times\\max(Y_{i-1},Y_{n-i}) $$\n我们把 $Y_n$ 代入，可得：\n$$ \\begin{aligned} E(Y_n) \u0026amp;=\\sum_{i=1}^{n}\\frac{1}{n}E\\lbrack2\\times\\max(Y_{i-1}, Y_{n-i})\\rbrack\\newline \u0026amp;=\\frac{2}{n}\\sum_{i=1}^{n}E\\lbrack\\max(Y_{i-1},Y_{n-i})\\rbrack\\newline \\end{aligned} $$\n接下来我们去掉最大值运算，根据最大值的性质，下式显然成立：\n$$ E\\lbrack\\max(X,Y)\\rbrack\\le E\\lbrack\\max(X,Y)+\\min(X,Y)\\rbrack=E\\lbrack X+Y\\rbrack=E\\lbrack X\\rbrack+E\\lbrack Y\\rbrack $$\n代入可得：\n$$ E(Y_n) \\le\\frac{2}{n}\\sum_{i=1}^{n}(E\\lbrack Y_{i-1}\\rbrack + E\\lbrack Y_{n-i} \\rbrack) =\\frac{2}{n}\\sum_{i=0}^{n-1}2E\\lbrack Y_i\\rbrack =\\frac{4}{n}\\sum_{i=0}^{n-1}E\\lbrack Y_i\\rbrack $$\n大小为 0 的数组构成的 BST 的高度显然为 0，我们设 $Y_0=0$ 。接下来用一个组合数公式来构造上界：\n$$ \\begin{align} 0\u0026amp;=Y_0=E\\lbrack Y_0 \\rbrack\\le \\frac{1}{4}\\begin{pmatrix}3\\newline 3\\end{pmatrix}=\\frac{1}{4}\\newline 1\u0026amp;=Y_1=E\\lbrack Y_1 \\rbrack\\le\\frac {1}{4}\\begin{pmatrix}3+1\\newline 3\\end{pmatrix}=1 \\newline \\vdots \\newline Y_i \u0026amp;=E\\lbrack Y_i\\rbrack\\le\\frac{1}{4}\\begin{pmatrix}i+3\\newline 3\\end{pmatrix} \\end{align} $$\n注意这里的组合数公式为：\n$$ \\begin{pmatrix}n\\newline r\\end{pmatrix}=\\frac{r!}{r!(n-r)!} $$\n代入可得：\n$$ \\begin{align} E(Y_n) \u0026amp;\\le \\frac{4}{n}\\sum_{i=0}^{n-1}E\\lbrack Y_i\\rbrack \\newline \u0026amp;\\le\\frac{4}{n}\\sum_{i=0}^{n-1}\\frac{1}{4}\\begin{pmatrix}i+3\\newline 3\\end{pmatrix} \\newline \u0026amp;=\\frac{1}{n}\\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\newline 3\\end{pmatrix} \\end{align} $$\n接下来我们去掉求和符号，首先根据组合数的性质，有以下等式成立\n$$ \\begin{align} \\begin{pmatrix}n\\newline k\\end{pmatrix}\u0026amp;=\\begin{pmatrix}n-1\\newline k-1\\end{pmatrix}+\\begin{pmatrix}n-1\\newline k\\end{pmatrix} \\newline \\begin{pmatrix}n\\newline n\\end{pmatrix}\u0026amp;=1 \\end{align} $$\n我们把求和式展开得到：\n$$ \\begin{align} \\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\newline 3\\end{pmatrix} \u0026amp;=\\begin{pmatrix}3\\newline 3\\end{pmatrix} + \\begin{pmatrix}4\\newline 3\\end{pmatrix}+\\cdots+\\begin{pmatrix}n+2\\newline 3\\end{pmatrix} \\newline \u0026amp;=\\begin{pmatrix}4\\newline 4\\end{pmatrix} + \\begin{pmatrix}4\\newline 3\\end{pmatrix}+\\cdots+\\begin{pmatrix}n+2\\newline 3\\end{pmatrix} \\newline \u0026amp;=\\begin{pmatrix}n+3\\newline 4\\end{pmatrix} \\end{align} $$\n代入可得：\n$$ \\begin{align} E(Y_n) \u0026amp;\\le\\frac{1}{n}\\sum_{i=0}^{n-1}\\begin{pmatrix}i+3\\newline 3\\end{pmatrix}\\newline \u0026amp;=\\frac{1}{n}\\begin{pmatrix}n+3\\newline 4 \\end{pmatrix} \\newline \u0026amp;=\\frac{1}{n}\\cdot\\frac{(n+3)!}{4!(n-1)!} \\newline \u0026amp;=\\frac{1}{4}\\cdot\\frac{(n+3)!}{3!n!} \\newline \u0026amp;=\\frac{(n+1)(n+2)(n+3)}{24} \\newline \u0026amp;=\\frac{n^3+6n^2+11n+6}{24} \\end{align} $$\n由于 $Y_n=2^{h_n}$ ，因此 $E\\lbrack Y_n \\rbrack=E\\lbrack 2^{h_n} \\rbrack$。\n由于 $f(x)=2^x$ 是个凸函数，可以应用延森不等式（凸函数的割线一定在函数上方），即 $2^{E\\lbrack h_n\\rbrack}\\le E\\lbrack Y_n\\rbrack$。\n于是得到结论：\n$$ 2^{E\\lbrack h_n\\rbrack} \\le \\frac{n^3+6n^2+11n+6}{24} \\newline E\\lbrack h_n \\rbrack\\le \\log(\\frac{n^3+6n^2+11n+6}{24}) $$\n另请参阅 # 快速排序的递归树可以视为 BST 的结论可以在下面这个 PPT 的第 5 页找到。\nQuickSort-纽约大学\n《算法导论》中关于随机 BST 高度的证明（P321 Theorem12.4）\nIntroduction to Algorithms\n也可以参考下面这个链接获得更详细的解释。\nProof that a randomly built binary search tree has logarithmic height-StackExchange\n"},{"id":260,"href":"/2-3-14/","title":"2.3.14","section":"《算法（第四版）》C# 题解","content":" 2.3.14 # 解答 # 中文版题目有误，详见官方勘误页面\n假设 $i \u0026lt; j​$ 。\n首先，在快速排序中，如果两个元素要发生交换，意味着其中一个元素被选为枢轴。\n而且数组中的元素各不相同，那么两个特定的元素的比较最多发生一次。\n那么先考虑一个特殊情况，$i = 1, j = n$ ，即求最大值和最小值比较的概率。\n此时，一旦枢轴不是这两个元素之一，\n最大值和最小值会被分到两个不同的子数组，无法发生比较。\n因此在这种特例下第 $i$ 大的元素和第 $j$ 大的元素发生比较的概率为 $\\frac{2}{n} = \\frac{2}{j-i+1}$ 。\n接下来考虑一般情况，如果枢轴选择了第 $i$ 到第 $j$ 大之外的元素，\n那么第 $i$ 大和第 $j$ 大的元素会被分到同一个子数组里，重复上述过程。\n因此我们所求的概率只和从第 $i$ 大到第 $j$ 大之间的元素有关，概率为 $\\frac{2}{j-i+1}$。\n（举个例子，一个箱子里有 2 个红球、1 个蓝球和 7 个白球，现在摸球而不放回。\n如果摸到白球可以再摸一次，直到摸到红球或蓝球为止。\n显然在这样的规则下摸到红球或蓝球的概率为 1，即白球对概率没有影响。）\n现在我们已经得到了某两个元素比较的概率 $E(X_{ij})$，接下来我们求每两个元素比较的概率 $E(X)$。\n$$ \\begin{align} E(X) \u0026amp;= \\sum_{i=1}^{n}\\sum_{j=i+1}^{n}E(X_{ij})\\newline \u0026amp;=\\sum_{i=1}^{n}2(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n-i+1}) \\newline \u0026amp;\u0026lt;2n(\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}) \\end{align} $$\n根据调和级数的性质（$\\ln (n) \u0026lt; 1+ \\frac{1}{2}+ \\cdots + \\frac{1}{n} \u0026lt; 1+\\ln(n)$），可以得到结论：\n$$ E(X) \u0026lt; 2n \\ln(n) $$\n另请参阅 # 下面这个链接里的 3.4.2 节给出了解法。 lect0906 - 卡内基梅隆大学 如果还是不能理解为什么多次切分不影响概率，可以参考三门问题的解释： 蒙提霍尔问题 - 维基百科 蒙提霍尔问题（又称三门问题、山羊汽车问题）的正解是什么？- 知乎\n"},{"id":261,"href":"/2-3-15/","title":"2.3.15","section":"《算法（第四版）》C# 题解","content":" 2.3.15 # 解答 # 事实上只需要修改快速排序的切分方法，分两次进行切分。\n首先选第一个螺母作为枢轴，找到对应的螺丝（$O(n)$）放到第一位，对螺丝数组进行切分。\n然后再用找到的螺丝对螺母数组进行切分。\n螺母类，实现了对螺丝类的 IComparable 接口\npublic class Nut\u0026lt;T\u0026gt; : IComparable\u0026lt;Bolt\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt; /// 螺母的值。 /// \u0026lt;/summary\u0026gt; public T Value { get; set; } /// \u0026lt;summary\u0026gt; /// 螺母的构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;螺母的值。\u0026lt;/param\u0026gt; public Nut(T value) =\u0026gt; Value = value; /// \u0026lt;summary\u0026gt; /// 比较方法，螺母只能和螺丝比较。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的螺丝。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int CompareTo(Bolt\u0026lt;T\u0026gt; other) { return Value.CompareTo(other.Value); } } 类似的有螺丝类。\npublic class Bolt\u0026lt;T\u0026gt; : IComparable\u0026lt;Nut\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt; /// 螺丝的值。 /// \u0026lt;/summary\u0026gt; public T Value { get; set; } /// \u0026lt;summary\u0026gt; /// 螺丝的默认构造函数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;螺丝的值。\u0026lt;/param\u0026gt; public Bolt(T value) =\u0026gt; Value = value; /// \u0026lt;summary\u0026gt; /// 比较方法，螺丝只能和螺母比较。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要比较的螺母。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int CompareTo(Nut\u0026lt;T\u0026gt; other) { return Value.CompareTo(other.Value); } } 代码 # 修改后的排序方法。\npublic class BoltsAndNuts { private readonly Random _random = new(); /// \u0026lt;summary\u0026gt; /// 对螺丝和螺母排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts) where T : IComparable\u0026lt;T\u0026gt; { if (bolts.Length != nuts.Length) throw new ArgumentException(\u0026#34;数组长度必须一致\u0026#34;); Shuffle(bolts); Shuffle(nuts); Sort(bolts, nuts, 0, bolts.Length - 1); } /// \u0026lt;summary\u0026gt; /// 对螺丝和螺母排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt; public void Sort\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) return; var j = Partition(bolts, nuts, lo, hi); Sort(bolts, nuts, lo, j - 1); Sort(bolts, nuts, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;bolts\u0026#34;\u0026gt;螺母数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;nuts\u0026#34;\u0026gt;螺丝数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;终止下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;切分位置。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(Bolt\u0026lt;T\u0026gt;[] bolts, Nut\u0026lt;T\u0026gt;[] nuts, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var pivotB = bolts[lo]; // 找到对应螺丝 for (var k = lo; k \u0026lt;= hi; k++) { if (nuts[k].CompareTo(pivotB) == 0) { Exch(nuts, k, lo); break; } } // 先用螺母去套螺丝 while (true) { while (nuts[++i].CompareTo(pivotB) \u0026lt; 0) if (i == hi) break; while (pivotB.CompareTo(nuts[--j]) \u0026lt; 0) if (j == lo) break; if (i \u0026gt;= j) break; Exch(nuts, i, j); } Exch(nuts, lo, j); // 再用螺丝去比较螺母 var pivotN = nuts[j]; i = lo; j = hi + 1; while (true) { while (bolts[++i].CompareTo(pivotN) \u0026lt; 0) if (i == hi) break; while (pivotN.CompareTo(bolts[--j]) \u0026lt; 0) if (j == lo) break; if (i \u0026gt;= j) break; Exch(bolts, i, j); } Exch(bolts, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + _random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } /// \u0026lt;summary\u0026gt; /// 交换两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要交换的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;需要交换的第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;需要交换的第二个元素。\u0026lt;/param\u0026gt; private void Exch\u0026lt;T\u0026gt;(T[] a, int lo, int hi) { var t = a[lo]; a[lo] = a[hi]; a[hi] = t; } } 另请参阅 # 下面这个网站给出了这道题的解法，还给出了另一种确定性算法（非随机的算法）的论文链接。 Matching Nuts and Bolts - Solution\n"},{"id":262,"href":"/2-3-16/","title":"2.3.16","section":"《算法（第四版）》C# 题解","content":" 2.3.16 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBest.java.html\n类似于快速排序的结构，只要中点的两边都是最佳情况，那么整个数组就是最佳情况了。\n具体方法是：\n首先构造一个有序数组，\n然后找到中点（作为枢轴），\n对中点左右两侧子数组进行构造，\n将选择的枢轴放到开始处(a[lo])。\n代码 # 用于构造最佳数组的类。\npublic class QuickBest { /// \u0026lt;summary\u0026gt; /// 构造函数，这个类不应该被实例化。 /// \u0026lt;/summary\u0026gt; private QuickBest() { } /// \u0026lt;summary\u0026gt; /// 构造适用于快速排序的最佳数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;数组长度。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;适用于快速排序的最佳情况数组。\u0026lt;/returns\u0026gt; public static int[] Best(int n) { var a = new int[n]; for (var i = 0; i \u0026lt; n; i++) { a[i] = i; } Best(a, 0, n - 1); return a; } /// \u0026lt;summary\u0026gt; /// 递归的构造数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要构造的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;构造的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;构造的终止下标。\u0026lt;/param\u0026gt; private static void Best(int[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; var mid = lo + (hi - lo) / 2; Best(a, lo, mid - 1); Best(a, mid + 1, hi); Exch(a, lo, mid); } /// \u0026lt;summary\u0026gt; /// 交换数组中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;包含要交换元素的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;需要交换的第一个元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;需要交换的第二个元素下标。\u0026lt;/param\u0026gt; private static void Exch(int[] a, int x, int y) { var t = a[x]; a[x] = a[y]; a[y] = t; } } 用于测试的方法\nvar quick = new QuickSortAnalyze { NeedShuffle = false, // 关闭打乱 NeedPath = true // 显示排序轨迹 }; var a = QuickBest.Best(10); for (var i = 0; i \u0026lt; 10; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); quick.Sort(a); for (var i = 0; i \u0026lt; 10; i++) { Console.Write(a[i] + \u0026#34; \u0026#34;); } Console.WriteLine(); 另请参阅 # Quick 库\n"},{"id":263,"href":"/2-3-17/","title":"2.3.17","section":"《算法（第四版）》C# 题解","content":" 2.3.17 # 解答 # 按照题意修改代码即可，在调用 Suffle() 之后添加一段用于寻找最大值的方法（$O(n)$）。\npublic override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位 var maxIndex = 0; for (var i = 0; i \u0026lt; a.Length; i++) { if (Less(a[maxIndex], a[i])) maxIndex = i; } Exch(a, maxIndex, a.Length - 1); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } 代码 # 修改后的快速排序类。\npublic class QuickSortX : BaseSort { /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); // 把最大元素放到最后一位 var maxIndex = 0; for (var i = 0; i \u0026lt; a.Length; i++) { if (Less(a[maxIndex], a[i])) maxIndex = i; } Exch(a, maxIndex, a.Length - 1); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) { } // if (i == hi) // break; while (Less(v, a[--j])) { } // if (j == lo) // break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 主方法。\nvar quick = new QuickSort(); var quickSortX = new QuickSortX(); var arrayLength = 1000000; var a = SortCompare.GetRandomArrayInt(arrayLength); var b = new int[arrayLength]; a.CopyTo(b, 0); var time1 = SortCompare.Time(quick, a); var time2 = SortCompare.Time(quickSortX, b); Console.WriteLine(\u0026#34;QSort\\tQSort with Sentinels\\t\u0026#34;); Console.WriteLine(time1 + \u0026#34;\\t\u0026#34; + time2 + \u0026#34;\\t\u0026#34;); 另请参阅 # Quick 库\n"},{"id":264,"href":"/2-3-18/","title":"2.3.18","section":"《算法（第四版）》C# 题解","content":" 2.3.18 # 解答 # 每次切分时都取前三个元素的中位数作为枢轴，这可以带来约 5%~10% 的性能提升。\n这里通过三次比较将前三个数排序，然后把三个数中的中位数放到数组开头，最大值放到数组末尾。\n最大值被放到了末尾，枢轴不可能大于末尾的这个数，因此右边界判断可以去掉。\n同时由于枢轴不可能小于自身，因此左边界判断也可以去掉。\n这样就可以把切分中的两个边界判断全部去掉了。\n最后对于大小为 2 的数组做特殊处理，通过一次比较直接排序并返回。\n测试结果：\n代码 # QuickSortMedian3 # public class QuickSortMedian3 : BaseSort { /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; // 只有两个元素的数组直接排序 if (hi == lo + 1) { if (Less(a[hi], a[lo])) Exch(a, lo, hi); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; if (Less(a[lo + 1], a[lo])) Exch(a, lo + 1, lo); if (Less(a[lo + 2], a[lo])) Exch(a, lo + 2, lo); if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 1, lo + 2); Exch(a, lo, lo + 1); // 中位数放最左侧 Exch(a, hi, lo + 2); // 较大的值放最右侧作为哨兵 var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) { } if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例 # var quickNormal = new QuickSort(); var quickMedian = new QuickSortMedian3(); var arraySize = 200000; // 初始数组大小。 const int trialTimes = 4; // 每次实验的重复次数。 const int trialLevel = 5; // 双倍递增的次数。 Console.WriteLine(\u0026#34;n\\tmedian\\tnormal\\tratio\u0026#34;); for (var i = 0; i \u0026lt; trialLevel; i++) { double timeMedian = 0; double timeNormal = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { var a = SortCompare.GetRandomArrayInt(arraySize); var b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeMedian += SortCompare.Time(quickMedian, a); } timeMedian /= trialTimes; timeNormal /= trialTimes; Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeMedian + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeMedian / timeNormal); arraySize *= 2; } 另请参阅 # Quick 库\n"},{"id":265,"href":"/2-3-19/","title":"2.3.19","section":"《算法（第四版）》C# 题解","content":" 2.3.19 # 解答 # 主要介绍一下这个少于七次比较的五取样算法。\n首先假设五个数字为 a b c d e\n对 b c 排序，d e 排序。（两次比较）\n比较 b 和 d，把较小那一组换到 b c 的位置上去。（一次比较）\n此时会有 b \u0026lt; c, b \u0026lt; d \u0026lt; e。\n交换 a, b，重新对 b c 排序。（一次比较）\n再次比较 b 和 d，把较小的那一组换到 b c 的位置上。（一次比较）\n最后比较 c 和 d，较小的那一个即为中位数。（一次比较）\n总共需要 6 次比较，严格小于 7 次。\n取样完毕后，a b 是最小值和次小值（这里没有对应关系，a 也可以是次小值）。\nd 和 e 是最大值和次大值（同样没有对应关系）。\n我们把 d 和 e 放到数组的最后作为哨兵，去掉右边界的判断。\n同时让左右两侧指针都向中间移动两位，减少不必要的比较。\n测试结果，对比普通快排性能提升约 10%，和三取样快排区别不大。\n代码 # 五取样快排 # public class QuickSortMedian5 : BaseSort { /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; // 少于五个元素的数组直接进行插入排序 if (hi - lo + 1 \u0026lt; 5) { var n = hi - lo + 1; for (var i = lo; i - lo \u0026lt; n; i++) { for (var k = i; k \u0026gt; 0 \u0026amp;\u0026amp; Less(a[k], a[k - 1]); --k) { Exch(a, k, k - 1); } } return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; // 假设为 a b c d e 五个数字 // 首先对 b c 排序 if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 2, lo + 1); // 然后再排序 d e if (Less(a[lo + 4], a[lo + 3])) Exch(a, lo + 4, lo + 3); // 这时满足 b \u0026lt; c, d \u0026lt; e // 比较 b d，把较小的一组放到 b c 的位置上去 if (Less(a[lo + 3], a[lo + 1])) { Exch(a, lo + 1, lo + 3); Exch(a, lo + 2, lo + 4); } // 这时满足 b \u0026lt; c, b \u0026lt; d \u0026lt; e，即 b 是 b c d e 中的最小值 // 交换 a 和 b Exch(a, lo, lo + 1); // 重新排序 b c if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 2, lo + 1); // 这时再次满足 b \u0026lt; c, d \u0026lt; e // 比较 b d，把最小的一组放到 b c 的位置上去 if (Less(a[lo + 3], a[lo + 1])) { Exch(a, lo + 1, lo + 3); Exch(a, lo + 2, lo + 4); } // 这时 a 和 b 为五个数中的最小值和次小值（顺序不固定，a 也可以是次小值） // 最后比较 c 和 d，较小的那一个即为中位数（即第三小的数） if (Less(a[lo + 3], a[lo + 2])) Exch(a, lo + 3, lo + 2); // 此时 c 即为中位数 Exch(a, lo, lo + 2); // d e 放到数组末尾充当哨兵 Exch(a, lo + 3, hi); Exch(a, lo + 4, hi - 1); // 调整指针位置，前两位和后两位都已经在合适位置了 j -= 2; i += 2; var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) { } if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 三取样快排 # public class QuickSortMedian3 : BaseSort { /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; // 少于五个元素的数组直接进行插入排序 if (hi - lo + 1 \u0026lt; 5) { var n = hi - lo + 1; for (var i = lo; i - lo \u0026lt; n; i++) { for (var k = i; k \u0026gt; 0 \u0026amp;\u0026amp; Less(a[k], a[k - 1]); --k) { Exch(a, k, k - 1); } } return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; if (Less(a[lo + 1], a[lo])) Exch(a, lo + 1, lo); if (Less(a[lo + 2], a[lo])) Exch(a, lo + 2, lo); if (Less(a[lo + 2], a[lo + 1])) Exch(a, lo + 1, lo + 2); Exch(a, lo, lo + 1); // 中位数放最左侧 Exch(a, hi, lo + 2); // 较大的值放最右侧作为哨兵 var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) { } if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例\nvar quickNormal = new QuickSort(); var quickMedian3 = new QuickSortMedian3(); var quickMedian5 = new QuickSortMedian5(); var arraySize = 200000; // 初始数组大小。 const int trialTimes = 4; // 每次实验的重复次数。 const int trialLevel = 6; // 双倍递增的次数。 Console.WriteLine(\u0026#34;n\\tmedian5\\tmedian3\\tnormal\\tmedian5/normal\\t\\tmedian5/median3\u0026#34;); for (var i = 0; i \u0026lt; trialLevel; i++) { double timeMedian3 = 0; double timeMedian5 = 0; double timeNormal = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { var a = SortCompare.GetRandomArrayInt(arraySize); var b = new int[a.Length]; var c = new int[a.Length]; a.CopyTo(b, 0); a.CopyTo(c, 0); timeNormal += SortCompare.Time(quickNormal, a); timeMedian3 += SortCompare.Time(quickMedian3, b); timeMedian5 += SortCompare.Time(quickMedian5, c); } timeMedian5 /= trialTimes; timeMedian3 /= trialTimes; timeNormal /= trialTimes; Console.WriteLine( arraySize + \u0026#34;\\t\u0026#34; + timeMedian5 + \u0026#34;\\t\u0026#34; + timeMedian3 + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeMedian5 / timeNormal + \u0026#34;\\t\u0026#34; + timeMedian5 / timeMedian3); arraySize *= 2; } 另请参阅 # Quick 库 Code to calculate “median of five” in C#\n"},{"id":266,"href":"/2-3-20/","title":"2.3.20","section":"《算法（第四版）》C# 题解","content":" 2.3.20 # 解答 # 事实上就是用一个栈保存每次切分后的子数组下标。\n关键代码如下：\n/// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); var stack = new Stack\u0026lt;int\u0026gt;(); stack.Push(0); stack.Push(a.Length - 1); while (stack.Count != 0) { // 压入顺序是先 lo，再 hi，故弹出顺序是先 hi 再 lo var hi = stack.Pop(); var lo = stack.Pop(); if (hi \u0026lt;= lo) continue; var j = Partition(a, lo, hi); // 让较大的子数组先入栈（先排序较小的子数组） if (j - lo \u0026gt; hi - j) { stack.Push(lo); stack.Push(j - 1); stack.Push(j + 1); stack.Push(hi); } else { stack.Push(j + 1); stack.Push(hi); stack.Push(lo); stack.Push(j - 1); } } Debug.Assert(IsSorted(a)); } 由于栈操作比函数调用操作耗费时间更长，因此测试后的结果会比原有快排慢一些。\n代码 # QuickSortNonRecursive # /// \u0026lt;summary\u0026gt; /// 快速排序类。 /// \u0026lt;/summary\u0026gt; public class QuickSortNonRecursive : BaseSort { /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); var stack = new Stack\u0026lt;int\u0026gt;(); stack.Push(0); stack.Push(a.Length - 1); while (stack.Count != 0) { // 压入顺序是先 lo，再 hi，故弹出顺序是先 hi 再 lo var hi = stack.Pop(); var lo = stack.Pop(); if (hi \u0026lt;= lo) continue; var j = Partition(a, lo, hi); // 让较大的子数组先入栈（先排序较小的子数组） if (j - lo \u0026gt; hi - j) { stack.Push(lo); stack.Push(j - 1); stack.Push(j + 1); stack.Push(hi); } else { stack.Push(j + 1); stack.Push(hi); stack.Push(lo); stack.Push(j - 1); } } Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例\nvar quickNormal = new QuickSort(); var quickNonRecursive = new QuickSortNonRecursive(); var arraySize = 200000; // 初始数组大小。 const int trialTimes = 4; // 每次实验的重复次数。 const int trialLevel = 5; // 双倍递增的次数。 Console.WriteLine(\u0026#34;n\\tnon-recursive\\tnormal\\tratio\u0026#34;); for (var i = 0; i \u0026lt; trialLevel; i++) { double timeRecursive = 0; double timeNormal = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { var a = SortCompare.GetRandomArrayInt(arraySize); var b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeRecursive += SortCompare.Time(quickNonRecursive, a); } timeRecursive /= trialTimes; timeNormal /= trialTimes; Console.WriteLine(arraySize + \u0026#34;\\t\u0026#34; + timeRecursive + \u0026#34;\\t\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeRecursive / timeNormal); arraySize *= 2; } 另请参阅 # Quick 库\n"},{"id":267,"href":"/2-3-21/","title":"2.3.21","section":"《算法（第四版）》C# 题解","content":" 2.3.21 # 解答 # 首先引入命题 I 的结论，对于互不相同的主键值，基于比较的排序算法的下界等于所形成的比较树的高度，即：\n$$ h \\ge \\log_2{N!} $$\n那么我们题目即可转化为求证\n$$ h \\ge \\log_2 (\\frac{N!}{f_1!f_2!\\cdots f_k!}) \\ge \\log_2 N! $$\n这里的 $f_i$ 为某个主键值出现的频率，即某个主键值出现的次数，因此 $f_i\\ge 1$ 。\n根据题目给出的条件，如果主键互不重复，此时 $k=N$，且 $f_1=f_2=\\cdots=f_k=1$ 。\n那么 $f_1!f_2!\\cdots f_k!=1$ ，待证式子即为命题 I 的结论。\n那么当主键有重复时，此时 $k \u0026lt; N$，为使 $f_1+f_2+ \\cdots + f_k=N$ ，至少存在一个 $f_m \\ge 2$。\n故此时：\n$$ f_1!f_2!\\cdots f_k! \u0026gt;1\\Rightarrow \\frac{N!}{f_1!f_2!\\cdots f_k!}\u0026lt;N! \\Rightarrow \\newline h \\ge \\log_2 (\\frac{N!}{f_1!f_2!\\cdots f_k!}) \\ge \\log_2 N! \\ \\blacksquare $$\n得证。\n另请参阅 # lower bounds of sorting-The University of Maryland\n"},{"id":268,"href":"/2-3-22/","title":"2.3.22","section":"《算法（第四版）》C# 题解","content":" 2.3.22 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html\n快速三向切分 # 论文引用见「另请参阅」部分。\n算法演示\nNinther 算法 # 官方实现中用到了 Ninther 算法用于选取近似中位数（作为枢轴），\n该算法由 John Tukey 在 1978 年提出，论文引用见「另请参阅」部分。\n这个算法的思想其实很简单，假设我们有三个数 $y_1, y_2, y_3$ ，那么其中位数为：\n$$ y_A= {\\rm median}\\lbrace y_1,y_2,y_3 \\rbrace $$\n现在对于九个数，我们以三个为一组，取三个中位数：\n$$ y_A= {\\rm median}\\lbrace y_1,y_2,y_3 \\rbrace \\newline y_B= {\\rm median}\\lbrace y_4,y_5,y_6 \\rbrace \\newline y_C= {\\rm median}\\lbrace y_7,y_8,y_9 \\rbrace $$\n接下来取这三个中位数的中位数，有：\n$$ y_E= {\\rm median}\\lbrace y_A,y_B,y_C \\rbrace $$\n我们把上述过程封装成函数，即 $y_E= {\\rm ninther}\\lbrace y_1,y_2,\\cdots,y_9 \\rbrace$ 。\n于是我们获得的 $y_E$ 即为近似中位数，如果 $\\lbrace y_1,y_2,\\cdots,y_9 \\rbrace$ 是单调数列，那么 $y_E$ 就是中位数。\n获取三个数中的中位数 # 事实上，我们可以直接画出三个数排列的所有可能，获得决策树。\n然后根据决策树写出取中位数的算法：\nprivate int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } 测试结果 # 提高约 20% 左右的性能。\n代码 # QuickBentleyMcIlroy\n/// \u0026lt;summary\u0026gt; /// 利用 Bentley-McIlroy 方法优化的快速排序。 /// \u0026lt;/summary\u0026gt; public class QuickBentleyMcIlroy : BaseSort { /// \u0026lt;summary\u0026gt; /// 小于这个数值的数组调用插入排序。 /// \u0026lt;/summary\u0026gt; private readonly int _insertionSortCutoff = 8; /// \u0026lt;summary\u0026gt; /// 小于这个数值的数组调用中位数作为枢轴。 /// \u0026lt;/summary\u0026gt; private readonly int _medianOf3Cutoff = 40; /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 对指定范围内的数组进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { var n = hi - lo + 1; if (n \u0026lt;= _insertionSortCutoff) { InsertionSort(a, lo, hi); return; } if (n \u0026lt;= _medianOf3Cutoff) { // 对于较小的数组，直接选择左中右三个元素中的中位数作为枢轴。 var m = Median3(a, lo, lo + n / 2, hi); Exch(a, m, lo); } else { // 对于较大的数组使用 Turkey Ninther 作为枢轴。 var eps = n / 8; var mid = lo + n / 2; var m1 = Median3(a, lo, lo + eps, lo + eps + eps); var m2 = Median3(a, mid - eps, mid, mid + eps); var m3 = Median3(a, hi - eps - eps, hi - eps, hi); var ninther = Median3(a, m1, m2, m3); Exch(a, ninther, lo); } // 三向切分 int i = lo, j = hi + 1; int p = lo, q = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])); if (i == j \u0026amp;\u0026amp; IsEqual(a[i], v)) Exch(a, ++p, i); if (i \u0026gt;= j) break; Exch(a, i, j); if (IsEqual(a[i], v)) Exch(a, ++p, i); if (IsEqual(a[j], v)) Exch(a, --q, j); } i = j + 1; for (var k = lo; k \u0026lt;= p; k++) Exch(a, k, j--); for (var k = hi; k \u0026gt;= q; k--) Exch(a, k, i++); Sort(a, lo, j); Sort(a, i, hi); } /// \u0026lt;summary\u0026gt; /// 判断两个元素是否值相等。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要判断的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;进行比较的第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;进行比较的第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;两个元素的值是否相等。\u0026lt;/returns\u0026gt; private bool IsEqual\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) == 0; } /// \u0026lt;summary\u0026gt; /// 用插入排序对指定范围内的数组排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt; private void InsertionSort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var i = lo; i \u0026lt;= hi; i++) { for (var j = i; j \u0026gt; lo \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) { Exch(a, j, j - 1); } } } /// \u0026lt;summary\u0026gt; /// 获取三个元素中的中位数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;第三个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt;，\u0026lt;paramref name=\u0026#34;j\u0026#34;/\u0026gt;，\u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的元素中的中位数下标。\u0026lt;/returns\u0026gt; private int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } } 测试用例\nvar quickNormal = new QuickSort(); var quickBentleyMcIlroy = new QuickBentleyMcIlroy(); var arraySize = 800000; // 初始数组大小。 const int trialTimes = 1; // 每次实验的重复次数。 const int trialLevel = 8; // 双倍递增的次数。 Console.WriteLine(\u0026#34;n\\t\\t3way\\tnormal\\tratio\u0026#34;); for (var i = 0; i \u0026lt; trialLevel; i++) { double timeBentleyMcIlroy = 0; double timeNormal = 0; for (var j = 0; j \u0026lt; trialTimes; j++) { var a = SortCompare.GetRandomArrayInt(arraySize); var b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeBentleyMcIlroy += SortCompare.Time(quickBentleyMcIlroy, a); } timeBentleyMcIlroy /= trialTimes; timeNormal /= trialTimes; if (arraySize \u0026lt; 10000000) Console.WriteLine( arraySize + \u0026#34;\\t\\t\u0026#34; + timeBentleyMcIlroy + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy / timeNormal); else Console.WriteLine( arraySize + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeBentleyMcIlroy / timeNormal); arraySize *= 2; } 另请参阅 # 有关这种快速排序算法的来源以及三个数的中位数的选取算法，请参阅下面这篇 1993 年的论文： Bentley J L, McIlroy M D. Engineering a sort function[J]. Software: Practice and Experience, 1993, 23(11): 1249-1265.\n下面这份 2002 年的 PPT 详细解释和分析了官方实现代码的思路和性能： Sedgewick R, Bentley J. Quicksort is optimal[J]. Knuthfest, Stanford University, Stanford, 2002.\n有关选取中位数 Ninther 算法，请参阅下面这篇 1978 年的论文： Tukey J W. The ninther, a technique for low-effort robust (resistant) location in large samples[M]//Contributions to Survey Sampling and Applied Statistics. 1978: 251-257.\n以及按照惯例给出本题用到的类库链接： Quick 库\n"},{"id":269,"href":"/2-3-23/","title":"2.3.23","section":"《算法（第四版）》C# 题解","content":" 2.3.23 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/23quicksort/QuickBentleyMcIlroy.java.html\n见 2.3.22 的解答，其中已经包含了这些改动。\n代码 # QuickBentleyMcIlroy\npublic class QuickBentleyMcIlroy : BaseSort { /// \u0026lt;summary\u0026gt; /// 小于这个数值的数组调用插入排序。 /// \u0026lt;/summary\u0026gt; private readonly int _insertionSortCutoff = 8; /// \u0026lt;summary\u0026gt; /// 小于这个数值的数组调用中位数作为枢轴。 /// \u0026lt;/summary\u0026gt; private readonly int _medianOf3Cutoff = 40; /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 对指定范围内的数组进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { var n = hi - lo + 1; if (n \u0026lt;= _insertionSortCutoff) { InsertionSort(a, lo, hi); return; } if (n \u0026lt;= _medianOf3Cutoff) { // 对于较小的数组，直接选择左中右三个元素中的中位数作为枢轴。 var m = Median3(a, lo, lo + n / 2, hi); Exch(a, m, lo); } else { // 对于较大的数组使用 Turkey Ninther 作为枢轴。 var eps = n / 8; var mid = lo + n / 2; var m1 = Median3(a, lo, lo + eps, lo + eps + eps); var m2 = Median3(a, mid - eps, mid, mid + eps); var m3 = Median3(a, hi - eps - eps, hi - eps, hi); var ninther = Median3(a, m1, m2, m3); Exch(a, ninther, lo); } // 三向切分 int i = lo, j = hi + 1; int p = lo, q = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) { } while (Less(v, a[--j])) if (j == lo) break; if (i == j \u0026amp;\u0026amp; IsEqual(a[i], v)) Exch(a, ++p, i); if (i \u0026gt;= j) break; Exch(a, i, j); if (IsEqual(a[i], v)) Exch(a, ++p, i); if (IsEqual(a[j], v)) Exch(a, --q, j); } i = j + 1; for (var k = lo; k \u0026lt;= p; k++) Exch(a, k, j--); for (var k = hi; k \u0026gt;= q; k--) Exch(a, k, i++); Sort(a, lo, j); Sort(a, i, hi); } /// \u0026lt;summary\u0026gt; /// 判断两个元素是否值相等。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要判断的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;进行比较的第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;进行比较的第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;两个元素的值是否相等。\u0026lt;/returns\u0026gt; private bool IsEqual\u0026lt;T\u0026gt;(T a, T b) where T : IComparable\u0026lt;T\u0026gt; { return a.CompareTo(b) == 0; } /// \u0026lt;summary\u0026gt; /// 用插入排序对指定范围内的数组排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;数组的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序的终止下标。\u0026lt;/param\u0026gt; private void InsertionSort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { for (var i = lo; i \u0026lt;= hi; i++) { for (var j = i; j \u0026gt; lo \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) { Exch(a, j, j - 1); } } } /// \u0026lt;summary\u0026gt; /// 获取三个元素中的中位数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;用于排序的元素。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;第三个待选元素的下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt;，\u0026lt;paramref name=\u0026#34;j\u0026#34;/\u0026gt;，\u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的元素中的中位数下标。\u0026lt;/returns\u0026gt; private int Median3\u0026lt;T\u0026gt;(T[] a, int i, int j, int k) where T : IComparable\u0026lt;T\u0026gt; { return (Less(a[i], a[j]) ? (Less(a[j], a[k]) ? j : Less(a[i], a[k]) ? k : i) : (Less(a[k], a[j]) ? j : Less(a[k], a[i]) ? k : i)); } } 另请参阅 # Quick 库\n"},{"id":270,"href":"/2-3-24/","title":"2.3.24","section":"《算法（第四版）》C# 题解","content":" 2.3.24 # 解答 # 取样排序的想法很简单：\n常规快排的枢轴只有一个。\n如果用一个数组来充当枢轴，根据排序位置的不同自动选择对应的枢轴，\n显然能够更好的估计中位数，以求更好的切分效果。\n于是引入了「取样」的概念，假如我们从源数组中随机取了 3 个元素并对其排序，\n那么这 3 个元素的中位数可以作为第一次切分的枢轴，剩余两个元素则可以充当切分后两个子数组的枢轴。\n那么当取样元素到达一个合适的数量时，就能达到提升切分效率的目标。\n大致思路如下：\n首先先从输入数组里随机取一些元素，作为「取样数组」。\n用任意排序算法（比如快排）对取样数组进行排序。\n（由于取样数组通常都比较小，这一步的时间消耗通常不会影响性能）\n取出取样数组里面的中位数，当作枢轴对剩下的数组进行切分。\n之后的切分中，根据排序区间在剩余数组中的相对位置，\n用取样数组中对应位置的数作为枢轴，直到整个排序完成。\n论文里提到了两种实现方式。\n第一种方法\n取样数组和剩余数组是分开保存的。\n每次切分完成后，并不把枢轴放入剩余数组中，\n而是等到剩余数组全部排序完毕之后再用一次归并（merge）操作将取样数组和剩余数组归并。\n第二种方法\n取样数组和剩余数组保存在同一片空间里，这也是这份题解所实现的方法。\n在打乱输入数组之后，取前 2^k-1 个元素作为取样数组，用快排对其排序。\n然后把取样数组的后半部分放到整个数组的末尾。\n这样操作的结果是输入数组分为了四个部分：\n有序的取样数组、取样数组的中位数、无序的剩余数组、有序的取样数组。\n中位数则位于第一部分的末尾，我们将其作为枢轴对剩余数组进行切分，数组变为：\n有序的取样数组、小于中位数的部分、枢轴、大于中位数的部分、有序的取样数组\n接下来我们再对第一个部分取半，放到中位数之前；对最后一部分取半，放到中位数之后：\n0 ~ 1/4 取样数组、小于中位数、1/4 ~ 1/2 取样数组、枢轴、1/2~3/4 取样数组、大于中位数、3/4~1 取样数组\n你会发现枢轴前后又分别变回了初始条件，递归执行上述操作，便能对整个数组排序。\n注意当取样数组用完的时候，直接变回普通的快排。\n现代的取样排序\n这里的「现代」并不意味着更好，只是让取样排序能更好的适应多线程排序。\n首先仍然是取样，取样的数量往往取决于线程的数量，比如说取了 p-1 个，就将数组分为 p 份。\n对取样数组进行排序，获得 p 个区间（桶）。\n遍历输入的数组，把元素扔到相应的桶里面。\n把每个桶和对应的枢轴送到对应的线程进行排序。\n汇总各个桶中的结果，排序完毕。\n测试结果：\n大概能提升 5%~10% 的性能。\n代码 # /// \u0026lt;summary\u0026gt; /// 取样排序类。 /// \u0026lt;/summary\u0026gt; public class SampleSort : QuickSort { /// \u0026lt;summary\u0026gt; /// 取样数组长度 2^k - 1 的阶数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;取样数组长度的阶数。\u0026lt;/value\u0026gt; public int K { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public SampleSort() { K = 8; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { if (a.Length \u0026lt; Math.Pow(2, K + 1)) { // 小于 2^(k+1) 的数组直接进行快排 base.Sort(a); return; } Shuffle(a); var samplehi = (int)Math.Pow(2, K) - 2; // 利用快速排序对取样数组进行排序 base.Sort(a, 0, samplehi); // 找到取样数组的中位数 var sampleMedian = samplehi / 2; // 将取样数组后半部分放到数组末尾 int i = samplehi, j = a.Length - 1; while (i != sampleMedian) Exch(a, i--, j--); // 根据取样数组进行排序 Sort(a, 0, sampleMedian, j, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sampleLo\u0026#34;\u0026gt;取样数组的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;samplehi\u0026#34;\u0026gt;取样数组的终止下标。\u0026lt;/param\u0026gt; private void Sort\u0026lt;T\u0026gt;(T[] a, int sampleLo, int lo, int hi, int samplehi) where T : IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; var j = Partition(a, lo, hi); // 将前部的有序取样数组取半，后半部分放在枢轴前面。 if (lo - sampleLo \u0026gt; 1) { // p 应该始终指向有序部分的最后一项 // v 应该始终指向有序部分的前面一项 int p = lo - 1, v = j - 1; for (var i = 0; i \u0026lt; (lo - sampleLo) / 2; i++) { Exch(a, p--, v--); } Sort(a, sampleLo, p, v, j - 1); } else { // 取样数组已经用完，退化为普通 Quicksort base.Sort(a, sampleLo, j - 1); } // 将尾部有序取样数组取半，前半部分放在枢轴后面。 if (samplehi - hi \u0026gt; 1) { // p 应该始终指向有序部分的前面一项 // v 应该始终指向有序部分的最后一项 int p = hi, v = j; for (var i = 0; i \u0026lt; (samplehi - hi) / 2; i++) { Exch(a, ++p, ++v); } Sort(a, j + 1, v, p, samplehi); } else { // 取样数组已用完，退化为普通 Quicksort base.Sort(a, j + 1, samplehi); } } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例：\nvar quickNormal = new QuickSort(); var sampleSort = new SampleSort(); var arraySize = 1600000; // 初始数组大小。 const int kSteps = 10; // 取样 k 值的递增次数。 const int trialTimes = 1; // 每次实验的重复次数。 const int trialLevel = 2; // 双倍递增的次数。 Console.WriteLine(\u0026#34;k\\tn\\t\\tsample\\tnormal\\tratio\u0026#34;); for (var i = 0; i \u0026lt; kSteps; i++) { var array = arraySize; for (var j = 0; j \u0026lt; trialLevel; j++) { double timeSample = 0; double timeNormal = 0; for (var k = 0; k \u0026lt; trialTimes; k++) { var a = SortCompare.GetRandomArrayInt(array); var b = new int[a.Length]; a.CopyTo(b, 0); timeNormal += SortCompare.Time(quickNormal, b); timeSample += SortCompare.Time(sampleSort, a); } timeSample /= trialTimes; timeNormal /= trialTimes; if (arraySize \u0026lt; 10000000) Console.WriteLine( sampleSort.K + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\\t\u0026#34; + timeSample + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeSample / timeNormal); else Console.WriteLine( sampleSort.K + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\u0026#34; + timeSample + \u0026#34;\\t\u0026#34; + timeNormal + \u0026#34;\\t\u0026#34; + timeSample / timeNormal); array *= 2; } sampleSort.K++; } 另请参阅 # 关于取样排序的论文（1970 年）： Frazer W D, McKellar A C. Samplesort: A sampling approach to minimal storage tree sorting[J]. Journal of the ACM (JACM), 1970, 17(3): 496-507. 维基百科中的取样排序： Samplesort-Wikipedia 本题用到的类库链接： Quick 库\n"},{"id":271,"href":"/2-3-25/","title":"2.3.25","section":"《算法（第四版）》C# 题解","content":" 2.3.25 # 解答 # 切换到插入排序的实现比较简单，在类内添加一个成员变量 M，在 Sort 方法里添加如下代码：\nprotected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } 下面放上实验结果： N=1000\nN=10000\nN=100000\nN=1000000\n小于 8 的 M 值会比较合适。\n代码 # 这里使用了 Background Worker 来防止程序失去响应，更多信息可以看 「另请参阅」部分。\nusing System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._25 { public partial class Form2 : Form { /// \u0026lt;summary\u0026gt; /// 测试数组大小。 /// \u0026lt;/summary\u0026gt; public int N = 100; public Form2(int n) { InitializeComponent(); this.N = n; } /// \u0026lt;summary\u0026gt; /// 启动页面时启动后台测试。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt; /// 后台测试方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSortInsertion quickSortInsertion = new QuickSortInsertion(); double[] timeRecord = new double[31]; for (int i = 0; i \u0026lt;= 30; i++) { worker.ReportProgress(i * 3); quickSortInsertion.M = i; int[] data = SortCompare.GetRandomArrayInt(this.N); timeRecord[i] = SortCompare.Time(quickSortInsertion, data); } e.Result = timeRecord; } /// \u0026lt;summary\u0026gt; /// 更新后台进度方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在绘图，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt; /// 测试完毕，进行绘图的方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } double[] result = e.Result as double[]; Graphics graphics = this.CreateGraphics(); // 获得绘图区矩形。 RectangleF rect = this.ClientRectangle; float unitX = rect.Width / 10; float unitY = rect.Width / 10; // 添加 10% 边距作为文字区域。 RectangleF center = new RectangleF (rect.X + unitX, rect.Y + unitY, rect.Width - 2 * unitX, rect.Height - 2 * unitY); // 绘制坐标系。 graphics.DrawLine(Pens.Black, center.Left, center.Top, center.Left, center.Bottom); graphics.DrawLine(Pens.Black, center.Left, center.Bottom, center.Right, center.Bottom); graphics.DrawString(result.Max().ToString(), this.Font, Brushes.Black, rect.Location); graphics.DrawString(result.Length.ToString(), this.Font, Brushes.Black, center.Right, center.Bottom); graphics.DrawString(\u0026#34;0\u0026#34;, this.Font, Brushes.Black, rect.Left, center.Bottom); // 初始化点。 PointF[] bluePoints = new PointF[result.Length]; unitX = center.Width / result.Length; unitY = center.Height / (float)result.Max(); for (int i = 0; i \u0026lt; result.Length; i++) { bluePoints[i] = new PointF(center.Left + unitX * (i + 1), center.Bottom - (float)(result[i] * unitY) - 10); } // 绘制点。 for (int i = 0; i \u0026lt; result.Length; i++) { graphics.FillEllipse(Brushes.Blue, new RectangleF(bluePoints[i], new Size(10, 10))); } graphics.Dispose(); this.Text = \u0026#34;绘图结果\u0026#34;; int min = 0; for (int i = 0; i \u0026lt; result.Length; i++) { if (result[i] \u0026lt; result[min]) min = i; } string report = \u0026#34;M \u0026#34; + min + \u0026#34;\\r\\ntime \u0026#34; + result[min]; MessageBox.Show(report, \u0026#34;最优结果\u0026#34;); } } } 快速排序类\npublic class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortInsertion() { M = 8; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 另请参阅 # BackgroundWorker 组件 | Microsoft Docs Quick 库\n"},{"id":272,"href":"/2-3-26/","title":"2.3.26","section":"《算法（第四版）》C# 题解","content":" 2.3.26 # 解答 # 在切换为插入排序之前先记录一下当前子数组的大小。\n在排序类内添加一个大小为 M+1 的数组，用于记录每种数组大小出现的次数。\n结果如下（N=100000）： M=10\nM=20\nM=50\n代码 # using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._26 { public partial class Form2 : Form { private int M; private int N; public Form2(int m, int n) { InitializeComponent(); this.M = m; this.N = n; } /// \u0026lt;summary\u0026gt; /// 启动页面时启动后台测试。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt; /// 后台测试方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSortInsertion quickSortInsertion = new QuickSortInsertion { M = this.M }; int[] data = SortCompare.GetRandomArrayInt(this.N); worker.ReportProgress(50); quickSortInsertion.Sort(data); e.Result = quickSortInsertion.Counts; } /// \u0026lt;summary\u0026gt; /// 更新后台进度方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在绘图，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt; /// 测试完毕，进行绘图的方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } //新建画布 Graphics graphics = this.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); int[] countsOrigin = e.Result as int[]; int[] counts = new int[countsOrigin.Length - 1]; for (int i = 0; i \u0026lt; counts.Length; i++) { counts[i] = countsOrigin[i + 1]; } //获取最大值 double max = counts.Max(); //计算间距 double unit = this.Width / (3.0 * counts.Length + 1); double marginTop = 100; //计算直方图的矩形 Rectangle[] rects = new Rectangle[counts.Length]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * (this.Height - marginTop)); for (int i = 1; i \u0026lt; counts.Length; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * (this.Height - marginTop)); } //绘图 graphics.FillRectangles(Brushes.Black, rects); //释放资源 graphics.Dispose(); this.Text = \u0026#34;绘图结果，最高次数：\u0026#34; + counts.Max() + \u0026#34; 最低次数：\u0026#34; + counts.Min(); } } } 快速排序类\npublic class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } public int[] Counts; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortInsertion() { M = 8; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Counts = new int[M + 1]; for (var i = 0; i \u0026lt; M + 1; i++) { Counts[i] = 0; } Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { Counts[hi - lo]++; // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 另请参阅 # BackgroundWorker 组件 | Microsoft Docs Quick 库\n"},{"id":273,"href":"/2-3-27/","title":"2.3.27","section":"《算法（第四版）》C# 题解","content":" 2.3.27 # 解答 # 实验结果如下：\nP.S. 测试机上的缓存是 L1 128K，L2 512K，L3 4MB。\n代码 # QuickSortIgnore\npublic class QuickSortIgnore : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortIgnore() { M = 10; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); // 插入排序处理小数组 for (var i = 0; i \u0026lt; a.Length; i++) for (var j = i; j \u0026gt; 0 \u0026amp;\u0026amp; Less(a[j], a[j - 1]); j--) Exch(a, j, j - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { return; // 直接忽略 } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } QuickSortInsertion\npublic class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortInsertion() { M = 10; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例\nvar insertion = new QuickSortInsertion(); var ignore = new QuickSortIgnore(); var arraySize = 20000; // 初始数组大小。 const int mSteps = 1; // M 值的递增次数。 const int trialTimes = 4; // 每次实验的重复次数。 const int trialLevel = 10; // 双倍递增的次数。 Console.WriteLine(\u0026#34;M\\tn\\t\\tignore\\tinsert\\tratio\u0026#34;); for (var i = 0; i \u0026lt; mSteps; i++) { var array = arraySize; for (var j = 0; j \u0026lt; trialLevel; j++) { double timeIgnore = 0; double timeInsertion = 0; for (var k = 0; k \u0026lt; trialTimes; k++) { var a = SortCompare.GetRandomArrayInt(array); var b = new int[a.Length]; a.CopyTo(b, 0); timeInsertion += SortCompare.Time(insertion, b); timeIgnore += SortCompare.Time(ignore, a); } timeIgnore /= trialTimes; timeInsertion /= trialTimes; if (array \u0026lt; 10000000) Console.WriteLine( ignore.M + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\\t\u0026#34; + timeIgnore + \u0026#34;\\t\u0026#34; + timeInsertion + \u0026#34;\\t\u0026#34; + timeIgnore / timeInsertion); else Console.WriteLine( ignore.M + \u0026#34;\\t\u0026#34; + array + \u0026#34;\\t\u0026#34; + timeIgnore + \u0026#34;\\t\u0026#34; + timeInsertion + \u0026#34;\\t\u0026#34; + timeIgnore / timeInsertion); array *= 2; } ignore.M++; } 另请参阅 # Quick 库\n"},{"id":274,"href":"/2-3-28/","title":"2.3.28","section":"《算法（第四版）》C# 题解","content":" 2.3.28 # 解答 # 对 Sort 方法做修改，添加一个层层传递的 depth 参数，每加一层 depth 就加一，结束时取左右较大的 depth 返回。\nprotected int Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int depth) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return depth; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return depth; } var j = Partition(a, lo, hi); var left = Sort(a, lo, j - 1, depth + 1); var right = Sort(a, j + 1, hi, depth + 1); return Less(left, right) ? right : left; } 测试结果\n代码 # public class QuickSortInsertion : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } /// \u0026lt;summary\u0026gt; /// 上一次排序的最大递归深度。 /// \u0026lt;/summary\u0026gt; public int Depth { get; private set; } /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortInsertion() { M = 10; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;递归深度。\u0026lt;/returns\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Shuffle(a); Depth = Sort(a, 0, a.Length - 1, 0); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;depth\u0026#34;\u0026gt;深度。\u0026lt;/param\u0026gt; protected int Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int depth) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return depth; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return depth; } var j = Partition(a, lo, hi); var left = Sort(a, lo, j - 1, depth + 1); var right = Sort(a, j + 1, hi, depth + 1); return Less(left, right) ? right : left; } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } /// \u0026lt;summary\u0026gt; /// 打乱数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要打乱的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要打乱的数组。\u0026lt;/param\u0026gt; private void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } } 测试用例\nConsole.WriteLine(\u0026#34;M\\tN\\tDepth\u0026#34;); Trial(10); Trial(20); Trial(50); // 进行一次测试。 static void Trial(int m) { var sort = new QuickSortInsertion(); var trialTime = 5; // 由于排序前有 Shuffle，因此直接输入有序数组。 // M=10 sort.M = m; var totalDepth = 0; for (var n = 1000; n \u0026lt; 10000000; n *= 10) { for (var i = 0; i \u0026lt; trialTime; i++) { var a = new int[n]; for (var j = 0; j \u0026lt; n; j++) { a[j] = j; } sort.Sort(a); totalDepth += sort.Depth; } Console.WriteLine(sort.M + \u0026#34;\\t\u0026#34; + n + \u0026#34;\\t\u0026#34; + totalDepth / trialTime); } } 另请参阅 # Quick 库\n"},{"id":275,"href":"/2-3-29/","title":"2.3.29","section":"《算法（第四版）》C# 题解","content":" 2.3.29 # 解答 # 在快排类内部添加一个随机数发生器，每次随机取枢轴并交换至第一位进行切分。\nprivate int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var pivot = _randomGenerator.Next(hi - lo) + lo; Exch(a, pivot, lo); var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } 测试结果：\n代码 # 使用随机枢轴的快排\npublic class QuickSortRandomPivot : BaseSort { /// \u0026lt;summary\u0026gt; /// 切换到插入排序的阈值。 /// \u0026lt;/summary\u0026gt; public int M { get; set; } /// \u0026lt;summary\u0026gt; /// 随机数发生器。 /// \u0026lt;/summary\u0026gt; private readonly Random _randomGenerator = new(); /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public QuickSortRandomPivot() { M = 10; } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 进行升序排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public override void Sort\u0026lt;T\u0026gt;(T[] a) { Sort(a, 0, a.Length - 1); Debug.Assert(IsSorted(a)); } /// \u0026lt;summary\u0026gt; /// 用快速排序对数组 a 的 lo ~ hi 范围排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要排序的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;排序范围的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;排序范围的结束下标。\u0026lt;/param\u0026gt; protected void Sort\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T: IComparable\u0026lt;T\u0026gt; { if (hi \u0026lt;= lo) // 别越界 return; if (hi - lo \u0026lt;= M) { // 调用插入排序 for (var i = lo; i \u0026lt;= hi; i++) for (var k = i; k \u0026gt; lo \u0026amp;\u0026amp; Less(a[k], a[k - 1]); k--) Exch(a, k, k - 1); return; } var j = Partition(a, lo, hi); Sort(a, lo, j - 1); Sort(a, j + 1, hi); } /// \u0026lt;summary\u0026gt; /// 对数组进行切分，返回枢轴位置。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;需要切分的数组类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要切分的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;切分的起始点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;切分的末尾点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;枢轴下标。\u0026lt;/returns\u0026gt; private int Partition\u0026lt;T\u0026gt;(T[] a, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { int i = lo, j = hi + 1; var pivot = _randomGenerator.Next(hi - lo) + lo; Exch(a, pivot, lo); var v = a[lo]; while (true) { while (Less(a[++i], v)) if (i == hi) break; while (Less(v, a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; Exch(a, i, j); } Exch(a, lo, j); return j; } } 测试用例\nConsole.WriteLine(\u0026#34;M\\tN\\tshuffle\\trandom\\tshuffle/random\u0026#34;); Trial(10); Trial(20); Trial(50); // 进行一次测试。 static void Trial(int m) { var withShuffle = new QuickSortInsertion(); var randomPivot = new QuickSortRandomPivot(); var trialTime = 5; // M=10 withShuffle.M = m; randomPivot.M = m; double timeShuffle = 0; double timeRandomPivot = 0; for (var n = 1000; n \u0026lt; 10000000; n *= 10) { for (var i = 0; i \u0026lt; trialTime; i++) { var a = new int[n]; var b = new int[n]; for (var j = 0; j \u0026lt; n; j++) { a[j] = j; } Shuffle(a); a.CopyTo(b, 0); timeShuffle += SortCompare.Time(withShuffle, a); timeRandomPivot += SortCompare.Time(randomPivot, b); } timeShuffle /= trialTime; timeRandomPivot /= trialTime; Console.WriteLine( withShuffle.M + \u0026#34;\\t\u0026#34; + n + \u0026#34;\\t\u0026#34; + timeShuffle + \u0026#34;\\t\u0026#34; + timeRandomPivot + \u0026#34;\\t\u0026#34; + timeShuffle / timeRandomPivot); } } // 打乱数组。 static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # Quick 库\n"},{"id":276,"href":"/2-3-30/","title":"2.3.30","section":"《算法（第四版）》C# 题解","content":" 2.3.30 # 解答 # 结果如下，在 N=5000000 时，随机选择枢轴会比事先打乱快一点。 代码 # var insertionSort = new QuickSortInsertion(); var randomSort = new QuickSortRandomPivot(); var n = 5000000; // 高斯分布（正态分布） var arrayInsertion = SortCompare.GetNormalDistributionArray(n); var arraySelection = new double[n]; arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Normal Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 泊松分布 arrayInsertion = SortCompare.GetPossionDistributionArray(n); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Poission Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 几何分布 arrayInsertion = SortCompare.GetGeometricDistributionArray(n, 0.3); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Geometric Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 离散分布 arrayInsertion = SortCompare.GetDiscretDistributionArray(n, new[] { 0.1, 0.2, 0.3, 0.1, 0.1, 0.1, 0.1 }); arrayInsertion.CopyTo(arraySelection, 0); Console.WriteLine(\u0026#34;Discret Distribution:\u0026#34;); Console.WriteLine(\u0026#34;Insertion: \u0026#34; + SortCompare.Time(insertionSort, arrayInsertion)); Console.WriteLine(\u0026#34;Random Pivot: \u0026#34; + SortCompare.Time(randomSort, arraySelection)); Console.WriteLine(); // 一半是 0 一半是 1 var arrayNormalInsertion = HalfZeroHalfOne(n); var arrayRandomPivot = new int[n]; arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half 0 and half 1\u0026#34;); Console.WriteLine(\u0026#34;Insertion:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); Console.WriteLine(); // 一半是 0， 1/4 是 1， 1/8 是 2…… arrayNormalInsertion = HalfAndHalf(n); arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half and half and half ...\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); Console.WriteLine(); // 一半是 0，一半是随机 int 值 arrayNormalInsertion = HalfZeroHalfRandom(n); arrayNormalInsertion.CopyTo(arrayRandomPivot, 0); Console.WriteLine(\u0026#34;half 0 half random\u0026#34;); Console.WriteLine(\u0026#34;Insertion Sort:\u0026#34; + SortCompare.Time(insertionSort, arrayNormalInsertion)); Console.WriteLine(\u0026#34;Random Pivot:\u0026#34; + SortCompare.Time(randomSort, arrayRandomPivot)); // 获取一半是 0 一半是 1 的随机 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfZeroHalfOne(int n) { var result = new int[n]; var random = new Random(); for (var i = 0; i \u0026lt; n; i++) { if (random.NextDouble() \u0026gt;= 0.5) { result[i] = 0; } else { result[i] = 1; } } return result; } // 生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfAndHalf(int n) { var array = new int[n]; HalfIt(0, 0, n / 2, array); Shuffle(array); return array; } // 递归生成 1/2 为 0， 1/4 为 1， 1/8 为 2 …… 的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfIt(int start, int number, int length, int[] array) { if (length == 0) return array; for (var i = 0; i \u0026lt; length; i++) { array[start + i] = number; } return HalfIt(start + length, number + 1, length / 2, array); } // 生成一半是 0 一半是随机整数的 \u0026lt;see cref=\u0026#34;int\u0026#34;/\u0026gt; 数组。 static int[] HalfZeroHalfRandom(int n) { var array = new int[n]; var random = new Random(); for (var i = 0; i \u0026lt; n / 2; i++) { array[i] = 0; } for (var i = n / 2; i \u0026lt; n; i++) { array[i] = random.Next(); } Shuffle(array); return array; } // 打乱数组。 static void Shuffle(int[] a) { var n = a.Length; var random = new Random(); for (var i = 0; i \u0026lt; n; i++) { var r = i + random.Next(n - i); // 等于StdRandom.uniform(N-i) var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # Quick 库\n"},{"id":277,"href":"/2-3-31/","title":"2.3.31","section":"《算法（第四版）》C# 题解","content":" 2.3.31 # 解答 # 以下所有结果 T=70\nN=1000 N=10000 N=100000 N=1000000 代码 # using System; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Windows.Forms; using Quick; namespace _2._3._31 { public partial class Form2 : Form { private int N; private int T; public Form2(int n, int t) { InitializeComponent(); this.N = n; this.T = t; } /// \u0026lt;summary\u0026gt; /// 启动页面时启动后台测试。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void Form2_Shown(object sender, EventArgs e) { this.Text = \u0026#34;正在绘图\u0026#34;; this.backgroundWorker1.RunWorkerAsync(); } /// \u0026lt;summary\u0026gt; /// 后台测试方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) { BackgroundWorker worker = sender as BackgroundWorker; QuickSort quick = new QuickSort(); double percentPerTrial = 100.0 / this.T; double[] totalTime = new double[this.T]; for (int i = 0; i \u0026lt; this.T; i++) { double[] data = SortCompare.GetRandomArrayDouble(this.N); totalTime[i] = SortCompare.Time(quick, data); worker.ReportProgress((int)(percentPerTrial * i)); } e.Result = totalTime; } /// \u0026lt;summary\u0026gt; /// 更新后台进度方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) { this.Text = \u0026#34;正在测试，已完成 \u0026#34; + e.ProgressPercentage + \u0026#34; %\u0026#34;; } /// \u0026lt;summary\u0026gt; /// 测试完毕，进行绘图的方法。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Error != null) { MessageBox.Show(e.Error.Message); } //新建画布 Graphics graphics = this.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, this.Height); graphics.ScaleTransform(1, -1); double[] counts = e.Result as double[]; //获取最大值 double max = counts.Max(); //计算间距 double unit = this.Width / (3.0 * counts.Length + 1); double marginTop = 100; //计算直方图的矩形 Rectangle[] rects = new Rectangle[counts.Length]; rects[0].X = (int)unit; rects[0].Y = 0; rects[0].Width = (int)(2 * unit); rects[0].Height = (int)((counts[0] / max) * (this.Height - marginTop)); for (int i = 1; i \u0026lt; counts.Length; ++i) { rects[i].X = (int)(rects[i - 1].X + 3 * unit); rects[i].Y = 0; rects[i].Width = (int)(2 * unit); rects[i].Height = (int)((counts[i] / (max + 1)) * (this.Height - marginTop)); } //绘图 graphics.FillRectangles(Brushes.Black, rects); //释放资源 graphics.Dispose(); this.Text = \u0026#34;绘图结果，最高耗时：\u0026#34; + counts.Max() + \u0026#34; 最低耗时：\u0026#34; + counts.Min(); } } } 另请参阅 # BackgroundWorker 组件 | Microsoft Docs Quick 库\n"},{"id":278,"href":"/2-4-1/","title":"2.4.1","section":"《算法（第四版）》C# 题解","content":" 2.4.1 # 解答 # R R P O T Y I I U Q E U 优先队列的变化如下：\n输入命令 优先队列 输出 P P R P R I P R I O P R I O * P I O R R P I O R * P I O R * I O P I I O I * I I O T I I T * I I T Y I I Y * I I Y * I I * I Q Q U Q U E Q U E * Q E U * E Q * E U U * U E E "},{"id":279,"href":"/2-4-2/","title":"2.4.2","section":"《算法（第四版）》C# 题解","content":" 2.4.2 # 解答 # 这种方式只能取出一次最大值，这个最大值就是输入序列里面的最大值。\n当需要继续取出最大值时（即继续取第二大、第三大、第 i 大的元素），\n这个方法就不再适用了（或者说不能在常数时间内完成）。\n"},{"id":280,"href":"/2-4-3/","title":"2.4.3","section":"《算法（第四版）》C# 题解","content":" 2.4.3 # 解答 # 有序数组的官方版本：https://algs4.cs.princeton.edu/24pq/OrderedArrayMaxPQ.java.html\n无序数组的官方版本：https://algs4.cs.princeton.edu/24pq/UnorderedArrayMaxPQ.java.html\n实现 insert() delMax() 有序数组 N 1 有序链表 N 1 无序数组 1 N 无序链表 1 N 在库文件中定义了如下接口，所有的（最大）优先队列都会实现它。\n/// \u0026lt;summary\u0026gt; /// 实现优先队列 API 的接口。（最大堆） /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TKey\u0026#34;\u0026gt;优先队列容纳的元素。\u0026lt;/typeparam\u0026gt; public interface IMaxPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 向优先队列中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;插入元素的类型。\u0026lt;/param\u0026gt; void Insert(TKey v); /// \u0026lt;summary\u0026gt; /// 返回最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的元素。\u0026lt;/returns\u0026gt; TKey Max(); /// \u0026lt;summary\u0026gt; /// 删除并返回最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的元素。\u0026lt;/returns\u0026gt; TKey DelMax(); /// \u0026lt;summary\u0026gt; /// 返回队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; bool IsEmpty(); /// \u0026lt;summary\u0026gt; /// 返回队列中的元素个数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;队列中的元素个数。\u0026lt;/returns\u0026gt; int Size(); } 于是我们就可以使用这样的方法测试所有类型的优先队列：\nstatic void Test(IMaxPq\u0026lt;string\u0026gt; pq) { Console.WriteLine(pq.ToString()); pq.Insert(\u0026#34;this\u0026#34;); pq.Insert(\u0026#34;is\u0026#34;); pq.Insert(\u0026#34;a\u0026#34;); pq.Insert(\u0026#34;test\u0026#34;); while (!pq.IsEmpty()) Console.Write(pq.DelMax() + \u0026#34; \u0026#34;); Console.WriteLine(); } 代码 # 给出链表的实现，基于数组的实现可以点击「另请参阅」中的 PriorityQueue 库查看。\n无序链表 # public class UnorderedLinkedMaxPq\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 保存元素的链表。 /// \u0026lt;/summary\u0026gt; private readonly LinkedList\u0026lt;TKey\u0026gt; _pq; /// \u0026lt;summary\u0026gt; /// 默认构造函数，建立一条优先队列。 /// \u0026lt;/summary\u0026gt; public UnorderedLinkedMaxPq() { _pq = new LinkedList\u0026lt;TKey\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 获得（但不删除）优先队列中的最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中的最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得并删除最大元素，请使用 \u0026lt;see cref=\u0026#34;DelMax\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Max() { var max = 0; for (var i = 1; i \u0026lt; _pq.Size(); i++) if (Less(_pq.Find(max), _pq.Find(i))) max = i; return _pq.Find(max); } /// \u0026lt;summary\u0026gt; /// 返回并删除优先队列中的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中的最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最大元素但不删除它，请使用 \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMax() { var max = 0; for (var i = 1; i \u0026lt; _pq.Size(); i++) if (Less(_pq.Find(max), _pq.Find(i))) max = i; return _pq.Delete(max); } /// \u0026lt;summary\u0026gt; /// 向优先队列中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) =\u0026gt; _pq.Insert(v); /// \u0026lt;summary\u0026gt; /// 检查优先队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果队列为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _pq.IsEmpty(); /// \u0026lt;summary\u0026gt; /// 检查优先队列中含有的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中含有元素的数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _pq.Size(); /// \u0026lt;summary\u0026gt; /// 比较第一个元素是否小于第二个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(TKey a, TKey b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; } 有序链表\npublic class OrderedLinkedMaxPq\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 用于保存元素的链表。 /// \u0026lt;/summary\u0026gt; private readonly LinkedList\u0026lt;TKey\u0026gt; _pq; /// \u0026lt;summary\u0026gt; /// 默认构造函数，建立一条优先队列。 /// \u0026lt;/summary\u0026gt; public OrderedLinkedMaxPq() { _pq = new LinkedList\u0026lt;TKey\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 向优先队列中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) { var i = _pq.Size() - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; Less(v, _pq.Find(i))) i--; _pq.Insert(v, i + 1); } /// \u0026lt;summary\u0026gt; /// 返回并删除优先队列中的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中的最大值。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最大值而不删除它，请使用 \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMax() =\u0026gt; _pq.Delete(_pq.Size() - 1); /// \u0026lt;summary\u0026gt; /// 检查优先队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _pq.IsEmpty(); /// \u0026lt;summary\u0026gt; /// 获得（但不删除）优先队列中的最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中的最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得并删除最大元素，请使用 \u0026lt;see cref=\u0026#34;DelMax\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Max() =\u0026gt; _pq.Find(_pq.Size() - 1); /// \u0026lt;summary\u0026gt; /// 检查优先队列中含有的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;优先队列中的元素数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _pq.Size(); /// \u0026lt;summary\u0026gt; /// 比较第一个元素是否小于第二个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(TKey a, TKey b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; } 另请参阅 # PriorityQueue 库\n"},{"id":281,"href":"/2-4-4/","title":"2.4.4","section":"《算法（第四版）》C# 题解","content":" 2.4.4 # 解答 # 是的。\n例如这个数组：9 8 7 6 5，画成二叉堆如下：\n"},{"id":282,"href":"/2-4-5/","title":"2.4.5","section":"《算法（第四版）》C# 题解","content":" 2.4.5 # 解答 # "},{"id":283,"href":"/2-4-6/","title":"2.4.6","section":"《算法（第四版）》C# 题解","content":" 2.4.6 # 解答 # 官方给出的最大堆实现：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n运行示意图：\n运行结果：\nP R P R P I R P I O P O I R P I O P O I O I O I I I I T I I I I Y I I I I I Q U Q U Q E Q E E U E 代码 # 最大堆的实现\npublic class MaxPq\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt;, IEnumerable\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 保存元素的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;保存元素的数组。\u0026lt;/value\u0026gt; protected TKey[] Pq; /// \u0026lt;summary\u0026gt; /// 堆中的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中的元素数量。\u0026lt;/value\u0026gt; protected int N; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public MaxPq() : this(1) { } /// \u0026lt;summary\u0026gt; /// 建立指定容量的最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt; public MaxPq(int capacity) { Pq = new TKey[capacity + 1]; N = 0; } /// \u0026lt;summary\u0026gt; /// 从已有元素建立一个最大堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt; public MaxPq(TKey[] keys) { N = keys.Length; Pq = new TKey[keys.Length + 1]; for (var i = 0; i \u0026lt; keys.Length; i++) Pq[i + 1] = keys[i]; for (var k = N / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt; /// 删除并返回最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;当堆为空时抛出该异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得但不删除最大元素，请使用 \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMax() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); var max = Pq[1]; Exch(1, N--); Sink(1); Pq[N + 1] = default; if ((N \u0026gt; 0) \u0026amp;\u0026amp; (N == Pq.Length / 4)) Resize(Pq.Length / 2); // Debug.Assert(IsMaxHeap()); return max; } /// \u0026lt;summary\u0026gt; /// 向堆中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) { if (N == Pq.Length - 1) Resize(2 * Pq.Length); Pq[++N] = v; Swim(N); // Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt; /// 删除一个结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;结点下标。\u0026lt;/param\u0026gt; internal void Remove(int k) { if (k == N) { Pq[N--] = default; return; } if (N \u0026lt;= 2) { Exch(1, k); Pq[N--] = default; return; } Exch(k, N--); Pq[N + 1] = default; Swim(k); Sink(k); } /// \u0026lt;summary\u0026gt; /// 检查堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;当堆为空时返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; N == 0; /// \u0026lt;summary\u0026gt; /// 获得堆中最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望删除并返回最大元素，请使用 \u0026lt;see cref=\u0026#34;DelMax\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Max() =\u0026gt; Pq[1]; /// \u0026lt;summary\u0026gt; /// 获得堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中元素数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; N; /// \u0026lt;summary\u0026gt; /// 输出最大堆中的元素，元素之间用空格分隔。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;形如 A B C D 的字符串。\u0026lt;/returns\u0026gt; public override string ToString() { var sb = new StringBuilder(); for (var i = 1; i \u0026lt; Pq.Length; i++) sb.Append(Pq[i] + \u0026#34; \u0026#34;); return sb.ToString(); } /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以降序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大堆的迭代器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TKey\u0026gt; GetEnumerator() { var copy = new MaxPq\u0026lt;TKey\u0026gt;(N); for (var i = 1; i \u0026lt;= N; i++) copy.Insert(Pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。 } /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以降序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大堆的迭代器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;实际调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt; 方法。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { while (k * 2 \u0026lt;= N) { var j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { var temp = new TKey[capacity]; for (var i = 1; i \u0026lt;= N; i++) { temp[i] = Pq[i]; } Pq = temp; } /// \u0026lt;summary\u0026gt; /// 判断堆中某个元素是否小于另一元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;若下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的元素较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(int i, int j) =\u0026gt; Pq[i].CompareTo(Pq[j]) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt; protected virtual void Exch(int i, int j) { var swap = Pq[i]; Pq[i] = Pq[j]; Pq[j] = swap; } /// \u0026lt;summary\u0026gt; /// 检查当前二叉树是不是一个最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMaxHeap() =\u0026gt; IsMaxHeap(1); /// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMaxHeap(int k) { if (k \u0026gt; N) return true; var left = 2 * k; var right = 2 * k + 1; if (left \u0026lt;= N \u0026amp;\u0026amp; Less(k, left)) return false; if (right \u0026lt;= N \u0026amp;\u0026amp; Less(k, right)) return false; return IsMaxHeap(left) \u0026amp;\u0026amp; IsMaxHeap(right); } } 另请参阅 # PriorityQueue 库\n"},{"id":284,"href":"/2-4-7/","title":"2.4.7","section":"《算法（第四版）》C# 题解","content":" 2.4.7 # 解答 # k = 2 时， 只可能出现在位置 2、3 上（根节点的子结点，深度为 2，根节点深度为 1）\nk = 3 时， 可以直接是根节点的子结点（第 2 或第 3 位，深度为 2），\n也可以是第二大元素的子结点（第 4~7 位，也就是深度为 3 的所有位置）\nk = 4 时，\n可以直接是根节点的子结点（深度为 2 的点）\n也可以是第二大元素的子结点（深度为 3 的点）\n也可以是第三大元素的子结点（深度为 4 的点）\n故范围为第 2~15 位。\n不难看出第 k 大元素只可能出现在深度＜k 的位置（$k \\ge 2$）\n即位置小于 $2 ^ k - 1, (k \\ge 2)$\n"},{"id":285,"href":"/2-4-8/","title":"2.4.8","section":"《算法（第四版）》C# 题解","content":" 2.4.8 # 解答 # 不难看出第 k 大元素只可能出现在深度＜k 的位置（$ k \\ge 2$）\n即位置小于 $ 2^k - 1, (k \\ge 2)$。\n出现范围为 $[2, \\min {2^k -1, n}]$，其中 n 为堆的大小。\n"},{"id":286,"href":"/2-4-9/","title":"2.4.9","section":"《算法（第四版）》C# 题解","content":" 2.4.9 # 解答 # 首先 A B C D E 中，根节点必须是 E （假设为最大堆）\nD 只能选择 E 作为父结点。\nC 可以选择 D 或者 E 作为父结点。\nB 可以选择 C 或 D 或 E 作为父结点。\nA 可以选择 B 或 C 或 D 或 E 作为父结点。\n又由于堆的大小为 5，堆的结构固定，一共三层。\nE 只能为根节点\nD 可以在左侧或者右侧\n当 D 在左侧时，\nD 的子结点可以在 A B C 中任取两个，剩下一个当 E 的右侧子结点\n总共有 A(3, 2) = 6 种\n当 D 在右侧时，\nC 的子结点只能取 A 和 B ，故只有 A(2, 2) = 2 种情况。\n综上，最大堆总共有 6 + 2 = 8 种构造堆的方式。\n最小堆的构造同理，也有 8 种构造方式。\n故总共有 8 + 8 = 16 种构造方式。\n构造方式（最大堆）：\n最大堆\nB 只能作为 B 的子结点，A 可以是 B 或 A 的子结点。\n根节点恒为 B\n第二层结点有两种选择 A B 和 B A\n第三层只有一种选择 A A\n故总共有两种构造堆的方式。\n最小堆\n根节点恒为 A\n第二层可以是 A A 或 A B\n第二层是 A A 时\n第三层只能选择 B B\n第二层时 A B 时\n第三层可选择 A B 或 B A\n故总共有三种构造堆的方式。\n综上所述，总共有 2 + 3 = 5 种构造方式。\n构造方式（全部）：\n"},{"id":287,"href":"/2-4-10/","title":"2.4.10","section":"《算法（第四版）》C# 题解","content":" 2.4.10 # 解答 # 左子树位于 $2k+1$，右子树位于 $2k+2$，父结点位于 $\\lfloor (i-1)/2 \\rfloor$ 。\n"},{"id":288,"href":"/2-4-11/","title":"2.4.11","section":"《算法（第四版）》C# 题解","content":" 2.4.11 # 解答 # 有大量插入操作，选择插入操作为常数级别的无序数组实现较为合适。\n"},{"id":289,"href":"/2-4-12/","title":"2.4.12","section":"《算法（第四版）》C# 题解","content":" 2.4.12 # 解答 # 堆实现会略优于有序数组实现。\n有序数组，查找最大元素操作是 O(1) 的，插入/删除元素是 O(N) 的。\n堆要看具体实现，基于数组的实现和有序数组类似，但插入/删除元素的效率更优。\n注：\n官网给出的堆实现会在插入 / 删除操作之后对整个数组进行检查，\n确认是否为最大堆（isMaxHeap 方法）。\n在测试时务必删除/注释掉这部分代码。\n"},{"id":290,"href":"/2-4-13/","title":"2.4.13","section":"《算法（第四版）》C# 题解","content":" 2.4.13 # 解答 # 在官方实现的基础上直接删除 j\u0026lt;N 语句，随后在 DelMax() 方法中在 Sink(1) 之前让 pq[n + 1] = pq[1] 即可。\n首先保存最大值，然后把堆中的第一个元素和最后一个元素交换，随后使 n = n - 1。\n随后让 pq[n + 1] = pq[1]，这样在下沉操作时就不会下沉到 pq[n + 1]了。（相等的元素是不会交换的）\n故之后的 Sink() 语句中不再需要进行边界判断，直接删去即可。\n修改后 DelMax() 的代码如下：\npublic Key DelMax() { if (IsEmpty()) throw new ArgumentOutOfRangeException(\u0026#34;Priority Queue Underflow\u0026#34;); Key max = pq[1]; Exch(1, n--); pq[n + 1] = pq[1]; Sink(1); pq[n + 1] = default; if ((n \u0026gt; 0) \u0026amp;\u0026amp; (n == pq.Length / 4)) Resize(pq.Length / 2); Debug.Assert(IsMaxHeap()); return max; } "},{"id":291,"href":"/2-4-14/","title":"2.4.14","section":"《算法（第四版）》C# 题解","content":" 2.4.14 # 解答 # 对于 n \u0026lt;= 2 的堆\n第一步让最大元素和末端元素交换。\n第二步下沉时由于 n \u0026lt;= 1，不需要交换。\n故总共发生了一次交换，两个元素发生了交换。\n对于 n = 3 的堆\n第一步让最大元素和末端元素交换。\n第二步如果末端元素大于另一侧的子结点，那么就不需要交换。\n故最优情况时总共发生一次交换，两个元素被交换。\n对于 n \u0026gt; 3 的堆。\n第一步需要让最末端元素和最大元素交换。\n由于堆中第二大的元素必定位于根节点之后。\n故最末端元素一定小于该第二大元素。\n因此在下沉操作时必定会和第二大元素进行交换。\n故至少发生两次交换，总共有三个元素发生了交换。\n构造的堆（n=15）\n92 和 100 交换，随后 92 和 99 交换\n构造最优情况堆的方式如下（取根结点为 100）：\n对于每个结点，左子结点大于右子结点，\n且左子结点的子元素都小于右子树的最小值，\n（上例中省略了这部分元素，可以将它们当作负数）\n于是第一次 DelMax 的时候，只需要两次交换，三个元素被交换。（即 87 最后被交换到上例中 99 的位置）\n第二次 DelMax 的时候，只需要三次交换，六个元素被交换. （88 交换到 97 的位置）\n因此当 n \u0026gt; 7 时，连续两次 DelMax() 最少只需要 5 次交换。\n第三次 DelMax 的时候，只需要四次交换，九个元素被交换。（89 交换到 95 的位置）\n因此当 n \u0026gt; 15 时，连续三次 DelMax() 最少只需要 9 次交换。\n"},{"id":292,"href":"/2-4-15/","title":"2.4.15","section":"《算法（第四版）》C# 题解","content":" 2.4.15 # 解答 # MinPQ 的官方实现见：https://algs4.cs.princeton.edu/24pq/MinPQ.java.html\n事实上只需要把 MaxPQ 中的比较调换方向即可。\n在线性时间内检测是否是面向最小元素的堆的方法：\n/// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private bool IsMinHeap(int k) { if (k \u0026gt; this.n) return true; int left = 2 * k; int right = 2 * k + 1; if (left \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= this.n \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } 用递归方法遍历整个二叉树，确认都满足堆的性质。由于每个结点都只会被比较三次（与父结点比较一次，与每个子结点各比较一次），由于 3N~N，因此这个方法是 O(n) 的。\n代码 # 最小堆的接口 IMinPQ。\npublic interface IMinPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 向优先队列中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;插入元素的类型。\u0026lt;/param\u0026gt; void Insert(TKey v); /// \u0026lt;summary\u0026gt; /// 返回最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小的元素。\u0026lt;/returns\u0026gt; TKey Min(); /// \u0026lt;summary\u0026gt; /// 删除并返回最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小的元素。\u0026lt;/returns\u0026gt; TKey DelMin(); /// \u0026lt;summary\u0026gt; /// 返回队列是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; bool IsEmpty(); /// \u0026lt;summary\u0026gt; /// 返回队列中的元素个数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;队列中的元素个数。\u0026lt;/returns\u0026gt; int Size(); } MinPQ.cs\npublic class MinPq\u0026lt;TKey\u0026gt; : IMinPq\u0026lt;TKey\u0026gt;, IEnumerable\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 保存元素的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;保存元素的数组。\u0026lt;/value\u0026gt; protected TKey[] Pq; /// \u0026lt;summary\u0026gt; /// 堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中元素的数量。\u0026lt;/value\u0026gt; protected int N; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public MinPq() : this(1) { } /// \u0026lt;summary\u0026gt; /// 建立指定容量的最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最小堆的容量。\u0026lt;/param\u0026gt; public MinPq(int capacity) { Pq = new TKey[capacity + 1]; N = 0; } /// \u0026lt;summary\u0026gt; /// 从已有元素建立一个最小堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt; public MinPq(TKey[] keys) { N = keys.Length; Pq = new TKey[keys.Length + 1]; for (var i = 0; i \u0026lt; keys.Length; i++) Pq[i + 1] = keys[i]; for (var k = N / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMinHeap()); } /// \u0026lt;summary\u0026gt; /// 删除并返回最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;如果堆为空则抛出该异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最小值但不删除它，请使用 \u0026lt;see cref=\u0026#34;Min\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMin() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); var min = Pq[1]; Exch(1, N--); Sink(1); Pq[N + 1] = default; if ((N \u0026gt; 0) \u0026amp;\u0026amp; (N == Pq.Length / 4)) Resize(Pq.Length / 2); //Debug.Assert(IsMinHeap()); return min; } /// \u0026lt;summary\u0026gt; /// 删除指定元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;元素下标。\u0026lt;/param\u0026gt; internal void Remove(int k) { if (k == N) { Pq[N--] = default; return; } if (N \u0026lt;= 2) { Exch(1, k); Pq[N--] = default; return; } Exch(k, N--); Pq[N + 1] = default; Swim(k); Sink(k); } /// \u0026lt;summary\u0026gt; /// 向堆中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) { if (N == Pq.Length - 1) Resize(2 * Pq.Length); Pq[++N] = v; Swim(N); //Debug.Assert(IsMinHeap()); } /// \u0026lt;summary\u0026gt; /// 检查堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果堆为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; N == 0; /// \u0026lt;summary\u0026gt; /// 获得堆中最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中最小元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得并删除最小元素，请使用 \u0026lt;see cref=\u0026#34;DelMin\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Min() =\u0026gt; Pq[1]; /// \u0026lt;summary\u0026gt; /// 获得堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中元素的数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; N; /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以升序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小堆的迭代器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TKey\u0026gt; GetEnumerator() { var copy = new MinPq\u0026lt;TKey\u0026gt;(N); for (var i = 1; i \u0026lt;= N; i++) copy.Insert(Pq[i]); while (!copy.IsEmpty()) yield return copy.DelMin(); // 下次迭代的时候从这里继续执行。 } /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以升序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小堆的迭代器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;该方法实际调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt; 方法。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Greater(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { while (k * 2 \u0026lt;= N) { var j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; Greater(j, j + 1)) j++; if (!Greater(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { var temp = new TKey[capacity]; for (var i = 1; i \u0026lt;= N; i++) { temp[i] = Pq[i]; } Pq = temp; } /// \u0026lt;summary\u0026gt; /// 判断堆中某个元素是否大于另一元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的元素较大，则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Greater(int i, int j) =\u0026gt; Pq[i].CompareTo(Pq[j]) \u0026gt; 0; /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt; protected virtual void Exch(int i, int j) { var swap = Pq[i]; Pq[i] = Pq[j]; Pq[j] = swap; } /// \u0026lt;summary\u0026gt; /// 检查当前二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMinHeap() =\u0026gt; IsMinHeap(1); /// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMinHeap(int k) { if (k \u0026gt; N) return true; var left = 2 * k; var right = 2 * k + 1; if (left \u0026lt;= N \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= N \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } } 另请参阅 # PriorityQueue 库\n"},{"id":293,"href":"/2-4-16/","title":"2.4.16","section":"《算法（第四版）》C# 题解","content":" 2.4.16 # 解答 # 最好情况比较简单，只需要一个所有键值完全相同的数组即可。\n最坏情况的构造方法参考了一篇论文（见「另请参阅」部分），结果如下：\n最好输入： 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n最坏输入： 1 4 7 12 10 16 14 19 17 20 5 27 8 28 2 24 9 18 6 23 11 22 21 31 13 26 25 30 15 29 3 32\n代码 # 用于构造堆排序最坏情况的类。\npublic class MaxPqWorstCase { /// \u0026lt;summary\u0026gt; /// 保存元素的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;保存元素的数组。\u0026lt;/value\u0026gt; private readonly int[] _pq; /// \u0026lt;summary\u0026gt; /// 堆中的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中的元素数量。\u0026lt;/value\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 建立指定容量的最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt; public MaxPqWorstCase(int capacity) { _pq = new int[capacity + 1]; _n = 0; } /// \u0026lt;summary\u0026gt; /// 制造堆排序的最坏情况。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;需要构造的数组大小。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;最坏情况的输入数组。\u0026lt;/returns\u0026gt; public int[] MakeWorst(int n) { var strategy = Win(n); for (var i = 0; i \u0026lt; strategy.Length; i++) { UnRemoveMax(strategy[i]); } for (var i = 1; i \u0026lt;= _n / 2; i++) UnFixHeap(i); var worstCase = new int[n]; for (var i = 1; i \u0026lt;= n; i++) worstCase[i - 1] = _pq[i]; return worstCase; } private bool Less(int i, int j) =\u0026gt; _pq[i].CompareTo(_pq[j]) \u0026lt; 0; private int PullDown(int i, int j) { var toReturn = _pq[j]; for (var m = j; m / 2 \u0026gt;= i; m /= 2) { _pq[m] = _pq[m / 2]; } return toReturn; } private void UnFixHeap(int i) { var j = (int)(i * Math.Pow(2, Math.Floor(Math.Log10(_n / i) / Math.Log10(2)))); _pq[i] = PullDown(i, j); } private void UnRemoveMax(int i) { var p = (_n + 1) / 2; if (Less(p, i)) return; _n++; _pq[_n] = PullDown(1, i); _pq[1] = _n; } private int[] Par(int l) { var n = (int)Math.Pow(2, l) - 1; int[] s7 = { 0, 1, 2, 3, 4, 4, 5 }; var strategy = new int[n]; for (var i = 0; i \u0026lt; Math.Min(n, 7); i++) { strategy[i] = s7[i]; } if (n \u0026lt;= 7) return strategy; for (var lev = 3; lev \u0026lt; l; lev++) { var i = (int)Math.Pow(2, lev) - 1; strategy[i] = i; strategy[i + 1] = i - 1; strategy[i + 2] = i + 1; strategy[i + 3] = i + 2; strategy[i + 4] = i + 4; strategy[i + 5] = i + 3; for (var k = i + 6; k \u0026lt;= 2 * i; k++) { strategy[k] = k - 1; } } return strategy; } private int[] Win(int n) { var strategy = new int[n]; var s = Par((int)Math.Floor(Math.Log10(n) / Math.Log10(2)) + 1); for (var i = 1; i \u0026lt;= n - 1; i++) { strategy[i] = s[i]; } var I = (int)Math.Pow(2, Math.Floor(Math.Log10(n + 1) / Math.Log10(2))) - 1; if ((n == I) || (n \u0026lt;= 7)) return strategy; strategy[I] = I; if (n == I + 1) return strategy; strategy[I + 1] = (I + 1) / 2; if (n == I + 2) return strategy; for (var i = I + 2; i \u0026lt;= n - 1; i++) { if (i == 2 * I - 2) strategy[i] = i; else strategy[i] = i - 1; } return strategy; } } 另请参阅 # 给出堆排序最坏情况构造方法的论文 Suchenek M A. A Complete Worst-Case Analysis of Heapsort with Experimental Verification of Its Results, A manuscript (MS)[J]. arXiv preprint arXiv:1504.01459, 2015. 本题用到的库文件 PriorityQueue 库\n"},{"id":294,"href":"/2-4-17/","title":"2.4.17","section":"《算法（第四版）》C# 题解","content":" 2.4.17 # 解答 # 英文版原文是：insert followed by remove the minimum，因此是先插入再删除。\n大致上相当于一个缓冲区，把比较大的留下来，比较小的筛出去。\n首先我们有一个大小为 k 的优先队列，保证最小值在最前。 接下来我们插入一个元素，可以分成两种情况。\n如果插入的元素比最小值还要小，那么这个插入的元素会在之后被删除，原队列中的元素不变。\n如果插入的元素比最小值大（或者相等），那么最小值会被删除，留下插入的元素。\n于是可以观察到这样一个逻辑，在不断的插入过程中，比较小的元素会被过滤，只留下较大的元素。\n那么我们可以把题目转化为：\n向一个优先队列插入 N 个元素，保证队列的大小不超过 k，如果超过 k 了就删除最小值。\n那么前 k 次插入不受影响，之后的 N-k 次插入就会按照之前说过的流程进行。\n最后只留下 N 个元素中较大的 k 个元素，得证。\n"},{"id":295,"href":"/2-4-18/","title":"2.4.18","section":"《算法（第四版）》C# 题解","content":" 2.4.18 # 解答 # 首先看第一种情况，一次 insert() 接一次 delMax()。\n由于插入的数比堆中的所有元素都大，这个元素会一路上升到根结点。\n记上升路径上的点为 $a_1,a_2,a_3, \\dots , a_k$，其中 $a_k$是插入的结点，$a_1$ 是根结点。\n插入完成后路径上点的次序变为 $a_k, a_1, a_2, \\dots, a_{k-1}$ 。\n随后进行一次 delMax()，先做交换，次序变为 $a_{k-1}, a_1, \\dots, a_{k-2}, a_k$ 。\n由于 $a_1$ 是堆中原来的最大值，下沉时一定会和它交换。\n根据定义，二叉堆是父结点总是优于子结点的完全二叉树，因此以后续结点作为根结点的子树也都是堆。\n故同理 $a_{k-1}$ 会和 $a_2, a_3, \\dots,a_{k-2}$ 交换，即沿原路径返回。\n因此这种情况下前后堆不发生改变。\n然后看第二种情况，操作顺序为 insert() insert() delMax() delMax()。\n根据之前的结论，插入最大结点之后立即删除最大元素不会使堆发生变化，中间的两个操作抵消。\n序列变为：insert() delMax()。\n同理再次利用刚才的结论，操作抵消，堆不发生变化。\n故第二种情况也不会使堆发生改变。\n"},{"id":296,"href":"/2-4-19/","title":"2.4.19","section":"《算法（第四版）》C# 题解","content":" 2.4.19 # 解答 # 官方实现已经包含了这部分的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n相应的构造函数（Java）\npublic MaxPQ(Key[] keys) { n = keys.length; pq = (Key[]) new Object[keys.length + 1]; for (int i = 0; i \u0026lt; n; i++) pq[i+1] = keys[i]; for (int k = n/2; k \u0026gt;= 1; k--) sink(k); assert isMaxHeap(); } 代码 # 构造函数（C#）\n/// \u0026lt;summary\u0026gt; /// 从已有元素建立一个最大堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt; public MaxPQ(Key[] keys) { _n = keys.Length; pq = new Key[keys.Length + 1]; for (var i = 0; i \u0026lt; keys.Length; i++) pq[i + 1] = keys[i]; for (var k = _n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } 另请参阅 # PriorityQueue 库\n"},{"id":297,"href":"/2-4-20/","title":"2.4.20","section":"《算法（第四版）》C# 题解","content":" 2.4.20 # 解答 # 官网给出了解答：https://algs4.cs.princeton.edu/24pq/\n首先介绍第一种解法。\n设叶子结点的高度为 $0$，根结点的高度为 $ h ​$。\n于是某个结点 sink 时的最大交换次数即为该结点的高度。\n故某一层结点的最大交换次数为 该层结点数 × 该层的高度。\n于是总交换次数最大为：\n$$ \\begin{align*} \u0026amp; h+2(h-1)+2^2(h-2)+ \\dots + 2^h(0) \\newline \u0026amp; =\\sum_{k=0}^{h-1} 2^k(h-k) \\newline \u0026amp; =h\\sum_{k=0}^{h-1}2^k - \\sum_{k=0}^{h-1}k2^k \\newline \\end {align*} $$\n第一项为等比数列的和，第二项为等差数列乘以等比数列的和。\n于是第一项可以直接通过公式求得，第二项可以利用错位相减法求得。\n$$ \\begin{align} \u0026amp; h\\sum_{k=0}^{h-1}2^k - \\sum_{k=0}^{h-1}k2^k \\newline \u0026amp; =h2^{h}-h-\\sum_{k=0}^{h-1}k2^k \\newline \u0026amp; =h2^{h}-h +\\sum_{k=0}^{h-1} k2^k - 2\\sum_{k=0}^{h-1} k2^k \\newline \u0026amp; =h2^{h}-h+2^h - 2-(h-1)2^h \\newline \u0026amp; =2^{h+1}-h-2 \\newline \u0026amp; =N-h-1 \\le N \\end{align} $$\n于是交换次数小于 $N$，比较次数小于 $2N$。\n另一种解法，可以配合官网的图片帮助理解。\n首先堆中某个结点最多一路下沉到叶子结点，\n最大交换次数就是该结点的高度（记叶子结点的高度为 0）。\n考虑根结点一路下沉到叶子结点的轨迹，\n设为 $a_0, a_1, a_2, \u0026hellip; , a_k$，其中 $k$ 为根结点的高度，$a_0$ 是根结点。\n$a_0$ 下沉后结点顺序变为 $a_1, a_2, \u0026hellip;, a_k, a_0$ 。\n根据下沉的定义，有 $a_1 \u0026gt; a_2 \u0026gt; \\dots \u0026gt; a_k \u0026gt; a_0$ 。\n因此 $a_1$ 下沉时不可能与 $a_2$ 交换，而会向另一个方向下沉。\n其余结点同理，可以发现每个结点的下沉路径不会与其他结点重合。\n一棵完全二叉树共有 $N - 1$ 条边，每访问一条边代表进行了一次交换。\n故交换次数必定小于 $N$，比较次数为交换次数的两倍小于 $2N$。\n"},{"id":298,"href":"/2-4-21/","title":"2.4.21","section":"《算法（第四版）》C# 题解","content":" 2.4.21 # 解答 # 给元素添上序号组成结点，按照序号排序即可，每个结点可以用类似于这样的实现：\nclass ElemType\u0026lt;T\u0026gt; : IComparable\u0026lt;ElemType\u0026lt;T\u0026gt;\u0026gt; { private int _key; private T _element; public ElemType(int key) =\u0026gt; _key = key; public int CompareTo(ElemType\u0026lt;T\u0026gt; other) { return _key.CompareTo(other._key); } } 栈：\n用最大元素在最前的优先队列。\n每个结点都包含一个元素和一个序号，\n插入新元素时序号递增，这样最后插入的元素总在最前。\n队列：\n用最小元素在最前的优先队列。\n每个结点都包含一个元素和一个序号，\n插入新元素时序号递增，这样最先插入的元素总在最前。\n随机队列：\n优先队列的选择任意\n每个结点都包含一个元素和一个序号，\n插入新元素时随机指定一个序号，这样元素的顺序就是任意的了。\n"},{"id":299,"href":"/2-4-22/","title":"2.4.22","section":"《算法（第四版）》C# 题解","content":" 2.4.22 # 解答 # 官方实现中已经包含了调整数组大小的代码，见：https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n截取如下：\n// helper function to double the size of the heap array private void resize(int capacity) { assert capacity \u0026gt; n; Key[] temp = (Key[]) new Object[capacity]; for (int i = 1; i \u0026lt;= n; i++) { temp[i] = pq[i]; } pq = temp; } 只要在队列快满时重新分配空间，再把元素复制进去即可。\n在不触发重新分配空间的情况下，\n每次队列操作的比较次数上限就等于命题 Q 中给出的 $\\lg N+1$（插入） 和 $2\\lg N$（删除）。\n插入元素最多需要 $\\lg N$ 次交换（比较次数-1），\n删除元素最多需要 $1 + \\lg N - 1 = \\lg N$ 次交换 （注意开始时有一次交换）。\n同时一次比较需要 $2$ 次数组访问，一次交换需要 $4$ 次数组访问（记 a[i] 为一次数组访问）。\n换算成数组访问次数就是 $6 \\lg N + 2$（插入）和 $8 \\lg N$ （删除）。\n在触发重新分配空间的情况下，需要额外的 $2N$ 次数组访问来重新分配空间。\n故上限为 $6 \\lg N +2N + 2$ 和 $8 \\lg N + 2N$。\n如果取均摊分析，那么相当于把多出来的 $2N$ 次访问平均到 $N$ 次操作中。\n设第 $n$ 次插入触发了重新分配空间，$n$ 是 $2$ 的幂。\n重新分配空间进行了 $2 + 4 + 8 + 16 + \u0026hellip; + 2n = 2n - 2$ 次数组访问。\n平均到 $n$ 次插入过程，每次插入多进行 $2 - 2 / n$ 次数组访问。\n于是插入的上限变为 $6 \\lg N + 4 - 2 / N$。\n同理删除的上限变为 $8 \\lg N + 2 - 2 / N$。\n代码 # 重新分配空间（C#）\n/// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { Key[] temp = new Key[capacity]; for (var i = 1; i \u0026lt;= _n; i++) { temp[i] = _pq[i]; } _pq = temp; } 另请参阅 # PriorityQueue 库\n"},{"id":300,"href":"/2-4-23/","title":"2.4.23","section":"《算法（第四版）》C# 题解","content":" 2.4.23 # 解答 # 简单的 sink 实现 # sink 方法会在所有的 $t$ 个子结点中寻找最大的结点。 如果找到的结点比当前结点大，那么就进行交换。\n否则视为结点已经下沉到了合适的位置，结束循环。\n根据题意，在 $t$ 个元素中找最大值需要 $t$ 次比较。\nsink 操作需要找到 $t$ 个子结点中的最大值并与当前结点相比较。\n于是 sink 操作每次最多需要 $t + 1$ 次比较。\n建堆过程，对 2.4.20 的证明进行推广。\n设 $t$ 叉树的高度为 $h$ ，叶子结点的高度为 $0$，根结点的高度为 $h$。\n根据 sink 操作的定义，高度为 $k$ 的结点最多进行 $k$ 次交换（到达叶子结点）。\n于是建堆需要的总交换次数为：\n$$ \\begin{align*} \u0026amp; h+t(h-1)+t^2(h-2)+ \\dots + t^h(0) \\newline \u0026amp; =\\sum_{k=0}^{h-1} t^k(h-k) \\newline \u0026amp; =h\\sum_{k=0}^{h-1}t^k - \\sum_{k=0}^{h-1}kt^k \\newline \\end {align*} $$\n其中，第一个数列是等比数列，第二个数列是等差数列和等比数列之积，可以利用错位相减法求得，即：\n$$ \\begin{align*} \u0026amp; h\\sum_{k=0}^{h-1}t^k - \\sum_{k=0}^{h-1}kt^k \\newline \u0026amp; =\\frac{h-ht^{h}}{1-t}-\\sum_{k=0}^{h-1}kt^k \\newline \u0026amp; =\\frac{h-ht^{h}}{1-t} -\\frac{\\sum kt^k - t\\sum kt^k}{1-t} \\newline \u0026amp; =\\frac{h-ht^h}{1-t}-\\frac{t(1-t^{h-1})}{(1-t)^2}+\\frac{(h-1)t^h}{1-t} \\newline \u0026amp; =\\frac{h-t^h}{1-t}-\\frac{t(1-t^{h-1})}{(1-t)^2} \\newline \u0026amp; =\\frac{h-ht+t^{h+1}-t}{(1-t)^2} \\end{align*} $$\n考虑到对于 $t$ 叉堆，结点数可以表示为 $n=\\frac{t^{h+1}-1}{t-1}$ 。故交换次数可以化简为：\n$$ \\begin{align*} \u0026amp; \\frac{h-ht+t^{h+1}-t}{(1-t)^2} \\newline \u0026amp; =\\frac{h-ht+t^{h+1}-t +1-1}{(1-t)^2} \\newline \u0026amp; =\\frac{t^{h+1}-1}{(1-t)^2}+\\frac{h-ht-t+1}{(1-t)^2} \\newline \u0026amp; =-\\frac{n}{1-t}+\\frac{h}{1-t}+\\frac{1}{1-t} \\newline \u0026amp; =\\frac{n-h-1}{t-1} \\le n \\end{align*} $$\n故建堆所需比较次数最大为 $(t+1)n$ 。\n每次删除最大元素都会对根结点调用一次 sink 操作，\n因此排序所需的比较次数最多为 $(t+1)n\\log_t(n)$ 。\n相加得堆排序所需的总交换次数最多为 $ (t+1)n + (t+1)n\\log_t(n) =(t+1)(n\\log_tn+n)$ 。\n利用换底公式将对数的底换成 2，得到：$\\frac{t+1}{\\lg t} n\\log n$ 。\n于是问题变为求 $f(t)= \\frac{t+1}{\\lg t}$ 的最小值，对其求导，得到：\n$$ ( \\frac{t+1}{\\lg t} )\u0026rsquo;=\\frac{-t+t\\ln t-1}{t\\ln^2t}·\\ln 2 $$\n直接求导数的零点会比较困难，但利用勘根公式可以寻找到根所在的区间。\n由于 $\\ln 2$ 不影响正负，我们直接将其去掉，变为：\n$$ \\frac{-t+t\\ln t-1}{t\\ln^2t}=\\frac{-1+\\ln t-\\frac{1}{t}}{\\ln^2t} $$\n由于 $t \u0026gt; 1$，分母总是为正，因此导函数正负就等于下面这个函数的正负：\n$$ \\begin {align*} g(t)=\\ln t -1-\\frac{1}{t} \\end {align*} $$\n$t = e$ 时 $g(t) \u0026lt; 0$，$t=e+1$ 时 $g(t) \u0026gt; 0$。于是可以求得在 $(e, e+1)$ 上 $f(t)$ 存在极小值。\n又由于 $g(t)$ 在 $(e + 1, +\\infty)$ 始终为正，因此在 $(e, e+1)$ 上存在的是最小值（$t \\ge 2$）。\n因为 $t$ 为大于 $1$ 的正整数，且 $f(4) \u0026lt; f(3)$，故 $t=4$ 时系数最小，此时系数为 $2.5$ 。\nFloyd 方法 # 在删除最大元素的过程中，根结点会和最后一个结点交换，然后对新的根结点执行 sink 操作。\n大多数情况下，这个结点会被一路交换到树的最后一层。\n因此我们省去 sink 操作中与自己比较的过程，直接和子结点中的较大者进行交换。\n这样一路交换到树的底部，随后再让这个结点与自己的父结点比较，向上「回到」合适的位置。\n大多数结点都不需要向上交换，\n因此这样的优化可以减少比较次数（下降一层需要的比较次数从 $t+1$ 变为 $t$）。\n利用 Floyd 方法对于建堆没有影响（建堆也可以使用 Floyd 方法，参见「另请参阅」部分）。\n于是建堆的比较次数仍为 $(t+1)n$ 。\n排序的比较次数变为 $tn\\log_t(n)$ 。\n总的比较次数变为 $(t+1)n + tn\\log_t(n)$ 。\n我们仍然只关心 $n\\lg n$ 的系数，系数为 $f(t)= \\frac{t}{\\lg t}$ 。\n按照之前的方法再求一次最小值，求得 $t = 3$ 时系数最小，此时系数为 $1.89$ 。\n另请参阅 # Floyd 提出的堆排序优化 Floyd R W. Algorithm 245: treesort[J]. Communications of the ACM, 1964, 7(12): 701.\n通过将这种方法应用到建堆获得的快速建堆方法 McDiarmid C J H, Reed B A. Building heaps fast[J]. Journal of algorithms, 1989, 10(3): 352-365.\n"},{"id":301,"href":"/2-4-24/","title":"2.4.24","section":"《算法（第四版）》C# 题解","content":" 2.4.24 # 解答 # 链式实现，每个结点都包含一个指向父结点的指针和两个指向子结点的指针。\n交换结点可以直接用交换两个结点的值来实现（与数组的实现一样），而不是对两个结点的指针进行交换。\n于是 Sink() 和 Swim() 操作就比较简单，直接按照定义实现即可。\n比较困难的是删除和插入结点，或者更具体的说，\n如何找到按照完全二叉树定义下序号向后/向前一位的结点？\n我们首先在堆里面维护两个指针，一个指向根结点（root），另一个指向当前最后一个结点（last）。\n当需要插入新结点时，我们需要找到 last 的后一位的父结点，然后把新的结点插入为该结点的左子结点。\n这段话可能比较绕，下面这个示意图可以帮助理解，有三种情况：\n标黄的代表 last 指着的位置。\n我们先从简单的说起，中间的第二种情况，新插入的结点应该放在右侧，即作为 last 的父结点的右子结点。\n如果 last 已经是右子结点了，那么就考虑第三种情况。\n此时应该向上回溯，直到在某一次回溯中，结点是从父结点的左侧回溯上来的 （即图中路径 A-B-B，B-B 这一步是从左子树回溯上来的）。\n于是待插入的位置就在该父结点的右子树的最左侧结点（即图中根结点的右子结点 A）。\n最后是图中第一种情况，整棵树已经是满二叉树了。\n这种情况下会一路回溯到根结点，那么只要一路下沉到最左侧的叶子结点，把新结点插入到其左子树上即可。\n删除结点同理，也是这三种情况，只是需要找前一个结点，判断条件中的左右正好相反。\n如果已经是右子结点了，只需要把 last 改为其父结点的左子树即可。\n如果是左子结点，就需要回溯，直到某一次回溯是从右子树回溯上来的，last 应该指向其左子树的最右侧结点。\n如果删除后正好变成满二叉树，那么会一直回溯到根结点，last 应该指向整棵树的最右侧结点。\n代码实现中还需要处理只有一个结点以及没有结点时的特殊情况。\n根据上面的算法，插入/删除找到相应位置所需的最大耗时为 2lgN （从树的一侧回溯到根结点，再下沉到另一侧的底部）。\nSink 和 Swim 是 O(lgN) 级的，因此整个插入/删除操作是 O(lgN) 的。\n代码 # public class MaxPqLinked\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 二叉堆的根结点。 /// \u0026lt;/summary\u0026gt; private TreeNode\u0026lt;TKey\u0026gt; _root; /// \u0026lt;summary\u0026gt; /// 二叉堆的最后一个结点。 /// \u0026lt;/summary\u0026gt; private TreeNode\u0026lt;TKey\u0026gt; _last; /// \u0026lt;summary\u0026gt; /// 二叉堆中的结点个数。 /// \u0026lt;/summary\u0026gt; private int _nodesCount; /// \u0026lt;summary\u0026gt; /// 删除并返回最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大值。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最大值而不删除它，请使用 \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMax() { var result = _root.Value; Exch(_root, _last); if (_nodesCount == 2) { _root.Left = null; _last = _root; _nodesCount--; return result; } if (_nodesCount == 1) { _last = null; _root = null; _nodesCount--; return result; } // 获得前一个结点。 var newLast = _last; if (newLast == _last.Prev.Right) newLast = _last.Prev.Left; else { // 找到上一棵子树。 while (newLast != _root) { if (newLast != newLast.Prev.Left) break; newLast = newLast.Prev; } // 已经是满二叉树。 if (newLast == _root) { // 一路向右，回到上一层。 while (newLast.Right != null) newLast = newLast.Right; } // 不是满二叉树。 else { // 向左子树移动，再一路向右。 newLast = newLast.Prev.Left; while (newLast.Right != null) newLast = newLast.Right; } } // 删除最后一个结点。 if (_last.Prev.Left == _last) _last.Prev.Left = null; else _last.Prev.Right = null; Sink(_root); // 指向新的最后一个结点。 _last = newLast; _nodesCount--; return result; } /// \u0026lt;summary\u0026gt; /// 插入一个新的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入的结点。\u0026lt;/param\u0026gt; public void Insert(TKey v) { var item = new TreeNode\u0026lt;TKey\u0026gt;(v); // 堆为空。 if (_last == null) { _root = item; _last = item; _nodesCount++; return; } // 堆只有一个结点。 if (_last == _root) { item.Prev = _root; _root.Left = item; _last = item; _nodesCount++; Swim(item); return; } // 定位到最后一个节点的父结点。 var prev = _last.Prev; // 右子节点为空，插入到右子节点。 if (prev.Right == null) { item.Prev = prev; prev.Right = item; } else { // 当前子树已满，需要向上回溯。 // 找到下一个子树（回溯的时候是从左子树回溯上去的）。 while (prev != _root) { if (prev != prev.Prev.Right) break; prev = prev.Prev; } // 已经是满二叉树。 if (prev == _root) { // 一路向左，进入下一层。 while (prev.Left != null) prev = prev.Left; item.Prev = prev; prev.Left = item; } // 不是满二叉树。 else { // 向右子树移动，再一路向左。 prev = prev.Prev.Right; while (prev.Left != null) prev = prev.Left; item.Prev = prev; prev.Left = item; } } _last = item; _nodesCount++; Swim(item); } /// \u0026lt;summary\u0026gt; /// 返回二叉堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _root == null; /// \u0026lt;summary\u0026gt; /// 返回二叉堆中的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中的最大值。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望删除并返回最大元素，请使用 \u0026lt;see cref=\u0026#34;DelMax\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Max() =\u0026gt; _root.Value; /// \u0026lt;summary\u0026gt; /// 返回二叉堆中的元素个数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中元素数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _nodesCount; /// \u0026lt;summary\u0026gt; /// 使结点上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的结点。\u0026lt;/param\u0026gt; private void Swim(TreeNode\u0026lt;TKey\u0026gt; k) { while (k.Prev != null) { if (Less(k.Prev, k)) { Exch(k.Prev, k); k = k.Prev; } else break; } } /// \u0026lt;summary\u0026gt; /// 使结点下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的结点。\u0026lt;/param\u0026gt; private void Sink(TreeNode\u0026lt;TKey\u0026gt; k) { while (k?.Left != null || k?.Right != null) { TreeNode\u0026lt;TKey\u0026gt; toExch; if (k.Left != null \u0026amp;\u0026amp; k.Right != null) toExch = Less(k.Left, k.Right) ? k.Right : k.Left; else if (k.Left != null) toExch = k.Left; else toExch = k.Right; if (Less(k, toExch)) Exch(k, toExch); else break; k = toExch; } } /// \u0026lt;summary\u0026gt; /// 交换二叉堆中的两个结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的第一个结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的第二个结点。\u0026lt;/param\u0026gt; private void Exch(TreeNode\u0026lt;TKey\u0026gt; a, TreeNode\u0026lt;TKey\u0026gt; b) { var temp = a.Value; a.Value = b.Value; b.Value = temp; } /// \u0026lt;summary\u0026gt; /// 比较第一个结点值的是否小于第二个。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;判断是否较小的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;判断是否较大的结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(TreeNode\u0026lt;TKey\u0026gt; a, TreeNode\u0026lt;TKey\u0026gt; b) =\u0026gt; a.Value.CompareTo(b.Value) \u0026lt; 0; } 另请参阅 # PriorityQueue 库\n"},{"id":302,"href":"/2-4-25/","title":"2.4.25","section":"《算法（第四版）》C# 题解","content":" 2.4.25 # 解答 # 官方实现：https://algs4.cs.princeton.edu/24pq/CubeSum.java.html\n注意这道题并不是要打印所有的 $a^3+b^3$ 的结果，而是需要找到 $a^3+b^3=c^3+d^3$ 这个丢番图方程的解。\n因此在官方实现的基础上，每次取出最小值之后和之前的最小值比较，如果相等则输出对应的组合。\n关键代码如下：\nCubeSum prev = new CubeSum(-1, -1); long pairCount = 0; while (!pq.IsEmpty()) { CubeSum s = pq.DelMin(); if (s.sum == prev.sum)\t// 如果与之前的数相等 { Console.WriteLine(s + \u0026#34; = \u0026#34; + prev.i + \u0026#34;^3 + \u0026#34; + prev.j + \u0026#34;^3\u0026#34;); pairCount++; } if (s.j \u0026lt; n) pq.Insert(new CubeSum(s.i, s.j + 1)); prev = s; } 当然，对于 n=10^6 来说结果会非常大，程序的运行时间需要以天为单位计算（约 14 天）。\nn=10^4 时，总共可以找到 41570 对数据。（result10K.txt, 下载大小 506 KB，解压后 1.93 MB）\nn=10^5 时，总共可以找到 895023 对数据。(result100K.txt，下载大小 12.7 MB，解压后 47.5 MB)\nn=10^6 时，总共可以找到 16953323 对数据。（result1M.txt，下载大小 280 MB，解压后 0.98 GB）\n结果下载链接：百度云、Onedrive\n代码 # CubeSum.cs\ninternal class CubeSum : IComparable\u0026lt;CubeSum\u0026gt; { /// \u0026lt;summary\u0026gt; /// 立方和。 /// \u0026lt;/summary\u0026gt; internal readonly long Sum; /// \u0026lt;summary\u0026gt; /// 第一个数。 /// \u0026lt;/summary\u0026gt; internal readonly long I; /// \u0026lt;summary\u0026gt; /// 第二个数。 /// \u0026lt;/summary\u0026gt; internal readonly long J; /// \u0026lt;summary\u0026gt; /// 建立一个立方和类。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;立方和的第一个数。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;立方和的第二个数。\u0026lt;/param\u0026gt; public CubeSum(long i, long j) { Sum = i * i * i + j * j * j; this.I = i; this.J = j; } /// \u0026lt;summary\u0026gt; /// 比较两个立方和的大小，返回 1, 0, -1 中的一个。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个数。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int CompareTo(CubeSum other) { return Sum.CompareTo(other.Sum); } /// \u0026lt;summary\u0026gt; /// 返回 \u0026#34;sum = i^3 + j^3\u0026#34; 形式的字符串。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return Sum + \u0026#34; = \u0026#34; + I + \u0026#34;^3 + \u0026#34; + J + \u0026#34;^3\u0026#34;; } } 主程序\nvar n = 1000000; var pq = new MinPq\u0026lt;CubeSum\u0026gt;(); Console.WriteLine(\u0026#34;正在初始化\u0026#34;); for (var i = 0; i \u0026lt;= n; i++) { pq.Insert(new CubeSum(i, i)); } var ostream = new FileStream(\u0026#34;./result.txt\u0026#34;, FileMode.Create, FileAccess.Write); var sw = new StreamWriter(ostream); Console.WriteLine(\u0026#34;正在写入文件……\u0026#34;); var prev = new CubeSum(-1, -1); long pairCount = 0; while (!pq.IsEmpty()) { var s = pq.DelMin(); if (s.Sum == prev.Sum) { sw.WriteLine(s + \u0026#34; = \u0026#34; + prev.I + \u0026#34;^3 + \u0026#34; + prev.J + \u0026#34;^3\u0026#34;); pairCount++; } if (s.J \u0026lt; n) pq.Insert(new CubeSum(s.I, s.J + 1)); prev = s; } sw.WriteLine(\u0026#34;共找到\u0026#34; + pairCount + \u0026#34;对数据\u0026#34;); Console.WriteLine(\u0026#34;共找到\u0026#34; + pairCount + \u0026#34;对数据\u0026#34;); sw.Close(); Console.WriteLine(\u0026#34;结果已经保存到程序所在目录下的 result.txt 文件中\u0026#34;); 另请参阅 # Diophantine Equation-3rd Powers - Wolfram MathWorld\nPriorityQueue 库\n"},{"id":303,"href":"/2-4-26/","title":"2.4.26","section":"《算法（第四版）》C# 题解","content":" 2.4.26 # 解答 # 用类似于「半交换」的方法避免频繁调用 Exch() 方法。\n上浮时，先单独保存待上浮的元素，随后进行比较，\n如果当前 k 值对应的父结点（即 k/2 ）小于待上浮的元素，令 pq[k]=pq[k/2]。\n否则令当前 k 值等于待上浮的元素，终止循环。 下沉的过程类似。\n修改后的 sink 和 swim 方法：\n/// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { var key = _pq[k]; while (k \u0026gt; 1 \u0026amp;\u0026amp; _pq[k / 2].CompareTo(key) \u0026lt; 0) { _pq[k] = _pq[k / 2]; k /= 2; } _pq[k] = key; } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { var key = _pq[k]; while (k * 2 \u0026lt;= _n) { var j = 2 * k; if (Less(j, j + 1)) j++; if (_pq[j].CompareTo(key) \u0026lt; 0) break; _pq[k] = _pq[j]; k = j; } _pq[k] = key; } 另请参阅 # PriorityQueue 库\n"},{"id":304,"href":"/2-4-27/","title":"2.4.27","section":"《算法（第四版）》C# 题解","content":" 2.4.27 # 解答 # 官网有解答，只要在 MaxPQ 里面加上一个记录最小值的指针就可以了。\n初始状态下这个指针为空。\n每次插入新元素的时候先更新一下这个指针。 删除最后一个元素的时候把它重新置空即可。\n具体实现见代码。\n代码 # public class MaxPqWithMin\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt;, IEnumerable\u0026lt;TKey\u0026gt; where TKey : class, IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 保存元素的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;保存元素的数组。\u0026lt;/value\u0026gt; private TKey[] _pq; /// \u0026lt;summary\u0026gt; /// 堆中的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中的元素数量。\u0026lt;/value\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 堆中的最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中的最小元素。\u0026lt;/value\u0026gt; private TKey _min; /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public MaxPqWithMin() : this(1) { } /// \u0026lt;summary\u0026gt; /// 建立指定容量的最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt; public MaxPqWithMin(int capacity) { _pq = new TKey[capacity + 1]; _n = 0; _min = null; } /// \u0026lt;summary\u0026gt; /// 从已有元素建立一个最大堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;已有元素。\u0026lt;/param\u0026gt; public MaxPqWithMin(TKey[] keys) { _n = keys.Length; _pq = new TKey[keys.Length + 1]; _min = null; if (_n == 0) return; // 复制元素的同时更新最小值。 _min = keys[0]; for (var i = 0; i \u0026lt; keys.Length; i++) { _pq[i + 1] = keys[i]; if (_pq[i + 1].CompareTo(_min) \u0026lt; 0) _min = _pq[i + 1]; } for (var k = _n / 2; k \u0026gt;= 1; k--) Sink(k); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt; /// 删除并返回最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中的最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentException\u0026#34;\u0026gt;当堆为空时抛出该异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最大元素但不删除它，请使用 \u0026lt;see cref=\u0026#34;Max\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMax() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); var max = _pq[1]; Exch(1, _n--); _pq[_n + 1] = _pq[1]; Sink(1); _pq[_n + 1] = null; if ((_n \u0026gt; 0) \u0026amp;\u0026amp; (_n == _pq.Length / 4)) Resize(_pq.Length / 2); // 如果堆变为空。 if (IsEmpty()) _min = null; Debug.Assert(IsMaxHeap()); return max; } /// \u0026lt;summary\u0026gt; /// 向堆中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) { if (_n == _pq.Length - 1) Resize(2 * _pq.Length); // 更新最小值。 if (_min == null) _min = v; else if (v.CompareTo(_min) \u0026lt; 0) _min = v; _pq[++_n] = v; Swim(_n); Debug.Assert(IsMaxHeap()); } /// \u0026lt;summary\u0026gt; /// 检查堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;若堆为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 获得堆中最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中的最大元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望删除并返回最大元素，请使用 \u0026lt;see cref=\u0026#34;DelMax\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Max() =\u0026gt; _pq[1]; /// \u0026lt;summary\u0026gt; /// 获得堆中的最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中的最小元素。\u0026lt;/returns\u0026gt; public TKey Min() =\u0026gt; _min; /// \u0026lt;summary\u0026gt; /// 获得堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中的元素数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以降序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大堆的迭代器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TKey\u0026gt; GetEnumerator() { var copy = new MaxPqWithMin\u0026lt;TKey\u0026gt;(_n); for (var i = 1; i \u0026lt;= _n; i++) copy.Insert(_pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); // 下次迭代的时候从这里继续执行。 } /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以降序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆的迭代器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;实际上调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { while (k * 2 \u0026lt;= _n) { var j = 2 * k; if (Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { var temp = new TKey[capacity]; for (var i = 1; i \u0026lt;= _n; i++) { temp[i] = _pq[i]; } _pq = temp; } /// \u0026lt;summary\u0026gt; /// 判断堆中某个元素是否小于另一元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;若下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的元素更小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(int i, int j) =\u0026gt; _pq[i].CompareTo(_pq[j]) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt; private void Exch(int i, int j) { var swap = _pq[i]; _pq[i] = _pq[j]; _pq[j] = swap; } /// \u0026lt;summary\u0026gt; /// 检查当前二叉树是不是一个最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMaxHeap() =\u0026gt; IsMaxHeap(1); /// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMaxHeap(int k) { if (k \u0026gt; _n) return true; var left = 2 * k; var right = 2 * k + 1; if (left \u0026lt;= _n \u0026amp;\u0026amp; Less(k, left)) return false; if (right \u0026lt;= _n \u0026amp;\u0026amp; Less(k, right)) return false; return IsMaxHeap(left) \u0026amp;\u0026amp; IsMaxHeap(right); } } 另请参阅 # PriorityQueue 库\n"},{"id":305,"href":"/2-4-28/","title":"2.4.28","section":"《算法（第四版）》C# 题解","content":" 2.4.28 # 解答 # 开始时让 N=10^5，在 M=10^4 不变的情况下令 N 不断翻倍，求出算法增长的数量级。\n再根据求出的增长的数量级估计 N=10^8 时所需要的时间。\n为了方便比较，需要编写一个欧几里得距离类，\n构造时输入一个点的坐标，内部自动计算并保存这个点到原点的欧几里得距离。\n欧几里得距离的计算公式如下：\n$$ d(x,y)=\\sqrt{\\sum_{i=1}^{n}(x_i-y_i)^2} $$\n其中，x 和 y 分别代表两个点。\n在本题中，y 始终是原点，且使用三维坐标系，因此公式可以简化为：\n$$ d=\\sqrt {x^2+y^2+z^2} $$\n同时这个类需要实现 IComparable 接口以作为最小堆的元素。\n做测试时，先随机生成 N 个点，再建立一个最小堆。\n随后开始计时，把开始的 m 个点插入。\n剩余的 n-m 个点则是先删除最小值再插入，这样可以保证最小堆的大小不变。\n最后再把堆中的所有元素输出，停止计时。\n用不断倍增的的 N 值做上述测试，获得每次的耗时，进而求得算法增长的数量级。\n求得的结果如下：\n可以推出当 N=10^8 时耗时为 $ 398 \\ ms × 1000 = 398 \\ s $\n代码 # 欧几里得距离类，EuclideanDistance3D\ninternal class EuclideanDistance3D : IComparable\u0026lt;EuclideanDistance3D\u0026gt; { private readonly int _x, _y, _z; private readonly double _distance; /// \u0026lt;summary\u0026gt; /// 计算点到原点的欧几里得距离。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;x 轴坐标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;y 轴坐标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;z\u0026#34;\u0026gt;z 轴坐标。\u0026lt;/param\u0026gt; public EuclideanDistance3D(int x, int y, int z) { _x = x; _y = y; _z = z; _distance = Math.Sqrt(x * x + y * y + z * z); } /// \u0026lt;summary\u0026gt; /// 比较两个欧几里得距离的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;另一个欧几里得距离。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int CompareTo(EuclideanDistance3D other) { return _distance.CompareTo(other._distance); } /// \u0026lt;summary\u0026gt; /// 以 \u0026#34;(x, y, z)\u0026#34; 形式输出点的坐标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return \u0026#34;(\u0026#34; + _x + \u0026#34;, \u0026#34; + _y + \u0026#34;, \u0026#34; + _z + \u0026#34;)\u0026#34;; } } 另请参阅 # 欧几里得距离-维基百科 PriorityQueue 库\n"},{"id":306,"href":"/2-4-29/","title":"2.4.29","section":"《算法（第四版）》C# 题解","content":" 2.4.29 # 解答 # 算法思想比较简单，但在实现上会有一些复杂。\n用一个最大堆和一个最小堆，每个堆中都保存了全部数组元素，且相同的元素之间有指针相连。\n插入元素时需要构建两个完全相同的元素分别插入到两个堆中。\n找到最小元素和找到最大元素只需要分别返回最大堆和最小堆的堆顶元素即可。\n以删除最小元素为例，先对最小堆进行 DelMin() 操作，再通过指针找到对应最大堆的元素并删除。\n下面介绍删除堆中任意元素的算法。\n首先将待删除元素与堆中最后一个元素交换，让堆的大小减一。\n随后对交换后的元素先进行 Swim 再进行 Sink，移动到正确的位置上。\n下图是一个例子，当删除最大元素 14 时，最小堆中删除元素 14 需要先 Swim。\n如果堆的层数更多一些，就需要先 Swim 再 Sink。\n现在来考虑一下实现，我们构建一个结点类，里面存放有当前结点的值、对应数组下标和另一个结点的指针。\nprivate sealed class MinMaxNode : IComparable\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt; /// 结点的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;结点的值。\u0026lt;/value\u0026gt; public TKey Key { get; set; } /// \u0026lt;summary\u0026gt; /// 结点在当前数组中的下标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;结点在当前数组中的下标。\u0026lt;/value\u0026gt; public readonly int Index; /// \u0026lt;summary\u0026gt; /// 指向孪生结点的引用。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;指向孪生结点的引用。\u0026lt;/value\u0026gt; public MinMaxNode Pair { get; set; } /// \u0026lt;summary\u0026gt; /// 这个类不能在外部实例化。 /// \u0026lt;/summary\u0026gt; private MinMaxNode(TKey key, int index) { Key = key; Index = index; } /// \u0026lt;summary\u0026gt; /// 工厂方法，建立两个孪生的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;结点中的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;minNode\u0026#34;\u0026gt;准备放到最小堆中的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;maxNode\u0026#34;\u0026gt;准备放到最大堆中的结点。\u0026lt;/param\u0026gt; public static void GetNodes(TKey key, int index, out MinMaxNode minNode, out MinMaxNode maxNode) { minNode = new MinMaxNode(key, index); maxNode = new MinMaxNode(key, index); minNode.Pair = maxNode; maxNode.Pair = minNode; } /// \u0026lt;summary\u0026gt; /// 比较两个元素的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;other\u0026#34;/\u0026gt; 比较小则返回正数，否则返回负数。\u0026lt;/returns\u0026gt; public int CompareTo(MinMaxNode other) { return Key.CompareTo(other.Key); } } 然后重写堆的 Exch 方法，交换结点时只交换指针和元素值，不交换数组下标。\nprotected override void Exch(int i, int j) { Pq[i].Pair.Pair = Pq[j]; Pq[j].Pair.Pair = Pq[i]; var swapNode = Pq[i].Pair; var swapKey = Pq[i].Key; Pq[i].Key = Pq[j].Key; Pq[i].Pair = Pq[j].Pair; Pq[j].Key = swapKey; Pq[j].Pair = swapNode; } 在最大堆和最小堆的实现中编写 Remove 方法，用于移除指定下标的元素。\ninternal void Remove(int k) { if (k == N) { Pq[N--] = default; return; } if (N \u0026lt;= 2) { Exch(1, k); Pq[N--] = default; return; } Exch(k, N--); Pq[N + 1] = default; Swim(k); Sink(k); } 代码 # 最大-最小堆\npublic class MinMaxPq\u0026lt;TKey\u0026gt; : IMaxPq\u0026lt;TKey\u0026gt;, IMinPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 最大-最小堆中的数据结点。 /// \u0026lt;/summary\u0026gt; private sealed class MinMaxNode : IComparable\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt; /// 结点的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;结点的值。\u0026lt;/value\u0026gt; public TKey Key { get; set; } /// \u0026lt;summary\u0026gt; /// 结点在当前数组中的下标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;结点在当前数组中的下标。\u0026lt;/value\u0026gt; public readonly int Index; /// \u0026lt;summary\u0026gt; /// 指向孪生结点的引用。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;指向孪生结点的引用。\u0026lt;/value\u0026gt; public MinMaxNode Pair { get; set; } /// \u0026lt;summary\u0026gt; /// 这个类不能在外部实例化。 /// \u0026lt;/summary\u0026gt; private MinMaxNode(TKey key, int index) { Key = key; Index = index; } /// \u0026lt;summary\u0026gt; /// 工厂方法，建立两个孪生的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;结点中的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;minNode\u0026#34;\u0026gt;准备放到最小堆中的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;maxNode\u0026#34;\u0026gt;准备放到最大堆中的结点。\u0026lt;/param\u0026gt; public static void GetNodes(TKey key, int index, out MinMaxNode minNode, out MinMaxNode maxNode) { minNode = new MinMaxNode(key, index); maxNode = new MinMaxNode(key, index); minNode.Pair = maxNode; maxNode.Pair = minNode; } /// \u0026lt;summary\u0026gt; /// 比较两个元素的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;需要与之比较的另一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;other\u0026#34;/\u0026gt; 比较小则返回正数，否则返回负数。\u0026lt;/returns\u0026gt; public int CompareTo(MinMaxNode other) { return Key.CompareTo(other.Key); } } /// \u0026lt;summary\u0026gt; /// 对 \u0026lt;see cref=\u0026#34;MinMaxNode\u0026#34;/\u0026gt; 偏特化的最大堆。 /// \u0026lt;/summary\u0026gt; private sealed class MaxPq : MaxPq\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt; /// 建立指定大小的最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt; public MaxPq(int capacity) : base(capacity) { } /// \u0026lt;summary\u0026gt; /// 利用指定的结点建立最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;nodes\u0026#34;\u0026gt;用于建立最大堆的结点。\u0026lt;/param\u0026gt; public MaxPq(MinMaxNode[] nodes) : base(nodes) { } /// \u0026lt;summary\u0026gt; /// 重写的 Exch 方法，只交换元素和指针。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; protected override void Exch(int i, int j) { Pq[i].Pair.Pair = Pq[j]; Pq[j].Pair.Pair = Pq[i]; var swapNode = Pq[i].Pair; var swapKey = Pq[i].Key; Pq[i].Key = Pq[j].Key; Pq[i].Pair = Pq[j].Pair; Pq[j].Key = swapKey; Pq[j].Pair = swapNode; } } /// \u0026lt;summary\u0026gt; /// 对 \u0026lt;see cref=\u0026#34;MinMaxNode\u0026#34;/\u0026gt; 偏特化的最小堆。 /// \u0026lt;/summary\u0026gt; private sealed class MinPq : MinPq\u0026lt;MinMaxNode\u0026gt; { /// \u0026lt;summary\u0026gt; /// 建立指定大小的最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最小堆的容量。\u0026lt;/param\u0026gt; public MinPq(int capacity) : base(capacity) { } /// \u0026lt;summary\u0026gt; /// 利用指定的结点建立最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;nodes\u0026#34;\u0026gt;用于建立最小堆的结点。\u0026lt;/param\u0026gt; public MinPq(MinMaxNode[] nodes) : base(nodes) { } /// \u0026lt;summary\u0026gt; /// 重写的 Exch 方法，只交换元素和指针。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的下标。\u0026lt;/param\u0026gt; protected override void Exch(int i, int j) { Pq[i].Pair.Pair = Pq[j]; Pq[j].Pair.Pair = Pq[i]; var swapNode = Pq[i].Pair; var swapKey = Pq[i].Key; Pq[i].Key = Pq[j].Key; Pq[i].Pair = Pq[j].Pair; Pq[j].Key = swapKey; Pq[j].Pair = swapNode; } } /// \u0026lt;summary\u0026gt; /// 最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;最小堆。\u0026lt;/value\u0026gt; private readonly MinPq _minPq; /// \u0026lt;summary\u0026gt; /// 最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;最大堆。\u0026lt;/value\u0026gt; private readonly MaxPq _maxPq; /// \u0026lt;summary\u0026gt; /// 堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆的大小。\u0026lt;/value\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 构造一个最大-最小堆。 /// \u0026lt;/summary\u0026gt; public MinMaxPq() : this(1) { } /// \u0026lt;summary\u0026gt; /// 构造一个指定容量的最大-最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;堆的大小。\u0026lt;/param\u0026gt; public MinMaxPq(int capacity) { _minPq = new MinPq(capacity); _maxPq = new MaxPq(capacity); _n = 0; } /// \u0026lt;summary\u0026gt; /// 根据已有元素建立一个最大-最小堆。（O(n)） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;需要建堆的元素。\u0026lt;/param\u0026gt; public MinMaxPq(TKey[] keys) { _n = keys.Length; var minNodes = new MinMaxNode[keys.Length]; var maxNodes = new MinMaxNode[keys.Length]; for (var i = 0; i \u0026lt; _n; i++) { MinMaxNode.GetNodes(keys[i], i + 1, out minNodes[i], out maxNodes[i]); } _minPq = new MinPq(minNodes); _maxPq = new MaxPq(maxNodes); } /// \u0026lt;summary\u0026gt; /// 删除并返回最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大元素。\u0026lt;/returns\u0026gt; public TKey DelMax() { // ⬇ 不可以交换操作顺序 ⬇ _minPq.Remove(_maxPq.Max().Pair.Index); var key = _maxPq.Max().Key; _maxPq.DelMax(); // ⬆ 不可以交换操作顺序 ⬆ _n--; return key; } /// \u0026lt;summary\u0026gt; /// 删除并返回最小值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小值。\u0026lt;/returns\u0026gt; public TKey DelMin() { // ⬇ 不可以交换操作顺序 ⬇ _maxPq.Remove(_minPq.Min().Pair.Index); var key = _minPq.Min().Key; _minPq.DelMin(); // ⬆ 不可以交换操作顺序 ⬆ _n--; return key; } /// \u0026lt;summary\u0026gt; /// 插入一个新的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入的新值。\u0026lt;/param\u0026gt; public void Insert(TKey v) { _n++; MinMaxNode.GetNodes(v, _n, out var minNode, out var maxNode); _maxPq.Insert(maxNode); _minPq.Insert(minNode); } /// \u0026lt;summary\u0026gt; /// 判断堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;若堆为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 获得堆中的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆的最大值。\u0026lt;/returns\u0026gt; public TKey Max() =\u0026gt; _maxPq.Max().Key; /// \u0026lt;summary\u0026gt; /// 获得堆中的最小值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆的最小值。\u0026lt;/returns\u0026gt; public TKey Min() =\u0026gt; _minPq.Min().Key; /// \u0026lt;summary\u0026gt; /// 获得堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆的大小。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; } 另请参阅 # Double Ended Priority Queue-Wikipedia PriorityQueue 库\n"},{"id":307,"href":"/2-4-30/","title":"2.4.30","section":"《算法（第四版）》C# 题解","content":" 2.4.30 # 解答 # 单独用一个变量存放中位数，然后前半部分元素放在一个最大堆中，后半部分元素放在一个最小堆中。\n如下图所示，注意 Median 和两个堆并没有直接连接，这里只是方便理解元素顺序。\n只要左右两个堆含有元素之差不超过 1，那么 Median 变量中存放的就是整个数组的中位数。\n如果元素差大于 1，就需要进行调整，\n把 Median 变量中存放的值插入到元素较少的堆，\n再从元素较多的堆中取出元素放入 Median 变量，直到元素差不大于 1。\n插入元素时，根据插入元素的大小插入到某一个堆中去，再做一次调整。\n删除中位数时，去掉中位数，然后从元素较多的一侧堆中取元素补位，再进行一次调整。\n编写代码时要注意堆中只有一个元素的情况需要特殊处理。\n代码 # 面向中位数的堆（MedianPQ.cs）\npublic class MedianPq\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 最大堆（保存前半段元素）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;最大堆（保存前半段元素）。\u0026lt;/value\u0026gt; private readonly MaxPq\u0026lt;TKey\u0026gt; _maxPq; /// \u0026lt;summary\u0026gt; /// 最小堆（保存后半段元素）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;最小堆（保存后半段元素）。\u0026lt;/value\u0026gt; private readonly MinPq\u0026lt;TKey\u0026gt; _minPq; /// \u0026lt;summary\u0026gt; /// 中位数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;中位数。\u0026lt;/value\u0026gt; private TKey _median; /// \u0026lt;summary\u0026gt; /// 堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆的大小。\u0026lt;/value\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 默认构造函数，构造一个面向中位数的堆。 /// \u0026lt;/summary\u0026gt; public MedianPq() { _maxPq = new MaxPq\u0026lt;TKey\u0026gt;(); _minPq = new MinPq\u0026lt;TKey\u0026gt;(); _median = default; _n = 0; } /// \u0026lt;summary\u0026gt; /// 构造一个指定容量的面向中位数的堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;初始容量。\u0026lt;/param\u0026gt; public MedianPq(int capacity) { _maxPq = new MaxPq\u0026lt;TKey\u0026gt;((capacity - 1) / 2); _minPq = new MinPq\u0026lt;TKey\u0026gt;((capacity - 1) / 2); _n = 0; _median = default; } /// \u0026lt;summary\u0026gt; /// 根据指定数组初始化面向中位数的堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;keys\u0026#34;\u0026gt;初始数组。\u0026lt;/param\u0026gt; public MedianPq(TKey[] keys) { _minPq = new MinPq\u0026lt;TKey\u0026gt;(); _maxPq = new MaxPq\u0026lt;TKey\u0026gt;(); if (keys.Length == 0) { _n = 0; _median = default; return; } _n = keys.Length; _median = keys[0]; for (var i = 1; i \u0026lt; keys.Length; i++) { if (_median.CompareTo(keys[i]) \u0026lt; 0) _minPq.Insert(keys[i]); else _maxPq.Insert(keys[i]); } UpdateMedian(); } /// \u0026lt;summary\u0026gt; /// 向面向中位数的堆中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey key) { if (_n == 0) { _n++; _median = key; return; } if (key.CompareTo(_median) \u0026lt; 0) _maxPq.Insert(key); else _minPq.Insert(key); _n++; UpdateMedian(); } /// \u0026lt;summary\u0026gt; /// 删除并返回中位数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;中位数。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;当堆为空时抛出该异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得中位数但不将其删除，请使用 \u0026lt;see cref=\u0026#34;Median\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMedian() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;MedianPQ underflow!\u0026#34;); var median = _median; if (_n == 1) { _n--; _median = default; return median; } // 从较大的一侧堆中取元素作为新的中位数。 if (_minPq.Size() \u0026gt; _maxPq.Size()) _median = _minPq.DelMin(); else _median = _maxPq.DelMax(); _n--; return median; } /// \u0026lt;summary\u0026gt; /// 获得中位数。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;中位数。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望删除并返回中位数，请使用 \u0026lt;see cref=\u0026#34;DelMedian\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Median() =\u0026gt; _median; /// \u0026lt;summary\u0026gt; /// 判断堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;若堆为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 更新中位数的值。 /// \u0026lt;/summary\u0026gt; private void UpdateMedian() { // 根据两个堆的大小调整中位数 while (_maxPq.Size() - _minPq.Size() \u0026gt; 1) { _minPq.Insert(_median); _median = _maxPq.DelMax(); } while (_minPq.Size() - _maxPq.Size() \u0026gt; 1) { _maxPq.Insert(_median); _median = _minPq.DelMin(); } } } 另请参阅 # PriorityQueue 库\n"},{"id":308,"href":"/2-4-31/","title":"2.4.31","section":"《算法（第四版）》C# 题解","content":" 2.4.31 # 解答 # 首先可以观察到堆有这样一个性质，从根结点到某一个叶子结点的路径是有序的，满足二分查找的条件。\n但是， 从叶子结点到根结点的路径可以通过不断地令 k = k / 2 得到（从下往上只有一条路径）。\n但从根结点到叶子结点的路径却不能简单地通过 k = k * 2 得到（从上往下会有两条分支）。\n因此只通过堆本身是无法满足二分查找对于随机访问的要求的。\n为了达到 ~loglogN 次比较，我们需要对 Swim() 方法做修改，\n即，先通过一个数组来保存路径，再对这个数组进行二分查找，从而获得合适的祖先结点。\n路径的长度是 ~logN（完全二叉树的性质），于是二分查找的比较次数即为 ~loglogN。\n删除操作原本就是 ~2logN 的，不需要修改。\n注意这样的方法仅仅只是减少了比较次数，\n为了保持堆的有序，即使找到了结点的合适位置也不能直接插入，\n仍然需要将路径上的结点依次下移，空出位置后再插入结点，复杂度仍然是 ~logN。\n由于增加了保存路径等操作（建立了大量的小数组），实际算法的运行时间是增加的。\n也可以用空间换时间，由于在堆中下标为 k 的结点到根结点的路径是唯一确定的。\n因此可以提前计算好路径，用一个数组保存起来（数组的数组），在 Swim 中取出对应路径进行二分查找。\n当然这样是很不划算的，除非元素比较的开销非常大。\n代码 # 修改后的 Swim() 方法，注意输入的路径是从下往上的。\nprivate void Swim(int k) { if (k == 1) return; // 获取路径 var path = new List\u0026lt;int\u0026gt;(); var temp = k; while (temp \u0026gt;= 1) { path.Add(temp); temp /= 2; } // lo=插入结点的父结点 hi=根结点 int lo = 1, hi = path.Count - 1; while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (Greater(k, path[mid])) hi = mid - 1; // 当前值比较大，应该向下走 else lo = mid + 1; // 值较小，向根结点方向走 } for (var i = 1; i \u0026lt; lo; i++) { Exch(path[i - 1], path[i]); } } 另请参阅 # PriorityQueue 库\n"},{"id":309,"href":"/2-4-32/","title":"2.4.32","section":"《算法（第四版）》C# 题解","content":" 2.4.32 # 解答 # 官网解答见：https://algs4.cs.princeton.edu/24pq/\n如果这样的话，堆排序的只需要 ~nloglogn 次比较即可。\n根据 2.3 中的证明，基于比较的排序的下界是 ~nlogn。\n因此不存在这样的最小堆。\n注意上题的方法不能用于下沉操作，因为我们不能预知下沉的路径。\n"},{"id":310,"href":"/2-4-33/","title":"2.4.33","section":"《算法（第四版）》C# 题解","content":" 2.4.33 # 解答 # 官方实现见：https://algs4.cs.princeton.edu/24pq/IndexMaxPQ.java.html\n书中算法 2.6 给出的是一个最大堆的实现，但本题给出的部分解答却是最小堆的。\n同时官网给出的解答是最大堆的，这里选择和官网保持一致，给出最大堆的实现。\n初看起来可能会比较难理解，但其实就是以指针为元素的堆。\n堆中存放的只是指向元素的指针（如果元素在数组里那就变成了下标）。\n做比较的时候要先根据指针（下标）找到对应元素，再进行比较。\n再来看题目中给出的要求，keys[] 数组中用于保存元素（比如 keys[0] = ‘A’;），\n而 pq[] 中保存的是元素在 key[] 数组中的下标（比如 pq[1] = 0;)，\n而 qp[] 中保存的是某个下标在 pq[]中 的对应位置。 （比如 qp[0] = 1）。\n在这三个数组中，pq[]是一个堆，我们的堆操作都作用在这个数组上。\nkeys[] 数组中的元素不随着 pq[] 中下标的移动而移动，只有当删除或添加元素时才发生变化。\nqp[]与pq[]中的索引一一对应，pq[]交换时也需要交换qp[]中的对应元素。\n代码 # public class IndexMaxPq\u0026lt;TKey\u0026gt; : IEnumerable\u0026lt;int\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 优先队列中的元素。 /// \u0026lt;/summary\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 索引最大堆。 /// \u0026lt;/summary\u0026gt; private readonly int[] _pq; /// \u0026lt;summary\u0026gt; /// pq 的逆索引，pq[qp[i]]=qp[pq[i]]=i /// \u0026lt;/summary\u0026gt; private readonly int[] _qp; /// \u0026lt;summary\u0026gt; /// 实际元素。 /// \u0026lt;/summary\u0026gt; private readonly TKey[] _keys; /// \u0026lt;summary\u0026gt; /// 建立指定大小的面向索引的最大堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最大堆的容量。\u0026lt;/param\u0026gt; public IndexMaxPq(int capacity) { if (capacity \u0026lt; 0) throw new ArgumentOutOfRangeException(); _n = 0; _keys = new TKey[capacity + 1]; _pq = new int[capacity + 1]; _qp = new int[capacity + 1]; for (var i = 0; i \u0026lt;= capacity; i++) _qp[i] = -1; } /// \u0026lt;summary\u0026gt; /// 将与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 相关联的元素换成 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改关联元素的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;用于替换的新元素。\u0026lt;/param\u0026gt; public void ChangeKey(int i, TKey k) { if (!Contains(i)) throw new ArgumentNullException(nameof(i), \u0026#34;队列中没有该索引\u0026#34;); _keys[i] = k; Swim(_qp[i]); Sink(_qp[i]); } /// \u0026lt;summary\u0026gt; /// 确认堆包含某个索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要查询的索引。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;包含则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(int i) =\u0026gt; _qp[i] != -1; /// \u0026lt;summary\u0026gt; /// 删除索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要清空的索引。\u0026lt;/param\u0026gt; public void Delete(int i) { if (!Contains(i)) throw new ArgumentOutOfRangeException(nameof(i), \u0026#34;index is not in the priority queue\u0026#34;); var index = _qp[i]; Exch(index, _n--); Swim(index); Sink(index); _keys[i] = default; _qp[i] = -1; } /// \u0026lt;summary\u0026gt; /// 删除并获得最大元素所在的索引。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大元素所在的索引。\u0026lt;/returns\u0026gt; public int DelMax() { if (_n == 0) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); var max = _pq[1]; Exch(1, _n--); Sink(1); _qp[max] = -1; _keys[max] = default; _pq[_n + 1] = -1; return max; } /// \u0026lt;summary\u0026gt; /// 将索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值减少为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;减少后的键值。\u0026lt;/param\u0026gt; public void DecreaseKey(int i, TKey key) { if (!Contains(i)) throw new ArgumentOutOfRangeException(nameof(i), \u0026#34;index is not in the priority queue\u0026#34;); if (_keys[i].CompareTo(key) \u0026lt;= 0) throw new ArgumentException(\u0026#34;Calling IncreaseKey() with given argument would not strictly increase the Key\u0026#34;); _keys[i] = key; Sink(_qp[i]); } /// \u0026lt;summary\u0026gt; /// 将索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值增加为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;增加后的键值。\u0026lt;/param\u0026gt; public void IncreaseKey(int i, TKey key) { if (!Contains(i)) throw new ArgumentOutOfRangeException(nameof(i), \u0026#34;index is not in the priority queue\u0026#34;); if (_keys[i].CompareTo(key) \u0026gt;= 0) throw new ArgumentException(\u0026#34;Calling IncreaseKey() with given argument would not strictly increase the Key\u0026#34;); _keys[i] = key; Swim(_qp[i]); } /// \u0026lt;summary\u0026gt; /// 将元素 \u0026lt;paramref name=\u0026#34;v\u0026#34;/\u0026gt; 与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 关联。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;待插入元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;需要关联的索引。\u0026lt;/param\u0026gt; public void Insert(TKey v, int i) { if (Contains(i)) throw new ArgumentException(\u0026#34;索引已存在\u0026#34;); _n++; _qp[i] = _n; _pq[_n] = i; _keys[i] = v; Swim(_n); } /// \u0026lt;summary\u0026gt; /// 堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 获得与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 关联的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;索引。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 关联的元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentNullException\u0026#34;\u0026gt;当队列中没有 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 时抛出该异常。\u0026lt;/exception\u0026gt; public TKey KeyOf(int i) { if (!Contains(i)) throw new ArgumentNullException(nameof(i), \u0026#34;队列中没有该索引\u0026#34;); return _keys[i]; } /// \u0026lt;summary\u0026gt; /// 返回最大元素对应的索引。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大元素对应的索引。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;当优先队列为空时抛出该异常。\u0026lt;/exception\u0026gt; public int MaxIndex() { if (_n == 0) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); return _pq[1]; } /// \u0026lt;summary\u0026gt; /// 获得最大元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;当优先队列为空时抛出该异常。\u0026lt;/exception\u0026gt; public TKey MaxKey() { if (_n == 0) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); return _keys[_pq[1]]; } /// \u0026lt;summary\u0026gt; /// 返回堆的元素数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆的元素数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; /// \u0026lt;summary\u0026gt; /// 比较第一个元素是否小于第二个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;第一个元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;第二个元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果堆中索引为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的元素较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(int i, int j) =\u0026gt; _keys[_pq[i]].CompareTo(_keys[_pq[j]]) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 交换两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的元素下标。\u0026lt;/param\u0026gt; private void Exch(int i, int j) { var swap = _pq[i]; _pq[i] = _pq[j]; _pq[j] = swap; _qp[_pq[i]] = i; _qp[_pq[j]] = j; } /// \u0026lt;summary\u0026gt; /// 使下标为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;上浮元素下标。\u0026lt;/param\u0026gt; private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(k / 2, k)) { Exch(k / 2, k); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 使下标为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { while (k * 2 \u0026lt;= _n) { var j = 2 * k; if (j \u0026lt; _n \u0026amp;\u0026amp; Less(j, j + 1)) j++; if (!Less(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 获取迭代器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大堆的迭代器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;int\u0026gt; GetEnumerator() { var copy = new IndexMaxPq\u0026lt;TKey\u0026gt;(_n); for (var i = 0; i \u0026lt; _n; i++) copy.Insert(_keys[_pq[i]], _pq[i]); while (!copy.IsEmpty()) yield return copy.DelMax(); } /// \u0026lt;summary\u0026gt; /// 获取迭代器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;迭代器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;该方法实际调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() =\u0026gt; GetEnumerator(); } 另请参阅 # PriorityQueue 库\n"},{"id":311,"href":"/2-4-34/","title":"2.4.34","section":"《算法（第四版）》C# 题解","content":" 2.4.34 # 解答 # 这里给出最大堆的实现，原因同 2.4.33。\nmaxIndex()：pq[1] 就是最小元素的下标。\nchange()：首先修改 keys 数组中对应的元素，然后对堆中该下标进行重排序。\ndelete()：先从堆中删除元素，再把 keys 和 qp 数组中的对应元素初始化。\n代码 # /// \u0026lt;summary\u0026gt; /// 返回最大元素对应的索引。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大元素对应的索引。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;当优先队列为空时抛出该异常。\u0026lt;/exception\u0026gt; public int MaxIndex() { if (_n == 0) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); return _pq[1]; } /// \u0026lt;summary\u0026gt; /// 将与索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 相关联的元素换成 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要修改关联元素的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;用于替换的新元素。\u0026lt;/param\u0026gt; public void ChangeKey(int i, TKey k) { if (!Contains(i)) throw new ArgumentNullException(nameof(i), \u0026#34;队列中没有该索引\u0026#34;); _keys[i] = k; Swim(_qp[i]); Sink(_qp[i]); } /// \u0026lt;summary\u0026gt; /// 删除索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 对应的键值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要清空的索引。\u0026lt;/param\u0026gt; public void Delete(int i) { if (!Contains(i)) throw new ArgumentOutOfRangeException(nameof(i), \u0026#34;index is not in the priority queue\u0026#34;); var index = _qp[i]; Exch(index, _n--); Swim(index); Sink(index); _keys[i] = default; _qp[i] = -1; } 另请参阅 # PriorityQueue 库\n"},{"id":312,"href":"/2-4-35/","title":"2.4.35","section":"《算法（第四版）》C# 题解","content":" 2.4.35 # 解答 # 本题有两个翻译错误。\nrandom() ——返回索引 i 的概率是 p[i]/T，而非返回概率和索引。（return an index i with probability p[i]/T）\n最后一句指的是像堆那样使用数组而非显式指针实现二叉树。（Avoid explicit pointers, as we do for heaps.）\n提示已经给出了实现方案，我们用一个例子来简单说明一下。\n现在给出一个分布 p，总和 T=1，如下图所示：\n为了实现这样的随机分布，我们在 0~T 之间随机一个小数，然后根据结果返回不同的值。 现在我们将这个思想应用到完全二叉树上。\n每次随机的过程其实构成了一棵选择树，我们把数组 p 当作一棵树，如下图：\n为方便起见，我们重新排列一下之前的随机表：\n每个值的概率并没有改变，只是每个值对应的区段换了一下。\n经过这样的变换后，你会发现，如果从根结点的角度看：\n如果随机的值小于 0.1，对应的编号就是 1。\n如果随机的值大于 0.5，那么对应编号只能是 3 或 6，即根结点的右子树。\n其他情况对应编号在左子树上。\n扩展到一般情况，就变成了：\n如果随机数小于当前结点，直接返回当前结点的编号。\n如果随机数大于左子树权值总和+当前结点的权值，减去它们，移动到右子树。\n其他情况减去当前结点的权值并移动到左子树。\n思想理解之后，代码实现就比较容易了，做了 100000 次实验的结果如下：\n代码 # internal class Sample { public double[] P; public double[] SumP; public double T; private readonly Random _random = new(); /// \u0026lt;summary\u0026gt; /// 构造一个离散取样类。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;取样数据。\u0026lt;/param\u0026gt; public Sample(double[] data) { // 复制权重 P = new double[data.Length + 1]; for (var i = 1; i \u0026lt;= data.Length; i++) { P[i] = data[i - 1]; T += data[i - 1]; } // 记录子树权重之和 SumP = new double[data.Length + 1]; for (var i = data.Length; i / 2 \u0026gt; 0; i--) { SumP[i / 2] += SumP[i] + P[i]; } } /// \u0026lt;summary\u0026gt; /// 根据构造时给定的取样概率返回索引。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public int Random() { var weight = _random.NextDouble() * T; var index = 1; while (index * 2 \u0026lt;= P.Length) { // 找到结点 if (weight \u0026lt;= P[index]) break; // 减去当前结点，向子结点搜寻 weight -= P[index]; index *= 2; // 在左子树范围内 if (weight \u0026lt;= SumP[index] + P[index]) continue; // 在右子树范围内，减去左子树 weight -= SumP[index] + P[index]; index++; } return index - 1; } /// \u0026lt;summary\u0026gt; /// 修改索引 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的权重为 \u0026lt;paramref name=\u0026#34;v\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;需要修改的索引。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;新的权重。\u0026lt;/param\u0026gt; public void Change(int i, double v) { i += 1; T = T - P[i] + v; P[i] = v; // 重新计算总和 while (i \u0026gt; 1) { i /= 2; SumP[i] = P[i * 2] + SumP[i * 2]; if (i * 2 + 1 \u0026lt; P.Length) { SumP[i] += P[i * 2 + 1] + SumP[i * 2 + 1]; } } } } 另请参阅 # PriorityQueue 库\n"},{"id":313,"href":"/2-4-36/","title":"2.4.36","section":"《算法（第四版）》C# 题解","content":" 2.4.36 # 解答 # 测试结果如下：\n可以看出增长数量级约为 O(nlogn)。\n代码 # var doubleTime = 5; var repeatTime = 5; var n = 100000; for (var i = 0; i \u0026lt; doubleTime; i++) { long totalTime = 0; Console.WriteLine(\u0026#34;count=\u0026#34; + n); for (var j = 0; j \u0026lt; repeatTime; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var time = Test(pq, n); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;平均用时：\u0026#34; + totalTime / repeatTime + \u0026#34;毫秒\u0026#34;); n *= 2; } long Test(MaxPq\u0026lt;int\u0026gt; pq, int count) { var random = new Random(); // 生成数据 var initData = new int[count]; var appendData = new int[count / 2]; for (var i = 0; i \u0026lt; count; i++) initData[i] = random.Next(); for (var i = 0; i \u0026lt; count / 2; i++) appendData[i] = random.Next(); // 开始测试 var stopwatch = new Stopwatch(); stopwatch.Start(); // 插入 count 个元素 for (var i = 0; i \u0026lt; count; i++) pq.Insert(initData[i]); // 删去一半 for (var i = 0; i \u0026lt; count / 2; i++) pq.DelMax(); // 插入一半 for (var i = 0; i \u0026lt; count / 2; i++) pq.Insert(appendData[i]); // 删除全部 for (var i = 0; i \u0026lt; count; i++) pq.DelMax(); stopwatch.Stop(); return stopwatch.ElapsedMilliseconds; } 另请参阅 # PriorityQueue 库\n"},{"id":314,"href":"/2-4-37/","title":"2.4.37","section":"《算法（第四版）》C# 题解","content":" 2.4.37 # 解答 # 建立一个全局变量 isRunning ，每次 DelMax() 之前都先确认这个值是否为 true，\n设立一个 Timer 在 1 秒钟之后自动将 isRunning 置为 false。\n测试结果如下：\n随着 n 增大，一秒钟之内能执行的 DelMax() 次数会下降。\n代码 # var doubleTime = 6; var repeatTime = 6; var n = 1000000; var isRunning = true; for (var i = 0; i \u0026lt; doubleTime; i++) { var totalDelCount = 0; Console.WriteLine(\u0026#34;count=\u0026#34; + n); for (var j = 0; j \u0026lt; repeatTime; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var delCount = Test(n, pq); totalDelCount += delCount; Console.Write(delCount + \u0026#34;\\t\u0026#34;); } Console.WriteLine(\u0026#34;平均最大删除次数：\u0026#34; + totalDelCount / repeatTime); n *= 2; } int Test(int count, MaxPq\u0026lt;int\u0026gt; pq) { var random = new Random(); var timer = new Timer(1000); timer.Elapsed += StopRunning; for (var i = 0; i \u0026lt; count; i++) { pq.Insert(random.Next()); } var delCount = 0; StartRunning(); timer.Start(); while (isRunning \u0026amp;\u0026amp; !pq.IsEmpty()) { pq.DelMax(); delCount++; } timer.Stop(); return delCount; } void StartRunning() =\u0026gt; isRunning = true; void StopRunning(object source, ElapsedEventArgs e) =\u0026gt; isRunning = false; 另请参阅 # PriorityQueue 库\n"},{"id":315,"href":"/2-4-38/","title":"2.4.38","section":"《算法（第四版）》C# 题解","content":" 2.4.38 # 解答 # 直接构造相应的数组测试即可。\n测试结果如下：\n最大堆来说顺序时会比较慢，因为每次插入都要一路上升到顶部。\n逆序的时候则是删除比较慢，最后一个元素是最小的元素，交换后需要一路下沉到底部。\n由于元素相同的时候我们选择不交换（less(i, j) 返回 false），较多的重复元素并不会影响性能。\n代码 # var random = new Random(); var n = 200000; var repeatTimes = 5; var doubleTimes = 4; for (var i = 0; i \u0026lt; doubleTimes; i++) { Console.WriteLine(\u0026#34;number=\u0026#34; + n); // 升序数组 long totalTime = 0; Console.Write(\u0026#34;Ascending:\\t\u0026#34;); for (var j = 0; j \u0026lt; repeatTimes; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var data = GetAscending(n); var time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 降序数组 totalTime = 0; Console.Write(\u0026#34;Descending:\\t\u0026#34;); for (var j = 0; j \u0026lt; repeatTimes; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var data = GetDescending(n); var time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 全部元素相同 totalTime = 0; Console.Write(\u0026#34;All Same:\\t\u0026#34;); for (var j = 0; j \u0026lt; repeatTimes; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var data = GetSame(n, 17763); var time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); // 只有两个值 totalTime = 0; Console.Write(\u0026#34;Binary Dist.:\\t\u0026#34;); for (var j = 0; j \u0026lt; repeatTimes; j++) { var pq = new MaxPq\u0026lt;int\u0026gt;(n); var data = GetBinary(n, 15254, 17763); var time = Test(pq, data); Console.Write(time + \u0026#34;\\t\u0026#34;); totalTime += time; } Console.WriteLine(\u0026#34;Average:\u0026#34; + totalTime / repeatTimes); n *= 2; } long Test(MaxPq\u0026lt;int\u0026gt; pq, int[] data) { var sw = new Stopwatch(); sw.Start(); for (var i = 0; i \u0026lt; data.Length; i++) { pq.Insert(data[i]); } for (var i = 0; i \u0026lt; data.Length; i++) { pq.DelMax(); } sw.Stop(); return sw.ElapsedMilliseconds; } int[] GetAscending(int number) { var ascending = new int[number]; for (var i = 0; i \u0026lt; number; i++) ascending[i] = random.Next(); Array.Sort(ascending); return ascending; } int[] GetDescending(int number) { var descending = GetAscending(number); descending = descending.Reverse().ToArray(); return descending; } int[] GetSame(int number, int v) { var same = new int[number]; for (var i = 0; i \u0026lt; number; i++) { same[i] = v; } return same; } int[] GetBinary(int number, int a, int b) { var binary = new int[number]; for (var i = 0; i \u0026lt; number; i++) { binary[i] = random.NextDouble() \u0026gt; 0.5 ? a : b; } return binary; } 另请参阅 # PriorityQueue 库\n"},{"id":316,"href":"/2-4-39/","title":"2.4.39","section":"《算法（第四版）》C# 题解","content":" 2.4.39 # 解答 # 结果如下，约占总耗时的 2~5%。 代码 # var random = new Random(); Console.WriteLine(\u0026#34;number\\tBuild\\tSort\\tRatio\u0026#34;); var n = 1000; // 当数据量到达 10^9 时会需要 2G 左右的内存 var multiTen = 7; for (var i = 0; i \u0026lt; multiTen; i++) { var data = GetRandomArray(n); var fullSort = new Stopwatch(); var buildHeap = new Stopwatch(); fullSort.Restart(); buildHeap.Restart(); BuildHeap(data); buildHeap.Stop(); HeapSort(data); fullSort.Stop(); var buildTime = buildHeap.ElapsedMilliseconds; var fullTime = fullSort.ElapsedMilliseconds; Console.WriteLine(n + \u0026#34;\\t\u0026#34; + buildTime + \u0026#34;\\t\u0026#34; + fullTime + \u0026#34;\\t\u0026#34; + (double)buildTime / fullTime); n *= 10; } short[] GetRandomArray(int number) { var data = new short[number]; for (var i = 0; i \u0026lt; number; i++) { data[i] = (short)random.Next(); } return data; } // 将数组构造成堆。 void BuildHeap(short[] data) { var count = data.Length; for (var k = count / 2; k \u0026gt;= 1; k--) { Sink(data, k, count); } } // 利用已经生成的堆排序。 void HeapSort(short[] heap) { var count = heap.Length; while (count \u0026gt; 1) { Exch(heap, 1, count--); Sink(heap, 1, count); } } // 令堆中的元素下沉。 void Sink(short[] pq, int k, int number) { while (2 * k \u0026lt;= number) { var j = 2 * k; if (j \u0026lt; number \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } // 比较堆中下标为 a 的元素是否小于下标为 b 的元素。 static bool Less(short[] pq, int a, int b) =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; // 交换堆中的两个元素。 static void Exch(short[] pq, int a, int b) { var temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } 另请参阅 # PriorityQueue 库\n"},{"id":317,"href":"/2-4-40/","title":"2.4.40","section":"《算法（第四版）》C# 题解","content":" 2.4.40 # 解答 # 如同书上所说，可以节省约 50% 的比较次数。 先沉后浮的实现也很简单，将 swim 方法加入，\n然后修改 sink 方法，去掉其中检查是否需要下沉的条件（if(!Less(pq, k, j))），\n然后在 sink 方法的循环之后调用 swim。\n为了获得比较次数，你可以添加一个静态全局变量 compareCount，\n然后修改 Less 方法，在作比较的同时使 compareCount++ ，\n每次执行 Sort 时先让 compareCount 置零，最后返回 compareCount。\n代码 # public static class HeapFloyd { /// \u0026lt;summary\u0026gt; /// 利用堆排序对数组进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public static void Sort\u0026lt;T\u0026gt;(T[] pq) where T : IComparable\u0026lt;T\u0026gt; { var n = pq.Length; // 建堆 for (var k = n / 2; k \u0026gt;= 1; k--) { Sink(pq, k, n); } // 排序 while (n \u0026gt; 1) { Exch(pq, 1, n--); SinkThenSwim(pq, 1, n); } } /// \u0026lt;summary\u0026gt; /// 令堆中的元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt; private static void Sink\u0026lt;T\u0026gt;(T[] pq, int k, int n) where T : IComparable\u0026lt;T\u0026gt; { while (2 * k \u0026lt;= n) { var j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 先下沉后上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;堆中的元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;包含堆元素的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要下沉的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;元素数量。\u0026lt;/param\u0026gt; private static void SinkThenSwim\u0026lt;T\u0026gt;(T[] pq, int k, int n) where T : IComparable\u0026lt;T\u0026gt; { while (2 * k \u0026lt;= n) { var j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; Less(pq, j, j + 1)) j++; Exch(pq, k, j); k = j; } Swim(pq, k); } /// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;优先队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private static void Swim\u0026lt;T\u0026gt;(T[] pq, int k) where T : IComparable\u0026lt;T\u0026gt; { while (k \u0026gt; 1 \u0026amp;\u0026amp; Less(pq, k / 2, k)) { Exch(pq, k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { var temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } } 另请参阅 # PriorityQueue 库\n"},{"id":318,"href":"/2-4-41/","title":"2.4.41","section":"《算法（第四版）》C# 题解","content":" 2.4.41 # 解答 # 多叉堆和二叉堆的实现上并没有很大的区别，\n只不过下沉（Sink）时需要比较的子结点数量变多了，上浮时父结点的下标不再是 $\\lfloor k /2 \\rfloor$。\n于是只要能推出 $d$ 叉堆的下标换算公式即可解决整个问题。\n先考虑 $d$ 叉堆的在数组中的保存方式，\n第一层显然只有根结点，第二层显然有 $d$ 个结点，第三层则有 $d \\times d=d^2$ 个结点，如下图所示：\n不难推出第 $k$ 层有 $d^{k-1}$ 个结点。\n接下来我们对其标号，根结点为 1，以此类推，如下图：\n现在我们来推导某个结点的子结点的下标公式。\n结点 $i$ 的第一个子结点在哪里呢？\n首先要加上本层剩下的结点，再加上它前面结点的所有子结点，再下一个就是它的第一个子结点了。\n以 2 号结点为例，它是第二层的第一个结点，第二层共有 $d^{2-1}=d$ 个结点，剩下 $d-1$ 个结点。\n2 号结点前面没有更多兄弟结点，于是第一个子结点下标即为 $2 + d - 1 + 1= 2 + d$。\n3 号结点之后剩余 $d-2$ 个结点，加上前面 2 号结点的 $d$ 个子结点，\n它的第一个子结点下标为 $3+d-2+d+1= 2+2d$。\n不难发现规律，结点序号加一，子结点的下标就要对应加上 $d$（要加上前一个结点的子结点），\n这个规律也可以从图上（$d=3$）看出来：\n1号结点的子结点范围是 $[2,d+1]$，每加一个结点子结点就要加上 $d$ 。\n于是立即可以推得结点 $i$ 的子结点下标范围是 $[d(i-1)+2,di+1]$ 。\n代入 $d=2$，可以发现是符合我们已知的规律的。\n接下来是结点 $i$ 的父结点，\n我们由上面的式子反推可以得到父结点的下标为 $ \\lfloor (i-2)/d \\rfloor +1$（或者 $\\lceil (i-2)/d \\rceil$）。\n获得这两个公式之后，只需要将 sink 和 swim 方法中上升和下降的公式做相应更改即可。\n测试结果，注意下标可能会超过 int 的范围，请使用 long。：\n代码 # public static class HeapMultiway { /// \u0026lt;summary\u0026gt; /// 利用堆排序对数组进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;d\u0026#34;\u0026gt;堆的分叉数。\u0026lt;/param\u0026gt; public static void Sort\u0026lt;T\u0026gt;(T[] pq, int d) where T : IComparable\u0026lt;T\u0026gt; { var n = pq.Length; // 建堆 for (var k = (n - 2) / d + 1; k \u0026gt;= 1; k--) { Sink(pq, k, n, d); } // 排序 while (n \u0026gt; 1) { Exch(pq, 1, n--); Sink(pq, 1, n, d); } } /// \u0026lt;summary\u0026gt; /// 令堆中的元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;d\u0026#34;\u0026gt;堆的分叉数。\u0026lt;/param\u0026gt; private static void Sink\u0026lt;T\u0026gt;(T[] pq, int k, int n, int d) where T : IComparable\u0026lt;T\u0026gt; { while ((k - 1) * d + 2 \u0026lt;= n) { var j = d * (k - 1) + 2; // 在 d 个子结点中找到最大的那个 for (int i = 0, q = j; i \u0026lt; d; i++) { if (q + i \u0026lt;= n \u0026amp;\u0026amp; Less(pq, j, q + i)) j = q + i; } if (!Less(pq, k, j)) break; Exch(pq, k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; =\u0026gt; pq[a - 1].CompareTo(pq[b - 1]) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { var temp = pq[a - 1]; pq[a - 1] = pq[b - 1]; pq[b - 1] = temp; } } 另请参阅 # D-ary Heap-Wikipedia PriorityQueue 库\n"},{"id":319,"href":"/2-4-42/","title":"2.4.42","section":"《算法（第四版）》C# 题解","content":" 2.4.42 # 解答 # 前序序列与完全二叉树 # 二叉树前序遍历的顺序是：自身，左子树，右子树。\n因此对于一个前序遍历序列，第一个元素是根结点，第二个元素是左子结点。\n再把左子结点找到，就可以把数组分成三部分：根结点，左子树，右子树，进而递归的构造出整个二叉树。\n现在问题是，右子结点在哪，或者说，左子树有多大？\n这里就要用到完全二叉树的性质了，我们先从比较简单的满二叉树入手。\n就满二叉树而言，根结点的左子树和右子树是一样大的，即左右子树大小均为 $(n-1)/2$ 。\n在这种情形下，右子结点的下标显然是 $(n+1)/2$ ，根结点下标为 0。 完全二叉树可以视为在满二叉树的基础上加了一层叶子结点，现在我们已知结点总数 $n$。\n于是可以求得二叉树的高度 $k=\\lfloor \\log_2(n) \\rfloor$ ，注意只有一个结点的树高度为 0。\n那么最后一层的叶子结点数目为 $l=n-2^{k}+1$ 个，如下图所示：\n如果把最后一层（第 $k$ 层）去掉，剩余部分即为高度为 $k-1$ 的满二叉树，结点总数为 $2^k - 1$ 。\n按照之前的说明可以知道左右子树大小都等于 $(2^{k}-2)/2=2^{k-1}-1$。\n现在要将第 $k$ 层的 $l$ 个结点分到左右子树里面去。\n第 $k$ 层最多能有 $2^k$ 个结点，取半就是 $2^k / 2 = 2^{k-1}$ 个。\n于是当 $l\u0026lt;=2^{k-1}$ 时，左右子树大小分别为 $2^{k-1}-1+l$ 和 $2^{k-1}-1$ 。\n当 $l \u0026gt; 2^{k-1}$ 时，左右子树大小分别为 $2^{k} - 1$ 和 $2^{k-1} -1 +l -2^{k-1}=l-1$ 。\n实际上，我们只要先取根结点，然后再取 $2^{k-1} -1$ 个结点给左子树，再做判断：\n如果 $n-2^{k-1} \u0026lt; 2^{k}-1$ ，那么对应第一种情况，末尾的 $2^{k-1}-1$ 个结点即为右子树。\n否则就是第二种情况，前面的 $ 2^k$ 个结点就是根结点和左子树，剩下的为右子树。\n堆排序的实现 # 现在我们能够根据结点总数 $n$ 来确定相应的完全二叉树，接下来则是如何进行堆排序。\n堆排序的第一步就是建堆，建堆时最主要的就是 sink 操作了。\n但前序序列中除了第一个结点（根结点）之外，其他结点的左右子结点下标是不能直接通过计算得到的。\n因此在前序实现中，sink 操作只能对根结点进行，引出了下面的递归建堆方法。\n如果根结点的左右两棵子树都已经是堆了，那么只要对根结点进行 sink 操作即可使整个二叉树变成堆。\n第一步先检查子树的大小，如果小于等于 1 则说明是叶结点，直接返回。\n否则计算出左右子结点的位置，递归地建堆。\n最后对根结点进行 sink 操作。\n那么这个 sink 操作是怎么做的呢？\n计算得到了左右子结点的下标后，比较得出较大的那个，如果大于根结点则交换，否则返回。\n交换后根结点变成了某一侧子树的根结点，递归地进行 sink 即可。\n接下来是排序，最主要的操作是 DelMax。\n前序序列的根结点好找，但是最后一个结点就比较麻烦了，它既可能在左子树也可能在右子树。\n但我们可以根据之前的大小关系来寻找，\n如果左子树小于等于 $2^k - 1$ ，那么最后一个结点一定在左子树，否则就在右子树。\n递归进行上述过程，直到到达叶子结点，该叶子结点就是最后一个结点。\n之后我们将最后一个结点暂存，整个数组从后向前补缺（这一步将导致算法变成 $O(n^2)$ ），\n再把第一个结点放到最后的空位上，最后把存起来的结点放到第一位，对该结点进行 sink 操作。\n依次往复即可完成排序。\n测试结果：\n这个算法在设计上与一般实现的比较次数大体相等，\n只是移动数组耗时较长，这里只给到 $10^7$。 代码 # public static class HeapPreorderAnalysis { private static long _compareTimes; /// \u0026lt;summary\u0026gt; /// 利用堆排序对数组进行排序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要排序的数组。\u0026lt;/param\u0026gt; public static long Sort\u0026lt;T\u0026gt;(T[] pq) where T : IComparable\u0026lt;T\u0026gt; { _compareTimes = 0; var n = pq.Length; BuildTree(pq, 0, pq.Length); // 排序 while (n \u0026gt; 1) { var tail = GetTail\u0026lt;T\u0026gt;(0, n); var temp = pq[tail]; for (var i = tail + 1; i \u0026lt; n; i++) pq[i - 1] = pq[i]; n--; Exch(pq, 0, n); pq[0] = temp; Sink(pq, 0, n); } return _compareTimes; } /// \u0026lt;summary\u0026gt; /// 递归获得堆的最后一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;堆中元素类型。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;当前位置。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆的元素数目。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;最后一个元素的下标。\u0026lt;/returns\u0026gt; private static int GetTail\u0026lt;T\u0026gt;(int p, int n) { if (n \u0026lt;= 1) return p; var k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度 var left = (int)Math.Pow(2, k - 1) - 1; var right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧 left = n - right - 1; return GetTail\u0026lt;T\u0026gt;(p + 1, left); } left = (int)Math.Pow(2, k) - 1; right = n - left - 1; return GetTail\u0026lt;T\u0026gt;(p + 1 + left, right); } /// \u0026lt;summary\u0026gt; /// 递归建堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;堆中元素。\u0026lt;/typeparam\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;堆所在的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;堆的起始下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆的元素数目。\u0026lt;/param\u0026gt; private static void BuildTree\u0026lt;T\u0026gt;(T[] pq, int p, int n) where T : IComparable\u0026lt;T\u0026gt; { if (n \u0026lt;= 1) return; var k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度 var left = (int)Math.Pow(2, k - 1) - 1; var right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧 left = n - right - 1; } else { left = (int)Math.Pow(2, k) - 1; right = n - left - 1; } BuildTree(pq, p + 1, left); BuildTree(pq, p + 1 + left, right); Sink(pq, p, n); } /// \u0026lt;summary\u0026gt; /// 令堆中的元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;需要执行操作的堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p\u0026#34;\u0026gt;需要执行下沉的结点下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;堆中元素的数目。\u0026lt;/param\u0026gt; private static void Sink\u0026lt;T\u0026gt;(T[] pq, int p, int n) where T : IComparable\u0026lt;T\u0026gt; { if (n \u0026lt;= 1) return; var k = (int)(Math.Log10(n) / Math.Log10(2)); // 高度 var left = (int)Math.Pow(2, k - 1) - 1; var right = left; if (n - left \u0026lt;= (int)Math.Pow(2, k)) { // 叶子结点全在左侧 left = n - right - 1; } else { left = (int)Math.Pow(2, k) - 1; right = n - left - 1; } // 找出较大的子结点 int j = p + 1, size = left; if (right != 0) // 有右结点 { if (Less(pq, j, p + left + 1)) { j = p + left + 1; size = right; } } // 与根结点比较 if (!Less(pq, p, j)) return; // 交换，继续下沉 Exch(pq, p, j); Sink(pq, j, size); } /// \u0026lt;summary\u0026gt; /// 比较堆中下标为 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 的元素是否小于下标为 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt; 的元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;元素所在的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;需要比较是否较小的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;需要比较是否较大的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static bool Less\u0026lt;T\u0026gt;(T[] pq, int a, int b) where T : IComparable\u0026lt;T\u0026gt; { _compareTimes++; return pq[a].CompareTo(pq[b]) \u0026lt; 0; } /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pq\u0026#34;\u0026gt;要交换的元素所在堆。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;要交换的结点序号。\u0026lt;/param\u0026gt; private static void Exch\u0026lt;T\u0026gt;(T[] pq, int a, int b) { var temp = pq[a]; pq[a] = pq[b]; pq[b] = temp; } } 另请参阅 # PriorityQueue 库\n"},{"id":320,"href":"/2-5-1/","title":"2.5.1","section":"《算法（第四版）》C# 题解","content":" 2.5.1 # 解答 # 如果比较的两个 String 引用的是同一个对象，那么就直接返回相等，不必再逐字符比较。\n一个例子：\nstring s = \u0026#34;abcabc\u0026#34;; string p = s; Console.WriteLine(s.CompareTo(p)); "},{"id":321,"href":"/2-5-2/","title":"2.5.2","section":"《算法（第四版）》C# 题解","content":" 2.5.2 # 解答 # 将字符串数组 keywords 按照长度排序，于是 keywords[0] 就是最短的字符串。\n组合词的最短长度 minLength = 最短字符串的长度 * 2 = keywords[0] * 2。\n先找到第一个长度大于等于 minLength 的字符串，下标为 canCombine。\n我们从 canCombine 开始，一个个检查是否是组合词。 如果 keywords[canCombine] 是一个组合词，那么它一定是由位于它之前的某两个字符串组合而成的。\n组合词的长度一定等于被组合词的长度之和，因此我们可以通过长度快速判断有可能的组合词。\n现在题目转化为了如何解决 ThreeSum 问题，即求 a + b = c 型问题，根据 1.4.41 中的解法求解。\nkeywords[canCombine] 的长度已知，i 从 0 到 canCombine 之间循环，\n用二分查找确认 i 到 canCombine 之间有没有符合条件的字符串，注意多个字符串可能长度相等。\n代码 # var keywords = Console.ReadLine().Split(\u0026#39; \u0026#39;); Array.Sort(keywords, new StringLengthComparer()); var minLength = keywords[0].Length * 2; // 找到第一个大于 minLength 的字符串 var canCombine = 0; while (keywords[canCombine].Length \u0026lt; minLength \u0026amp;\u0026amp; canCombine \u0026lt; keywords.Length) canCombine++; // 依次测试是否可能 while (canCombine \u0026lt; keywords.Length) { var sum = keywords[canCombine].Length; for (var i = 0; i \u0026lt; canCombine; i++) { var start = BinarySearch(keywords, sum - keywords[i].Length, i, canCombine); if (start != -1) { while (keywords[start].Length + keywords[i].Length == sum) { if (keywords[start] + keywords[i] == keywords[canCombine]) Console.WriteLine(keywords[canCombine] + \u0026#34; = \u0026#34; + keywords[start] + \u0026#34; + \u0026#34; + keywords[i]); else if (keywords[i] + keywords[start] == keywords[canCombine]) Console.WriteLine(keywords[canCombine] + \u0026#34; = \u0026#34; + keywords[i] + \u0026#34; + \u0026#34; + keywords[start]); start++; } } } canCombine++; } // 二分查找，返回符合条件的最小下标。 static int BinarySearch(string[] keys, int length, int lo, int hi) { while (lo \u0026lt;= hi) { var mid = lo + (hi - lo) / 2; if (keys[mid].Length == length) { while (mid \u0026gt;= lo \u0026amp;\u0026amp; keys[mid].Length == length) mid--; return mid + 1; } if (length \u0026gt; keys[mid].Length) lo = mid + 1; else hi = mid - 1; } return -1; } /// \u0026lt;summary\u0026gt; /// 根据字符串长度进行比较。 /// \u0026lt;/summary\u0026gt; internal class StringLengthComparer : IComparer\u0026lt;string\u0026gt; { public int Compare(string x, string y) { return x.Length.CompareTo(y.Length); } } "},{"id":322,"href":"/2-5-3/","title":"2.5.3","section":"《算法（第四版）》C# 题解","content":" 2.5.3 # 解答 # 这样会破坏相等的传递性。\n例如 a = 0.005, b=0.000, c=-0.005，则 a == b, c == b，但是 a != c。\n"},{"id":323,"href":"/2-5-4/","title":"2.5.4","section":"《算法（第四版）》C# 题解","content":" 2.5.4 # 解答 # 先排序，然后用书中的代码进行去重。\nstatic string[] Dedup(string[] a) { if (a.Length == 0) return a; var sorted = new string[a.Length]; for (var i = 0; i \u0026lt; a.Length; i++) { sorted[i] = a[i]; } Array.Sort(sorted); // sorted = sorted.Distinct().ToArray(); var distinct = new string[sorted.Length]; distinct[0] = sorted[0]; var j = 1; for (var i = 1; i \u0026lt; sorted.Length; i++) { if (sorted[i].CompareTo(sorted[i - 1]) != 0) distinct[j++] = sorted[i]; } return distinct; } "},{"id":324,"href":"/2-5-5/","title":"2.5.5","section":"《算法（第四版）》C# 题解","content":" 2.5.5 # 解答 # 因为选择排序会交换不相邻的元素。 例如：\nB1 B2 A A B2 B1 此时 B1 和 B2 的相对位置被改变，如果将交换限定在相邻元素之间（插入排序）。\nB1 B2 A B1 A B2 A B2 B2 此时排序就是稳定的了。\n"},{"id":325,"href":"/2-5-6/","title":"2.5.6","section":"《算法（第四版）》C# 题解","content":" 2.5.6 # 解答 # 非递归官网实现见：https://algs4.cs.princeton.edu/23quicksort/QuickPedantic.java.html\n原本是和快速排序一块介绍的，将数组重新排列，使得 a[k] 正好是第 k 小的元素，k 从 0 开始。\n具体思路类似于二分查找，\n先切分，如果切分位置小于 k，那么在右半部分继续切分，否则在左半部分继续切分。\n直到切分位置正好等于 k，直接返回 a[k] 。\n代码 # // 使 a[k] 变为第 k 小的数，k 从 0 开始。 // a[0] ~ a[k-1] 都小于等于 a[k], a[k+1]~a[n-1] 都大于等于 a[k] static T Select\u0026lt;T\u0026gt;(T[] a, int k, int lo, int hi) where T : IComparable\u0026lt;T\u0026gt; { if (k \u0026gt; a.Length || k \u0026lt; 0) throw new ArgumentOutOfRangeException(nameof(k), \u0026#34;select out of bound\u0026#34;); if (lo \u0026gt;= hi) return a[lo]; var i = Partition(a, lo, hi); if (i \u0026gt; k) return Select(a, k, lo, i - 1); if (i \u0026lt; k) return Select(a, k, i + 1, hi); return a[i]; } 另请参阅 # SortApplication 库\n"},{"id":326,"href":"/2-5-7/","title":"2.5.7","section":"《算法（第四版）》C# 题解","content":" 2.5.7 # 解答 # 参考书中给出的快速排序性能分析方法（中文版 P186，英文版 P293）。\n设 $C_n$ 代表找出 $n$ 个元素中的最小值所需要的比较次数。\n一次切分需要 $n+1$ 次比较，下一侧的元素个数从 $0$ 到 $ n-1 ​$ 都有可能，\n于是根据全概率公式，有：\n$$ \\begin{eqnarray} C_n\u0026amp;=\u0026amp;\\frac {1}{n} (n+1) +\\frac{1}{n} (n+1+C_1)+ \\cdots + \\frac{1}{n}(n+1+C_{n-1}) \\newline C_n\u0026amp;=\u0026amp;n+1+\\frac{1}{n}(C_1+C_2+\\cdots+C_{n-1}) \\newline nC_n\u0026amp;=\u0026amp;n(n+1)+(C_1+C_2+\\cdots+C_{n-1}) \\newline nC_n-(n-1)C_{n-1}\u0026amp;=\u0026amp;2n+C_{n-1} \\newline nC_n\u0026amp;=\u0026amp;2n+nC_{n-1} \\newline C_n\u0026amp;=\u0026amp;2+C_{n-1} \\newline C_n \u0026amp;=\u0026amp; C_1+2(n-1) \\newline C_n \u0026amp;=\u0026amp; 2n-2 \u0026lt; 2n \\end{eqnarray} $$\n测试结果符合我们的预期。 附加：找出第 $k$ 小的数平均需要的比较次数。\n类似的方法也在计算快速排序的平均比较次数时使用，见 {% post_link 2-3-14.md %}。\n首先和快速排序类似，select 方法的所有元素比较都发生在切分过程中。\n接下来考虑第 $i$ 小和第 $j$ 小的元素（$x_i$ ，$x_j$），\n当枢轴选为 $x_i$ 或 $x_j$ 时，它们会发生比较；\n如果枢轴选为 $x_i$ 和 $x_j$ 之间的元素，那么它们会被切分到两侧，不可能发生比较；\n如果枢轴选为小于 $x_i$ 或大于 $x_j$ 的元素，它们会被切分到同一侧，进入下次切分。\n但要注意的是，select 只会对切分的一侧进行再切分，另一侧会被抛弃（快速排序则是两侧都会再切分）。\n因此我们需要将第 $k$ 小的数 $x_k$ 纳入考虑。\n如果 $x_k\u0026gt;x_j\u0026gt;x_i$ ，且枢轴选了 $x_k$ 到 $x_j$ 之间的元素，切分后 $x_i$ 和 $x_j$ 会被一起抛弃，不发生比较。\n如果 $x_j \u0026gt; x_k \u0026gt; x_i$ ，枢轴的选择情况和快速排序一致。\n如果 $x_j \u0026gt; x_i \u0026gt; x_k$ ，且枢轴选了 $x_i$ 到 $x_k$ 之间的元素，切分后 $x_i$ 和 $x_j$ 会被一起抛弃，不发生比较。\n综上我们可以得到 $x_i$ 和 $x_j$ 之间发生比较的概率 $\\frac{2}{\\max(j-i+1, k-i+1,j-k+1)}$ 。\n我们利用线性规划的知识把最大值函数的区域画出来，如下图所示：\n对蓝色区域积分得：\n$$ \\begin{eqnarray} \u0026amp;\u0026amp;\\int_{0}^{k} dj \\int_{0}^{j} \\frac{2}{j-k+1}\\ di \\newline \u0026amp;=\u0026amp; 2 \\int_{0}^{k} \\frac{j}{j-k+1} \\ dj \\newline \u0026amp;\u0026lt;\u0026amp; 2 k \\end{eqnarray} $$\n对红色区域积分得：\n$$ \\begin {eqnarray} \u0026amp;\u0026amp; \\int_{k}^{n} di \\int_{i}^{n} \\frac{2}{k-i+1} dj \\newline \u0026amp;=\u0026amp; 2\\int_{k}^{n} \\frac{n-i}{k-i+1} di \\newline \u0026amp;\u0026lt;\u0026amp; 2(n-k) \\end {eqnarray} $$\n对绿色区域积分得：\n$$ \\begin{eqnarray} \u0026amp;\u0026amp; \\int_{0}^{k}di\\int_{k}^{n} \\frac{2}{j-i+1} dj \\newline \u0026amp;\u0026lt;\u0026amp; \\int_{0}^{k}di\\int_{k}^{n} \\frac{2}{j-i} dj \\newline \u0026amp;=\u0026amp; 2\\int_{0}^{k} \\ln (n-i) di - 2\\int_{0}^{k} \\ln(k-i)di \\newline \u0026amp;=\u0026amp; 2i\\ln(n-i) \\bigg|{0}^{k} + 2\\int{0}^{k}\\frac{i}{n-i} di - \\left[ i\\ln(k-i) \\bigg|{0}^{k} + 2\\int{0}^{k} \\frac{i}{k-i} di \\right] \\newline \u0026amp;=\u0026amp; 2k\\ln(n-k)+2\\int_{0}^{k}\\frac{n}{n-i}-1 \\ di -2\\int_{0}^{k} \\frac{k}{k-i}-1 \\ di \\newline \u0026amp;=\u0026amp; 2k\\ln(n-k)+2\\int_{0}^{k}\\frac{n}{n-i} \\ di -2k - 2\\int_{0}^{k} \\frac{k}{k-i} \\ di +2k \\newline \u0026amp;=\u0026amp; 2k\\ln(n-k) -2n\\ln(n-i) \\bigg|{0}^{k} +2k\\ln(k-i)\\bigg|{0}^{k} \\newline \u0026amp;=\u0026amp; 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k \\end{eqnarray} $$\n全部相加得到：\n$$ \\begin{eqnarray} \u0026amp;\u0026amp; 2k+2(n-k)+2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k \\newline \u0026amp;=\u0026amp; 2n + 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n -2k\\ln k \\newline \u0026amp;=\u0026amp; 2n + 2k\\ln(n-k)-2n\\ln(n-k)+2n\\ln n-2k\\ln k +2k\\ln n-2k\\ln n \\newline \u0026amp;=\u0026amp; 2n + 2k\\ln n-2k\\ln k+2n\\ln n-2n\\ln(n-k) - 2k\\ln n + 2k\\ln(n-k) \\newline \u0026amp;=\u0026amp; 2n + 2k\\ln \\left(\\frac{n}{k} \\right)+2n\\ln\\left(\\frac{n}{n-k} \\right) - 2k\\ln\\left(\\frac{n}{n-k} \\right) \\newline \u0026amp;=\u0026amp; 2n+2k\\ln\\left(\\frac{n}{k}\\right)+2(n-k)\\ln\\left(\\frac{n}{n-k} \\right) \\end{eqnarray} $$\n于是得到了命题 U 中的结果（中文版 P221，英文版 P347）。\n另请参阅 # Blum-style analysis of Quickselect\n"},{"id":327,"href":"/2-5-8/","title":"2.5.8","section":"《算法（第四版）》C# 题解","content":" 2.5.8 # 解答 # 官网实现见：https://algs4.cs.princeton.edu/25applications/Frequency.java.html\n用到的数据来自（右键另存为）：https://introcs.cs.princeton.edu/java/data/tale.txt\n先把所有单词读入，然后排序，一样的单词会被放在一起，\n接下来遍历一遍记录每个单词出现的次数。\n然后按照频率排序，倒序输出即可。\n定义了一个嵌套类 Record 来记录单词及出现次数，实现的比较器按照出现次数排序。\nclass Record : IComparable\u0026lt;Record\u0026gt; { public string Key { get; set; } // 单词 public int Value { get; set; } // 频率 public Record(string key, int value) { this.Key = key; this.Value = value; } public int CompareTo(Record other) { return this.Value.CompareTo(other.Value); } } 测试结果（前 1% 的单词）：\n代码 # var filename = \u0026#34;tale.txt\u0026#34;; var sr = new StreamReader(File.OpenRead(filename)); var a = sr.ReadToEnd().Split(new[] { \u0026#39; \u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); Array.Sort(a); var records = new Record[a.Length]; var word = a[0]; var freq = 1; var m = 0; for (var i = 0; i \u0026lt; a.Length; i++) { if (!a[i].Equals(word)) { records[m++] = new Record(word, freq); word = a[i]; freq = 0; } freq++; } records[m++] = new Record(word, freq); Array.Sort(records, 0, m); // 只显示频率为前 1% 的单词 for (var i = m - 1; i \u0026gt;= m * 0.99; i--) { Console.WriteLine(records[i].Value + \u0026#34; \u0026#34; + records[i].Key); } internal class Record : IComparable\u0026lt;Record\u0026gt; { public string Key { get; set; } // 单词 public int Value { get; set; } // 频率 public Record(string key, int value) { Key = key; Value = value; } public int CompareTo(Record other) { return Value.CompareTo(other.Value); } } "},{"id":328,"href":"/2-5-9/","title":"2.5.9","section":"《算法（第四版）》C# 题解","content":" 2.5.9 # 解答 # 右侧给出的是道琼斯指数，官方数据（右键另存为）：DJI\n设计一个类保存日期和交易量，然后按照交易量排序即可。\ninternal class Djia : IComparable\u0026lt;Djia\u0026gt; { public string Date { get; set; } public long Volume { get; set; } public Djia(string date, long vol) { Date = date; Volume = vol; } public int CompareTo(Djia other) { return Volume.CompareTo(other.Volume); } } "},{"id":329,"href":"/2-5-10/","title":"2.5.10","section":"《算法（第四版）》C# 题解","content":" 2.5.10 # 解答 # 用一个 int 数组来保存版本号，按顺序进行比较。\n如果两个版本号不等长且前缀相同，那么较长的版本号比较高，例如：1.2.1 和 1.2。\ninternal class Version : IComparable\u0026lt;Version\u0026gt; { private readonly int[] _versionNumber; public Version(string version) { var versions = version.Split(\u0026#39;.\u0026#39;); _versionNumber = new int[versions.Length]; for (var i = 0; i \u0026lt; versions.Length; i++) { _versionNumber[i] = int.Parse(versions[i]); } } public int CompareTo(Version other) { for (var i = 0; i \u0026lt; _versionNumber.Length \u0026amp;\u0026amp; i \u0026lt; other._versionNumber.Length; i++) { if (_versionNumber[i].CompareTo(other._versionNumber[i]) != 0) return _versionNumber[i].CompareTo(other._versionNumber[i]); } return _versionNumber.Length.CompareTo(other._versionNumber.Length); } public override string ToString() { var result = \u0026#34;\u0026#34;; for (var i = 0; i \u0026lt; _versionNumber.Length - 1; i++) { result += _versionNumber[i] + \u0026#34;.\u0026#34;; } result += _versionNumber[_versionNumber.Length - 1].ToString(); return result; } } "},{"id":330,"href":"/2-5-11/","title":"2.5.11","section":"《算法（第四版）》C# 题解","content":" 2.5.11 # 解答 # 结果如下，其中快速排序去掉了一开始打乱数组的步骤：\n只有快速排序和堆排序会进行交换，剩下四种排序都不会进行交换。\n插入排序在排序元素完全相同的数组时只会进行一次遍历，不会交换。\n选择排序第 i 次找到的最小值就是 a[i] ，只会让 a[i] 和 a[i] 交换，不会影响顺序。\n希尔排序和插入排序类似，每轮排序都不会进行交换。\n归并排序是稳定的，就本例而言，只会从左到右依次归并，不会发生顺序变化。\n快速排序在遇到相同元素时会交换，因此顺序会发生变化，且每次都是对半切分。\n堆排序在删除最大元素时会将第一个元素和最后一个元素交换，使元素顺序发生变化。\n代码 # // 插入排序 Console.WriteLine(\u0026#34;Insertion Sort\u0026#34;); Test(new InsertionSort(), 7, 1); // 选择排序 Console.WriteLine(\u0026#34;Selection Sort\u0026#34;); Test(new SelectionSort(), 7, 1); // 希尔排序 Console.WriteLine(\u0026#34;Shell Sort\u0026#34;); Test(new ShellSort(), 7, 1); // 归并排序 Console.WriteLine(\u0026#34;Merge Sort\u0026#34;); Test(new MergeSort(), 7, 1); // 快速排序 Console.WriteLine(\u0026#34;Quick Sort\u0026#34;); var quick = new QuickSortAnalyze { NeedShuffle = false, NeedPath = false }; Test(quick, 7, 1); // 堆排序 Console.WriteLine(\u0026#34;Heap Sort\u0026#34;); var array = new Item\u0026lt;int\u0026gt;[7]; for (var i = 0; i \u0026lt; 7; i++) array[i] = new Item\u0026lt;int\u0026gt;(i, 1); Heap.Sort(array); for (var i = 0; i \u0026lt; 7; i++) Console.Write(array[i].Index + \u0026#34; \u0026#34;); Console.WriteLine(); static void Test(BaseSort sort, int n, int constant) { var array = new Item\u0026lt;int\u0026gt;[n]; for (var i = 0; i \u0026lt; n; i++) array[i] = new Item\u0026lt;int\u0026gt;(i, constant); sort.Sort(array); for (var i = 0; i \u0026lt; n; i++) Console.Write(array[i].Index + \u0026#34; \u0026#34;); Console.WriteLine(); } /// \u0026lt;summary\u0026gt; /// 用来排序的元素，记录有自己的初始下标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt; internal class Item\u0026lt;T\u0026gt; : IComparable\u0026lt;Item\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public readonly int Index; public T Key; public Item(int index, T key) { Index = index; Key = key; } public int CompareTo(Item\u0026lt;T\u0026gt; other) { return Key.CompareTo(other.Key); } } 另请参阅 # SortApplication 库\n"},{"id":331,"href":"/2-5-12/","title":"2.5.12","section":"《算法（第四版）》C# 题解","content":" 2.5.12 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/SPT.java.html\n把任务按照处理时间升序排序即可。\n建立 Job 类，保存任务的名称和处理时间，并实现了 IConparable\u0026lt;Job\u0026gt; 接口。\ninternal class Job : IComparable\u0026lt;Job\u0026gt; { public readonly string Name; public readonly double Time; public Job(string name, double time) { Name = name; Time = time; } public int CompareTo(Job other) { return Time.CompareTo(other.Time); } } 代码 # var n = int.Parse(Console.ReadLine()); var jobs = new Job[n]; for (var i = 0; i \u0026lt; n; i++) { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;); jobs[i] = new Job(input[0], double.Parse(input[1])); } Array.Sort(jobs); for (var i = 0; i \u0026lt; jobs.Length; i++) { Console.WriteLine(jobs[i].Name + \u0026#34; \u0026#34; + jobs[i].Time); } "},{"id":332,"href":"/2-5-13/","title":"2.5.13","section":"《算法（第四版）》C# 题解","content":" 2.5.13 # 解答 # 官方解答见：https://algs4.cs.princeton.edu/25applications/LPT.java.html\n使用上题的 Job 类，在本题建立 Processor 类来代表处理器，定义如下：\ninternal class Processor : IComparable\u0026lt;Processor\u0026gt; { private readonly List\u0026lt;Job\u0026gt; _jobs = new(); private double _busyTime; public void Add(Job job) { _jobs.Add(job); _busyTime += job.Time; } public int CompareTo(Processor other) { return _busyTime.CompareTo(other._busyTime); } public override string ToString() { var sb = new StringBuilder(); var nowList = _jobs.ToArray(); for (var i = 0; i \u0026lt; nowList.Length; i++) { sb.AppendLine(nowList[i].Name + \u0026#34; \u0026#34; + nowList[i].Time); } return sb.ToString(); } } 按照读入所有的任务并排序，再将所有的处理器放进一个最小堆里。\n从最小堆取出任务最轻的处理器，按取耗时最长的任务分配给它，再将它放回最小堆中。\n最后依次打印处理器的任务分配即可。\n代码 # using System; using System.Collections.Generic; using System.Text; using SortApplication; // ReSharper disable AssignNullToNotNullAttribute // ReSharper disable PossibleNullReferenceException var processorNum = int.Parse(Console.ReadLine()); var jobNum = int.Parse(Console.ReadLine()); var jobs = new Job[jobNum]; for (var i = 0; i \u0026lt; jobNum; i++) { var jobDesc = Console.ReadLine().Split(\u0026#39; \u0026#39;); jobs[i] = new Job(jobDesc[0], double.Parse(jobDesc[1])); } Array.Sort(jobs); var processors = new MinPq\u0026lt;Processor\u0026gt;(processorNum); for (var i = 0; i \u0026lt; processorNum; i++) { processors.Insert(new Processor()); } for (var i = jobs.Length - 1; i \u0026gt;= 0; i--) { var min = processors.DelMin(); min.Add(jobs[i]); processors.Insert(min); } while (!processors.IsEmpty()) { Console.WriteLine(processors.DelMin()); } internal class Job : IComparable\u0026lt;Job\u0026gt; { public readonly string Name; public readonly double Time; public Job(string name, double time) { Name = name; Time = time; } public int CompareTo(Job other) { return Time.CompareTo(other.Time); } } internal class Processor : IComparable\u0026lt;Processor\u0026gt; { private readonly List\u0026lt;Job\u0026gt; _jobs = new(); private double _busyTime; public void Add(Job job) { _jobs.Add(job); _busyTime += job.Time; } public int CompareTo(Processor other) { return _busyTime.CompareTo(other._busyTime); } public override string ToString() { var sb = new StringBuilder(); var nowList = _jobs.ToArray(); for (var i = 0; i \u0026lt; nowList.Length; i++) { sb.AppendLine(nowList[i].Name + \u0026#34; \u0026#34; + nowList[i].Time); } return sb.ToString(); } } 另请参阅 # SortApplication 库\n"},{"id":333,"href":"/2-5-14/","title":"2.5.14","section":"《算法（第四版）》C# 题解","content":" 2.5.14 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/Domain.java.html\n按照逆域名排序，例如输入的是 com.google 和 com.apple ，\n比较的时候是按照 google.com 和 apple.com 进行比较的。\n排序结果自然是 apple.com, google.com。\n编写的 Domain 类，CompareTo() 中是按照倒序进行比较的。\ninternal class Domain : IComparable\u0026lt;Domain\u0026gt; { private readonly string[] _fields; private readonly int _n; /// \u0026lt;summary\u0026gt; /// 构造一个域名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;url\u0026#34;\u0026gt;域名的 url。\u0026lt;/param\u0026gt; public Domain(string url) { _fields = url.Split(\u0026#39;.\u0026#39;); _n = _fields.Length; } public int CompareTo(Domain other) { var minLength = Math.Min(_n, other._n); for (var i = 0; i \u0026lt; minLength; i++) { var c = _fields[minLength - i - 1].CompareTo(other._fields[minLength - i - 1]); if (c != 0) return c; } return _n.CompareTo(other._n); } public override string ToString() { var sb = new StringBuilder(); for (var i = 0; i \u0026lt; _fields.Length; i++) { if (i != 0) sb.Append(\u0026#39;.\u0026#39;); sb.Append(_fields[i]); } return sb.ToString(); } } 代码 # var domains = new Domain[5]; domains[0] = new Domain(\u0026#34;edu.princeton.cs\u0026#34;); domains[1] = new Domain(\u0026#34;edu.princeton.ee\u0026#34;); domains[2] = new Domain(\u0026#34;com.google\u0026#34;); domains[3] = new Domain(\u0026#34;edu.princeton\u0026#34;); domains[4] = new Domain(\u0026#34;com.apple\u0026#34;); Array.Sort(domains); for (var i = 0; i \u0026lt; domains.Length; i++) { Console.WriteLine(domains[i]); } "},{"id":334,"href":"/2-5-15/","title":"2.5.15","section":"《算法（第四版）》C# 题解","content":" 2.5.15 # 解答 # 利用上一题的逆域名排序将域名相同的电子邮件分在一起。\n代码 # // 利用上一题的逆域名排序，将相同的域名放在一起。 var emails = new Domain[5]; emails[0] = new Domain(\u0026#34;wayne@cs.princeton.edu\u0026#34;); emails[1] = new Domain(\u0026#34;windy@apple.com\u0026#34;); emails[2] = new Domain(\u0026#34;rs@cs.princeton.edu\u0026#34;); emails[3] = new Domain(\u0026#34;ike@ee.princeton.edu\u0026#34;); emails[4] = new Domain(\u0026#34;admin@princeton.edu\u0026#34;); Array.Sort(emails); for (var i = 0; i \u0026lt; emails.Length; i++) { Console.WriteLine(emails[i]); } "},{"id":335,"href":"/2-5-16/","title":"2.5.16","section":"《算法（第四版）》C# 题解","content":" 2.5.16 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/California.java.html\n数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt\n建立一个 string 的比较器，按照题目给定的顺序比较。\nprivate class CandidateComparer : IComparer\u0026lt;string\u0026gt; { private static readonly string order = \u0026#34;RWQOJMVAHBSGZXNTCIEKUPDYFL\u0026#34;; public int Compare(string x, string y) { int n = Math.Min(x.Length, y.Length); for (int i = 0; i \u0026lt; n; i++) { int a = order.IndexOf(x[i]); int b = order.IndexOf(y[i]); if (a != b) return a.CompareTo(b); } return x.Length.CompareTo(y.Length); } } 代码 # // 数据来源：https://introcs.cs.princeton.edu/java/data/california-gov.txt var sr = new StreamReader(File.OpenRead(\u0026#34;california-gov.txt\u0026#34;)); var names = sr.ReadToEnd() .ToUpper() .Split( new[] { \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); Array.Sort(names, new CandidateComparer()); for (var i = 0; i \u0026lt; names.Length; i++) { Console.WriteLine(names[i]); } // 官方解答：https://algs4.cs.princeton.edu/25applications/California.java.html internal class CandidateComparer : IComparer\u0026lt;string\u0026gt; { private const string Order = \u0026#34;RWQOJMVAHBSGZXNTCIEKUPDYFL\u0026#34;; public int Compare(string x, string y) { var n = Math.Min(x.Length, y.Length); for (var i = 0; i \u0026lt; n; i++) { var a = Order.IndexOf(x[i]); var b = Order.IndexOf(y[i]); if (a != b) return a.CompareTo(b); } return x.Length.CompareTo(y.Length); } } "},{"id":336,"href":"/2-5-17/","title":"2.5.17","section":"《算法（第四版）》C# 题解","content":" 2.5.17 # 解答 # 用一个 Wrapper 类包装准备排序的元素，在排序前同时记录元素的内容和下标。\n随后对 Wrapper 数组排序，相同的元素会被放在一起，检查它们的下标是否是递增的。\n如果不是递增的，则排序算法就是不稳定的；否则排序算法就有可能是稳定的。 （不稳定的排序算法也可能不改变相同元素的相对位置，比如用选择排序对有序数组排序）\n代码 # var data = new[] { 7, 7, 4, 8, 8, 5, 1, 7, 7 }; var merge = new MergeSort(); var insertion = new InsertionSort(); var shell = new ShellSort(); var selection = new SelectionSort(); var quick = new QuickSort(); Console.WriteLine(\u0026#34;Merge Sort: \u0026#34; + CheckStability(data, merge)); Console.WriteLine(\u0026#34;Insertion Sort: \u0026#34; + CheckStability(data, insertion)); Console.WriteLine(\u0026#34;Shell Sort: \u0026#34; + CheckStability(data, shell)); Console.WriteLine(\u0026#34;Selection Sort: \u0026#34; + CheckStability(data, selection)); Console.WriteLine(\u0026#34;Quick Sort: \u0026#34; + CheckStability(data, quick)); bool CheckStability\u0026lt;T\u0026gt;(T[] input, BaseSort sort) where T : IComparable\u0026lt;T\u0026gt; { var items = new Wrapper\u0026lt;T\u0026gt;[input.Length]; for (var i = 0; i \u0026lt; input.Length; i++) items[i] = new Wrapper\u0026lt;T\u0026gt;(i, input[i]); sort.Sort(items); var index = 0; while (index \u0026lt; input.Length - 1) { while (index \u0026lt; input.Length - 1 \u0026amp;\u0026amp; items[index].Key.Equals(items[index + 1].Key)) { if (items[index].Index \u0026gt; items[index + 1].Index) return false; index++; } index++; } return true; } internal class Wrapper\u0026lt;T\u0026gt; : IComparable\u0026lt;Wrapper\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public readonly int Index; public T Key; public Wrapper(int index, T elements) { Index = index; Key = elements; } public int CompareTo(Wrapper\u0026lt;T\u0026gt; other) { return Key.CompareTo(other.Key); } } 另请参阅 # SortApplication 库\n"},{"id":337,"href":"/2-5-18/","title":"2.5.18","section":"《算法（第四版）》C# 题解","content":" 2.5.18 # 解答 # 用和上题一样的 Wrapper 类进行排序。\n排序之后，相同的元素会被放在一起，形成一个个子数组。\n根据事先保存的原始下标对它们进行排序，即可将不稳定的排序稳定化。\n结果：\n代码 # var data = new[] { 5, 7, 3, 4, 7, 3, 6, 3, 3 }; var quick = new QuickSort(); var shell = new ShellSort(); Console.WriteLine(\u0026#34;Quick Sort\u0026#34;); Stabilize(data, quick); Console.WriteLine(); Console.WriteLine(\u0026#34;Shell Sort\u0026#34;); Stabilize(data, shell); static void Stabilize\u0026lt;T\u0026gt;(T[] data, BaseSort sort) where T : IComparable\u0026lt;T\u0026gt; { var items = new Wrapper\u0026lt;T\u0026gt;[data.Length]; for (var i = 0; i \u0026lt; data.Length; i++) { items[i] = new Wrapper\u0026lt;T\u0026gt;(i, data[i]); } sort.Sort(items); Console.Write(\u0026#34;Index:\\t\u0026#34;); for (var i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Index + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;Elem:\\t\u0026#34;); for (var i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Key + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(); var index = 0; while (index \u0026lt; items.Length - 1) { while (index \u0026lt; items.Length - 1 \u0026amp;\u0026amp; items[index].Key.Equals(items[index + 1].Key)) { // 插入排序 for (var j = index + 1; j \u0026gt; 0 \u0026amp;\u0026amp; items[j].Index \u0026lt; items[j - 1].Index; j--) { if (!items[j].Key.Equals(items[j - 1].Key)) break; var temp = items[j]; items[j] = items[j - 1]; items[j - 1] = temp; } index++; } index++; } Console.Write(\u0026#34;Index:\\t\u0026#34;); for (var i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Index + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.Write(\u0026#34;Elem:\\t\u0026#34;); for (var i = 0; i \u0026lt; items.Length; i++) { Console.Write(items[i].Key + \u0026#34; \u0026#34;); } Console.WriteLine(); } internal class Wrapper\u0026lt;T\u0026gt; : IComparable\u0026lt;Wrapper\u0026lt;T\u0026gt;\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { public readonly int Index; public T Key; public Wrapper(int index, T elements) { Index = index; Key = elements; } public int CompareTo(Wrapper\u0026lt;T\u0026gt; other) { return Key.CompareTo(other.Key); } } 另请参阅 # SortApplication 库\n"},{"id":338,"href":"/2-5-19/","title":"2.5.19","section":"《算法（第四版）》C# 题解","content":" 2.5.19 # 解答 # 官方解答： Kendall Tau：https://algs4.cs.princeton.edu/25applications/KendallTau.java.html\nInversion：https://algs4.cs.princeton.edu/22mergesort/Inversions.java.html\n由书中 2.5.3.2 节得，两个数组之间的 Kendall Tau 距离即为两数组之间顺序不同的数对数目。\n如果能够把其中一个数组变成标准排列（即 1,2,3,4... 这样的数组），\n那么此时 Kendall Tau 距离就等于另一个数组中的逆序对数量。\n现在我们来解决如何把一个数组 a 变成标准排列的方法。\n也就是找到函数 $ f(x) ​$，使得 $ f(a[i])=i ​$ ，这样的函数其实就是数组 a 的逆数组。\n如下图所示，逆数组 ainv 即为满足 ainv[a[i]] = i 的数组。\n获得逆数组之后，对另一个数组 b 做同样的变换，令数组 bnew[i] = ainv[b[i]] 。\n即 ainv[a[i]] = i, ainv[b[i]] = bnew[i] 。\n于是问题转化为了 bnew 和标准排列之间的 Kendall Tau 距离，即 bnew 的逆序对数量。\n逆序对数量的求法见 2-2-19。\n代码 # int[] testA = { 0, 3, 1, 6, 2, 5, 4 }; int[] testB = { 1, 0, 3, 6, 4, 2, 5 }; Console.WriteLine(Distance(testA, testB)); static long Distance(int[] a, int[] b) { if (a.Length != b.Length) throw new ArgumentException(\u0026#34;Array dimensions disagree\u0026#34;); var n = a.Length; var ainv = new int[n]; for (var i = 0; i \u0026lt; n; i++) { ainv[a[i]] = i; } var bnew = new int[n]; for (var i = 0; i \u0026lt; n; i++) { bnew[i] = ainv[b[i]]; } var inversions = new Inversions(); inversions.Count(bnew); return inversions.Counter; } "},{"id":339,"href":"/2-5-20/","title":"2.5.20","section":"《算法（第四版）》C# 题解","content":" 2.5.20 # 解答 # 我们以事件为单位进行处理，每个事件包含任务名，记录时刻和开始/结束标记。\n随后按照时间从小到大排序，遍历事件数组。\n设开始的时候机器空闲，设置计数器，作为当前正在运行的任务数量。\n当遇到开始事件时，计数器加一；遇到结束事件时，计数器减一。\n如果计数器加一之前计数器为 0，说明空闲状态结束，记录并更新空闲时间，当前时间为忙碌开始的时间。\n如果计数器减一之后计数器为 0，说明忙碌状态结束，记录并更新忙碌时间，当前时间为空闲开始的时间。\n测试结果：\n代码 # var nowRunning = 0; // 正在运行的程序数量 var maxIdle = 0; var maxBusy = 0; var items = int.Parse(Console.ReadLine()); var jobs = new JobEvent[items * 2]; for (var i = 0; i \u0026lt; jobs.Length; i += 2) { jobs[i] = new JobEvent(); jobs[i + 1] = new JobEvent(); jobs[i].IsFinished = false; // 开始事件 jobs[i + 1].IsFinished = true; // 停止事件 var record = Console.ReadLine().Split(new[] { \u0026#39; \u0026#39;, \u0026#39;:\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); jobs[i].JobName = record[0]; jobs[i + 1].JobName = record[0]; jobs[i].Time = int.Parse(record[1]) * 60 + int.Parse(record[2]); jobs[i + 1].Time = int.Parse(record[3]) * 60 + int.Parse(record[4]); } Array.Sort(jobs); // 事件处理 var idleStart = 0; var busyStart = 0; for (var i = 0; i \u0026lt; jobs.Length; i++) { // 启动事件 if (!jobs[i].IsFinished) { // 空闲状态结束 if (nowRunning == 0) { var idle = jobs[i].Time - idleStart; if (idle \u0026gt; maxIdle) maxIdle = idle; // 开始忙碌 busyStart = jobs[i].Time; } nowRunning++; } else { nowRunning--; // 忙碌状态结束 if (nowRunning == 0) { var busy = jobs[i].Time - busyStart; if (busy \u0026gt; maxBusy) maxBusy = busy; // 开始空闲 idleStart = jobs[i].Time; } } } Console.WriteLine(\u0026#34;Max Idle: \u0026#34; + maxIdle); Console.WriteLine(\u0026#34;Max Busy: \u0026#34; + maxBusy); /// \u0026lt;summary\u0026gt; /// 任务变化事件。 /// \u0026lt;/summary\u0026gt; internal class JobEvent : IComparable\u0026lt;JobEvent\u0026gt; { public string JobName; public int Time; public bool IsFinished; // false = 开始，true = 结束 public int CompareTo(JobEvent other) { return Time.CompareTo(other.Time); } } "},{"id":340,"href":"/2-5-21/","title":"2.5.21","section":"《算法（第四版）》C# 题解","content":" 2.5.21 # 解答 # 与之前的版本号比较十分类似，对数组进行包装，然后按照次序依次比较即可。\ninternal class Vector : IComparable\u0026lt;Vector\u0026gt; { private readonly int[] _data; public int Length { get; set; } public Vector(int[] data) { _data = data; Length = data.Length; } public int CompareTo(Vector other) { var maxN = Math.Max(Length, other.Length); for (var i = 0; i \u0026lt; maxN; i++) { var comp = _data[i].CompareTo(other._data[i]); if (comp != 0) return comp; } return Length.CompareTo(other.Length); } public override string ToString() { var sb = new StringBuilder(); for (var i = 0; i \u0026lt; Length; i++) { if (i != 0) sb.Append(\u0026#39; \u0026#39;); sb.Append(_data[i]); } return sb.ToString(); } } "},{"id":341,"href":"/2-5-22/","title":"2.5.22","section":"《算法（第四版）》C# 题解","content":" 2.5.22 # 解答 # 建立最小堆和最大堆，最小堆保存卖家的报价，最大堆保存买家的报价。\n如果最小堆中的最低卖出价低于最大堆的最高买入价，交易达成，交易份额较大的一方需要重新回到堆内。\n测试结果：\n代码 # // 输入格式： buy 20.05 100 var buyer = new MaxPq\u0026lt;Ticket\u0026gt;(); var seller = new MinPq\u0026lt;Ticket\u0026gt;(); var n = int.Parse(Console.ReadLine()); for (var i = 0; i \u0026lt; n; i++) { var ticket = new Ticket(); var item = Console.ReadLine().Split(\u0026#39; \u0026#39;); ticket.Price = double.Parse(item[1]); ticket.Share = int.Parse(item[2]); if (item[0] == \u0026#34;buy\u0026#34;) buyer.Insert(ticket); else seller.Insert(ticket); } while (!buyer.IsEmpty() \u0026amp;\u0026amp; !seller.IsEmpty()) { if (buyer.Max().Price \u0026lt; seller.Min().Price) break; var buy = buyer.DelMax(); var sell = seller.DelMin(); Console.Write(\u0026#34;sell $\u0026#34; + sell.Price + \u0026#34; * \u0026#34; + sell.Share); if (buy.Share \u0026gt; sell.Share) { Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + sell.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); buy.Share -= sell.Share; buyer.Insert(buy); } else if (buy.Share \u0026lt; sell.Share) { sell.Share -= buy.Share; seller.Insert(sell); Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + buy.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); } else { Console.WriteLine(\u0026#34; -\u0026gt; \u0026#34; + sell.Share + \u0026#34; -\u0026gt; $\u0026#34; + buy.Price + \u0026#34; * \u0026#34; + buy.Share + \u0026#34; buy\u0026#34;); } } internal class Ticket : IComparable\u0026lt;Ticket\u0026gt; { public double Price; public int Share; public int CompareTo(Ticket other) { return Price.CompareTo(other.Price); } } 另请参阅 # SortApplication 库\n"},{"id":342,"href":"/2-5-23/","title":"2.5.23","section":"《算法（第四版）》C# 题解","content":" 2.5.23 # 解答 # 这里我们使用 Floyd-Rivest 算法进行优化，大致思想是：\n我们期望第 $k$ 大的元素位于 a[k] 附近，因此优先对 a[k] 附近的区域进行选择。\n每次切分时枢轴都选择 a[k]，先递归对样本区域选择，再对整个数组进行选择。\n运行示意图：\n测试结果：\n代码 # // Floyd–Rivest 方法优化，令 a[k] 变成第 k 小的元素。 static T SelectInternal\u0026lt;T\u0026gt;(T[] a, int lo, int hi, int k) where T : IComparable\u0026lt;T\u0026gt; { if (k \u0026lt; 0 || k \u0026gt; a.Length) { throw new IndexOutOfRangeException(\u0026#34;SelectInternal elements out of bounds\u0026#34;); } while (hi \u0026gt; lo) { if (hi - lo \u0026gt; 600) { var n = hi - lo + 1; var i = k - lo + 1; var z = (int)Math.Log(n); var s = (int)(Math.Exp(2 * z / 3) / 2); var sd = (int)Math.Sqrt(z * s * (n - s) / n) * Math.Sign(i - n / 2) / 2; var newLo = Math.Max(lo, k - i * s / n + sd); var newHi = Math.Min(hi, k + (n - i) * s / n + sd); SelectInternal(a, newLo, newHi, k); } Exch(a, lo, k); var j = Partition(a, lo, hi); if (j \u0026gt; k) { hi = j - 1; } else if (j \u0026lt; k) { lo = j + 1; } else { return a[j]; } } return a[lo]; } 另请参阅 # Floyd–Rivest algorithm - Wikipedia\n"},{"id":343,"href":"/2-5-24/","title":"2.5.24","section":"《算法（第四版）》C# 题解","content":" 2.5.24 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/StableMinPQ.java.html\n在元素插入的同时记录插入顺序，比较的时候把插入顺序也纳入比较。\n对于值一样的元素，插入顺序在前的的元素比较小。\n交换的时候需要同时交换插入次序。\n代码 # public class MinPqStable\u0026lt;TKey\u0026gt; : IMinPq\u0026lt;TKey\u0026gt;, IEnumerable\u0026lt;TKey\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 保存元素的数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;保存元素的数组。\u0026lt;/value\u0026gt; protected TKey[] Pq; /// \u0026lt;summary\u0026gt; /// 堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;堆中元素的数量。\u0026lt;/value\u0026gt; protected int N; /// \u0026lt;summary\u0026gt; /// 元素的插入次序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;元素的插入次序。\u0026lt;/value\u0026gt; private long[] _time; /// \u0026lt;summary\u0026gt; /// 元素的插入次序计数器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;元素的插入次序计数器。\u0026lt;/value\u0026gt; private long _timeStamp = 1; // 元素插入次序计数器。 /// \u0026lt;summary\u0026gt; /// 默认构造函数。 /// \u0026lt;/summary\u0026gt; public MinPqStable() : this(1) { } /// \u0026lt;summary\u0026gt; /// 建立指定容量的最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;最小堆的容量。\u0026lt;/param\u0026gt; public MinPqStable(int capacity) { _time = new long[capacity + 1]; Pq = new TKey[capacity + 1]; N = 0; } /// \u0026lt;summary\u0026gt; /// 删除并返回最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小元素。\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentOutOfRangeException\u0026#34;\u0026gt;如果堆为空则抛出该异常。\u0026lt;/exception\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得最小值但不删除它，请使用 \u0026lt;see cref=\u0026#34;Min\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey DelMin() { if (IsEmpty()) throw new InvalidOperationException(\u0026#34;Priority Queue Underflow\u0026#34;); var min = Pq[1]; Exch(1, N--); Sink(1); Pq[N + 1] = default; _time[N + 1] = 0; if ((N \u0026gt; 0) \u0026amp;\u0026amp; (N == Pq.Length / 4)) Resize(Pq.Length / 2); //Debug.Assert(IsMinHeap()); return min; } /// \u0026lt;summary\u0026gt; /// 向堆中插入一个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;v\u0026#34;\u0026gt;需要插入的元素。\u0026lt;/param\u0026gt; public void Insert(TKey v) { if (N == Pq.Length - 1) Resize(2 * Pq.Length); Pq[++N] = v; _time[N] = ++_timeStamp; Swim(N); //Debug.Assert(IsMinHeap()); } /// \u0026lt;summary\u0026gt; /// 检查堆是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果堆为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; N == 0; /// \u0026lt;summary\u0026gt; /// 获得堆中最小元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中最小元素。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;如果希望获得并删除最小元素，请使用 \u0026lt;see cref=\u0026#34;DelMin\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; public TKey Min() =\u0026gt; Pq[1]; /// \u0026lt;summary\u0026gt; /// 获得堆中元素的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;堆中元素的数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; N; /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以升序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小堆的迭代器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TKey\u0026gt; GetEnumerator() { var copy = new MinPqStable\u0026lt;TKey\u0026gt;(N); for (var i = 1; i \u0026lt;= N; i++) copy.Insert(Pq[i]); while (!copy.IsEmpty()) yield return copy.DelMin(); // 下次迭代的时候从这里继续执行。 } /// \u0026lt;summary\u0026gt; /// 获取堆的迭代器，元素以升序排列。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小堆的迭代器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;该方法实际调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt; 方法。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } /// \u0026lt;summary\u0026gt; /// 使元素上浮。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要上浮的元素。\u0026lt;/param\u0026gt; private void Swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; Greater(k / 2, k)) { Exch(k, k / 2); k /= 2; } } /// \u0026lt;summary\u0026gt; /// 使元素下沉。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要下沉的元素。\u0026lt;/param\u0026gt; private void Sink(int k) { while (k * 2 \u0026lt;= N) { var j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; Greater(j, j + 1)) j++; if (!Greater(k, j)) break; Exch(k, j); k = j; } } /// \u0026lt;summary\u0026gt; /// 重新调整堆的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;调整后的堆大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { var temp = new TKey[capacity]; var timeTemp = new long[capacity]; for (var i = 1; i \u0026lt;= N; i++) { temp[i] = Pq[i]; timeTemp[i] = _time[i]; } Pq = temp; _time = timeTemp; } /// \u0026lt;summary\u0026gt; /// 判断堆中某个元素是否大于另一元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;判断是否较大的元素。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;判断是否较小的元素。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果下标为 \u0026lt;paramref name=\u0026#34;i\u0026#34;/\u0026gt; 的元素较大，则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Greater(int i, int j) { var cmp = Pq[i].CompareTo(Pq[j]); if (cmp == 0) return _time[i].CompareTo(_time[j]) \u0026gt; 0; return cmp \u0026gt; 0; } /// \u0026lt;summary\u0026gt; /// 交换堆中的两个元素。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;要交换的第一个元素下标。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;j\u0026#34;\u0026gt;要交换的第二个元素下标。\u0026lt;/param\u0026gt; protected virtual void Exch(int i, int j) { var swap = Pq[i]; Pq[i] = Pq[j]; Pq[j] = swap; var temp = _time[i]; _time[i] = _time[j]; _time[j] = temp; } /// \u0026lt;summary\u0026gt; /// 检查当前二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMinHeap() =\u0026gt; IsMinHeap(1); /// \u0026lt;summary\u0026gt; /// 确定以 k 为根节点的二叉树是不是一个最小堆。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要检查的二叉树根节点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果是则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsMinHeap(int k) { if (k \u0026gt; N) return true; var left = 2 * k; var right = 2 * k + 1; if (left \u0026lt;= N \u0026amp;\u0026amp; Greater(k, left)) return false; if (right \u0026lt;= N \u0026amp;\u0026amp; Greater(k, right)) return false; return IsMinHeap(left) \u0026amp;\u0026amp; IsMinHeap(right); } } 另请参阅 # SortApplication 库\n"},{"id":344,"href":"/2-5-25/","title":"2.5.25","section":"《算法（第四版）》C# 题解","content":" 2.5.25 # 解答 # 官方解答见：https://algs4.cs.princeton.edu/25applications/Point2D.java.html\n这些比较器都以嵌套类的形式在 Point2D 中定义。\n静态比较器直接在类中以静态成员的方式声明。\n非静态比较器则需要提供工厂方法，该方法新建并返回对应的比较器对象。\n代码 # /// \u0026lt;summary\u0026gt; /// 按照 X 顺序比较。 /// \u0026lt;/summary\u0026gt; private class XOrderComparer : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.X \u0026lt; y.X) { return -1; } if (x.X \u0026gt; y.X) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 Y 顺序比较。 /// \u0026lt;/summary\u0026gt; private class YOrderComparer : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { if (x.Y \u0026lt; y.Y) { return -1; } if (x.Y \u0026gt; y.Y) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极径顺序比较。 /// \u0026lt;/summary\u0026gt; private class ROrderComparer : Comparer\u0026lt;Point2D\u0026gt; { public override int Compare(Point2D x, Point2D y) { var delta = (x.X * x.X + x.Y * x.Y) - (y.X * y.X + y.Y * y.Y); if (delta \u0026lt; 0) { return -1; } if (delta \u0026gt; 0) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照 atan2 值顺序比较。 /// \u0026lt;/summary\u0026gt; private class Atan2Order : Comparer\u0026lt;Point2D\u0026gt; { private readonly Point2D _parent; public Atan2Order(Point2D parent) { _parent = parent; } public override int Compare(Point2D x, Point2D y) { var angle1 = _parent.AngleTo(x); var angle2 = _parent.AngleTo(y); if (angle1 \u0026lt; angle2) { return -1; } if (angle1 \u0026gt; angle2) { return 1; } return 0; } } /// \u0026lt;summary\u0026gt; /// 按照极角顺序比较。 /// \u0026lt;/summary\u0026gt; private class PolarOrder : Comparer\u0026lt;Point2D\u0026gt; { private readonly Point2D _parent; public PolarOrder(Point2D parent) { _parent = parent; } public override int Compare(Point2D q1, Point2D q2) { var dx1 = q1.X - _parent.X; var dy1 = q1.Y - _parent.Y; var dx2 = q2.X - _parent.X; var dy2 = q2.Y - _parent.Y; if (dy1 \u0026gt;= 0 \u0026amp;\u0026amp; dy2 \u0026lt; 0) { return -1; } if (dy2 \u0026gt;= 0 \u0026amp;\u0026amp; dy1 \u0026lt; 0) { return 1; } if (dy1 == 0 \u0026amp;\u0026amp; dy2 == 0) { if (dx1 \u0026gt;= 0 \u0026amp;\u0026amp; dx2 \u0026lt; 0) { return -1; } if (dx2 \u0026gt;= 0 \u0026amp;\u0026amp; dx1 \u0026lt; 0) { return 1; } return 0; } return -Ccw(_parent, q1, q2); } } 另请参阅 # SortApplication 库\n"},{"id":345,"href":"/2-5-26/","title":"2.5.26","section":"《算法（第四版）》C# 题解","content":" 2.5.26 # 解答 # 提示中已经给出了方法，使用上一题编写的比较器进行排序即可。\n效果演示：\n代码 # 绘图部分代码：\nusing System.Collections.Generic; using System.Drawing; using System.Windows.Forms; using SortApplication; namespace _2._5._26 { public partial class Form2 : Form { Graphics panel; List\u0026lt;Point2D\u0026gt; points; Point2D startPoint; double maxX = 0, maxY = 0; public Form2() { InitializeComponent(); } /// \u0026lt;summary\u0026gt; /// 显示并初始化绘图窗口。 /// \u0026lt;/summary\u0026gt; public void Init() { Show(); this.panel = CreateGraphics(); this.points = new List\u0026lt;Point2D\u0026gt;(); this.startPoint = null; } /// \u0026lt;summary\u0026gt; /// 向画板中添加一个点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;point\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Add(Point2D point) { this.points.Add(point); if (this.startPoint == null) { this.startPoint = point; this.maxX = point.X * 1.1; this.maxY = point.Y * 1.1; } else if (this.startPoint.Y \u0026gt; point.Y) this.startPoint = point; else if (this.startPoint.Y == point.Y \u0026amp;\u0026amp; this.startPoint.X \u0026gt; point.X) this.startPoint = point; if (point.X \u0026gt; this.maxX) this.maxX = point.X * 1.1; if (point.Y \u0026gt; this.maxY) this.maxY = point.Y * 1.1; this.points.Sort(this.startPoint.Polor_Order()); RefreashPoints(); } public void RefreashPoints() { double unitX = this.ClientRectangle.Width / this.maxX; double unitY = this.ClientRectangle.Height / this.maxY; double left = this.ClientRectangle.Left; double bottom = this.ClientRectangle.Bottom; this.panel.Clear(this.BackColor); Pen line = (Pen)Pens.Red.Clone(); line.Width = 6; Point2D before = this.startPoint; foreach (var p in this.points) { this.panel.FillEllipse(Brushes.Black, (float)(left + p.X * unitX - 5.0), (float)(bottom - p.Y * unitY - 5.0), (float)10.0, (float)10.0); this.panel.DrawLine(line, (float)(left + before.X * unitX), (float)(bottom - before.Y * unitY), (float)(left + p.X * unitX), (float)(bottom - p.Y * unitY)); before = p; } this.panel.DrawLine(line, (float)(left + before.X * unitX), (float)(bottom - before.Y * unitY), (float)(left + this.startPoint.X * unitX), (float)(bottom - this.startPoint.Y * unitY)); } } } 另请参阅 # SortApplication 库\n"},{"id":346,"href":"/2-5-27/","title":"2.5.27","section":"《算法（第四版）》C# 题解","content":" 2.5.27 # 解答 # 类似于索引排序的做法，访问数组都通过一层索引来间接实现。\n首先创建一个数组 index，令 index[i] = i。\n排序时的交换变成 index 数组中元素的交换，\n读取元素时使用 a[index[i]] 而非 a[i] 。\n代码 # // 间接排序。 static int[] IndirectSort\u0026lt;T\u0026gt;(T[] keys) where T : IComparable\u0026lt;T\u0026gt; { var n = keys.Length; var index = new int[n]; for (var i = 0; i \u0026lt; n; i++) index[i] = i; for (var i = 0; i \u0026lt; n; i++) for (var j = i; j \u0026gt; 0 \u0026amp;\u0026amp; keys[index[j]].CompareTo(keys[index[j - 1]]) \u0026lt; 0; j--) { var temp = index[j]; index[j] = index[j - 1]; index[j - 1] = temp; } return index; } "},{"id":347,"href":"/2-5-28/","title":"2.5.28","section":"《算法（第四版）》C# 题解","content":" 2.5.28 # 解答 # 官方解答：https://algs4.cs.princeton.edu/25applications/FileSorter.java.html\n先获得目录里的所有文件名，然后排序输出即可。\n代码 # var directoryName = Console.ReadLine(); if (!Directory.Exists(directoryName)) { Console.WriteLine(directoryName + \u0026#34; doesn\u0026#39;t exist or isn\u0026#39;t a directory\u0026#34;); return; } var directoryFiles = Directory.GetFiles(directoryName); Array.Sort(directoryFiles); for (var i = 0; i \u0026lt; directoryFiles.Length; i++) Console.WriteLine(directoryFiles[i]); "},{"id":348,"href":"/2-5-29/","title":"2.5.29","section":"《算法（第四版）》C# 题解","content":" 2.5.29 # 解答 # 首先定义一系列比较器，分别根据文件大小、文件名和最后修改日期比较。\n然后修改 Less 的实现，接受一个比较器数组，使用数组中的比较器依次比较，直到比较结果为两者不相同。\n最后使用插入排序作为稳定排序，传入比较器数组用于 Less 函数。\n代码 # var arguments = Console.ReadLine().Split(\u0026#39; \u0026#39;); var directoryPath = arguments[0]; var filenames = Directory.GetFiles(directoryPath); var fileInfos = new FileInfo[filenames.Length]; for (var i = 0; i \u0026lt; filenames.Length; i++) fileInfos[i] = new FileInfo(filenames[i]); var comparers = new List\u0026lt;Comparer\u0026lt;FileInfo\u0026gt;\u0026gt;(); for (var i = 1; i \u0026lt; arguments.Length; i++) { var command = arguments[i]; switch (command) { case \u0026#34;-t\u0026#34;: comparers.Add(new FileTimeStampComparer()); break; case \u0026#34;-s\u0026#34;: comparers.Add(new FileSizeComparer()); break; case \u0026#34;-n\u0026#34;: comparers.Add(new FileNameComparer()); break; } } InsertionSort(fileInfos, comparers.ToArray()); for (var i = 0; i \u0026lt; fileInfos.Length; i++) { Console.WriteLine(fileInfos[i].Name + \u0026#34;\\t\u0026#34; + fileInfos[i].Length + \u0026#34;\\t\u0026#34; + fileInfos[i].LastWriteTime); } static bool Less\u0026lt;T\u0026gt;(T[] keys, int x, int y, Comparer\u0026lt;T\u0026gt;[] comparables) { var cmp = 0; for (var i = 0; i \u0026lt; comparables.Length \u0026amp;\u0026amp; cmp == 0; i++) { cmp = comparables[i].Compare(keys[x], keys[y]); } return cmp \u0026lt; 0; } static void InsertionSort\u0026lt;T\u0026gt;(T[] keys, Comparer\u0026lt;T\u0026gt;[] comparers) { for (var i = 0; i \u0026lt; keys.Length; i++) for (var j = i; j \u0026gt; 0 \u0026amp;\u0026amp; Less(keys, j, j - 1, comparers); j--) { var temp = keys[j]; keys[j] = keys[j - 1]; keys[j - 1] = temp; } } internal class FileSizeComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.Length.CompareTo(y.Length); } } internal class FileNameComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.FullName.CompareTo(y.FullName); } } internal class FileTimeStampComparer : Comparer\u0026lt;FileInfo\u0026gt; { public override int Compare(FileInfo x, FileInfo y) { return x.LastWriteTime.CompareTo(y.LastWriteTime); } } "},{"id":349,"href":"/2-5-30/","title":"2.5.30","section":"《算法（第四版）》C# 题解","content":" 2.5.30 # 解答 # 不妨按照升序排序，$x_{ij}$ 代表第 $i$ 行第 $j$ 列的元素。\n首先保证每列都是有序的。\n对第一行排序，对于第一行的元素 $x_{1i}$ ，排序结果无非两种。\n要么 $x_{1i}$ 不改变，要么和更小的元素进行交换。\n显然，无论哪种情况，第 $i$ 列都是有序的。\n因此对第一行排序之后，第一行有序，每一列都分别有序。\n之后我们对第二行排序，考虑元素 $x_{11}$。\n此时 $x_{11}$ 小于第一列的所有其他元素，也小于第一行的所有其他元素。\n又每一列都分别有序，因此 $x_{11}$ 是整个矩阵的最小值，第二行不存在比它小的元素。\n考虑使用选择排序，我们把第二行的最小值和 $x_{21}$ 交换，第一列仍然有序。\n现在去掉第一列，对剩下的矩阵做一样的操作，可以将第二行依次排序。\n同时保证第二行的元素都小于同列的第一行元素。\n接下来的行都可以依次类推，最终将整个矩阵的所有行排序，定理得证。\n"},{"id":350,"href":"/2-5-31/","title":"2.5.31","section":"《算法（第四版）》C# 题解","content":" 2.5.31 # 解答 # 编写代码进行实验即可，实验结果如下，可以发现十分接近：\n代码 # var T = 10; // 重复次数 var n = 1000; // 数组初始大小 var nMultipleBy10 = 4; // 数组大小 ×10 的次数 var mMultipleBy2 = 3; // 数据范围 ×2 的次数 var random = new Random(); for (var i = 0; i \u0026lt; nMultipleBy10; i++) { Console.WriteLine(\u0026#34;n=\u0026#34; + n); Console.WriteLine(\u0026#34;\\tm\\temprical\\ttheoretical\u0026#34;); var m = n / 2; for (var j = 0; j \u0026lt; mMultipleBy2; j++) { var distinctSum = 0; for (var k = 0; k \u0026lt; T; k++) { var data = new int[n]; for (var l = 0; l \u0026lt; n; l++) data[l] = random.Next(m); distinctSum += Distinct(data); } var empirical = (double)distinctSum / T; var alpha = (double)n / m; var theoretical = m * (1 - Math.Exp(-alpha)); Console.WriteLine(\u0026#34;\\t\u0026#34; + m + \u0026#34;\\t\u0026#34; + empirical + \u0026#34;\\t\u0026#34; + theoretical); m *= 2; } n *= 10; } // 计算数组中重复元素的个数。 static int Distinct\u0026lt;T\u0026gt;(T[] a) where T : IComparable\u0026lt;T\u0026gt; { if (a.Length == 0) return 0; Array.Sort(a); var distinct = 1; for (var i = 1; i \u0026lt; a.Length; i++) if (a[i].CompareTo(a[i - 1]) != 0) distinct++; return distinct; } "},{"id":351,"href":"/2-5-32/","title":"2.5.32","section":"《算法（第四版）》C# 题解","content":" 2.5.32 # 解答 # （前置知识：提前了解 Dijkstra 算法能够降低理解 A* 算法的难度。）\nA* 算法是 Dijkstra 算法和最佳优先算法的一种结合。\nDijkstra 算法需要遍历所有结点来找到最短路径，唯一的优化条件就是路径长度。\n建立队列 queue ，把所有的结点加入 queue 中；建立数组 d，d[v] 代表起点到点 v 的距离。\n开始时只有起点到起点的距离为 0，其他都为无穷大，然后重复如下步骤：\n从队列中取出已知距离最短的结点 u，检查该结点的所有边。\n如果通过这个点能够以更近的距离到达 v，更新起点到 v 的距离 d[v] = d[u] + distance(u, v)。\n等到队列为空之后数组 d 中就存放着起点到其他所有结点的最短距离。\nDijkstra 算法会计算起点到所有点的最短路径，因此会均匀的遍历所有结点，效率较低。\n很多时候，我们只需要找到起点到某一终点的最短路径即可，为此遍历整个图显然是不必要的。\n通过修改算法，使得比较接近终点的结点优先得到搜索，我们就可能在遍历完全部结点之前获得结果。\n在 Dijkstra 算法中，离起点最近的点会被优先搜索，记结点离起点的距离为 g[n] 。\n现在引入新的条件，用于估计结点和终点的接近程度，记结点离终点的估计距离为 h[n] 。\n令 f[n] = g[n] + h[n]，我们按照 f[n] 对等待搜索的结点进行排序。\n同时令 h[n] 始终小于 g[n] ，保证离起点的距离 g[n] 权重大于离终点的估计距离 h[n] 。 （h[n]也被称之为容许估计）\n于是在离起点距离接近的条件下，离终点比较近的点会被优先搜索，减少搜索范围。\n接下来就是算法的具体内容，与 Dijkstra 算法不同，A* 算法不一定需要访问所有结点，\n因此 A* 算法需要维护两个集合，openSet 保存等待搜索的结点，closeSet 保存已经搜索过的结点。\n和 Dijkstra 算法类似，一开始 openSet 中只有起点，closeSet 则是空的。\n然后重复执行如下步骤，直到 openSet 为空：\n从 openSet 中取出 f[n] 最小的结点 u ，放入 closeSet。（标记为已访问）\n如果 u 就是终点，算法结束。\n计算结点 u 直接可达的周围结点，放入集合 neighbors。\n遍历 `neighbors` 中的所有结点 `v`，做如下判断： 如果 `v` 已经存在于 `closeSet` ，忽略之。（防止走回头路） 如果经过 `u` 不能缩短起点到 `v` 的路径长度 `g[v]`，忽略之。（和 Dijkstra 算法一样的做法） 否则将 `v` 放入 `openSet`，更新 `g[v] = g[u] + distance(u, v)` ，计算 `f[v] = g[v] + h[v]`。（更新结点） 以上是 A* 算法的核心逻辑，\n为了结合具体问题，我们需要自定义计算 g[n] 和 h[n] 的方法，以及获得某个结点周围结点的方法。\n这里有个问题，openSet 和 closeSet 应该用什么数据结构？\ncloseSet 比较简单，只需要添加和查找即可，哈希表 HashSet 是不二选择。\nopenSet 需要读取并删除最小元素，以及添加和查找元素，用最小堆 MinPQ 会是比较方便的方法。\n书中给出的最小堆 MinPQ 没有实现 Contains 方法，需要自己实现一个，简单顺序查找就够用了。\n同时 MinPQ 的 Greater 比较方法也需要重新实现，需要使用基于 f[n] 进行比较的比较器。\n现在我们考虑 8 字谜题如何用 A* 算法实现。\n棋盘的每一个状态就是一个结点，每走一步就能进入下一个状态，结点可以这么定义：\nclass SearchNode { int[] Board;\t// 棋盘状态 int Steps;\t// 已经使用的步数 } g(start, goal) 直接就是 goal.Steps - start.Steps，h(start, goal) 则根据题意有不同的实现。\n获得周围结点的方法 GetNeighbors(current)，会返回一个数组，其中有从 current 上下左右走获得的棋盘状态。\n运行结果，初始状态为：\n0 1 3 4 2 5 7 9 6 代码 # A* 算法的泛型实现\npublic abstract class AStar\u0026lt;T\u0026gt; where T : IComparable\u0026lt;T\u0026gt; { /// \u0026lt;summary\u0026gt; /// 相等比较器。 /// \u0026lt;/summary\u0026gt; private readonly IEqualityComparer\u0026lt;T\u0026gt; _equalityComparer; /// \u0026lt;summary\u0026gt; /// 默认相等比较器。 /// \u0026lt;/summary\u0026gt; private class DefaultEqualityComparer : IEqualityComparer\u0026lt;T\u0026gt; { public bool Equals(T x, T y) { Debug.Assert(x != null, nameof(x) + \u0026#34; != null\u0026#34;); return x.Equals(y); } public int GetHashCode(T obj) { return obj.GetHashCode(); } } /// \u0026lt;summary\u0026gt; /// 根据 FScore 进行比较的比较器。 /// \u0026lt;/summary\u0026gt; private class FScoreComparer : IComparer\u0026lt;T\u0026gt; { private readonly Dictionary\u0026lt;T, int\u0026gt; _fScore; public FScoreComparer(Dictionary\u0026lt;T, int\u0026gt; fScore) { _fScore = fScore; } public int Compare(T x, T y) { if (!_fScore.ContainsKey(x!)) _fScore[x] = int.MaxValue; if (!_fScore.ContainsKey(y!)) _fScore[y] = int.MaxValue; return _fScore[x].CompareTo(_fScore[y]); } } /// \u0026lt;summary\u0026gt; /// 新建一个 Astar 寻路器，使用元素默认相等比较器。 /// \u0026lt;/summary\u0026gt; protected AStar() : this(new DefaultEqualityComparer()) { } /// \u0026lt;summary\u0026gt; /// 新建一个 AStar 寻路器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;equalityComparer\u0026#34;\u0026gt;用于确定状态之间相等的比较器。\u0026lt;/param\u0026gt; protected AStar(IEqualityComparer\u0026lt;T\u0026gt; equalityComparer) { _equalityComparer = equalityComparer; } /// \u0026lt;summary\u0026gt; /// 获得最短路径。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;起始状态。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;终止状态。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;start\u0026#34;/\u0026gt; 至 \u0026lt;paramref name=\u0026#34;goal\u0026#34;/\u0026gt; 之间的最短路径。\u0026lt;/returns\u0026gt; public T[] GetPath(T start, T goal) { var comeFrom = new Dictionary\u0026lt;T, T\u0026gt;(_equalityComparer); var gScore = new Dictionary\u0026lt;T, int\u0026gt;(_equalityComparer); var fScore = new Dictionary\u0026lt;T, int\u0026gt;(_equalityComparer); var openSet = new MinPq\u0026lt;T\u0026gt;(new FScoreComparer(fScore), _equalityComparer); var closeSet = new HashSet\u0026lt;T\u0026gt;(_equalityComparer); openSet.Insert(start); gScore.Add(start, 0); fScore.Add(start, HeuristicDistance(start, goal)); while (!openSet.IsEmpty()) { var current = openSet.DelMin(); if (_equalityComparer.Equals(current, goal)) return ReconstructPath(comeFrom, current); closeSet.Add(current); var neighbors = GetNeighbors(current); foreach (var neighbor in neighbors) { if (closeSet.Contains(neighbor)) continue; var gScoreTentative = gScore[current] + ActualDistance(current, neighbor); // 新状态 if (!openSet.Contains(neighbor)) openSet.Insert(neighbor); else if (gScoreTentative \u0026gt;= gScore[neighbor]) continue; // 记录新状态 comeFrom[neighbor] = current; gScore[neighbor] = gScoreTentative; fScore[neighbor] = gScore[neighbor] + HeuristicDistance(neighbor, goal); } } return null; } /// \u0026lt;summary\u0026gt; /// 倒回重建最佳路径。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;comeFrom\u0026#34;\u0026gt;包含所有状态的数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前状态位置。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;重建之后的最短路径。\u0026lt;/returns\u0026gt; private T[] ReconstructPath(Dictionary\u0026lt;T, T\u0026gt; comeFrom, T current) { var pathReverse = new Stack\u0026lt;T\u0026gt;(); while (comeFrom.ContainsKey(current)) { pathReverse.Push(current); current = comeFrom[current]; } var path = new T[pathReverse.Count]; for (var i = 0; i \u0026lt; path.Length; i++) { path[i] = pathReverse.Pop(); } return path; } /// \u0026lt;summary\u0026gt; /// 计算两个状态之间的估计距离，即 h(n)。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;初始状态。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;目标状态。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;估计距离。\u0026lt;/returns\u0026gt; protected abstract int HeuristicDistance(T start, T goal); /// \u0026lt;summary\u0026gt; /// 计算两个状态之间的实际距离，即 g(n)。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;初始状态。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;goal\u0026#34;\u0026gt;目标状态。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;实际距离。\u0026lt;/returns\u0026gt; protected abstract int ActualDistance(T start, T goal); /// \u0026lt;summary\u0026gt; /// 获得当前状态的周围状态。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前状态。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;保存周围状态的数组。\u0026lt;/returns\u0026gt; protected abstract T[] GetNeighbors(T current); } 另请参阅 # A* search algorithm-Wikipedia SortApplication 库\n"},{"id":352,"href":"/2-5-33/","title":"2.5.33","section":"《算法（第四版）》C# 题解","content":" 2.5.33 # 解答 # 编写代码实验即可，结果如下：\n代码 # 随机交易生成器 TransactionGenerator\ninternal class TransactionGenerator { private static readonly Random Random = new(); /// \u0026lt;summary\u0026gt; /// 生成 n 条随机交易记录。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;交易记录的数量。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Transaction[] Generate(int n) { var trans = new Transaction[n]; for (var i = 0; i \u0026lt; n; i++) { trans[i] = new Transaction (GenerateName(), GenerateDate(), Random.NextDouble() * 1000); } return trans; } /// \u0026lt;summary\u0026gt; /// 获取随机姓名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static string GenerateName() { var nameLength = Random.Next(4, 7); var sb = new StringBuilder(); sb.Append(Random.Next(\u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39; + 1)); for (var i = 1; i \u0026lt; nameLength; i++) sb.Append(Random.Next(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39; + 1)); return sb.ToString(); } /// \u0026lt;summary\u0026gt; /// 获取随机日期。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static Date GenerateDate() { var year = Random.Next(2017, 2019); var month = Random.Next(1, 13); int day; if (month == 2) day = Random.Next(1, 29); else if ((month \u0026lt; 8 \u0026amp;\u0026amp; month % 2 == 1) || (month \u0026gt; 7 \u0026amp;\u0026amp; month % 2 == 0)) day = Random.Next(1, 32); else day = Random.Next(1, 31); var date = new Date(month, day, year); return date; } } 另请参阅 # SortApplication 库\n"},{"id":353,"href":"/3-1-1/","title":"3.1.1","section":"《算法（第四版）》C# 题解","content":" 3.1.1 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/GPA.java.html\nST.java：https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/ST.java.html\n建立一个符号表，然后把键值放进去，读取计算即可。\n和上一章节用过的方法类似，先定义了一个接口 IST\u0026lt;Key, Value\u0026gt; ，包含书中提到的基本 API。\n然后定义类 ST ，用标准库里面的 Dictionary 实现了 IST 。\n代码 # public class St\u0026lt;TKey, TValue\u0026gt; : ISt\u0026lt;TKey, TValue\u0026gt;, IEnumerable\u0026lt;TKey\u0026gt; { private readonly Dictionary\u0026lt;TKey, TValue\u0026gt; _st; /// \u0026lt;summary\u0026gt; /// 新建一个符号表。 /// \u0026lt;/summary\u0026gt; public St() =\u0026gt; _st = new Dictionary\u0026lt;TKey, TValue\u0026gt;(); /// \u0026lt;summary\u0026gt; /// 检查符号表中是否存在与键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要检查是否存在的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public virtual bool Contains(TKey key) =\u0026gt; _st.ContainsKey(key); /// \u0026lt;summary\u0026gt; /// 从符号表中删除键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; public virtual void Delete(TKey key) =\u0026gt; _st.Remove(key); /// \u0026lt;summary\u0026gt; /// 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在时返回 null。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public virtual TValue Get(TKey key) =\u0026gt; _st[key]; /// \u0026lt;summary\u0026gt; /// 获取枚举器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表的枚举器。\u0026lt;/returns\u0026gt; public IEnumerator\u0026lt;TKey\u0026gt; GetEnumerator() =\u0026gt; _st.Keys.GetEnumerator(); /// \u0026lt;summary\u0026gt; /// 检查符号表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果符号表为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public virtual bool IsEmpty() =\u0026gt; _st.Count == 0; /// \u0026lt;summary\u0026gt; /// 获得符号表中所有键的集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;包含符号表中所有键的集合。\u0026lt;/returns\u0026gt; public virtual IEnumerable\u0026lt;TKey\u0026gt; Keys() =\u0026gt; _st.Keys; /// \u0026lt;summary\u0026gt; /// 向符号表中插入新的键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要插入的键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;对应的值。\u0026lt;/param\u0026gt; public virtual void Put(TKey key, TValue value) { if (_st.ContainsKey(key)) _st[key] = value; else _st.Add(key, value); } /// \u0026lt;summary\u0026gt; /// 获取符号表中键值对的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中键值对的数量。\u0026lt;/returns\u0026gt; public virtual int Size() =\u0026gt; _st.Count; /// \u0026lt;summary\u0026gt; /// 获取枚举器。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表的枚举器。\u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt;实际上调用的是 \u0026lt;see cref=\u0026#34;GetEnumerator\u0026#34;/\u0026gt;。\u0026lt;/remarks\u0026gt; IEnumerator IEnumerable.GetEnumerator() =\u0026gt; GetEnumerator(); } 另请参阅 # SymbolTable 库\n"},{"id":354,"href":"/3-1-2/","title":"3.1.2","section":"《算法（第四版）》C# 题解","content":" 3.1.2 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/ArrayST.java.html\n建立两个数组，分别存放键和值，一一对应。\n添加时直接将新键值对放到数组最后即可。\n删除时将待删除的键值对和位于最后的键值对交换，然后将其置空即可。\n代码 # public class ArraySt\u0026lt;TKey, TValue\u0026gt; : ISt\u0026lt;TKey, TValue\u0026gt; { /// \u0026lt;summary\u0026gt; /// 键数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;键数组。\u0026lt;/value\u0026gt; private TKey[] _keys; /// \u0026lt;summary\u0026gt; /// 值数组。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;值数组。\u0026lt;/value\u0026gt; private TValue[] _values; /// \u0026lt;summary\u0026gt; /// 键值对数目。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;键值对数目。\u0026lt;/value\u0026gt; private int _n; /// \u0026lt;summary\u0026gt; /// 建立基于数组实现的符号表。 /// \u0026lt;/summary\u0026gt; public ArraySt() : this(8) { } /// \u0026lt;summary\u0026gt; /// 建立基于数组实现的符号表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;initCapacity\u0026#34;\u0026gt;初始大小。\u0026lt;/param\u0026gt; public ArraySt(int initCapacity) { _keys = new TKey[initCapacity]; _values = new TValue[initCapacity]; } /// \u0026lt;summary\u0026gt; /// 检查键 \u0026lt;typeparamref name=\u0026#34;TKey\u0026#34;/\u0026gt; 是否存在。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要检查是否存在的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(TKey key) =\u0026gt; Get(key).Equals(default(TKey)); /// \u0026lt;summary\u0026gt; /// 删除键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要删除的键。\u0026lt;/param\u0026gt; public void Delete(TKey key) { for (var i = 0; i \u0026lt; _n; i++) { if (key.Equals(_keys[i])) { _keys[i] = _keys[_n - 1]; _values[i] = _values[_n - 1]; _keys[_n - 1] = default; _values[_n - 1] = default; _n--; if (_n \u0026gt; 0 \u0026amp;\u0026amp; _n == _keys.Length / 4) Resize(_keys.Length / 2); return; } } } /// \u0026lt;summary\u0026gt; /// 获取键对应的值，若键不存在则返回 null。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;需要查找的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;找到的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;\u0026lt;/returns\u0026gt; public TValue Get(TKey key) { for (var i = 0; i \u0026lt; _n; i++) if (_keys[i].Equals(key)) return _values[i]; return default; } /// \u0026lt;summary\u0026gt; /// 检查符号表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 获得包含全部键的集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;全部键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() { var result = new TKey[_n]; Array.Copy(_keys, result, _n); return result; } /// \u0026lt;summary\u0026gt; /// 向符号表中插入新元素，若键存在将被替换。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public void Put(TKey key, TValue value) { Delete(key); if (_n \u0026gt;= _values.Length) Resize(_n * 2); _keys[_n] = key; _values[_n] = value; _n++; } /// \u0026lt;summary\u0026gt; /// 返回符号表中键值对的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;键值对数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; /// \u0026lt;summary\u0026gt; /// 为符号表重新分配空间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;capacity\u0026#34;\u0026gt;新分配的空间大小。\u0026lt;/param\u0026gt; private void Resize(int capacity) { var tempKey = new TKey[capacity]; var tempValue = new TValue[capacity]; for (var i = 0; i \u0026lt; _n; i++) tempKey[i] = _keys[i]; for (var i = 0; i \u0026lt; _n; i++) tempValue[i] = _values[i]; _keys = tempKey; _values = tempValue; } } 另请参阅 # SymbolTable 库\n"},{"id":355,"href":"/3-1-3/","title":"3.1.3","section":"《算法（第四版）》C# 题解","content":" 3.1.3 # 解答 # 基于无序链表的官方实现：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html\n有序符号表的 API 见书中表 3.1.4（中文版 P230，英文版 P366）。\n在官方实现的基础上修改 Put 方法，先找到合适位置再插入新的键值对，保证链表有序。\n为方便插入操作，可以使用双向链表作为基础进行实现。\n表中同时维护开头和末尾引用，加快获得最值的速度。\n代码 # public class OrderedSequentialSearchSt\u0026lt;TKey, TValue\u0026gt; : ISt\u0026lt;TKey, TValue\u0026gt;, IOrderedSt\u0026lt;TKey, TValue\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { /// \u0026lt;summary\u0026gt; /// 符号表结点。 /// \u0026lt;/summary\u0026gt; private class Node { public TKey Key { get; set; } // 键。 public TValue Value { get; set; } // 值。 public Node Next { get; set; } // 后继。 public Node Prev { get; set; } // 前驱。 } private Node _first; // 起始结点。 private Node _tail; // 末尾结点。 private int _n; // 键值对数量。 /// \u0026lt;summary\u0026gt; /// 大于等于 key 的最小值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;大于等于 key 的最小值，不存在则返回 \u0026lt;c\u0026gt;default(Key)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public TKey Ceiling(TKey key) { var pointer = _first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, key)) pointer = pointer.Next; return pointer == null ? default : pointer.Key; } /// \u0026lt;summary\u0026gt; /// 键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在表中是否存在对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(TKey key) =\u0026gt; Floor(key).Equals(key); /// \u0026lt;summary\u0026gt; /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; public void Delete(TKey key) { var pointer = _first; while (pointer != null \u0026amp;\u0026amp; !pointer.Key.Equals(key)) pointer = pointer.Next; if (pointer == null) return; Delete(pointer); } /// \u0026lt;summary\u0026gt; /// 从链表中删除结点 \u0026lt;paramref name=\u0026#34;node\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;待删除的结点。\u0026lt;/param\u0026gt; private void Delete(Node node) { var prev = node.Prev; var next = node.Next; if (prev == null) _first = next; else prev.Next = next; if (next == null) _tail = prev; _n--; } /// \u0026lt;summary\u0026gt; /// 删除最大的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMax() { if (_n == 0) throw new Exception(\u0026#34;ST Underflow\u0026#34;); Delete(_tail); } /// \u0026lt;summary\u0026gt; /// 删除最小的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMin() { if (_n == 0) throw new Exception(\u0026#34;ST Underflow\u0026#34;); Delete(_first); } /// \u0026lt;summary\u0026gt; /// 小于等于 Key 的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大值。\u0026lt;/returns\u0026gt; public TKey Floor(TKey key) { var pointer = _tail; while (pointer != null \u0026amp;\u0026amp; Greater(pointer.Key, key)) pointer = pointer.Prev; return pointer == null ? default : pointer.Key; } /// \u0026lt;summary\u0026gt; /// 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 null。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;typeparamref name=\u0026#34;TKey\u0026#34;/\u0026gt; 对应的值。\u0026lt;/returns\u0026gt; public TValue Get(TKey key) { var pointer = _first; while (pointer != null \u0026amp;\u0026amp; Greater(key, pointer.Key)) pointer = pointer.Next; if (pointer == null) return default; if (pointer.Key.Equals(key)) return pointer.Value; return default; } /// \u0026lt;summary\u0026gt; /// 符号表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() =\u0026gt; _n == 0; /// \u0026lt;summary\u0026gt; /// 获得符号表中所有键的集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中所有键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() =\u0026gt; _n == 0 ? new List\u0026lt;TKey\u0026gt;() : Keys(_first.Key, _tail.Key); /// \u0026lt;summary\u0026gt; /// 获得符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { var list = new List\u0026lt;TKey\u0026gt;(); var pointer = _first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, lo)) pointer = pointer.Next; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, hi)) { list.Add(pointer.Key); pointer = pointer.Next; } Debug.Assert(pointer != null, nameof(pointer) + \u0026#34; != null\u0026#34;); if (pointer.Key.Equals(hi)) list.Add(pointer.Key); return list; } /// \u0026lt;summary\u0026gt; /// 最大的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的键，不存在则返回 \u0026lt;c\u0026gt;default(Key)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public TKey Max() =\u0026gt; _tail == null ? default : _tail.Key; /// \u0026lt;summary\u0026gt; /// 最小的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小的键，不存在则返回 \u0026lt;c\u0026gt;default(Key)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public TKey Min() =\u0026gt; _first == null ? default : _first.Key; /// \u0026lt;summary\u0026gt; /// 向符号表插入键值对，重复值将被替换。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public void Put(TKey key, TValue value) { Delete(key); var temp = new Node { Key = key, Value = value, Prev = null, Next = null }; Node left = null, right = _first; while (right != null \u0026amp;\u0026amp; Less(right.Key, temp.Key)) { left = right; right = right.Next; } Insert(left, right, temp); if (left == null) _first = temp; if (right == null) _tail = temp; _n++; } /// \u0026lt;summary\u0026gt; /// 小于 Key 的键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于 Key 的键的数量。\u0026lt;/returns\u0026gt; public int Rank(TKey key) { var counter = 0; var pointer = _first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, key)) { pointer = pointer.Next; counter++; } return counter; } /// \u0026lt;summary\u0026gt; /// 获得排名为 insert 的键（从 0 开始）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;排名\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;获得排名为 insert 的键（从 0 开始）。\u0026lt;/returns\u0026gt; public TKey Select(int k) { if (k \u0026gt;= _n) throw new Exception(\u0026#34;insert must less than ST size!\u0026#34;); var pointer = _first; for (var i = 0; i \u0026lt; k; i++) pointer = pointer.Next; return pointer.Key; } /// \u0026lt;summary\u0026gt; /// 获得符号表中键值对的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中键值对的数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; /// \u0026lt;summary\u0026gt; /// [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;[\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。\u0026lt;/returns\u0026gt; public int Size(TKey lo, TKey hi) { var counter = 0; var pointer = _first; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, lo)) pointer = pointer.Next; while (pointer != null \u0026amp;\u0026amp; Less(pointer.Key, hi)) { pointer = pointer.Next; counter++; } return counter; } /// \u0026lt;summary\u0026gt; /// 键 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 是否小于 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;检查是否较小的键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;检查是否较大的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较小则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Less(TKey a, TKey b) =\u0026gt; a.CompareTo(b) \u0026lt; 0; /// \u0026lt;summary\u0026gt; /// 键 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 是否大于 \u0026lt;paramref name=\u0026#34;b\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;a\u0026#34;\u0026gt;检查是否较大的键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;b\u0026#34;\u0026gt;检查是否较小的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;paramref name=\u0026#34;a\u0026#34;/\u0026gt; 较大则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Greater(TKey a, TKey b) =\u0026gt; a.CompareTo(b) \u0026gt; 0; /// \u0026lt;summary\u0026gt; /// 将结点 \u0026lt;paramref name=\u0026#34;insert\u0026#34;/\u0026gt; 插入到 \u0026lt;paramref name=\u0026#34;left\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;right\u0026#34;/\u0026gt; 之间。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;left\u0026#34;\u0026gt;作为前驱的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;right\u0026#34;\u0026gt;作为后继的结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;insert\u0026#34;\u0026gt;待插入的结点。\u0026lt;/param\u0026gt; private void Insert(Node left, Node right, Node insert) { insert.Prev = left; insert.Next = right; if (left != null) left.Next = insert; if (right != null) right.Prev = insert; } } 另请参阅 # SymbolTable 库\n"},{"id":356,"href":"/3-1-4/","title":"3.1.4","section":"《算法（第四版）》C# 题解","content":" 3.1.4 # 解答 # 利用 Time 类型记录时间，用 Event 来记录事件内容。\nTime 类型包含时分秒三个 int 变量，同时实现 IComparable 接口。\nEvent 类型只包含事件的名称，相当于对 string 做了一个封装。\n随后以 Time 为键类型，Event 为值类型，利用上一题编写的有序符号表进行操作。\n代码 # Time 类\npublic class Time : IComparable\u0026lt;Time\u0026gt; { public int Hour { get; init; } public int Minute { get; init; } public int Second { get; init; } public Time() : this(0, 0, 0) { } public Time(int hour, int minute, int second) { Hour = hour; Minute = minute; Second = second; } public int CompareTo(Time other) { var result = Hour.CompareTo(other.Hour); if (result == 0) result = Minute.CompareTo(other.Minute); if (result == 0) result = Second.CompareTo(other.Second); return result; } public override bool Equals(object obj) { if (this == obj) return true; return CompareTo((Time)obj) == 0; } public override int GetHashCode() { var result = 1; result += Hour; result *= 31; result += Minute; result *= 31; result += Second; return result; } public override string ToString() { var sb = new StringBuilder(); sb.Append(Hour \u0026lt; 10 ? \u0026#34;0\u0026#34; + Hour : Hour.ToString()); sb.Append(\u0026#39;:\u0026#39;); sb.Append(Minute \u0026lt; 10 ? \u0026#34;0\u0026#34; + Minute : Minute.ToString()); sb.Append(\u0026#39;:\u0026#39;); sb.Append(Second \u0026lt; 10 ? \u0026#34;0\u0026#34; + Second : Second.ToString()); return sb.ToString(); } } Event 类\npublic class Event { public string EventMessage { get; set; } public Event() : this(null) { } public Event(string message) { EventMessage = message; } public override string ToString() { return EventMessage; } } 另请参阅 # SymbolTable 库\n"},{"id":357,"href":"/3-1-5/","title":"3.1.5","section":"《算法（第四版）》C# 题解","content":" 3.1.5 # 解答 # 官方解答：https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html\nsize() 方法只需要直接返回当前的 n 值即可。\ndelete() 方法需要遍历链表，找到对应结点并删除。\nkeys() 方法只需要根据当前的 n 新建一个数组，把链表中的键值存入即可。\n代码 # /// \u0026lt;summary\u0026gt; /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及其对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; public void Delete(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;key can\u0026#39;t be null\u0026#34;); Node before = null, target = _first; while (target != null \u0026amp;\u0026amp; !target.Key.Equals(key)) { before = target; target = target.Next; } if (target != null) Delete(before, target); } /// \u0026lt;summary\u0026gt; /// 从链表中删除指定的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;before\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;target\u0026#34;/\u0026gt; 的前驱。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;target\u0026#34;\u0026gt;准备删除的结点。\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026#34;ArgumentNullException\u0026#34;\u0026gt;当 \u0026lt;paramref name=\u0026#34;target\u0026#34;/\u0026gt; 为 \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt; 时抛出此异常。\u0026lt;/exception\u0026gt; private void Delete(Node before, Node target) { if (target == null) throw new ArgumentNullException(nameof(target), \u0026#34;target can\u0026#39;t be null\u0026#34;); if (before == null) _first = target.Next; else before.Next = target.Next; _n--; } /// \u0026lt;summary\u0026gt; /// 获得所有的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;包含所有键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() { var keys = new TKey[_n]; var pointer = _first; for (var i = 0; i \u0026lt; _n; i++) { keys[i] = pointer.Key; pointer = pointer.Next; } return keys; } /// \u0026lt;summary\u0026gt; /// 获取符号表中的键值对数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;当前符号表中的键值对数量。\u0026lt;/returns\u0026gt; public int Size() =\u0026gt; _n; 另请参阅 # SymbolTable 库\n"},{"id":358,"href":"/3-1-6/","title":"3.1.6","section":"《算法（第四版）》C# 题解","content":" 3.1.6 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n每个单词都会被放进符号表一次，\n因此 Put 的调用次数就等于单词总数 W +1（注意寻找最大值的时候有一次 Put 调用）\n对于重复的单词，输入时会先调用 Get 获得当前计数之后再 Put 回去。\n寻找最大值时，对于符号表中的每个键值都会调用两次 Get。\n重复的单词数量 = (W - D)。\n因此 Get 方法的调用次数 = (W - D) + 2D\n"},{"id":359,"href":"/3-1-7/","title":"3.1.7","section":"《算法（第四版）》C# 题解","content":" 3.1.7 # 解答 # 在 FrequencyCounter 中添加一个 CountDistinct 方法，计算不重复的键数。\npublic static int CountDistinct\u0026lt;TKey\u0026gt;(TKey[] keys, ISt\u0026lt;TKey, int\u0026gt; st) { var distinct = 0; for (var i = 0; i \u0026lt; keys.Length; i++) { if (!st.Contains(keys[i])) st.Put(keys[i], distinct++); } return distinct; } 结果如下：\n另请参阅 # SymbolTable 库\n"},{"id":360,"href":"/3-1-8/","title":"3.1.8","section":"《算法（第四版）》C# 题解","content":" 3.1.8 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n官网给出的数据末尾有完整的版权说明，因此使用频率最高的单词变成了版权方的名字 Gutenberg-tm。\n去掉末尾的版权声明之后，获得的单词是：Monseigneur\n另请参阅 # SymbolTable 库\n"},{"id":361,"href":"/3-1-9/","title":"3.1.9","section":"《算法（第四版）》C# 题解","content":" 3.1.9 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n对 FrequencyCounter 做修改，在调用 Put 方法之前，将单词记录在字符串变量 lastPut 中。\n在读入单词结束之后输出 lastPut 和 words 变量。\n将末尾的版权信息删除后，得到的结果如下：\n代码 # public static string MostFrequentlyWord(string filename, int minLength, ISt\u0026lt;string, int\u0026gt; st) { var words = 0; var sr = new StreamReader(File.OpenRead(filename)); var inputs = sr .ReadToEnd() .Split(new[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); var lastPut = \u0026#34;\u0026#34;; foreach (var s in inputs) { if (s.Length \u0026lt; minLength) continue; words++; if (st.Contains(s)) { lastPut = s; st.Put(s, st.Get(s) + 1); } else { lastPut = s; st.Put(s, 1); } } Console.WriteLine(\u0026#34;Last Put: \u0026#34; + lastPut + \u0026#34;\\t words count: \u0026#34; + words); var max = \u0026#34;\u0026#34;; st.Put(max, 0); foreach (var s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 # SymbolTable 库\n"},{"id":362,"href":"/3-1-10/","title":"3.1.10","section":"《算法（第四版）》C# 题解","content":" 3.1.10 # 解答 # 如图所示：\n插入新的键值对需要遍历整个链表，比较次数等于链表在插入前的键值对数目。\n修改已有的键值对则需要遍历链表直到找到该键值对，比较次数等于该键值对以及它之前所有键值对的数目。\n共比较 0 + 1 + 2 + 3 + 4 + 5 + 6 + 4 + 6 + 7 + 8 + 9 = 55 次。\n"},{"id":363,"href":"/3-1-11/","title":"3.1.11","section":"《算法（第四版）》C# 题解","content":" 3.1.11 # 解答 # 键的轨迹如下图所示：\n键查找使用二分查找优化，插入新的键时不必与每个键都进行比较。\n共进行了 0 + 1 + 2 + 2 + 2 + 3 + 3 + 3 + 3 + 3 + 3 + 4 = 29 次比较。\n"},{"id":364,"href":"/3-1-12/","title":"3.1.12","section":"《算法（第四版）》C# 题解","content":" 3.1.12 # 解答 # 建立类 Item：\npublic class Item\u0026lt;TKey, TValue\u0026gt; : IComparable\u0026lt;Item\u0026lt;TKey, TValue\u0026gt;\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { public TKey Key { get; set; } public TValue Value { get; set; } public int CompareTo(Item\u0026lt;TKey, TValue\u0026gt; other) { return Key.CompareTo(other.Key); } } 之后修改 BinarySearchST，将其中的 TKey[] keys 和 TValue[] values 数组用 Item[] items 数组代替。\n例如 keys[i] 变为 items[i].Key，values[i] 变为 items[i].Value。\n添加一个构造函数，调用之前编写的归并排序实现。\n/// \u0026lt;summary\u0026gt; /// 根据已有的键值对构造一个符号表。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;items\u0026#34;\u0026gt;已有的键值对。\u0026lt;/param\u0026gt; public ItemBinarySearchSt(Item\u0026lt;TKey, TValue\u0026gt;[] items) { _items = new Item\u0026lt;TKey, TValue\u0026gt;[items.Length]; Array.Copy(items, _items, items.Length); _n = items.Length; var merge = new MergeSort(); merge.Sort(_items); } 另请参阅 # Merge 库 SymbolTable 库\n"},{"id":365,"href":"/3-1-13/","title":"3.1.13","section":"《算法（第四版）》C# 题解","content":" 3.1.13 # 解答 # Get() 调用次数比 Put() 调用次数多了三个数量级，\nBinarySearchST 和 SequentialSearchST 的平均 Put() 开销是一样的，\n因此选择平均 Get() 开销更小的 BinarySearchST。\n"},{"id":366,"href":"/3-1-14/","title":"3.1.14","section":"《算法（第四版）》C# 题解","content":" 3.1.14 # 解答 # 根据上题给出的结论，选择 BinarySearchST。\n由于 BinarySearchST 和 SequentialSearchST 执行 Put() 的开销相同\n因此选择 Get() 开销更低的 BinarySearchST。\n"},{"id":367,"href":"/3-1-15/","title":"3.1.15","section":"《算法（第四版）》C# 题解","content":" 3.1.15 # 解答 # 假设先全部 Put()，再进行查找操作。\n即分别进行 $1$, $10 ^ 3$, $10 ^ 6$ 次插入\n$N = 1$ 时，可以直接得出比例 $0.1 %$。\n$N = 10 ^ 3$ 时，\n插入耗时 $= 1 + 2 + \u0026hellip; + 10 ^ 3 = 500500$，\n查询耗时 $= 10 ^ 6 * \\lg(10 ^ 3) = 9965784$，\n比例为 $4.782 %$。\n$N = 10 ^ 6$ 时\n插入耗时 $= 1 + 2 + \u0026hellip; + 10 ^ 6 = 500000500000$，\n查询耗时 $= 10 ^ 9 * \\lg(10 ^ 6) = 19931568569$，\n比例为 $ 96.17 % ​$。\n"},{"id":368,"href":"/3-1-16/","title":"3.1.16","section":"《算法（第四版）》C# 题解","content":" 3.1.16 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html\n先通过二分查找获得下标，然后后面的元素依次向前移动一位。\npublic void Delete(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;argument to Delete() is null\u0026#34;); if (IsEmpty()) return; var i = Rank(key); if (i == _n \u0026amp;\u0026amp; _keys[i].CompareTo(key) != 0) return; for (var j = i; j \u0026lt; _n - 1; j++) { _keys[j] = _keys[j + 1]; _values[j] = _values[j + 1]; } _n--; _keys[_n] = default; _values[_n] = default; if (_n \u0026gt; 0 \u0026amp;\u0026amp; _n == _keys.Length / 4) Resize(_keys.Length / 2); Debug.Assert(Check()); } 另请参阅 # SymbolTable 库\n"},{"id":369,"href":"/3-1-17/","title":"3.1.17","section":"《算法（第四版）》C# 题解","content":" 3.1.17 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html\n先通过二分查找大于等于 key 的键下标 i，\n如果 keys[i] 和 key 相等则直接返回 keys[i]， 否则返回 keys[i-1]。\npublic TKey Floor(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;argument to Floor() is null\u0026#34;); var i = Rank(key); if (i \u0026lt; _n \u0026amp;\u0026amp; _keys[i].CompareTo(key) == 0) return _keys[i]; if (i == 0) return default; return _keys[i - 1]; } 另请参阅 # SymbolTable 库\n"},{"id":370,"href":"/3-1-18/","title":"3.1.18","section":"《算法（第四版）》C# 题解","content":" 3.1.18 # 解答 # 设 key 为目标键。\n算法初始时 lo = 0, hi = n - 1，数组已排序。\n当找到目标键时，返回的下标 mid 显然是正确的。 （0\u0026hellip;a[mid - 1] 都小于 a[mid]，同时 a[mid] = key）\n接下来证明：当目标键不存在时，lo 可以代表小于 key 的键的个数。\n由算法内容，当循环退出时，一定有 lo 和 hi 交叉，即 lo \u0026gt; hi。\n考虑最后一次循环，必然执行了 lo = mid + 1 或者 hi = mid - 1。\n即最后一次循环之后 lo = mid + 1 \u0026gt; hi 或 hi = mid - 1 \u0026lt; lo。\n又由于 mid = (lo + hi) / 2，代入有：\n即(lo + hi) / 2 + 1 \u0026gt; hi 或(lo + hi) / 2 - 1 \u0026lt; lo\n(lo - hi) / 2 + 1 \u0026gt; 0 或(hi - lo) / 2 - 1 \u0026lt; 0\n(hi - lo) / 2 \u0026lt; 1\nhi - lo \u0026lt; 2\n由于 hi 和 lo 都是整数，故有 hi -lo \u0026lt;= 1\n由算法的内容可以得出，最后一次循环时，\n下标小于 lo 的元素都小于 key，下标大于 hi 的元素都大于 key\n且下标小于 lo 的元素正好有 lo 个 （0\u0026hellip;lo - 1)。\n当 lo = hi 时，mid = lo\n若 key \u0026gt; lo，则 lo = lo + 1，即 a[lo] 本身也小于 key。\n若 key\u0026lt;lo，lo 不变，即 a[lo] 就是大于 key 的第一个元素。\n当 lo = hi - 1 时，mid = lo\n若 key \u0026gt; lo，则 lo = lo + 1 = hi，变为上一种情况。\n若 key\u0026lt;lo，则 hi = lo - 1，a[lo] 是大于 key 的第一个元素。\n综上，Rank() 是正确的。\n"},{"id":371,"href":"/3-1-19/","title":"3.1.19","section":"《算法（第四版）》C# 题解","content":" 3.1.19 # 解答 # 将频率和当前最大频率相同的单词都放到一个队列里即可。\nvar max = \u0026#34;\u0026#34;; var queue = new Queue\u0026lt;string\u0026gt;(); st.Put(max, 0); foreach (var s in st.Keys()) { if (st.Get(s) \u0026gt; st.Get(max)) { max = s; queue.Clear(); queue.Enqueue(s); } else if (st.Get(s) == st.Get(max)) { queue.Enqueue(s); } } 另请参阅 # SymbolTable 库\n"},{"id":372,"href":"/3-1-20/","title":"3.1.20","section":"《算法（第四版）》C# 题解","content":" 3.1.20 # 解答 # 国内的书中关于命题 B 的证明有错误，新版的证明结论已经改为：\n$$ C(n)=C(2^k-1) \\le k = \\lg (n+1) \\le \\lg n +1 $$\n其中 $n=2^k - 1 $ 。 先证单调性，利用数学归纳法： 已知对于 $N=0$，满足 $C(0) \\le C(1)$。 假设对于 $N=n$，满足 $C(n) \\le C(n+1)$。 根据递归式，有：\n$$ \\begin{eqnarray*} \u0026amp; C(n) \u0026amp; \\le C(\\lfloor n/2 \\rfloor) + 1 \\newline \\newline \u0026amp; C(n+1) \u0026amp; \\le \\begin{cases} C(\\lfloor n/2 \\rfloor) +1 \u0026amp; \\text{$n$ 是偶数} \\newline C(\\lfloor n/2 \\rfloor + 1) + 1 \u0026amp; \\text{$n$ 是奇数} \\end{cases}\\newline \\newline \u0026amp; C(n+2) \u0026amp; \\le C(\\lfloor n/2 \\rfloor + 1) + 1 \\end{eqnarray*} $$\n又 $ C(n) \\le C(n+1) ​$ ，推出 $ C(\\lfloor n/2 \\rfloor) + 1 \\le C(\\lfloor n/2 \\rfloor + 1) + 1 ​$。 故 $ C(n+1) \\le C(n+2) ​$，由数学归纳法，$ C(n) \\le C(n+1) ​$ 成立。\n已知当 $N = 2^k - 1$ 时，有 $ C(N) \\le k = \\lg(N+1) \\le \\lg N + 1$。 接下来证明在 $(2^k - 1, 2^{k + 1} -1) $ 范围内上式仍然成立。 不妨设 $0 \u0026lt; M \u0026lt; 2^k$ ，则有 $2^k - 1 \u0026lt; N + M \u0026lt; 2^{k + 1} -1 $。 转变为证：$C(N+M) \\le \\lg (N+M) + 1$ 。 由于 $C(N+M)$ 是一个整数，则 $\\lfloor \\lg(N+M) +1\\rfloor = k+1$。 即求证： $C(N+M) \\le k+1$。 由单调性可得 $ C(N+M) \\le C(2^{k+1} - 1) \\le k+1 ​$，得证。\n"},{"id":373,"href":"/3-1-21/","title":"3.1.21","section":"《算法（第四版）》C# 题解","content":" 3.1.21 # 解答 # BinarySearchST\n包含一个键数组和一个值数组，以及一个 int 变量。\n数组长度变化范围为 N~4N ，故总大小：\n从 2 × (24 + 8N) +4 = 52 + 16N 字节 （100 %），\n到 2 × (24 + 32N) +4 = 52 + 64N 字节（25 %）之间变动。\nSequentialSearchST\n包含 N 个结点以及一个 int 变量 (16 + 8 + 8 + 8)N + 4 = 4 + 40N 字节\n"},{"id":374,"href":"/3-1-22/","title":"3.1.22","section":"《算法（第四版）》C# 题解","content":" 3.1.22 # 解答 # 对 Get() 做修改，得到 MoveToFrontArrayST。\npublic TValue Get(TKey key) { int i; for (i = 0; i \u0026lt; _n; i++) if (_keys[i].Equals(key)) break; if (i == _n) return default; var toFrontKey = _keys[i]; var toFrontValue = _values[i]; for (var j = i; j \u0026gt; 0; j--) _keys[j] = _keys[j - 1]; for (var j = i; j \u0026gt; 0; j--) _values[j] = _values[j - 1]; _keys[0] = toFrontKey; _values[0] = toFrontValue; return _values[0]; } 另请参阅 # SymbolTable 库\n"},{"id":375,"href":"/3-1-23/","title":"3.1.23","section":"《算法（第四版）》C# 题解","content":" 3.1.23 # 解答 # 这里的右移操作可以理解为 「小数点前移一位」\n即数字依次向右退一位，个位上的数字被舍弃。\n对于十进制，小数点前移一位会使 $n$ 变为 $\\lfloor n / 10 \\rfloor$。\n同样对于二进制就会使 $n$ 变为 $\\lfloor n / 2 \\rfloor$。\n当需要除以 $2$ 的 $k$ 次幂的时候，可以用右移 $k$ 位代替并减少时间开销。\n同理可以用左移 $k$ 位来代替乘以 $2$ 的 $k$ 次幂。\n注： 这样会降低程序可读性，\n并且某些语言（C / C++）的编译器已经可以自动执行这项优化了。\n请充分考虑你的代码受众之后再决定是否采用这种写法。\n二分查找的最大查找次数 = $ \\lg N + 1$ （见 3.1.20 的证明 {% post_link 3-1-20 %}）\n一个数最多被左移的次数也正好等于 $\\lfloor \\lg N \\rfloor + 1$ （任意正整数都能被表示为 $2 ^ k + m$ 的形式，即 $k +1$ 位二进制数）\n因此一次二分查找所需的最大比较次数正好是 $N$ 的二进制表示的位数。\n"},{"id":376,"href":"/3-1-24/","title":"3.1.24","section":"《算法（第四版）》C# 题解","content":" 3.1.24 # 解答 # FrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n二分查找总是与中间值进行比较，现在改为与数组中第 x% 位置上的元素比较。\n具体而言，$\\frac{k_x-k_{lo}}{k_{hi}-k_{lo}}$ 代表数组在均匀情况下目标值 $k_x$ 的相对位置（一个比率，在数组第 x% 的位置上）。\n那么相对应的下标就等于 $lo+\\frac{k_x-k_{lo}}{k_{hi}-k_{lo}} \\times (hi - lo)$。\n用这个式子代替原来的 $mid=lo + (hi-lo)/2$ 即可。\n不难看出这种方法对于分布相对均匀的数组比较有利，相对于二分查找而言迭代次数会少很多。\n但如果数组分布不够均匀，也可能表现出不如二分查找的性能。\n实验结果也证实了这一判断，就随机数组而言，插值查找相对于二分查找只有 1% 左右的性能提升。 代码 # SearchCompare 在书中没有出现，但可以简单的实现为调用 FrequencyCounter 并计时的方法：\npublic static long Time\u0026lt;TKey\u0026gt;(IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { Stopwatch sw = new Stopwatch(); sw.Start(); FrequencyCounter.MostFrequentlyKey(st, keys); sw.Stop(); return sw.ElapsedMilliseconds; } 由于这里需要使用数字而非字符串作为键值，需要对官方给出的 FrequencyCounter 做一些修改：\npublic static TKey MostFrequentlyKey\u0026lt;TKey\u0026gt; (IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { foreach (TKey s in keys) { if (st.Contains(s)) st.Put(s, st.Get(s) + 1); else st.Put(s, 1); } TKey max = keys[0]; foreach (TKey s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 # SymbolTable 库\n"},{"id":377,"href":"/3-1-25/","title":"3.1.25","section":"《算法（第四版）》C# 题解","content":" 3.1.25 # 解答 # 英文原文指的是 most recently accessed key，因此指的是最近访问的键。\n实现比较简单，先在类中定义一个新的成员 cache 作为缓存，\n然后修改 Get 方法，在实际查找之前先检查缓存，如果缓存未命中则在查找之后更新它。\n要注意的是缓存指向内容的有效性，在数组中指的是下标是否有效，在链表中指的是结点是否为空。\n利用《双城记》测试的结果：\n代码 # BinarySearchST # cache 是一个 int 类型的变量，代表下标。 在二分查找前先检查缓存，要注意cache超出数组大小的情况。 如果缓存未命中，则进行二分查找，并在返回结果前更新缓存。\npublic TValue Get(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;argument to Get() is null\u0026#34;); if (IsEmpty()) return default; if (_cache \u0026lt; _n \u0026amp;\u0026amp; _keys[_cache].Equals(key)) // 缓存检查 return _values[_cache]; var rank = Rank(key); if (rank \u0026lt; _n \u0026amp;\u0026amp; _keys[rank].Equals(key)) { _cache = rank; // 更新缓存 return _values[rank]; } return default; } SequentialSearchST # cache 是一个结点类型的变量，代表一个键值对。 类似的，在顺序查找前先检查缓存，如果缓存未命中则更新缓存。 要注意的是如果缓存的结点被删除，需要将缓存置为 null。\nGet() 方法\npublic TValue Get(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;key can\u0026#39;t be null\u0026#34;); if (_cache != null \u0026amp;\u0026amp; _cache.Key.Equals(key)) // 检查缓存 return _cache.Value; for (var pointer = _first; pointer != null; pointer = pointer.Next) { if (pointer.Key.Equals(key)) { _cache = pointer; // 更新缓存 return pointer.Value; } } return default; } Delete() 方法\npublic void Delete(TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;key can\u0026#39;t be null\u0026#34;); Node before = null, target = _first; while (target != null \u0026amp;\u0026amp; !target.Key.Equals(key)) { before = target; target = target.Next; } if (target == _cache) // 删除缓存 _cache = null; if (target != null) Delete(before, target); } 另请参阅 # SymbolTable 库\n"},{"id":378,"href":"/3-1-26/","title":"3.1.26","section":"《算法（第四版）》C# 题解","content":" 3.1.26 # 解答 # 字典文件：https://introcs.cs.princeton.edu/java/data/web2.txt\n《双城记》：https://introcs.cs.princeton.edu/java/data/tale.txt\n浏览器可能会直接打开 txt，此时右键链接-目标另存为即可下载。\nFrequencyCounter 的官方实现：https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html\n我们利用 BinarySearchST 会自动对键排序的性质来实现字典序排序。\n首先将字典存到一个符号表中，按照 “单词-序号” 的形式保存。\n然后读入文件，如果读入的单词存在于字典中，\n则将其以 “序号-单词” 的形式存到 BinarySearchST 中去。\n读入完毕后，遍历 BinarySearchST 即可获得字典序的单词列表。\n对于按频率排序，我们基于已有的实现修改。\n在每次取得最大值之后，输出并删除最大值，如此循环即可获得频率排序的单词序列。\n也可以将单词-频率序列全部读出来存放到数组之中，然后用第二章的排序算法排序。\n测试结果，取 minLength = 13，只截取了部分。\n代码 # public static void LookUpDictionary(string filename, string dictionaryFile, int minLength) { // 初始化字典 var sr = new StreamReader(File.OpenRead(dictionaryFile)); var words = sr.ReadToEnd().Split(new[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); var dictionary = new BinarySearchSt\u0026lt;string, int\u0026gt;(); for (var i = 0; i \u0026lt; words.Length; i++) { if (words[i].Length \u0026gt; minLength) dictionary.Put(words[i], i); } sr.Close(); // 读入单词 var srFile = new StreamReader(File.OpenRead(filename)); var inputs = srFile.ReadToEnd().Split(new[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); srFile.Close(); var stDictionary = new BinarySearchSt\u0026lt;int, string\u0026gt;(); var stFrequency = new BinarySearchSt\u0026lt;string, int\u0026gt;(); foreach (var s in inputs) { if (stFrequency.Contains(s)) stFrequency.Put(s, stFrequency.Get(s) + 1); else if (dictionary.Contains(s)) { stFrequency.Put(s, 1); stDictionary.Put(dictionary.Get(s), s); } } // 输出字典序 Console.WriteLine(\u0026#34;Alphabet\u0026#34;); foreach (var i in stDictionary.Keys()) { var s = stDictionary.Get(i); Console.WriteLine(s + \u0026#34;\\t\u0026#34; + stFrequency.Get(s)); } // 频率序 Console.WriteLine(\u0026#34;Frequency\u0026#34;); var n = stFrequency.Size(); for (var i = 0; i \u0026lt; n; i++) { var max = \u0026#34;\u0026#34;; stFrequency.Put(max, 0); foreach (var s in stFrequency.Keys()) if (stFrequency.Get(s) \u0026gt; stFrequency.Get(max)) max = s; Console.WriteLine(max + \u0026#34;\\t\u0026#34; + stFrequency.Get(max)); stFrequency.Delete(max); } } 另请参阅 # SymbolTable 库\n"},{"id":379,"href":"/3-1-27/","title":"3.1.27","section":"《算法（第四版）》C# 题解","content":" 3.1.27 # 解答 # 事实上就是说，先构造一个包含 N 个不重复键的符号表，然后进行 S 次查找。\n给出 S 的增长数量级，使得构造符号表的成本和查找的成本相同。\n这里假设一次数组交换和一次比较的成本是相同的。\n先考虑构造符号表的成本，一次 Put() 需要调用一次 Rank() 和一次插入操作。\n2.1 节插入排序的命题 B 给出了每次插入平均需要移动一半的数组元素的结论。\n于是构造符号表所需的成本约为：$n\\lg n + \\frac{1}{2}\\sum_{k=1}^{n} k=n\\lg n + \\frac{n(n-1)}{4} $ 。\n这里查找的成本是这么计算的：$\\lg0+\\lg1+\\cdots+\\lg n \u0026lt; n\\lg n$\n查找所需的成本比较简单，一次二分查找的比较次数约为 $\\lg n$，总成本就是 $S\\lg n$ 。\n令两边相等，解方程即可得到 $S=n+\\frac{n(n-1)}{4\\lg n}$ 。\n如果用大 O 记法，也可以记为 $O(n^2 / \\lg n)$，如果要选择一个比较常用的上界则可以选择 $O(n^2)$。\n实验结果，两边的成本是很接近的：\n另请参阅 # SymbolTable 库\n"},{"id":380,"href":"/3-1-28/","title":"3.1.28","section":"《算法（第四版）》C# 题解","content":" 3.1.28 # 解答 # 将重新分配数组空间的代码提前，然后添加判断语句即可。 BinarySearchSTOrderedInsertion：\n/* 省略 */ if (_n == _keys.Length) Resize(_n * 2); // 如果插入的键比所有键都大则直接插入末尾。 if (_n == 0 || _keys[_n - 1].CompareTo(key) \u0026lt; 0) { _keys[_n] = key; _values[_n] = value; _n++; return; } var i = Rank(key); /* 省略 */ 另请参阅 # SymbolTable 库\n"},{"id":381,"href":"/3-1-29/","title":"3.1.29","section":"《算法（第四版）》C# 题解","content":" 3.1.29 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/TestBinarySearchST.java.html\n官方实现中有几处错误，需要做一些修改。\n/* 省略 */ Console.WriteLine(\u0026#34;Testing Select()\u0026#34;); Console.WriteLine(\u0026#34;-----------------------------------\u0026#34;); for (var i = 0; i \u0026lt; st.Size(); i++) // 循环条件不能有 \u0026#39;=\u0026#39; Console.WriteLine(i + \u0026#34; \u0026#34; + st.Select(i)); Console.WriteLine(); /* 省略 */ while (!st.IsEmpty()) st.Delete(st.Select(st.Size() / 2)); Console.WriteLine(\u0026#34;After deleting the remaining keys\u0026#34;); Console.WriteLine(\u0026#34;-----------------------------------\u0026#34;); // 异常处理 try { foreach (var s in st.Keys()) Console.WriteLine(s + \u0026#34; \u0026#34; + st.Get(s)); } catch (Exception ex) { Console.WriteLine(\u0026#34;Exception: \u0026#34; + ex.Message); } Console.WriteLine(); /* 省略 */ 结果如下：\nsize = 10 min = A max = X Testing Keys() ----------------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 Testing Select() ----------------------------------- 0 A 1 C 2 E 3 H 4 L 5 M 6 P 7 R 8 S 9 X key Rank Floor Ceil ----------------------------------- A 0 A A B 1 A C C 1 C C D 2 C E E 2 E E F 3 E H G 3 E H H 3 H H I 4 H L J 4 H L K 4 H L L 4 L L M 5 M M N 6 M P O 6 M P P 6 P P Q 7 P R R 7 R R S 8 S S T 9 S X U 9 S X V 9 S X W 9 S X X 9 X X Y 10 X Z 10 X After deleting the smallest 3 keys ----------------------------------- H 5 L 11 M 9 P 10 R 3 S 0 X 7 After deleting the remaining keys ----------------------------------- Exception: called Min() with empty table After adding back N keys ----------------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 另请参阅 # SymbolTable 库\n"},{"id":382,"href":"/3-1-30/","title":"3.1.30","section":"《算法（第四版）》C# 题解","content":" 3.1.30 # 解答 # 官方实现：https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html。\n首先在 BinarySearchST 中添加如下方法。\n/// \u0026lt;summary\u0026gt; /// 检查符号表结构是否有效。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;检查通过则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool Check() =\u0026gt; IsSorted() \u0026amp;\u0026amp; RankCheck(); /// \u0026lt;summary\u0026gt; /// 检查 \u0026lt;see cref=\u0026#34;_keys\u0026#34;/\u0026gt; 数组是否有序。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;如果 \u0026lt;see cref=\u0026#34;_keys\u0026#34;/\u0026gt; 有序则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool IsSorted() { for (var i = 1; i \u0026lt; Size(); i++) if (_keys[i].CompareTo(_keys[i - 1]) \u0026lt; 0) return false; return true; } /// \u0026lt;summary\u0026gt; /// 检查 Rank(Select(i)) = i 是否成立。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;成立则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; private bool RankCheck() { for (var i = 0; i \u0026lt; Size(); i++) if (i != Rank(Select(i))) return false; for (var i = 0; i \u0026lt; Size(); i++) if (_keys[i].CompareTo(Select(Rank(_keys[i]))) != 0) return false; return true; } 然后在 Put() 和 Delete() 方法的末尾添加：Debug.Assert(Check()); 即可。\n另请参阅 # SymbolTable 库\n"},{"id":383,"href":"/3-1-31/","title":"3.1.31","section":"《算法（第四版）》C# 题解","content":" 3.1.31 # 解答 # 性能测试方法构造如下：\n先编写一个随机字符串方法，生成一个长度大于 50 的字符串（作为未命中访问）。\n然后随机生成符合要求的字符串数组，将它们全部放入符号表中。\n然后遍历 10 次生成的字符串数组，对于数组中的每个元素都进行一次命中查询。\n同时在每次命中查询的同时都进行一次未命中查询即可。\n测试结果：\n代码 # 按照要求编写代码，在 SearchCompare 类里添加一个 Random random 成员，并添加如下方法： 随机字符串发生器：\npublic static string GetRandomString(int minLength, int maxLength) { var length = Random.Next(minLength, maxLength); var sb = new StringBuilder(); for (var i = 0; i \u0026lt; length; i++) { var choice = Random.NextDouble(); if (choice \u0026lt; 0.333) sb.Append((char)Random.Next(\u0026#39;A\u0026#39;, \u0026#39;Z\u0026#39;)); else if (choice \u0026lt; 0.666) sb.Append((char)Random.Next(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;)); else sb.Append((char)Random.Next(\u0026#39;0\u0026#39;, \u0026#39;9\u0026#39;)); } return sb.ToString(); } 生成随机字符串数组：\npublic static string[] GetRandomArrayString(int n, int minLength, int maxLength) { var result = new string[n]; for (var i = 0; i \u0026lt; n; i++) { result[i] = GetRandomString(minLength, maxLength); } return result; } 测试方法：\npublic static long Performance(ISt\u0026lt;string, int\u0026gt; st, int n, int averageHit) { var keys = GetRandomArrayString(n, 2, 50); var keyNotExist = GetRandomString(51, 52); var sw = Stopwatch.StartNew(); // 构建 for (var i = 0; i \u0026lt; n; i++) st.Put(keys[i], i); // 查询 for (var i = 0; i \u0026lt; averageHit; i++) { for (var j = 0; j \u0026lt; n; j++) { st.Get(keys[j]); st.Get(keyNotExist); } } sw.Stop(); return sw.ElapsedMilliseconds; } 另请参阅 # SymbolTable 库\n"},{"id":384,"href":"/3-1-32/","title":"3.1.32","section":"《算法（第四版）》C# 题解","content":" 3.1.32 # 解答 # 编码实现即可，实验结果如下：\n对于保持键有序的 BinarySearchST 来说，逆序输入是最坏情况，顺序输入则是最好情况。\n而对于键无序的 SequentialSearchST 来说，输入顺序对于性能的影响不大。\n只有一种键的时候，每次 Put 都只需要比较一次，值一直在被替换。\n只有两种值对性能的影响不大，性能主要由输入的键决定。\n代码 # 测试方法，IST 代表一个符号表。\nstatic void Test(ISt\u0026lt;string, int\u0026gt;[] sts, int n) { var sw = new Stopwatch(); var data = SearchCompare.GetRandomArrayString(n, 3, 10); var item1 = \u0026#34;item1\u0026#34;; Array.Sort(data); // 有序的数组 Console.Write(\u0026#34;Sorted Array: \u0026#34;); sw.Start(); for (var i = 0; i \u0026lt; n; i++) { sts[0].Put(data[i], i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 逆序的数组 Console.Write(\u0026#34;Sorted Array Reversed: \u0026#34;); sw.Restart(); for (var i = n - 1; i \u0026gt;= 0; i--) { sts[1].Put(data[i], i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 只有一种键 Console.Write(\u0026#34;One Distinct Key: \u0026#34;); sw.Restart(); for (var i = 0; i \u0026lt; n; i++) { sts[2].Put(item1, i); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); // 只有两种值 Console.Write(\u0026#34;Two Distinct Values: \u0026#34;); sw.Restart(); for (var i = 0; i \u0026lt; n; i++) { sts[3].Put(data[i], i % 2); } sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); } 另请参阅 # SymbolTable 库\n"},{"id":385,"href":"/3-1-33/","title":"3.1.33","section":"《算法（第四版）》C# 题解","content":" 3.1.33 # 解答 # 概率分布的实现方式：\n假设存有键的数组为 keys，对 keys 排序。\n然后再建立一个长度为 10N 的数组 querys，\n前 1/2 置为 keys[0]，1/2 到 3/4 置为 keys[1]，以此类推，直到数组填满。\n然后遍历 query 数组，对符号表进行 Get() 操作。\n实验结果如下：\n代码 # var n = 1000; var multiplyBy10 = 4; for (var i = 0; i \u0026lt; multiplyBy10; i++) { Console.WriteLine(\u0026#34;n=\u0026#34; + n); // 构造表 var bst = new BinarySearchSt\u0026lt;string, int\u0026gt;(n); var mst = new MoveToFrontArraySt\u0026lt;string, int\u0026gt;(n); var keys = SearchCompare.GetRandomArrayString(n, 3, 20); for (var j = 0; j \u0026lt; n; j++) { bst.Put(keys[j], j); mst.Put(keys[j], j); } // 构造查询 Array.Sort(keys); var querys = new string[10 * n]; int queryIndex = 0, keyIndex = 0; while (queryIndex \u0026lt; querys.Length) { var searchTimes = (int)Math.Ceiling((Math.Pow(0.5, keyIndex + 1) * querys.Length)); for (var j = 0; j \u0026lt; searchTimes \u0026amp;\u0026amp; queryIndex \u0026lt; querys.Length; j++) { querys[queryIndex++] = keys[keyIndex]; } keyIndex++; } Shuffle(querys); var sw = new Stopwatch(); // 测试 MoveToFrontArrayST sw.Start(); for (var j = 0; j \u0026lt; querys.Length; j++) { mst.Get(querys[j]); } sw.Stop(); Console.WriteLine(\u0026#34;MoveToFrontArrayST: \u0026#34; + sw.ElapsedMilliseconds); // 测试 BinarySearchST sw.Restart(); for (var j = 0; j \u0026lt; querys.Length; j++) { bst.Get(querys[j]); } sw.Stop(); Console.WriteLine(\u0026#34;BinarySearchST: \u0026#34; + sw.ElapsedMilliseconds); n *= 10; } static void Shuffle\u0026lt;T\u0026gt;(T[] data) { for (var i = 0; i \u0026lt; data.Length; i++) { var r = i + new Random().Next(data.Length - i); var temp = data[r]; data[r] = data[i]; data[i] = temp; } } 另请参阅 # SymbolTable 库\n"},{"id":386,"href":"/3-1-34/","title":"3.1.34","section":"《算法（第四版）》C# 题解","content":" 3.1.34 # 解答 # 在上一题的基础上进行修改即可。\n调和级数 $H_n = 1+\\frac{1}{2}+\\frac{1}{3} + \\cdots+\\frac{1}{n}$ 。\n查询数组变为前 1/2 为 key[0]，随后的 1/3 为 key[1]，以此类推。\n和上一题中的序列进行比较即可，注意删除最后的打乱步骤。\n实验结果如下：\n代码 # 首先建立一个数组计算调和级数，就像这样：\n// 调和级数 var harmonicNumber = new double[n * (int)Math.Pow(10, multiplyBy10)]; harmonicNumber[0] = 1; for (var i = 1; i \u0026lt; harmonicNumber.Length; i++) { harmonicNumber[i] = harmonicNumber[i - 1] + 1 / (i + 1); } 然后修改构造查询的代码：\n// 构造查询 Array.Sort(keys); var queryZipf = new string[10 * n]; int queryIndex = 0, keyIndex = 0; while (queryIndex \u0026lt; queryZipf.Length) { var searchTimes = (int)Math.Ceiling(queryZipf.Length / (harmonicNumber[keyIndex + 1] * (i + 1))); for (var j = 0; j \u0026lt; searchTimes \u0026amp;\u0026amp; queryIndex \u0026lt; queryZipf.Length; j++) { queryZipf[queryIndex++] = keys[keyIndex]; } keyIndex++; } 另请参阅 # SymbolTable 库\n"},{"id":387,"href":"/3-1-35/","title":"3.1.35","section":"《算法（第四版）》C# 题解","content":" 3.1.35 # 解答 # 实验结果：\n由于包含重复单词，因此结果会比 4 略低一些。\n需要对 FrequencyCounter 做一些修改，令其只取前 n 个单词。\n代码 # var n = 8000; var multiplyBy2 = 5; var repeatTimes = 5; double lastTime = -1; Console.WriteLine(\u0026#34;n\\ttime\\tratio\u0026#34;); for (var i = 0; i \u0026lt; multiplyBy2; i++) { Console.Write(n + \u0026#34;\\t\u0026#34;); long timeSum = 0; for (var j = 0; j \u0026lt; repeatTimes; j++) { var st = new SequentialSearchSt\u0026lt;string, int\u0026gt;(); var sw = Stopwatch.StartNew(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, n, 0, st); sw.Stop(); timeSum += sw.ElapsedMilliseconds; } timeSum /= repeatTimes; Console.Write(timeSum + \u0026#34;\\t\u0026#34;); if (lastTime \u0026lt; 0) Console.WriteLine(\u0026#34;--\u0026#34;); else Console.WriteLine(timeSum / lastTime); lastTime = timeSum; n *= 2; } 另请参阅 # SymbolTable 库\n"},{"id":388,"href":"/3-1-36/","title":"3.1.36","section":"《算法（第四版）》C# 题解","content":" 3.1.36 # 解答 # 实验结果如下，增长级为 O(N) ，但速度很快。 其实只要列出《双城记》不同长度的单词数目，原因就一目了然了。 大部分单词都集中在中间长度，因此大部分访问也集中在数组中部。\n二分查找在访问数组中部的元素时速度很快，因此结果好于预期。\n代码 # var n = 8000; var multiplyBy2 = 5; var repeatTimes = 5; double lastTime = -1; Console.WriteLine(\u0026#34;n\\ttime\\tratio\u0026#34;); for (var i = 0; i \u0026lt; multiplyBy2; i++) { Console.Write(n + \u0026#34;\\t\u0026#34;); long timeSum = 0; for (var j = 0; j \u0026lt; repeatTimes; j++) { var st = new BinarySearchSt\u0026lt;string, int\u0026gt;(); var sw = Stopwatch.StartNew(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, n, 0, st); sw.Stop(); timeSum += sw.ElapsedMilliseconds; } timeSum /= repeatTimes; Console.Write(timeSum + \u0026#34;\\t\u0026#34;); if (lastTime \u0026lt; 0) Console.WriteLine(\u0026#34;--\u0026#34;); else Console.WriteLine(timeSum / lastTime); lastTime = timeSum; n *= 2; } 另请参阅 # SymbolTable 库\n"},{"id":389,"href":"/3-1-37/","title":"3.1.37","section":"《算法（第四版）》C# 题解","content":" 3.1.37 # 解答 # 实验结果如下：\nM=10 的时候随机的数字集中在 1024 到 2048 之间，重复值较多，因此 Put 耗时较少。\n随着重复值的减少 Put 的耗时会大幅度提高，和实验结果显示的一样。\nM=20 的时候数字在 1048576~2097152 之间随机，基本上没有重复值了。\nM=30 的时候和 M=20 的情况类似，都是重复值几乎没有的情况。\n随机数可以通过如下的方式产生：\nresult[i] = min + (long)(random.NextDouble() * (max - min)); 代码 # 这里构造了 BinarySearchSTAnalysis 类，在类中声明了两个 Stopwatch 对象，\n一个在 Put 方法的开始和结束部分进行计时，\n另一个在 Get 方法的开始和结束部分进行计时。\nvar n = 1000000; var m = 10; var addBy10 = 3; for (var i = 0; i \u0026lt; addBy10; i++) { var bst = new BinarySearchStAnalysis\u0026lt;long, int\u0026gt;(n); var data = SearchCompare.GetRandomArrayLong(n, (long)Math.Pow(2, m), (long)Math.Pow(2, m + 1)); FrequencyCounter.MostFrequentlyKey(bst, data); Console.WriteLine( \u0026#34;m=\u0026#34; + m + \u0026#34;\\t\u0026#34; + bst.GetTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + bst.PutTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + bst.PutTimer.ElapsedMilliseconds / (double)bst.GetTimer.ElapsedMilliseconds); m += 10; } var st = new BinarySearchStAnalysis\u0026lt;string, int\u0026gt;(); FrequencyCounter.MostFrequentlyWord(\u0026#34;tale.txt\u0026#34;, 0, st); Console.WriteLine( \u0026#34;tales\\t\u0026#34; + st.GetTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + st.PutTimer.ElapsedMilliseconds + \u0026#34;\\t\u0026#34; + st.PutTimer.ElapsedMilliseconds / (double)st.GetTimer.ElapsedMilliseconds); Console.ReadLine(); 另请参阅 # SymbolTable 库\n"},{"id":390,"href":"/3-1-38/","title":"3.1.38","section":"《算法（第四版）》C# 题解","content":" 3.1.38 # 解答 # 实验结果如下：\nBinarySearchST SequentialSearchST 对于 BinarySearchST ，每次比较之后以及移动元素时令 Cost 增加。\n对于 SequentialSearchST，统计每次的查找次数即可。 然后绘制成散点图即可。\n代码 # 有关绘图的函数，传入的参数为第 i 次 Put() 的开销。\npublic void Draw(int[] data) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / data.Length; float unitY = (float)this.ClientRectangle.Height / data.Max(); int accumulation = 0; for (int i = 0; i \u0026lt; data.Length; i++) { // Gray panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, this.ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red panel.FillEllipse(Brushes.Red, (i + 1) * unitX, this.ClientRectangle.Bottom - accumulation / (i + 1) * unitY, 2, 2); accumulation += data[i]; } } 另请参阅 # SymbolTable 库\n"},{"id":391,"href":"/3-1-39/","title":"3.1.39","section":"《算法（第四版）》C# 题解","content":" 3.1.39 # 解答 # 实验结果如下：\nBinarySearchST SequentialSearchST 图像分为两段，分别代表不断向符号表中加入单词和寻找频率最大的单词两个部分。\n第一段两个图像的形状类似（注意它们的 y 轴比例不同）。\n第二段中 BinarySearchST 的表现要比 SequentialSearchST 稳定的多。\n代码 # 绘图部分代码：\npublic void Draw(int[] x, long[] y) { Graphics panel = this.CreateGraphics(); float unitX = (float)this.ClientRectangle.Width / x.Max(); float unitY = (float)this.ClientRectangle.Height / y.Max(); for (int i = 0; i \u0026lt; x.Length; i++) { panel.FillEllipse( Brushes.Black, x[i] * unitX, this.ClientRectangle.Height - y[i] * unitY, 2, 2); } } 另请参阅 # SymbolTable 库\n"},{"id":392,"href":"/3-1-40/","title":"3.1.40","section":"《算法（第四版）》C# 题解","content":" 3.1.40 # 解答 # 顺序查找平均需要进行 $N/2$ 次比较，二分查找则是 $\\lg N$ 次。\n列出方程可以解出 N 的大小\n$$ \\begin {eqnarray*} 1000 \\log_2 N \u0026amp;=\u0026amp; N / 2 \\newline \\log_2 N \u0026amp;=\u0026amp; N / 2000\\newline \\frac{\\ln N}{\\ln 2} \u0026amp;=\u0026amp; N/2000 \\newline N \u0026amp;=\u0026amp; e^{\\frac{\\ln 2}{2000}N}\\newline 1 \u0026amp;=\u0026amp; Ne^{-\\frac{\\ln 2}{2000}N}\\newline N_1 = e^{-W(-\\frac{\\ln 2}{2000})}=1 \u0026amp;\\ \u0026amp; N_2= e^{-W_{-1}(-\\frac{\\ln 2}{2000})}=29718\\newline \\newline \\end {eqnarray*} $$\n这个方程是一个超越方程，最后的结果中出现了朗伯 W 函数。\n同理可以求得 10000 倍的 N=369939。\n实验结果如下：\n由于存在缓存优化，每次比较的耗时并不相同。\n因此实际耗时并未达到预期，但比较次数是符合预期的。\n另请参阅 # 朗伯 W 函数-维基百科\n"},{"id":393,"href":"/3-1-41/","title":"3.1.41","section":"《算法（第四版）》C# 题解","content":" 3.1.41 # 解答 # 英文版描述为 1, 2, and 10 times faster。\n即一样快，快一倍和快十倍（一个例子）。\n和上题类似，也是解超越方程。\n插值查找的平均查找次数为 $\\lg(\\lg(N))$。\n可以解得 N = 1, 4, 58。\n实验结果如下：\n由于 N 太小，可以看到插值查找的运行时间几乎没有变化。\n"},{"id":394,"href":"/3-2-1/","title":"3.2.1","section":"《算法（第四版）》C# 题解","content":" 3.2.1 # 解答 # 构造出的树如下图所示：\n总比较次数：0 + 1 + 1 + 2 + 2 + 3 + 1 + 2 + 4 + 3 + 4 + 5 = 28 次\n另请参阅 # BinarySearchTree 库\n"},{"id":395,"href":"/3-2-2/","title":"3.2.2","section":"《算法（第四版）》C# 题解","content":" 3.2.2 # 解答 # 用这样的序列就可以构造出最坏情况：\n\u0026#34;A X C S E R H\u0026#34;, \u0026#34;X A S C R E H\u0026#34;, \u0026#34;A C E H R S X\u0026#34;, \u0026#34;X S R H E C A\u0026#34;, \u0026#34;X A S R H E C\u0026#34;, \u0026#34;A X S R H E C\u0026#34; 构造出来的树看起来像这样：\n"},{"id":396,"href":"/3-2-3/","title":"3.2.3","section":"《算法（第四版）》C# 题解","content":" 3.2.3 # 解答 # 官方答案：第一个插入的是 H，且 C 在 A 和 E 之前插入，S 在 R 和 X 之前插入的树。\n对序列排序，得到 A C E H R S X 。\n最优情况需要树两侧平衡，因此 H 为根结点，C 和 S 分别为 H 的子结点。\n同理，A 和 E 为 C 的子结点，R 和 X 为 S 的子结点。\n"},{"id":397,"href":"/3-2-4/","title":"3.2.4","section":"《算法（第四版）》C# 题解","content":" 3.2.4 # 解答 # d 是错误的。\n要点是追踪序列中的左右顺序，\n如果向右查找，那么后面的树一定都比它大，反之都比它小。\n例如 d 选项，2-\u0026gt;7 向右查找，但后面的 8 比 7 大，应该挂在 7 的右子树上，不可能在 7 的左子树里。\n"},{"id":398,"href":"/3-2-5/","title":"3.2.5","section":"《算法（第四版）》C# 题解","content":" 3.2.5 # 解答 # 事实上，这个问题可以归结为，如何根据频率来构造一棵最优的 BST？\n如果知道树的形状，逆推插入顺序也就不难了（先序遍历）。\n首先我们定义某个结点的查找开销为该结点的深度加一乘以频率， （注意根结点的深度为 0，树的高度等于整棵树中最大的深度值）\n所有结点的查找开销加起来就是一整棵树的查找开销了。\n$$ cost(n)=\\sum_{i=0}^{n} (depth(i)+1) \\times frequency(i) $$\n对于固定的一组键值和频率，$cost$ 最小的树即为我们要找的树。\n这样的树被称为最优化二叉树，或者 Optimal BST。\n根据二叉树的性质，我们可以将 $cost$ 的表达式变为：\n$$ cost(n)=cost(left)+cost(right)+\\sum_{i=1}^{n} frequency(i) $$\n即左子树的开销和右子树的开销相加，再加上所有结点的频率之和。 （左子树和右子树开销计算时每个结点的深度都少了 1，因此要加上频率和）\n不难得到结论，Optimal BST 的所有子树也都是 Optimal BST。\n我们可以利用一种类似于构造哈夫曼树的方法构造 Optimal BST，\n哈夫曼树中比较的是频率，而构造 Optimal BST 时比较的则是开销。\n由于二叉查找树是有序的，因此我们先对序列排序。\n然后计算所有大小为 1 的子树开销，显然就等于各个节点的频率。\n再计算大小为 2 的子树，注意这里只能按顺序取结点，不能跳着取（例如取第一个和第三个结点），\n每种结点取法都对应有两种根结点选择，计算出最小的开销并记录。\n以此类推，直到计算到大小为 n 的树，此时整棵 BST 就被构造出来了。\n举个例子，例如给出键值和频率如下表所示：\n$$ \\begin{array}{l|lllll} key \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \\\\ \\hline p \u0026amp; 0.4 \u0026amp; 0.1 \u0026amp; 0.2 \u0026amp; 0.1 \u0026amp; 0.2 \\end{array} $$\n当 $s=1$ 时，各子树的开销如下表（根结点不唯一）：\n$$ \\begin{array}{l|lllll} subtree \u0026amp; [1,1] \u0026amp; [2,2] \u0026amp; [3,3] \u0026amp; [4,4] \u0026amp; [5,5] \\\\ \\hline cost \u0026amp; 0.4 \u0026amp; 0.1 \u0026amp; 0.2 \u0026amp; 0.1 \u0026amp; 0.2 \\\\ root \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \\end{array} $$\n当 $s=2$ 时，各个子树的开销如下（根结点不唯一）：\n$$ \\begin{array}{l|cccc} subtree \u0026amp; [1,2] \u0026amp; [2,3] \u0026amp; [3,4] \u0026amp; [4,5] \\\\ \\hline cost \u0026amp; \\min \\begin{cases} 0+[2,2]+0.5, \\\\ \\ [1,1]+0+0.5 \\end{cases} =0.6 \u0026amp; \\min \\begin{cases} 0+[3,3]+0.3, \\\\ [2,2]+0+0.3 \\end{cases} =0.4 \u0026amp; \\min \\begin{cases} 0+[4,4]+0.3, \\\\ [3,3]+0+0.3 \\end{cases} =0.4 \u0026amp; \\min \\begin{cases} 0 +[5,5]+0.3, \\\\ [4,4]+0+0.3 \\end{cases} =0.4 \\\\ root \u0026amp; 1 \u0026amp; 3 \u0026amp; 3 \u0026amp; 5 \\end{array} $$\n当 $s=3$ 时，各个子树的开销如下表（根结点不唯一）：\n$$ \\begin{array}{l|ccc} subtree \u0026amp; [1,3] \u0026amp; [2,4] \u0026amp; [3,5] \\\\ \\hline cost \u0026amp; \\min \\begin{cases} 0+[2,3]+0.7, \\\\ [1,1]+[3,3]+0.7, \\\\ [1,2]+0+0.7 \\end{cases} =1.1 \u0026amp; \\min \\begin{cases} 0+[3,4]+0.4, \\\\ [2,2]+[4,4]+0.4, \\\\ [2,3]+0+0.4 \\end{cases} =0.6 \u0026amp; \\min \\begin{cases} 0+[4,5]+0.5, \\\\ [3,3]+[5,5]+0.5, \\\\ [3,4]+0+0.5 \\end{cases} =0.9 \\\\ root \u0026amp; 1 \u0026amp; 3 \u0026amp; 3 \\end{array} $$\n当 $s=4$ 时，各个子树的开销如下表（根结点不唯一）：\n$$ \\begin{array}{l|ll} subtree \u0026amp; [1,1] \u0026amp; [2,2] \\\\ \\hline cost \u0026amp; \\min \\begin{cases} 0+[2,4]+0.8, \\\\ [1,1]+[3,4]+0.8, \\\\ [1,2]+[4,4]+0.8, \\\\ [1,3]+0+0.8 \\end{cases} = 1.4 \u0026amp; \\min \\begin{cases} 0+[3,5]+0.5, \\\\ [2,2]+[4,5]+0.5, \\\\ [2,3]+[5,5]+0.5, \\\\ [2,4]+0+0.5 \\end{cases} = 1.0 \\\\ root \u0026amp; 1 \u0026amp; 3 \\end{array} $$\n当 $s=5$ 时，各个子树的开销如下表（根结点不唯一）：\n$$ \\begin{array}{l|l} subtree \u0026amp; [1,5] \\\\ \\hline cost \u0026amp; \\min \\begin{cases} 0+[2,5]+1.0, \\\\ [1,1]+[3,5]+1.0, \\\\ [1,2]+[4,5]+1.0, \\\\ [1,3]+[5,5]+1.0, \\\\ [1,4]+0+1.0 \\end{cases} = 2.0 \\\\ root \u0026amp; 1 \\end{array} $$\n于是最优二叉树为（不唯一）：\n另请参阅 # Optimal Binary Search Tree - Wikipedia\n"},{"id":399,"href":"/3-2-6/","title":"3.2.6","section":"《算法（第四版）》C# 题解","content":" 3.2.6 # 解答 # 官方 BST 实现见：https://algs4.cs.princeton.edu/32bst/BST.java.html\n二叉树的高度=左右子树最大高度+1，叶结点的高度为 0。 于是我们可以构造如下递归方法：\nprotected virtual int Height(Node x) { return x == null ? -1 : 1 + Math.Max(Height(x.Left), Height(x.Right)); } 当 x 等于 null 时，说明它是叶子结点的左/右子树，应该返回 0-1=-1。\n也可以在结点中添加一个 Height 属性，记录当前结点的高度，当插入新结点时重新计算高度。\n在 Put 方法中添加计算高度的代码：\nprotected virtual Node Put(Node x, TKey key, TValue value) { if (x == null) return new Node(key, value, 1); var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); return x; } 由于叶结点的高度为零，因此新插入的结点高度应该初始化为 0。\n"},{"id":400,"href":"/3-2-7/","title":"3.2.7","section":"《算法（第四版）》C# 题解","content":" 3.2.7 # 解答 # 平均查找次数 = 树所有结点的深度之和 / 结点个数 + 1。\n只要能够获得深度和，就能构造出如下用于计算平均查找次数的方法：\npublic int AverageCompares() { return DepthSum(_root) / Size() + 1; } 二叉树的深度之和 = 左子树的深度和 + 右子树的深度和 + 左子树的结点个数 + 右子树的结点个数 （加上根结点会使左右子树所有结点的深度+1）\n于是我们可以获得如下递归方法，用于计算一棵树的深度和：\nprivate int DepthSum(Node x) { if (x == null) return 0; return DepthSum(x.Left) + DepthSum(x.Right) + x.Size - 1; } 也可以在结点中直接添加一个 DepthSum 属性，用于记录当前结点的深度和。\n需要在每次插入新结点时重新计算查找路径上所有结点的 DepthSum。\nprivate Node Put(Node x, TKey key, TValue value, int depth) { if (x == null) return new Node(key, value, 1, depth); var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value, depth + 1); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value, depth + 1); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); x.DepthSum = depth; if (x.Left != null) x.DepthSum += x.Left.DepthSum; if (x.Right != null) x.DepthSum += x.Right.DepthSum; return x; } 在插入结点时需要传入一个参数以记录当前深度，新插入结点的默认深度和就是当前深度。\n"},{"id":401,"href":"/3-2-8/","title":"3.2.8","section":"《算法（第四版）》C# 题解","content":" 3.2.8 # 解答 # 假设输入的完全二叉树结点数目为 $n$。\n完全二叉树总是可以分成两部分，一个满二叉树，以及多余的结点。\n于是完全二叉树中满二叉树的部分层数为 $l = \\lfloor \\log_2 (n+1) \\rfloor$。（根结点位于第一层）\n满二叉树占的结点数量为 $n_1 = 2^l -1$，多余结点数量为 $n_2=n-n_1$。\n又因为深度等于层数 - 1，多余结点正好在满二叉树的下一层，因此多余结点的深度即为 $l$。\n于是多余结点的深度和 $d_2 = l \\times n_2$。\n接下来计算满二叉树的深度和。\n一个层数为 $l$ 的满二叉树，最后一层正好有 $2^{l-1}$ 个结点。\n于是深度和为 $d_1 = 0 \\times 1 + 1 \\times 2+2 \\times 4+\\cdots+(l-1)2^{l-1} =\\sum_{i=1}^{l-1} i2^i$。\n用错位相减法，有：\n$$ \\begin{eqnarray*} d_1\u0026amp;=\u0026amp;1\\times 2^1 + \u0026amp;2 \\times 2^2 + \\cdots + (l-1)2^{l-1} \\newline 2d_1\u0026amp;=\u0026amp; \u0026amp;1\\times 2^2 + \\cdots+(l-2)2^{l-1} +(l-1)2^{l} \\newline d_1-2d_1\u0026amp;=\u0026amp; 1 \\times2^1+ \u0026amp;1 \\times2^2+\\cdots+1\\times2^{l-1}-(l-1)2^l \\newline d_1 \u0026amp;=\u0026amp;(l-1)2^l \u0026amp;-2^l+2 \\newline \u0026amp;=\u0026amp;(l-2)2^l \u0026amp;+2 \\end{eqnarray*} $$\n于是可得总深度和： $d=d_1+d_2=l\\times n_2+ (l-2)2^l+2$。\n平均查找次数即为：$avgCompare=d / n + 1$ 。\n代码 # int OptCompares(int n) { // 完全二叉树 = 满二叉树 + 多余结点 // 满二叉树的层数。 var l = (int)Math.Log(n + 1, 2); // 多余结点的个数。 var extraNodes = n + 1 - (int)Math.Pow(2, l); var depthSum = extraNodes * l + (l - 2) * (int)Math.Pow(2, l) + 2; return depthSum / n + 1; } "},{"id":402,"href":"/3-2-9/","title":"3.2.9","section":"《算法（第四版）》C# 题解","content":" 3.2.9 # 解答 # 比较简单，可以按照如下步骤解决：\n生成 n 个数。 生成这 n 个数的全排列。 生成 n! 棵二叉搜索树，取其中结构不同的部分。 全排列可以通过递归方式生成，方法类似于 DFS。\n开始 pool 中存有所有的数，遍历 pool ，每次取一个数放入 path 中，然后递归选择下一个。\nvoid Permutation(List\u0026lt;int\u0026gt; pool, List\u0026lt;int\u0026gt; path, List\u0026lt;int[]\u0026gt; result) { if (pool.Count == 0) { result.Add(path.ToArray()); return; } for (var i = 0; i \u0026lt; pool.Count; i++) { var item = pool[i]; path.Add(item); pool.RemoveAt(i); Permutation(pool, path, result); pool.Insert(i, item); path.Remove(item); } } 有了 n! 棵二叉树之后，我们需要过滤掉结构相同的树。\n我们可以把二叉树转换成数组表示（层序遍历即可），然后遍历数组进行比较。\npublic static bool IsStructureEqual\u0026lt;TKeyA, TValueA, TKeyB, TValueB\u0026gt;(Bst\u0026lt;TKeyA, TValueA\u0026gt; a, Bst\u0026lt;TKeyB, TValueB\u0026gt; b) where TKeyA : IComparable\u0026lt;TKeyA\u0026gt; where TKeyB : IComparable\u0026lt;TKeyB\u0026gt; { var treeA = a.ToArray(); var treeB = b.ToArray(); if (treeA.Length != treeB.Length) return false; for (var i = 0; i \u0026lt; treeA.Length; i++) { if (treeA[i] == null \u0026amp;\u0026amp; treeB[i] == null) continue; if (treeA[i] != null \u0026amp;\u0026amp; treeB[i] != null) continue; return false; } return true; } 结果如下：\nn=2 n=3 n=4 n=5 n=6 另请参阅 # BinarySearchTree 库\n"},{"id":403,"href":"/3-2-10/","title":"3.2.10","section":"《算法（第四版）》C# 题解","content":" 3.2.10 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/TestBST.java.html\n测试结果：\nsize = 10 min = A max = X Testing keys() --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 Testing select --------------------------- 0 A 1 C 2 E 3 H 4 L 5 M 6 P 7 R 8 S 9 X key rank floor ceil --------------------------- A 0 A A B 1 A C C 1 C C D 2 C E E 2 E E F 3 E H G 3 E H H 3 H H I 4 H L J 4 H L K 4 H L L 4 L L M 5 M M N 6 M P O 6 M P P 6 P P Q 7 P R R 7 R R S 8 S S T 9 S X U 9 S X V 9 S X W 9 S X X 9 X X Y 10 X Z 10 X range search --------------------------- A-Z (11)A C E H L M P R S X Z-A (0) X-X (1)X 0-Z (11)A C E H L M P R S X B-G (3)C E C-L (4)C E H L After deleting the smallest 3 keys --------------------------- H 5 L 11 M 9 P 10 R 3 S 0 X 7 After deleting the remaining keys --------------------------- After adding back the keys --------------------------- A 8 C 4 E 12 H 5 L 11 M 9 P 10 R 3 S 0 X 7 "},{"id":404,"href":"/3-2-11/","title":"3.2.11","section":"《算法（第四版）》C# 题解","content":" 3.2.11 # 解答 # 树的高度为树中深度最大的点的深度。\n因此 N 个结点最多只能构造出高度为 N-1 的树来，并不能构成高度为 N 的树。\n如果将题目变为用 N 个结点构造高度为 N-1 的二叉搜索树。\n这样的树即为二叉搜索树的最坏情况，除唯一的叶子结点之外，每个结点有且只有一个子树。\n于是除根结点外，每个结点都有两种选择，要么在左，要么在右。\n因此共有 $2 ^ {n - 1}$ 种形状。\n接下来证明，对于某一种确定的最坏情况，在 N 个元素各不相同的情况下，输入顺序是唯一的。\n证明：\n就 1 2 3 这三个元素而言，构造这样一棵树：\n2 1 3 可以有 2 1 3 和 2 3 1 两种序列，因为在插入 2 之后可以选择的位置有两个\n但最坏情况下的二叉搜索树不存在具有两个子结点的结点，因此输入顺序是唯一的。\n反证：\n也可以这样考虑，假设序列 A 可以构造出一棵最坏情况下的二叉树，插入顺序为 $x_1 \\dots x_n$\n假设存在与 A 顺序不同的序列 B，它构造出的二叉树与 A 的相同。\n由于 A 和 B 的元素相同，因此 A 必然可以通过有限次元素交换得到 B。\n根据最坏情况下的二叉搜索树的性质，A 中的元素 $x_n$ 必然满足 $x_1 \\dots x_{n - 1}$ 的所有关系。\n例如，假设 $x_1 \u0026gt; x_2$， 则 $x_3$ 也必然满足 $x_1 \u0026gt; x_3$，即后面的元素必然满足前面元素的关系。\n于是 A 存在关系序列 $r_1 \\dots r_{n - 1}$，只有满足这样序列的输入才能构造出对应的二叉树。 （可以将 $r$ 理解为大于号或者小于号，由于元素各不相同，因此不存在等号）\n显然 A 中的任意两个元素交换会导致至少一个 $r$ 倒置，除非进行逆向交换，否则这种倒置不可能消除。 （大于号和小于号是不满足交换律的）\n因此 A 和 B 必定相同，得证。\n于是每一种最坏情况下的形状都唯一对应一种输入序列，共有 $2 ^ {n - 1}$ 种构造方式。\n"},{"id":405,"href":"/3-2-12/","title":"3.2.12","section":"《算法（第四版）》C# 题解","content":" 3.2.12 # 解答 # 二叉树的大小=左子树的大小+右子树的大小+1\n根据上述表达式可以构造出一个递归的 Size() 方法，并删除结点中的 Size 。\nRank() 和 Select() 仍然可以正常工作，但最坏情况下的耗时可能会达到 $O(n)$ 和 $O(n^2 )$。\n"},{"id":406,"href":"/3-2-13/","title":"3.2.13","section":"《算法（第四版）》C# 题解","content":" 3.2.13 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/NonrecursiveBST.java.html\nGet 方法可以很方便的改成非递归形式。\nprivate TValue Get(Node x, TKey key) { if (key == null) throw new ArgumentNullException(nameof(key), \u0026#34;calls get() with a null key\u0026#34;); var cur = x; while (cur != null) { var cmp = key.CompareTo(cur.Key); if (cmp \u0026lt; 0) cur = cur.Left; else if (cmp \u0026gt; 0) cur = cur.Right; else return cur.Value; } return default; } Put 方法结构类似，但需要注意更新路径上各个结点的 Size 属性。\nprivate Node Put(Node x, TKey key, TValue value) { if (x == null) return new Node(key, value, 1); var path = new Stack\u0026lt;Node\u0026gt;(); var cur = x; while (cur != null) { path.Push(cur); var cmp = key.CompareTo(cur.Key); if (cmp \u0026lt; 0) cur = cur.Left; else if (cmp \u0026gt; 0) cur = cur.Right; else { cur.Value = value; return x; } } var parent = path.Peek(); var node = new Node(key, value, 1); if (parent.Key.CompareTo(key) \u0026gt; 0) parent.Left = node; else parent.Right = node; while (path.Count \u0026gt; 0) path.Pop().Size++; return x; } Keys 方法中，可以用新建一个栈来代替递归栈记录路径。\nprivate static void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { var stack = new Stack\u0026lt;Node\u0026gt;(); while (x != null || stack.Count \u0026gt; 0) { if (x != null) { var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpHi \u0026gt;= 0) stack.Push(x); if (cmpLo \u0026lt; 0) x = x.Left; else x = null; } else { x = stack.Pop(); var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) queue.Enqueue(x.Key); x = x.Right; } } } 另请参阅 # BinarySearchTree 库\n"},{"id":407,"href":"/3-2-14/","title":"3.2.14","section":"《算法（第四版）》C# 题解","content":" 3.2.14 # 解答 # 就 min，max 和 select 而言，它们是尾递归的，可以直接转换成迭代形式。 （简单的说，尾递归就是所有递归操作都出现在 return 语句上，且返回值不需要参与其他运算）\n例如 min，递归形式为：\nif (x.Left == null) return x; return Min(x.Left); 递归调用获得的值直接返回，不再参与运算，可以直接转换为递推：\nwhile (true) { if (x.Left == null) return x; x = x.Left; } ceiling 和 floor 会略微复杂一些，具体见代码。\n代码 # min 和 max 比较简单，用一个 while 循环就可以转换为递推形式，例如 min。\nwhile (x != null) { if (x.Left == null) return x; x = x.Left; } return x; floor 和 ceiling 则要稍微复杂一点，需要记录当前找到的最小/最大值，例如 floor。\nNode floor = null; while (x != null) { var cmp = key.CompareTo(x.Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { x = x.Left; } else { floor = x; x = x.Right; } } return floor; rank 和它们类似，需要用一个变量记录当前排名。\nvar rank = 0; while (x != null) { var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { x = x.Left; } else if (cmp \u0026gt; 0) { rank += 1 + Size(x.Left); x = x.Right; } else { rank += Size(x.Left); return rank; } } return rank; select 比较简单，不需要维护变量。\nwhile (x != null) { var t = Size(x.Left); if (t \u0026gt; k) { x = x.Left; } else if (t \u0026lt; k) { x = x.Right; k = k - t - 1; } else { return x; } } return null; 另请参阅 # 尾递归-维基百科\nBinarySearchTree 库\n"},{"id":408,"href":"/3-2-15/","title":"3.2.15","section":"《算法（第四版）》C# 题解","content":" 3.2.15 # 解答 # 比较简单，这里比较/取值都算一次访问，因此 keys 的访问序列会出现重复元素。\n函数 路径 floor(Q) E Q select(5) E Q ceiling(Q) E Q rank(J) E Q J size(D, T) E Q T E D keys(D, T) E D E Q J J M Q T S S T "},{"id":409,"href":"/3-2-16/","title":"3.2.16","section":"《算法（第四版）》C# 题解","content":" 3.2.16 # 解答 # 在高德纳的《计算机程序设计艺术》第一卷里出现了这个公式，编号为 $2.3.4.5(3)$。\n书中的证明简单直接：\n考虑二叉树中的某个叶子结点 $V$，设根结点到它的路径长度为 $k$，现在将 $V$ 删去。 对于二叉树的内部路径长度 $I$ 和外部路径长度 $E$ ：\n由于 $V$ 被删去，$E$ 将会减少 $2(k+1)$，$I$ 将会减少 $k$，但此时 $V$ 变成了一个外部结点，$E$ 又会加上 $k$。 因此最后 $E$ 减少了 $k+2$，$I$ 减少了 $k$，重复 $N$ 次操作之后就可以得到 $E = I + 2N$。\n另请参阅 # 《计算机程序设计艺术：第一卷 基本算法》（第三版）P400\n"},{"id":410,"href":"/3-2-17/","title":"3.2.17","section":"《算法（第四版）》C# 题解","content":" 3.2.17 # 解答 # 像这样，有一些字母是重复的，因此删除后树形状不变：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------S-------| |---Q |---Y |-O |-U N T I---------------| |-------T-------| |---Q |---Y |-O U N I---------------| |-------T-------| |---Q U |-O N I-------| |---T---| |-O U N I-------| |---T |-O N I-------| |---T |-O N I-------| |---T |-O N I---| |-O N |-O N N "},{"id":411,"href":"/3-2-18/","title":"3.2.18","section":"《算法（第四版）》C# 题解","content":" 3.2.18 # 解答 # 和上一题类似，只是删除顺序不同：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N E-------------------------------| |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |-------S-------| |---Q |---Y |-O |-U N T |-------S-------| |---Q |---Y O |-U T |-------S-------| Q |---Y |-U T S-------| |---Y |-U T |---Y |-U T |---Y |-U T |-Y U Y "},{"id":412,"href":"/3-2-19/","title":"3.2.19","section":"《算法（第四版）》C# 题解","content":" 3.2.19 # 解答 # 类似于这样的序列：\n|-------------------------------E-------------------------------| A |---------------S---------------| |-------Q |-------Y I---| |---U |-O T N |---------------I---------------| A |-------S-------| |---Q |---Y |-O |-U N T |---------------N---------------| A |-------S-------| |---Q |---Y O |-U T |---------------O---------------| A |-------S-------| Q |---Y |-U T |---------------Q---------------| A S-------| |---Y |-U T |-------S-------| A |---Y |-U T |---T---| A |-Y U |-U-| A Y |-Y A A "},{"id":413,"href":"/3-2-20/","title":"3.2.20","section":"《算法（第四版）》C# 题解","content":" 3.2.20 # 解答 # 勘误：英文版为 keys() 方法（而非 Size() 方法）。\n先来观察一下 keys() 方法的实现：\npublic IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(root, queue, lo, hi); return queue; } private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { var cmplo = lo.CompareTo(x.Key); var cmphi = hi.CompareTo(x.Key); if (cmplo \u0026lt; 0) Keys(x.Left, queue, lo, hi); if (cmplo \u0026lt;= 0 \u0026amp;\u0026amp; cmphi \u0026gt;= 0) queue.Enqueue(x.Key); if (cmphi \u0026gt; 0) Keys(x.Right, queue, lo, hi); } 简单地说，就是从根结点同时向两侧查找，同时把中间的键加入到队列中（树高的倍数+范围内键的数量）。\n于是 Keys() 的耗时可以分成两部分：\n寻找小于 lo 的最大键值和大于 hi 的最小键值在最坏情况下需要的访问结点数——即树高。 （例如当 lo 小于树中的最小键或者 hi 大于树中最大键时）\n以及访问 lo 和 hi 之间所有结点。\n"},{"id":414,"href":"/3-2-21/","title":"3.2.21","section":"《算法（第四版）》C# 题解","content":" 3.2.21 # 解答 # 要注意保持每个键的出现概率相等，可以先随机一个排名，然后从树中将对应排名的键取出来。\nprivate static readonly Random Random = new Random(); public TKey RandomKey() { var rank = Random.Next(1, Size() + 1); return GetKeyWithRank(root, rank); } private TKey GetKeyWithRank(Node x, int rank) { var left = (x.Left == null ? 0 : x.Left.Size) + 1; if (left \u0026gt; rank) { return GetKeyWithRank(x.Left, rank); } else if (left == rank) { return x.Key; } else { return GetKeyWithRank(x.Right, rank - left); } } 可以观察到每个键的出现概率都是差不多的。\n另请参阅 # BinarySearchTree 库\n"},{"id":415,"href":"/3-2-22/","title":"3.2.22","section":"《算法（第四版）》C# 题解","content":" 3.2.22 # 解答 # 这里的前驱和后继指的是二叉树中序遍历序列里结点的前驱和后继。\n由于二叉搜索树的性质，它的中序遍历序列是递增有序的。\n因此一个结点如果有左子树，要么前驱就是左子树中最大的结点（最右侧）；\n同理结点如果有右子树，要么后继就是右子树中最小的结点（最左侧）。\n于是结点的前驱不会有右子节点，后继不会有左子节点，得证。\n"},{"id":416,"href":"/3-2-23/","title":"3.2.23","section":"《算法（第四版）》C# 题解","content":" 3.2.23 # 解答 # 不满足，反例如下：\n|-------10 |---5---| 3 |-8-| 6 9 Delete 5 then delete 3 |-------10 6---| 8-| 9 Delete 3 then delete 5 |---10 |-8-| 6 9 这里先删除 3 会使 5 的左子树为空，导致删除 5 的时候采取的策略被改变（尽管 5 的右子树没有任何变化）。\n另请参阅 # Deletion procedure for a Binary Search Tree-Stackoverflow\n"},{"id":417,"href":"/3-2-24/","title":"3.2.24","section":"《算法（第四版）》C# 题解","content":" 3.2.24 # 解答 # 根据命题 D （英文版 P404，中文版 P255），一次插入所需的比较次数平均为 $ 1.39\\lg N$。 (我们这里要求和，因此可以直接使用平均值进行计算）\n于是构造一棵二叉查找树所需的比较次数为：\n$$ 1.39C= 1.39\\sum_{i=0}^N \\lg i=1.39 \\times(\\lg 1 + \\lg2+\\cdots+\\lg N) $$\n根据对数恒等式，有：\n$$ C=\\lg 1 + \\lg2+\\cdots+\\lg N=\\lg(1\\times2\\times3\\times\\cdots\\times N)=\\lg(N!) $$\n于是有 $ 1.39C=1.39\\lg(N!) \u0026gt; \\lg(N!)$ ，得证。\n"},{"id":418,"href":"/3-2-25/","title":"3.2.25","section":"《算法（第四版）》C# 题解","content":" 3.2.25 # 解答 # 官方实现：https://algs4.cs.princeton.edu/32bst/PerfectBalance.java.html\n先排序，然后视其为中序序列，每次取中间的键作为根结点，左半数组是左子树，右半数组是右子树，递归构造。\nprivate Node BuildTree(KeyValuePair\u0026lt;TKey, TValue\u0026gt;[] init, int lo, int hi)// init is sorted { if (lo \u0026gt; hi) { return null; } var mid = (hi - lo) / 2 + lo; var current = new Node(init[mid].Key, init[mid].Value, 1); current.Left = BuildTree(init, lo, mid - 1); current.Right = BuildTree(init, mid + 1, hi); if (current.Left != null) { current.Size += current.Left.Size; } if (current.Right != null) { current.Size += current.Right.Size; } return current; } 另请参阅 # BinarySearchTree 库\n"},{"id":419,"href":"/3-2-26/","title":"3.2.26","section":"《算法（第四版）》C# 题解","content":" 3.2.26 # 解答 # 在 {% post_link 3-2-9 3.2.9 %} 的代码基础上进行修改，统计每种形状的出现次数，以此获得准确的概率。\n概率如下，基本呈现一个对称的图形。\n原始数据：\nn=2 50% 50% n=3 16.666666% 16.666666% 33.333332% 16.666666% 16.666666% n=4 8.333333% 16.666666% 37.5% 12.5% 8.333333% 16.666666% n=5 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 5% 5% 5% 5% 3.3333333% 3.3333333% 6.6666665% 3.3333333% 3.3333333% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% 2.5% 2.5% 2.5% 2.5% 0.8333333% 0.8333333% 1.6666666% 0.8333333% 0.8333333% n=6 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.1111112% 2.2222223% 1.9444444% 0.8333333% 1.9444444% 0.8333333% 1.1111112% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.3888888% 2.7777777% 6.25% 2.0833333% 1.3888888% 2.7777777% 4.1666665% 2.7777777% 4.1666665% 4.1666665% 2.7777777% 4.1666665% 1.3888888% 1.3888888% 2.7777777% 2.7777777% 1.3888888% 1.3888888% 1.3888888% 2.7777777% 6.25% 2.0833333% 1.3888888% 2.7777777% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% 1.1111112% 2.2222223% 1.9444444% 0.8333333% 1.9444444% 0.8333333% 1.1111112% 0.2777778% 0.5555556% 1.25% 0.41666666% 0.2777778% 0.5555556% "},{"id":420,"href":"/3-2-27/","title":"3.2.27","section":"《算法（第四版）》C# 题解","content":" 3.2.27 # 解答 # 二叉查找树的内存开销=对象开销+根结点引用+N个结点 =对象开销+根结点引用+N×(对象开销+父类型引用+左/右子树引用+键/值引用+结点数)\n=16+8+N×(16+8+16+16+4+4)=24+64N 字节\nBinarySearchST：对象开销+键/值数组引用+键/值数组+计数器（一个 int）。\n=16+16+(16+4+4+8N)×2+4+4=88+16N 字节。\nSequentialSearchST：对象开销+头结点引用+N个结点+计数器\n=对象开销+头结点引用+N×(对象开销+父类型引用+next引用+键/值引用)+计数器\n=16+8+N×(16+8+8+16)+4+4=32+48N 字节\n示意图如下：\n其中，对象开销 16 字节，其他均为引用，各占 8 字节。\n《双城记》中不重复的单词有 26436 个（不包括最后的版权声明），全部是原文的子字符串，每个占 40 字节。\n一个 Integer 占 24 字节，于是估计的内存消耗为：24+(64+40+24)×26436=3383832 字节。\n"},{"id":421,"href":"/3-2-28/","title":"3.2.28","section":"《算法（第四版）》C# 题解","content":" 3.2.28 # 解答 # 修改一下 Put 和 Get 方法，在实际操作之前先检查缓存是否符合要求，然后在操作之后更新缓存。\n代码 # private Node _cache; public override TValue Get(TKey key) { if (_cache != null \u0026amp;\u0026amp; _cache.Key.CompareTo(key) == 0) { return _cache.Value; } return Get(root, key).Value; } protected override Node Get(Node x, TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;calls get() with a null key\u0026#34;); } if (x == null) { return null; } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { return Get(x.Left, key); } else if (cmp \u0026gt; 0) { return Get(x.Right, key); } else { _cache = x; return x; } } public override void Put(TKey key, TValue value) { if (key == null) { throw new ArgumentNullException(\u0026#34;calls Put() with a null key\u0026#34;); } if (value == null) { Delete(key); return; } if (_cache != null \u0026amp;\u0026amp; _cache.Key.CompareTo(key) == 0) { _cache.Value = value; return; } root = Put(root, key, value); } protected override Node Put(Node x, TKey key, TValue value) { if (x == null) { _cache = new Node(key, value, 1); return _cache; } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Put(x.Left, key, value); else if (cmp \u0026gt; 0) x.Right = Put(x.Right, key, value); else x.Value = value; x.Size = 1 + Size(x.Left) + Size(x.Right); return x; } 另请参阅 # BinarySearchTree 库\n"},{"id":422,"href":"/3-2-29/","title":"3.2.29","section":"《算法（第四版）》C# 题解","content":" 3.2.29 # 解答 # 本题在原书后续印刷中已修改，这里仍采用中文版的题目。\n部分解答：https://algs4.cs.princeton.edu/32bst/BST.java.html（isSizeConsistent()）\n如果根结点记录的结点数=左子树的结点数+右子树的结点数+1，就符合要求。\n按照这个题意编制递归方法即可。\n先写边界，当输入为 null 时，显然符合要求。\n然后计算左子树的 Size 和右子树的 Size 加起来是否等于根结点的 Size + 1，\n以及左子树和右子树是否符合同样的条件。\n代码 # protected static bool IsBinaryTree(Node x) { if (x == null) { return true; // 空树显然符合二叉树条件。 } var size = 1; // 包括当前结点本身。 if (x.Left != null) { size += x.Left.Size; } if (x.Right != null) { size += x.Right.Size; } return IsBinaryTree(x.Left) \u0026amp;\u0026amp; IsBinaryTree(x.Right) \u0026amp;\u0026amp; x.Size == size; } 另请参阅 # BinarySearchTree 库\n"},{"id":423,"href":"/3-2-30/","title":"3.2.30","section":"《算法（第四版）》C# 题解","content":" 3.2.30 # 解答 # 本题在原书后续印刷中已修改，这里仍然采用中文版的题目。\n与上一题非常类似，条件有：\n根结点必须在 min 和 max 范围内，\n且左右子树要么不存在，要么小于/大于根结点的键，\n左右子树同样满足上述条件。\n代码 # protected static bool IsOrdered(Node x, TKey min, TKey max) { if (x == null) { return true; // 空树显然是满足要求的。 } return IsOrdered(x.Left, min, max) \u0026amp;\u0026amp; IsOrdered(x.Right, min, max) \u0026amp;\u0026amp; // 左右子树都满足要求。 x.Key.CompareTo(max) \u0026lt;= 0 \u0026amp;\u0026amp; x.Key.CompareTo(min) \u0026gt;= 0 \u0026amp;\u0026amp; // 当前结点位于范围内。 (x.Left == null || x.Left.Key.CompareTo(x.Key) \u0026lt; 0) \u0026amp;\u0026amp; (x.Right == null || x.Right.Key.CompareTo(x.Key) \u0026gt; 0); // 当前结点与子结点满足大小关系。 } 另请参阅 # BinarySearchTree 库\n"},{"id":424,"href":"/3-2-31/","title":"3.2.31","section":"《算法（第四版）》C# 题解","content":" 3.2.31 # 解答 # 本题在原书后续印刷中已删除，这里仍然采用中文版的题目。\n注意这个题并没有递归的要求，直接广度优先搜索即可，随时记录和检查已找到的键。\n代码 # protected static bool HasNoDuplicates(Node x) { var keys = new List\u0026lt;TKey\u0026gt;(); // 也可以用 HashSet 之类的数据结构提高效率。 var queue = new Queue\u0026lt;Node\u0026gt;(); queue.Enqueue(x); while (queue.Count \u0026gt; 0) { var node = queue.Dequeue(); if (node == null) { continue; } if (keys.Contains(node.Key)) { return false; } keys.Add(node.Key); queue.Enqueue(node.Left); queue.Enqueue(node.Right); } return true; } 另请参阅 # BinarySearchTree 库\n"},{"id":425,"href":"/3-2-32/","title":"3.2.32","section":"《算法（第四版）》C# 题解","content":" 3.2.32 # 解答 # 本题在原书后续印刷中已修改，这里仍然采用中文版的题目。\n官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isBST()）\n书中已经给出了答案，当然在 Java 和 C# 里，\u0026amp;\u0026amp; 总是从左向右计算的，而且遇到 false 会直接返回结果。\n如果数据结构中存在环，IsOrdered 有可能会陷入无限递归的情况，因此调用顺序比较重要。\n代码 # public static bool IsBST(BST\u0026lt;TKey, TValue\u0026gt; bst) { return IsBinaryTree(bst) \u0026amp;\u0026amp; IsOrdered(bst) \u0026amp;\u0026amp; HasNoDuplicates(bst); } 另请参阅 # Boolean logical operators (C# reference)\nEquality, Relational, and Conditional Operators\nBinarySearchTree 库\n"},{"id":426,"href":"/3-2-33/","title":"3.2.33","section":"《算法（第四版）》C# 题解","content":" 3.2.33 # 解答 # 官网解答见：https://algs4.cs.princeton.edu/32bst/BST.java.html （isRankConsistent()）\n按照题目要求实现即可，分为两步进行测试。\n代码 # public static bool IsRankConsistent(BST\u0026lt;TKey, TValue\u0026gt; bst) { for (var i = 0; i \u0026lt; bst.Size(); i++) { if (i != bst.Rank(bst.Select(i))) { return false; } } foreach (var key in bst.Keys()) { if (key.CompareTo(bst.Select(bst.Rank(key))) != 0) { return false; } } return true; } 另请参阅 # BinarySearchTree 库\n"},{"id":427,"href":"/3-2-34/","title":"3.2.34","section":"《算法（第四版）》C# 题解","content":" 3.2.34 # 解答 # 其实就是将所有的结点按照中序序列排成了一个双向链表，对树进行修改时要同时更新这个双向链表。\n当插入新结点时，插到左侧的结点会变为父结点的新前驱，同理右侧会变为新后继。\n注意要更新父结点原来的前驱和后继结点（如果有）。\n删除结点时较为简单，只要更新需要删除结点的前驱和后继结点即可。\n原本操作 left 和 right 的代码不需要更改，只需要加上对 prev 和 next 做操作的代码即可。\nPrev 方法实现如下（Next 类似），修改了内部的 Get 方法使之返回 Node 而非 TValue。\npublic TKey Prev(TKey key) { var node = Get(root, key); if (node == null || node.Prev == null) return null; return node.Prev.Key; } 代码 # 处理结点关系的几个方法。\nprivate void DeleteNode(Node x) { if (x.Prev != null) x.Prev.Next = x.Next; if (x.Next != null) x.Next.Prev = x.Prev; } private void InsertRight(Node parent, Node newNode) { parent.Right = newNode; InsertBetween(parent, newNode, parent.Next); } private void InsertLeft(Node parent, Node newNode) { parent.Left = newNode; InsertBetween(parent.Prev, newNode, parent); } private void InsertBetween(Node prev, Node newNode, Node next) { newNode.Prev = prev; newNode.Next = next; if (prev != null) prev.Next = newNode; if (next != null) next.Prev = newNode; } Put 方法\nprotected virtual Node Put(Node x, TKey key, TValue value) { if (x == null) { return new Node(key, value, 1); // 树是空的。 } var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) { if (x.Left == null) { var newNode = new Node(key, value, 1); InsertLeft(x, newNode); } else { x.Left = Put(x.Left, key, value); } } else if (cmp \u0026gt; 0) { if (x.Right == null) { var newNode = new Node(key, value, 1); InsertRight(x, newNode); } else { x.Right = Put(x.Right, key, value); } } else { x.Value = value; } x.Size = 1 + Size(x.Left) + Size(x.Right); return x; } Delete 方法\nprotected virtual Node Delete(Node x, TKey key) { if (x == null) return null; var cmp = key.CompareTo(x.Key); if (cmp \u0026lt; 0) x.Left = Delete(x.Left, key); else if (cmp \u0026gt; 0) x.Right = Delete(x.Right, key); else { DeleteNode(x); // 在中序链表中删除结点。 if (x.Right == null) return x.Left; if (x.Left == null) return x.Right; var t = x; x = Min(t.Right); x.Right = DeleteMin(t.Right); x.Left = t.Left; } x.Size = Size(x.Left) + Size(x.Right) + 1; return x; } DeleteMin 方法，DeleteMax 类似。\nprotected virtual Node DeleteMin(Node x) { if (x.Left == null) { DeleteNode(x); return x.Right; } x.Left = DeleteMin(x.Left); x.Size = Size(x.Left) + Size(x.Right) + 1; return x; } 另请参阅 # BinarySearchTree 库\n"},{"id":428,"href":"/3-2-35/","title":"3.2.35","section":"《算法（第四版）》C# 题解","content":" 3.2.35 # 解答 # 根据书中已经给出的归纳关系式（中文版 P255/英文版 P403）：\n$$ C_N=N-1+(C_0+C_{N-1})/N+(C_1+C_{N-2})/N+\\cdots+(C_{N-1}+C_0)/N $$\n整理得：\n$$ C_N=N-1+(C_0+C_1+\\cdots+C_{N-1})/N+(C_{N-1}+\\cdots+C_1+C_0)/N $$\n这和快速排序的式子基本一致，只是 $N+1$ 变成了 $N-1$。\n遵循相同的推导过程，我们可以获得类似的结果，两边同乘以 $N$：\n$$ NC_N=N(N-1)+2(C_0+C_1+\\cdots+C_{N-1}) $$\n用 $N+1$ 时的等式减去该式得：\n$$ (N+1)C_{N+1}-NC_N=2N+2C_N \\newline (N+1)C_{N+1}=2N+(N+2)C_N \\newline \\frac{C_{N+1}}{N+2}=\\frac{2N}{(N+1)(N+2)} + \\frac{C_N}{N+1} $$\n令 $T_N = \\frac{C_N}{N+1}$，得到：\n$$ T_{N+1}=\\frac{2N}{(N+1)(N+2)} + T_N \\newline T_{N+1}-T_{N} = \\frac{2N}{(N+1)(N+2)} $$\n归纳得：\n$$ \\begin{aligned} T_N \u0026amp;= 2 \\sum_{i=2}^{N} \\frac{i-1}{i(i+1)} \\newline C_N\u0026amp;=2(N+1)\\sum_{i=2}^{N} \\frac{i-1}{i(i+1)} \\newline C_N\u0026amp;=2(N+1)\\sum_{i=2}^{N}(i-1) (\\frac{1}{i}-\\frac{1}{i+1}) \\newline C_N\u0026amp;=-2(N-1)+ 2(N+1)\\sum_{i=2}^{N}\\frac{1}{i}\\newline C_N\u0026amp;=-2(N-1)+ 2(N+1)(-1+\\sum_{i=1}^{N}\\frac{1}{i})\\newline C_N\u0026amp;=-4N+2(N+1)(\\ln N+\\gamma) \\end{aligned} $$\n于是平均成本为：$1+C_N/N \\sim 2\\ln N+2\\gamma-3$ 。\n"},{"id":429,"href":"/3-2-36/","title":"3.2.36","section":"《算法（第四版）》C# 题解","content":" 3.2.36 # 解答 # 用一个栈来模拟递归即可，将路径上的结点记录到栈里。\n注意 Queue\u0026lt;TKey\u0026gt; 不算额外空间，因为它在keys执行完毕之后不会被回收。\n代码 # private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { var stack = new Stack\u0026lt;Node\u0026gt;(); while (x != null || stack.Count \u0026gt; 0) { if (x != null) { var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpHi \u0026gt;= 0) stack.Push(x); if (cmpLo \u0026lt; 0) x = x.Left; else x = null; } else { x = stack.Pop(); var cmpLo = lo.CompareTo(x.Key); var cmpHi = hi.CompareTo(x.Key); if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) queue.Enqueue(x.Key); x = x.Right; } } } 另请参阅 # BinarySearchTree 库\n"},{"id":430,"href":"/3-2-37/","title":"3.2.37","section":"《算法（第四版）》C# 题解","content":" 3.2.37 # 解答 # 二叉树层序遍历，出队一个结点，打印它，将结点的左右子树入队，循环即可。\n代码 # private void PrintLevel(Node x) { var queue = new Queue\u0026lt;Node\u0026gt;(); queue.Enqueue(x); while (queue.Count \u0026gt; 0) { var node = queue.Dequeue(); if (node.Left != null) queue.Enqueue(node.Left); if (node.Right != null) queue.Enqueue(node.Right); Console.Write(node.Key + \u0026#34;, \u0026#34;); } } 另请参阅 # BinarySearchTree 库\n"},{"id":431,"href":"/3-2-38/","title":"3.2.38","section":"《算法（第四版）》C# 题解","content":" 3.2.38 # 解答 # 通过层序遍历计算结点的坐标，然后绘制即可。\n先算出最大深度，确定每一层的高度 Y，\n再将每一层的宽度分成 $2^n-1$ 份，从左到右依次对结点赋值。\n效果如下：\n代码 # 计算坐标的函数。\npublic void DrawTree(Graphics pen, RectangleF panel) { var depth = Depth(root); // 确定最大深度。 var layerHeight = panel.Height / depth; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); for (var layer = 0; layer != depth; layer++) { var unitSizeX = (float)(panel.Width / Math.Pow(2, layer)); var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; var cursorX = 0.0f; var cursorY = layer * layerHeight; while (nowLayer.Count != 0) { var node = nowLayer.Dequeue(); if (node != null) { nextLayer.Enqueue(node.Left); nextLayer.Enqueue(node.Right); } else { nextLayer.Enqueue(null); nextLayer.Enqueue(null); } if (node != null) { node.X = cursorX + unitSizeX / 2.0f; node.Y = cursorY; } cursorX += unitSizeX; } } } "},{"id":432,"href":"/3-2-39/","title":"3.2.39","section":"《算法（第四版）》C# 题解","content":" 3.2.39 # 解答 # 测试结果：\n可以看到和公式给出的结果十分一致。\n测试时先生成 0~2n 顺序序列，奇数插入二叉树中，偶数用于测试查找失败的情况。\n代码 # static void Main(string[] args) { var n = 10000; var trial = 100; for (var i = 0; i \u0026lt; 3; i++) { var odds = new int[n]; var evens = new int[n]; var bst = new BSTAnalysis\u0026lt;int, int\u0026gt;(); for (var j = 100; j \u0026lt; n; j++) { evens[j] = j; odds[j] = j + 1; } Shuffle(odds); foreach (var item in odds) { bst.Put(item, item); } Console.WriteLine(\u0026#34;n:\u0026#34; + n); // hit Shuffle(odds); Test(bst, odds, trial, \u0026#34;hit\u0026#34;); // miss Shuffle(evens); Test(bst, evens, trial, \u0026#34;miss\u0026#34;); n *= 10; } } static void Test(BSTAnalysis\u0026lt;int, int\u0026gt; bst, int[] testCases, int trials, string label) { var testRecords = new long[trials]; for (var j = 0; j \u0026lt; trials; j++) { bst.CompareTimes = 0; // reset bst.Get(testCases[j]); // test testRecords[j] = bst.CompareTimes; // record } var testAverage = 0d; // \u0026#39;d\u0026#39; for double foreach (var record in testRecords) { testAverage += record; } testAverage /= testRecords.Length; var testStandardDeviation = 0d; foreach (var record in testRecords) { testStandardDeviation += (record - testAverage) * (record - testAverage); } testStandardDeviation /= testRecords.Length; testStandardDeviation = Math.Sqrt(testStandardDeviation); // 2lnN + 2γ - 3 var expect = 2 * Math.Log(testCases.Length) + 2 * 0.5772156649 - 3; Console.WriteLine(label + \u0026#34;: ActualAverage: \u0026#34; + testAverage + \u0026#34;\\tExpectAverage: \u0026#34; + expect + \u0026#34;\\tStandardDevitation:\u0026#34; + testStandardDeviation); } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # BinarySearchTree 库\n"},{"id":433,"href":"/3-2-40/","title":"3.2.40","section":"《算法（第四版）》C# 题解","content":" 3.2.40 # 解答 # 书中的结论是 1986 年 L. Devroye 给出的，原式为 $H_n \\rightarrow c\\log(n)$。\n其中 $c$ 是方程 $c\\log \\frac{2e}{c}=1$ 的最大解，约为 $4.31107$。\n2002 年 Michael Drmota 给出了一个跟精确的公式：$\\mathrm{E}(H_n)=c\\log n-\\frac{3c}{2(c-1)}\\log \\log n + O(1)$。\n测试结果如下，误差基本稳定在一个常数。\n代码 # static void Main(string[] args) { var n = 10000; var trials = 100; for (var i = 0; i \u0026lt; 3; i++) { var items = new int[n]; for (var j = 0; j \u0026lt; n; j++) { items[j] = j; } var aveHeight = 0d; for (var j = 0; j \u0026lt; trials; j++) { var bst = new BST\u0026lt;int, int\u0026gt;(); Shuffle(items); foreach (var item in items) { bst.Put(item, item); } aveHeight += bst.Height(); } aveHeight /= trials; var c = 4.31107d; var expectHeightLuc = c * Math.Log(n); var expectHeightMichael = c * Math.Log(n) - (3 * c / (2 * (c - 1))) * Math.Log(Math.Log(n)); Console.WriteLine(\u0026#34;n:\u0026#34; + n); Console.WriteLine(\u0026#34;Actual Height:\u0026#34; + aveHeight); Console.WriteLine(\u0026#34;Devroye: \u0026#34; + expectHeightLuc + \u0026#34;\\tDiff: \u0026#34; + (float)(expectHeightLuc - aveHeight)); Console.WriteLine(\u0026#34;Michael: \u0026#34; + expectHeightMichael + \u0026#34;\\tDiff: \u0026#34; + (float)(expectHeightMichael - aveHeight)); n *= 10; } } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # A note on the height of binary search tree\nNote The Variance of the height of binary search trees\nBinarySearchTree 库\n"},{"id":434,"href":"/3-2-41/","title":"3.2.41","section":"《算法（第四版）》C# 题解","content":" 3.2.41 # 解答 # 大体上和标准 BST 实现差不多，做如下变换即可：\nx.Key =\u0026gt; _nodes[x].Key; x.Value =\u0026gt; _nodes[x].Value; x.Left =\u0026gt; _left[x]; x.Right =\u0026gt; _right[x]; 由于使用了数组，在正常「删除」二叉树结点之后，还需要手工「垃圾回收」，如下图所示：\n性能比较：\n可见数组实现在删除节点时有巨大的性能差距。\n代码 # private readonly Node[] _nodes; private readonly int[] _left; private readonly int[] _right; private int _size; private int _root; /// \u0026lt;summary\u0026gt; /// 二叉搜索树的结点。 /// \u0026lt;/summary\u0026gt; private class Node { public TKey Key { get; set; } public TValue Value { get; set; } } /// \u0026lt;summary\u0026gt; /// 建立一个以数组为基础的二叉搜索树。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;maxSize\u0026#34;\u0026gt;二叉搜索树中的结点数。\u0026lt;/param\u0026gt; public BSTArray(int maxSize) { _nodes = new Node[maxSize]; _left = new int[maxSize]; _right = new int[maxSize]; for (var i = 0; i \u0026lt; maxSize; i++) { _left[i] = -1; _right[i] = -1; } _size = 0; _root = 0; } /// \u0026lt;summary\u0026gt; /// 向符号表插入键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public void Put(TKey key, TValue value) { if (_size == _nodes.Length) { throw new InvalidOperationException(\u0026#34;BST is full\u0026#34;); } if (IsEmpty()) { _nodes[_size] = new Node{Key = key, Value = value}; _size++; return; } Put(key, value, null, _root); } /// \u0026lt;summary\u0026gt; /// 向二叉树插入键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;treeSide\u0026#34;\u0026gt;子树数组。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点下标。\u0026lt;/param\u0026gt; private void Put(TKey key, TValue value, int[] treeSide, int parent) { int now; if (treeSide == null) // init { now = parent; } else if (treeSide[parent] == -1) // finish { _nodes[_size] = new Node { Key = key, Value = value }; treeSide[parent] = _size; _size++; return; } else { now = treeSide[parent]; } var cmp = _nodes[now].Key.CompareTo(key); if (cmp \u0026gt; 0) { Put(key, value, _left, now); } else if (cmp \u0026lt; 0) { Put(key, value, _right, now); } else { _nodes[now].Value = value; } } /// \u0026lt;summary\u0026gt; /// 获取键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的值，不存在则返回 \u0026lt;c\u0026gt;default(Value)\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public TValue Get(TKey key) { var indices = Get(key, _root); if (indices == -1) { return default; } return _nodes[indices].Value; } /// \u0026lt;summary\u0026gt; /// 获取 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 对应的下标，不存在则返回 -1。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;start\u0026#34;\u0026gt;起始搜索下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;找到则返回对应下标，否则返回 -1。\u0026lt;/returns\u0026gt; private int Get(TKey key, int start) { var now = start; while (now != -1) { var cmp = _nodes[now].Key.CompareTo(key); if (cmp \u0026gt; 0) { now = _left[now]; } else if (cmp \u0026lt; 0) { now = _right[now]; } else { return now; } } return -1; } /// \u0026lt;summary\u0026gt; /// 从表中删去键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 及其对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; public void Delete(TKey key) { var toDelete = Get(key, _root); if (toDelete == -1) { throw new InvalidOperationException(\u0026#34;No Such Key in BST\u0026#34;); } _root = Delete(key, _root); RemoveNode(toDelete); } /// \u0026lt;summary\u0026gt; /// 从根结点为 \u0026lt;paramref name=\u0026#34;root\u0026#34;/\u0026gt; 的二叉搜索树中删除键为 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的结点。 /// 返回删除结点后树的根结点下标。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要删除的键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除结点后树的根结点下标。\u0026lt;/returns\u0026gt; private int Delete(TKey key, int root) { if (root == -1 || _nodes[root] == null) { return -1; } var cmp = _nodes[root].Key.CompareTo(key); if (cmp \u0026gt; 0) { _left[root] = Delete(key, _left[root]); } else if (cmp \u0026lt; 0) { _right[root] = Delete(key, _right[root]); } else { if (_left[root] == -1) { return _right[root]; } if (_right[root] == -1) { return _left[root]; } var toReplace = Min(_right[root]); _right[toReplace] = DeleteMin(_right[root]); _left[toReplace] = _left[root]; root = toReplace; } return root; } /// \u0026lt;summary\u0026gt; /// 键 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在表中是否存在对应的值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;如果存在则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool Contains(TKey key) { return Get(key, _root) \u0026gt; -1; } /// \u0026lt;summary\u0026gt; /// 符号表是否为空。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;为空则返回 \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt;，否则返回 \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;。\u0026lt;/returns\u0026gt; public bool IsEmpty() { return _size == 0; } /// \u0026lt;summary\u0026gt; /// 获得符号表中键值对的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中键值对的数量。\u0026lt;/returns\u0026gt; public int Size() { return _size; } /// \u0026lt;summary\u0026gt; /// [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;[\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间键的数量。\u0026lt;/returns\u0026gt; public int Size(TKey lo, TKey hi) { return Keys(lo, hi).Count(); } /// \u0026lt;summary\u0026gt; /// 计算以 \u0026lt;paramref name=\u0026#34;root\u0026#34;/\u0026gt; 为根结点的二叉树的大小。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;二叉树的根结点下标。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;二叉树中的结点个数。\u0026lt;/returns\u0026gt; private int Size(int root) { if (root == -1) { return 0; } return 1 + Size(_left[root]) + Size(_right[root]); } /// \u0026lt;summary\u0026gt; /// 获得符号表中所有键的集合。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;符号表中所有键的集合。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() { if (IsEmpty()) { return new List\u0026lt;TKey\u0026gt;(); } return Keys(Min(), Max()); } /// \u0026lt;summary\u0026gt; /// 获得符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;范围起点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;范围终点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符号表中 [\u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt;, \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt;] 之间的键。\u0026lt;/returns\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { if (lo == null) throw new ArgumentNullException(\u0026#34;first argument to keys() is null\u0026#34;); if (hi == null) throw new ArgumentNullException(\u0026#34;second argument to keys() is null\u0026#34;); var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(_root, queue, lo, hi); return queue; } /// \u0026lt;summary\u0026gt; /// 获取二叉查找树中在 \u0026lt;paramref name=\u0026#34;lo\u0026#34;/\u0026gt; 和 \u0026lt;paramref name=\u0026#34;hi\u0026#34;/\u0026gt; 之间的所有键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;queue\u0026#34;\u0026gt;要填充的队列。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lo\u0026#34;\u0026gt;键的下限。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hi\u0026#34;\u0026gt;键的上限。\u0026lt;/param\u0026gt; private void Keys(int x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { if (x == -1) { return; } var cmplo = lo.CompareTo(_nodes[x].Key); var cmphi = hi.CompareTo(_nodes[x].Key); if (cmplo \u0026lt; 0) { Keys(_left[x], queue, lo, hi); } if (cmplo \u0026lt;= 0 \u0026amp;\u0026amp; cmphi \u0026gt;= 0) { queue.Enqueue(_nodes[x].Key); } if (cmphi \u0026gt; 0) { Keys(_right[x], queue, lo, hi); } } /// \u0026lt;summary\u0026gt; /// 最小的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最小的键。\u0026lt;/returns\u0026gt; public TKey Min() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is Empty!\u0026#34;); } return _nodes[Min(_root)].Key; } /// \u0026lt;summary\u0026gt; /// 在二叉查找树中查找包含最小键的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;包含最小键的结点。\u0026lt;/returns\u0026gt; private int Min(int x) { if (_left[x] == -1) { return x; } return Min(_left[x]); } /// \u0026lt;summary\u0026gt; /// 最大的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;最大的键。\u0026lt;/returns\u0026gt; public TKey Max() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is Empty!\u0026#34;); } return _nodes[Max(_root)].Key; } /// \u0026lt;summary\u0026gt; /// 在二叉查找树中查找包含最大键的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;包含最大键的结点。\u0026lt;/returns\u0026gt; private int Max(int x) { if (_right[x] == -1) { return x; } return Max(_right[x]); } /// \u0026lt;summary\u0026gt; /// 小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大值。\u0026lt;/returns\u0026gt; public TKey Floor(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to floor is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls floor with empty symbol table\u0026#34;); } var x = Floor(_root, key); if (x == -1) { return default; } else { return _nodes[x].Key; } } /// \u0026lt;summary\u0026gt; /// 获得符号表中小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;小于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最大结点。\u0026lt;/returns\u0026gt; private int Floor(int x, TKey key) { if (x == -1) { return -1; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp == 0) { return x; } else if (cmp \u0026lt; 0) { return Floor(_left[x], key); } var t = Floor(_right[x], key); if (t != -1) { return t; } return x; } /// \u0026lt;summary\u0026gt; /// 大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小值。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小值。\u0026lt;/returns\u0026gt; public TKey Ceiling(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to ceiling is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls ceiling with empty symbol table\u0026#34;); } var x = Ceiling(_root, key); if (x == -1) { return default; } return _nodes[x].Key; } /// \u0026lt;summary\u0026gt; /// 获取符号表中大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;符号表中大于等于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的最小结点。\u0026lt;/returns\u0026gt; private int Ceiling(int x, TKey key) { if (x == -1) { return -1; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { var t = Ceiling(_left[x], key); if (t != -1) { return t; } return x; } return Ceiling(_right[x], key); } /// \u0026lt;summary\u0026gt; /// 小于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的键的数量。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;小于 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的键的数量。\u0026lt;/returns\u0026gt; public int Rank(TKey key) { if (key == null) { throw new ArgumentNullException(\u0026#34;argument to rank() is null\u0026#34;); } return Rank(_root, key); } /// \u0026lt;summary\u0026gt; /// 返回 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 在二叉查找树中的排名。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要查找排名的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt; 的排名。\u0026lt;/returns\u0026gt; private int Rank(int x, TKey key) { if (x == -1) { return 0; } var cmp = key.CompareTo(_nodes[x].Key); if (cmp \u0026lt; 0) { return Rank(_left[x], key); } else if (cmp \u0026gt; 0) { return 1 + Size(_left[x]) + Rank(_right[x], key); } else { return Size(_left[x]); } } /// \u0026lt;summary\u0026gt; /// 获得排名为 k 的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;需要获得的键的排名。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;排名为 k 的键。\u0026lt;/returns\u0026gt; public TKey Select(int k) { if (k \u0026lt; 0 || k \u0026gt;= Size()) { throw new ArgumentException(\u0026#34;argument to select() is invaild: \u0026#34; + k); } var x = Select(_root, k); return _nodes[x].Key; } /// \u0026lt;summary\u0026gt; /// 挑拣出排名为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;k\u0026#34;\u0026gt;要挑拣的排名。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;排名为 \u0026lt;paramref name=\u0026#34;k\u0026#34;/\u0026gt; 的结点。\u0026lt;/returns\u0026gt; private int Select(int x, int k) { if (x == -1) { return -1; } var t = Size(_left[x]); if (t \u0026gt; k) { return Select(_left[x], k); } else if (t \u0026lt; k) { return Select(_right[x], k - t - 1); } else { return x; } } /// \u0026lt;summary\u0026gt; /// 删除最小的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMin() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;Symbol table underflow\u0026#34;); } var minIndex = Min(_root); _root = DeleteMin(_root); RemoveNode(minIndex); } /// \u0026lt;summary\u0026gt; /// 在以 \u0026lt;paramref name=\u0026#34;x\u0026#34;/\u0026gt; 为根结点的二叉查找树中删除最小结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除后的二叉查找树。\u0026lt;/returns\u0026gt; private int DeleteMin(int x) { if (_left[x] == -1) { return _right[x]; } _left[x] = DeleteMin(_left[x]); return x; } /// \u0026lt;summary\u0026gt; /// 删除最大的键。 /// \u0026lt;/summary\u0026gt; public void DeleteMax() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;Symbol table underflow\u0026#34;); } var maxIndex = Max(_root); _root = DeleteMax(_root); RemoveNode(maxIndex); } /// \u0026lt;summary\u0026gt; /// 从指定二叉查找树中删除最大结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉查找树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;删除后的二叉查找树。\u0026lt;/returns\u0026gt; private int DeleteMax(int x) { if (_right[x] == -1) return _left[x]; _right[x] = DeleteMax(_right[x]); return x; } /// \u0026lt;summary\u0026gt; /// 删除下标为 \u0026lt;paramref name=\u0026#34;index\u0026#34;/\u0026gt; 的结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;index\u0026#34;\u0026gt;要删除的结点下标。\u0026lt;/param\u0026gt; private void RemoveNode(int index) { _size--; // Remove Node for (var i = index; i \u0026lt; _size; i++) { _nodes[i] = _nodes[i + 1]; _left[i] = _left[i + 1]; _right[i] = _right[i + 1]; } // Adjust Index if (_root \u0026gt;= index) { _root--; } for (var i = 0; i \u0026lt; _size; i++) { if (_left[i] \u0026gt;= index) { _left[i]--; } if (_right[i] \u0026gt;= index) { _right[i]--; } } } 另请参阅 # BinarySearchTree 库\n"},{"id":435,"href":"/3-2-42/","title":"3.2.42","section":"《算法（第四版）》C# 题解","content":" 3.2.42 # 解答 # 按照题意实现即可，关键点有两个：\n一是选择前驱的实现方式，只要选择左子树中的最大结点即可。\nif (_random.NextDouble() \u0026lt; 0.5) { x = Min(t.Right); x.Right = DeleteMin(t.Right); x.Left = t.Left; } else { x = Max(t.Left); x.Left = DeleteMax(t.Left); x.Right = t.Right; } 二是内部路径长度的计算方式，需要用层序遍历把所有结点的深度加起来。\nvar internalPath = 0; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.Count \u0026gt; 0) { var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count \u0026gt; 0) { var node = nowLayer.Dequeue(); if (node.Left != null) { nextLayer.Enqueue(node.Left); } if (node.Right != null) { nextLayer.Enqueue(node.Right); } internalPath += depth; } depth++; } return internalPath; 结果如下：\n另请参阅 # BinarySearchTree 库\n"},{"id":436,"href":"/3-2-43/","title":"3.2.43","section":"《算法（第四版）》C# 题解","content":" 3.2.43 # 解答 # 依照题意实现即可，put/get 大约 10 倍差距。\nMostFrequentlyKey 的实现：\npublic static TKey MostFrequentlyKey\u0026lt;TKey\u0026gt;(IST\u0026lt;TKey, int\u0026gt; st, TKey[] keys) { foreach (var s in keys) { if (st.Contains(s)) st.Put(s, st.Get(s) + 1); else st.Put(s, 1); } var max = keys[0]; foreach (var s in st.Keys()) if (st.Get(s) \u0026gt; st.Get(max)) max = s; return max; } 另请参阅 # BinarySearchTree 库\n"},{"id":437,"href":"/3-2-44/","title":"3.2.44","section":"《算法（第四版）》C# 题解","content":" 3.2.44 # 解答 # 使用类似于 3.1.38 的方法进行绘图，当 n=10000 时的结果如下：\n代码 # 绘图部分：\npublic void Draw(long[] data) { var panel = CreateGraphics(); var unitX = (float)ClientRectangle.Width / data.Length; var unitY = (float)ClientRectangle.Height / data.Max(); var accumulation = 0f; // f = float for (var i = 0; i \u0026lt; data.Length; i++) { // Gray panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, ClientRectangle.Bottom - data[i] * unitY, 2, 2); // Red panel.FillEllipse(Brushes.Red, (i + 1) * unitX, ClientRectangle.Bottom - accumulation / (i + 1) * unitY, 2, 2); accumulation += data[i]; } panel.DrawString($\u0026#34;n:{data.Length}\\nave:{accumulation / data.Length}\u0026#34;, SystemFonts.DefaultFont, Brushes.Red, 0, 0); } 测试部分：\nprivate long[] Test(int n) { var testCases = new long[n]; var testResult = new long[n]; for (var i = 0; i \u0026lt; n; i++) { testCases[i] = i; } Shuffle(testCases); var bst = new BSTAnalysis\u0026lt;long, int\u0026gt;(); for (var i = 0; i \u0026lt; n; i++) { bst.CompareTimes = 0; bst.Put(testCases[i], 1); testResult[i] = bst.CompareTimes; } return testResult; } static void Shuffle\u0026lt;T\u0026gt;(T[] a) { var random = new Random(); for (var i = 0; i \u0026lt; a.Length; i++) { var r = i + random.Next(a.Length - i); var temp = a[i]; a[i] = a[r]; a[r] = temp; } } 另请参阅 # BinarySearchTree 库\n"},{"id":438,"href":"/3-2-45/","title":"3.2.45","section":"《算法（第四版）》C# 题解","content":" 3.2.45 # 解答 # 结果如下，可参考 3.1.39。\nSequentialSearchST\nBinarySearchST\nBST\n可以看到 BST 的曲线更为平滑，插入和查找部分耗时十分接近。\n另请参阅 # BinarySearchTree 库\n"},{"id":439,"href":"/3-2-46/","title":"3.2.46","section":"《算法（第四版）》C# 题解","content":" 3.2.46 # 解答 # 翻译有些问题，其实指的是用 N 个 double 构造一个 BST 和 BinarySearchST 的速度对比。\nGet 速度 BST 是不会比 BinarySearchST 快的。（$1.39\\lg N$\u0026gt;$\\lg N$）\n二叉搜索树一次查找平均需要 $1.39\\lg N$ 次比较，二分查找则是 $N/2$，于是可以求得开销：\n二叉查找树：$1.39 \\sum_{i=1}^{N-1} \\lg i=1.39 \\lg (N-1)!=1.39(N-1)\\lg(N-1)$。\n二分查找实现的符号表：$1/2+2/2+ \\cdots+(N-1)/2=N(N-1)/4$ 。\n令两式相等，可以求得快 10 倍，100 倍，1000 倍的 $N$ 值。 例如快 10 倍的方程：\n$$ 13.9(N-1)\\lg(N-1)=N(N-1)/4 \\newline 13.9\\lg (N-1)=N/4 $$\n这是一个超越方程，可以简单用程序穷举出一个数值解。\nfor (var i = 0d; i \u0026lt; int.MaxValue; i++) { if (13.9 * Math.Log2(i - 1) \u0026lt; i / 4) { Console.WriteLine(i); return; } } 解得的三个 N 值分别为 499，7115，91651。\n除了基本的新元素赋值外，二叉树在插入时只需要进行比较即可。\n但二分查找实现的符号表还需要维持数组有序，需要额外的赋值操作。\n因此二分查找实现的符号表和二叉搜索树的开销如下：\n其中 Array 包含了比较和额外的赋值次数，Tree 只有比较次数。\n一般我们认为比较（Compare）和赋值（=）开销是一样的，但实际上比较会慢 6 倍左右（.net core 3.1），因此如果直接进行计时测试，可能得不出快 10 倍/100 倍/1000 倍的结果。\n另请参阅 # BinarySearchTree 库\n"},{"id":440,"href":"/3-2-47/","title":"3.2.47","section":"《算法（第四版）》C# 题解","content":" 3.2.47 # 解答 # 如下图所示，内部路径平均长度是比较符合规律的：\n方差：\n代码 # 一次测试：\nprivate int Test(int n) { var data = GetRandomInt(n); var bst = new BST\u0026lt;int, int\u0026gt;(); foreach (var d in data) { bst.Put(d, d); } return bst.AverageInternalPathLength(); } 求解内部路径长度：\npublic int AverageInternalPathLength() =\u0026gt; InternalPath() / Size() + 1; private int InternalPath() { var internalPath = 0; var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(root); var depth = 0; while (nextLayer.Count \u0026gt; 0) { var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count \u0026gt; 0) { var node = nowLayer.Dequeue(); if (node.Left != null) { nextLayer.Enqueue(node.Left); } if (node.Right != null) { nextLayer.Enqueue(node.Right); } internalPath += depth; } depth++; } return internalPath; } 另请参阅 # BinarySearchTree 库\n"},{"id":441,"href":"/3-3-1/","title":"3.3.1","section":"《算法（第四版）》C# 题解","content":" 3.3.1 # 解答 # 结果如下：\nE AE |--E--| A S |--E--| A SY |--ES--| A Q Y |--ES--| A Q UY |--------S--------| |--E--| |--U--| A Q T Y |--------S--------| |--E--| |--U--| A IQ T Y |--------S--------| |--EO--| |--U--| A I Q T Y |--------S--------| |--EO--| |--U--| A IN Q T Y 代码 # 2-3 树的实现\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; // ReSharper disable CognitiveComplexity namespace BalancedSearchTree { /// \u0026lt;summary\u0026gt; /// 2-3 树。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TKey\u0026#34;\u0026gt;键。\u0026lt;/typeparam\u0026gt; /// \u0026lt;typeparam name=\u0026#34;TValue\u0026#34;\u0026gt;值。\u0026lt;/typeparam\u0026gt; public class TwoThreeBst\u0026lt;TKey, TValue\u0026gt; : IOrderedSt\u0026lt;TKey, TValue\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; { private int _count; private Node _root; /// \u0026lt;inheritdoc /\u0026gt; public void Put(TKey key, TValue value) { if (_root == null) { _root = new Node(null); _root.AddPair(key, value); return; } var (ends, current, _) = Get(null, _root, key); if (current != null) throw new InvalidOperationException($\u0026#34;The Key {key} has already been added\u0026#34;); ends.AddPair(key, value); _root = BalanceBottomUp(ends); _count++; } /// \u0026lt;inheritdoc /\u0026gt; public TValue Get(TKey key) { if (_root == null) return default; var (_, node, index) = Get(null, _root, key); if (node == null) return default; return node.Contents[index].Value; } /// \u0026lt;inheritdoc /\u0026gt; public void Delete(TKey key) { var (parent, node, index) = Get(null, _root, key); if (node == null) { throw new InvalidOperationException(\u0026#34;trying to delete a key not exists\u0026#34;); } var pairToRemove = node.Contents[index]; if (node.IsLeaf()) { if (parent == null) { // root node node.Contents.Remove(pairToRemove); if (node.Contents.Count == 0) { _root = null; } _count--; return; } if (node.Degree == 2) { // node is 2-node, make it 3 or 4 // find sibling Node sibling; if (node == parent.Left) { sibling = parent.Children[1]; } else if (node == parent.Right) { sibling = parent.Children[^2]; } else { sibling = parent.Left.Degree \u0026gt; parent.Right.Degree ? parent.Left : parent.Right; } if (sibling.Degree == 2) { node = Merge(node, sibling); } else { node = Redistribution(node, sibling); } } // now node is not 2-node, direct remove node.Contents.Remove(pairToRemove); // all children is null, just delete last one node.Children.RemoveAt(node.Degree - 1); _count--; return; } var min = Min(node.Right); var t = node.Contents[index]; node.Contents[index] = min.Contents[0]; min.Contents[0] = t; node.Right = DeleteMin(node.Right); _count--; } /// \u0026lt;inheritdoc /\u0026gt; public bool Contains(TKey key) { return Get(null, _root, key).Node != null; } /// \u0026lt;inheritdoc /\u0026gt; public bool IsEmpty() { return _root == null; } /// \u0026lt;inheritdoc /\u0026gt; public int Size() { return _count; } private int Size(Node x) { if (x == null) { return 0; } if (x.Degree == 2) { return 1 + Size(x.Left) + Size(x.Right); } return 2 + Size(x.Left) + Size(x.Middle) + Size(x.Right); } /// \u0026lt;inheritdoc /\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys() { if (IsEmpty()) { return new List\u0026lt;TKey\u0026gt;(); } return Keys(Min(), Max()); } /// \u0026lt;inheritdoc /\u0026gt; public int Size(TKey lo, TKey hi) { if (lo == null) { throw new ArgumentNullException(nameof(lo), \u0026#34;first argument to Size() is null\u0026#34;); } if (hi == null) { throw new ArgumentNullException(nameof(hi), \u0026#34;second argument to Size() is null\u0026#34;); } if (lo.CompareTo(hi) \u0026gt; 0) { return 0; } if (Contains(hi)) { return Rank(hi) - Rank(lo) + 1; } return Rank(hi) - Rank(lo); } /// \u0026lt;inheritdoc /\u0026gt; public IEnumerable\u0026lt;TKey\u0026gt; Keys(TKey lo, TKey hi) { if (lo == null) { throw new ArgumentNullException(nameof(lo), \u0026#34;first argument to Keys() is null\u0026#34;); } if (hi == null) { throw new ArgumentNullException(nameof(hi), \u0026#34;second argument to Keys() is null\u0026#34;); } var queue = new Queue\u0026lt;TKey\u0026gt;(); Keys(_root, queue, lo, hi); return queue; } private void Keys(Node x, Queue\u0026lt;TKey\u0026gt; queue, TKey lo, TKey hi) { if (x == null) { return; } var cmpLo = lo.CompareTo(x.Contents[0].Key); var cmpHi = hi.CompareTo(x.Contents[0].Key); if (cmpLo \u0026lt; 0) { Keys(x.Left, queue, lo, hi); } if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) { queue.Enqueue(x.Contents[0].Key); } if (cmpHi \u0026gt; 0) { Keys(x.Children[1], queue, lo, hi); } // 3-node extra if (x.Children.Count == 3) { cmpLo = lo.CompareTo(x.Contents[1].Key); cmpHi = hi.CompareTo(x.Contents[1].Key); if (cmpLo \u0026lt; 0) { Keys(x.Middle, queue, lo, hi); } if (cmpLo \u0026lt;= 0 \u0026amp;\u0026amp; cmpHi \u0026gt;= 0) { queue.Enqueue(x.Contents[1].Key); } if (cmpHi \u0026gt; 0) { Keys(x.Right, queue, lo, hi); } } } /// \u0026lt;inheritdoc /\u0026gt; public TKey Min() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } return Min(_root).Contents[0].Key; } private Node Min(Node h) { if (h.Left == null) { return h; } return Min(h.Left); } /// \u0026lt;inheritdoc /\u0026gt; public TKey Max() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } return Max(_root).Contents[^1].Key; } private Node Max(Node h) { if (h.Right == null) { return h; } return Max(h.Right); } /// \u0026lt;inheritdoc /\u0026gt; public TKey Floor(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Floor() is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls Floor() with empty symbol table\u0026#34;); } var x = Floor(_root, key); if (x == null) { throw new InvalidOperationException(\u0026#34;argument to Floor() is too small\u0026#34;); } return x.Contents[0].Key; } private Node Floor(Node x, TKey key) { if (x == null) { return null; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { return Floor(x.Left, key); } if (x.Degree == 3) { cmp = key.CompareTo(x.Contents[1].Key); if (cmp == 0) { return x; } if (cmp \u0026lt; 0) { return Floor(x.Middle, key); } } var t = Floor(x.Right, key); if (t != null) { return t; } return x; } /// \u0026lt;inheritdoc /\u0026gt; public TKey Ceiling(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Ceiling() is null\u0026#34;); } if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;calls Ceiling with empty symbol table\u0026#34;); } var x = Ceiling(_root, key); if (x == null) { throw new InvalidOperationException(\u0026#34;argument to Ceiling is too small\u0026#34;); } return x.Contents[^1].Key; } private Node Ceiling(Node x, TKey key) { if (x == null) { return null; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp == 0) { return x; } if (cmp \u0026gt; 0) { return Ceiling(x.Right, key); } if (x.Degree == 3) { cmp = key.CompareTo(x.Contents[1].Key); if (cmp == 0) { return x; } if (cmp \u0026gt; 0) { return Ceiling(x.Right, key); } } var t = Ceiling(x.Left, key); if (t != null) { return t; } return x; } /// \u0026lt;inheritdoc /\u0026gt; public int Rank(TKey key) { if (key == null) { throw new ArgumentNullException(nameof(key), \u0026#34;argument to Rank() is null\u0026#34;); } return Rank(_root, key); } private int Rank(Node x, TKey key) { if (x == null) { return 0; } var cmp = key.CompareTo(x.Contents[0].Key); if (cmp \u0026lt; 0) { return Rank(x.Left, key); } if (cmp \u0026gt; 0) { if (x.Degree == 2) { return 1 + Size(x.Left) + Rank(x.Right, key); } cmp = key.CompareTo(x.Contents[1].Key); if (cmp \u0026lt; 0) { return 1 + Size(x.Left) + Rank(x.Right, key); } if (cmp \u0026gt; 0) { return 1 + Size(x.Left) + Size(x.Middle) + Rank(x.Right, key); } return Size(x.Left) + Size(x.Middle); } return Size(x.Left); } /// \u0026lt;inheritdoc /\u0026gt; public TKey Select(int k) { if (k \u0026lt; 0 || k \u0026gt;= Size()) { throw new ArgumentOutOfRangeException(nameof(k), \u0026#34;argument to Select() is invalid \u0026#34; + k); } return Select(_root, k); } private TKey Select(Node x, int rank) { if (x == null) { return default; } var leftSize = Size(x.Left); if (leftSize \u0026gt; rank) { return Select(x.Left, rank); } if (leftSize \u0026lt; rank) { if (x.Degree == 3) { leftSize += Size(x.Middle); if (leftSize \u0026gt; rank) { return Select(x.Middle, rank - leftSize - 1); } if (leftSize == rank) { return x.Contents[1].Key; } } return Select(x.Right, rank - leftSize - 1); } return x.Contents[0].Key; } /// \u0026lt;inheritdoc /\u0026gt; public void DeleteMin() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST underflow\u0026#34;); } _root = DeleteMin(_root); } private Node DeleteMin(Node x) { if (x.Left == null) { // remove left key x.Contents.RemoveAt(0); x.Children.RemoveAt(0); return BalanceBottomUp(x); } if (x.Left.Degree != 2) { // left child is not 2-node, do nothing and turn left return DeleteMin(x.Left); } if (x.Children[1].Degree \u0026gt; 2) { // sibling is not 2-node, borrow one key into left // get key from parent x.Left.AddPair(x.Contents[0]); // parent get key from sibling x.Contents.RemoveAt(0); x.Contents.Insert(0, x.Children[1].Contents[0]); // sibling delete min key x.Children[1].Contents.RemoveAt(0); // move sibling\u0026#39;s child to left\u0026#39;s child x.Left.Children.Add(x.Children[1].Left); x.Children[1].Children.RemoveAt(0); return DeleteMin(x.Left); } // sibling is 2-node, merge them into 3-node if (x.Degree == 2) { // current node and its children are all 2-node x.AddPair(x.Left.Contents[0]); x.AddPair(x.Right.Contents[0]); x.Left.Children.ForEach(c =\u0026gt; c.Parent = x); x.Right.Children.ForEach(c =\u0026gt; c.Parent = x); var t = x.Left; x.Left = t.Left; x.MiddleLeft = t.Right; t = x.Right; x.MiddleRight = t.Left; x.Right = t.Right; return DeleteMin(x); } x.Left.AddPair(x.Contents[0]); x.Contents.RemoveAt(0); x.Left.AddPair(x.Children[1].Contents[0]); x.Left.MiddleRight = x.Children[1].Left; x.Left.Right = x.Children[1].Right; x.Children.RemoveAt(1); return DeleteMin(x.Left); } /// \u0026lt;inheritdoc /\u0026gt; public void DeleteMax() { if (IsEmpty()) { throw new InvalidOperationException(\u0026#34;BST is empty\u0026#34;); } _root = DeleteMax(_root); } private Node DeleteMax(Node x) { if (x.Right == null) { // remove right key x.Contents.RemoveAt(x.Contents.Count - 1); x.Children.RemoveAt(x.Degree - 1); return BalanceBottomUp(x); } if (x.Right.Degree != 2) { // left child is not 2-node, do nothing and turn left return DeleteMax(x.Right); } if (x.Children[^2].Degree \u0026gt; 2) { // sibling is not 2-node, borrow one key into left // get key from parent x.Right.AddPair(x.Contents[^1]); // parent get key from sibling x.Contents.RemoveAt(x.Contents.Count - 1); x.Contents.Insert(x.Contents.Count - 1, x.Children[^2].Contents[^1]); // sibling delete max key x.Children[^2].Contents.RemoveAt(x.Children[^2].Contents.Count - 1); // move sibling\u0026#39;s child to right\u0026#39;s child x.Right.Children.Add(x.Children[^2].Right); x.Children[^2].Children.RemoveAt(x.Children[^2].Degree - 1); return DeleteMax(x.Right); } // sibling is 2-node, merge them into 3-node if (x.Degree == 2) { // current node and its children are all 2-node x.AddPair(x.Left.Contents[0]); x.AddPair(x.Right.Contents[0]); x.Left.Children.ForEach(c =\u0026gt; c.Parent = x); x.Right.Children.ForEach(c =\u0026gt; c.Parent = x); var t = x.Left; x.Left = t.Left; x.MiddleLeft = t.Right; t = x.Right; x.MiddleRight = t.Left; x.Right = t.Right; return DeleteMax(x); } x.Right.AddPair(x.Contents[^1]); x.Contents.RemoveAt(x.Contents.Count - 1); x.Right.AddPair(x.Children[^2].Contents[^1]); x.Left.MiddleRight = x.Children[^2].Left; x.Left.Right = x.Children[^2].Right; x.Children.RemoveAt(x.Degree - 2); return DeleteMax(x.Right); } public override string ToString() { if (IsEmpty()) { return string.Empty; } var maxDepth = Depth(_root); var layer = 0; var bottomLine = (int)Math.Pow(3, maxDepth) * 2; // BFS var lines = new List\u0026lt;string\u0026gt;(); var nowLayer = new Queue\u0026lt;Node\u0026gt;(); var nextLayer = new Queue\u0026lt;Node\u0026gt;(); nextLayer.Enqueue(_root); while (layer != maxDepth) { var sb = new StringBuilder(); var unitSize = bottomLine / (int)Math.Pow(3, layer); var temp = nowLayer; nowLayer = nextLayer; nextLayer = temp; while (nowLayer.Count != 0) { var x = nowLayer.Dequeue(); if (x != null) { nextLayer.Enqueue(x.Left); if (x.Degree == 3) nextLayer.Enqueue(x.Middle); else nextLayer.Enqueue(null); nextLayer.Enqueue(x.Right); } else { nextLayer.Enqueue(null); nextLayer.Enqueue(null); nextLayer.Enqueue(null); } if (x != null \u0026amp;\u0026amp; x.Left != null) { for (var i = 0; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34; \u0026#34;); sb.Append(\u0026#34;|\u0026#34;); for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34;-\u0026#34;); } else { for (var i = 0; i \u0026lt; unitSize / 3; i++) sb.Append(\u0026#34; \u0026#34;); } if (x == null) sb.Append(\u0026#34; \u0026#34;); else sb.Append(x.Contents.Aggregate(string.Empty, (s, n) =\u0026gt; s + n.Key)); if (x != null \u0026amp;\u0026amp; x.Right != null) { for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34;-\u0026#34;); sb.Append(\u0026#34;|\u0026#34;); for (var i = 1; i \u0026lt; unitSize / 6; i++) sb.Append(\u0026#34; \u0026#34;); } else { for (var i = 1; i \u0026lt; unitSize / 3; i++) sb.Append(\u0026#34; \u0026#34;); } } lines.Add(sb.ToString()); layer++; } // Trim var margin = int.MaxValue; foreach (var line in lines) { var firstNonWhite = 0; for (var i = 0; i \u0026lt; line.Length; i++) { if (line[i] == \u0026#39; \u0026#39;) continue; firstNonWhite = i; break; } margin = Math.Min(margin, firstNonWhite); } for (var i = 0; i \u0026lt; lines.Count; i++) { lines[i] = lines[i].Substring(margin); } var result = new StringBuilder(); foreach (var line in lines) { result.AppendLine(line); } return result.ToString(); } /// \u0026lt;summary\u0026gt; /// 获取 2-3 树的最大深度。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;二叉树的根结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;二叉树的最大深度。\u0026lt;/returns\u0026gt; private int Depth(Node x) { if (x == null) return 0; if (x.Degree == 2) return 1 + Math.Max(Depth(x.Left), Depth(x.Right)); return 1 + Math.Max(Depth(x.Left), Math.Max(Depth(x.Middle), Depth(x.Right))); } /// \u0026lt;summary\u0026gt; /// 自底向上对 2-3 树进行平衡。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static Node BalanceBottomUp(Node node) { if (node.Degree != 4) { // not 4-node return node.Parent == null ? node : BalanceBottomUp(node.Parent); } // break 4-node into 2 2-node var left = new Node(node.Parent); left.AddPair(node.Contents[0]); left.Left = node.Left; left.Right = node.MiddleLeft; var right = new Node(node.Parent); right.AddPair(node.Contents[2]); right.Left = node.MiddleRight; right.Right = node.Right; if (node.Parent == null) { // root is 4-node var root = new Node(null); root.AddPair(node.Contents[1]); root.Left = left; root.Right = right; left.Parent = root; right.Parent = root; return root; } node.Parent.AddPair(node.Contents[1]); if (node.Parent.Degree == 3) { // parent was 2-node if (node == node.Parent.Children[0]) { // 4-node is 2-node\u0026#39;s left child node.Parent.Left = left; node.Parent.Middle = right; } else { // 4-node is 2-node\u0026#39;s right child node.Parent.Middle = left; node.Parent.Right = right; } return BalanceBottomUp(node.Parent); } // parent was 3-node if (node == node.Parent.Children[0]) { // 4-node is 3-node\u0026#39;s left child node.Parent.Left = left; node.Parent.MiddleLeft = right; } else if (node == node.Parent.Children[1]) { // 4-node is 3-node\u0026#39;s middle child node.Parent.MiddleLeft = left; node.Parent.MiddleRight = right; } else { // 4-node is 3-node\u0026#39;s right child node.Parent.MiddleRight = left; node.Parent.Right = right; } return BalanceBottomUp(node.Parent); } /// \u0026lt;summary\u0026gt; /// 在 2-3 树中搜索 \u0026lt;paramref name=\u0026#34;key\u0026#34;/\u0026gt;。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;current\u0026#34;\u0026gt;当前结点\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;要搜索的键。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;父结点、当前结点和键的下标。\u0026lt;/returns\u0026gt; private static (Node Parent, Node Node, int Index) Get(Node parent, Node current, TKey key) { if (current == null) return (parent, null, -1); for (var i = 0; i \u0026lt; current.Contents.Count; i++) { var pair = current.Contents[i]; var cmp = key.CompareTo(pair.Key); if (cmp == 0) return (parent, current, i); if (cmp \u0026lt; 0) return Get(current, current.Children[i], key); } // larger to all keys, turn right return Get(current, current.Children[^1], key); } /// \u0026lt;summary\u0026gt; /// 将两个结点合并。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; private static Node Merge(Node x, Node y) { if (x.Degree != 2 || y.Degree != 2) { throw new InvalidOperationException(\u0026#34;x and y must all be 2-node to merge\u0026#34;); } if (x.Parent != y.Parent) { throw new InvalidOperationException(\u0026#34;two nodes must be siblings to perform merge\u0026#34;); } var parent = x.Parent; if (parent.Degree == 2) { parent.AddPair(x.Contents[0]); parent.AddPair(y.Contents[0]); parent.Left = x.Left; parent.MiddleLeft = x.Right; parent.MiddleRight = y.Left; parent.Right = y.Right; return parent; } if (x == parent.Left || y == parent.Left) { // merge middle to left x = parent.Left; y = parent.Middle; x.AddPair(parent.Contents[0]); x.AddPair(y.Contents[0]); x.MiddleRight = y.Left; x.Right = y.Right; parent.Contents.RemoveAt(0); parent.Children.Remove(y); return parent; } // merge middle to right x = parent.Middle; y = parent.Right; y.AddPair(parent.Contents[^1]); y.AddPair(x.Contents[0]); y.Left = x.Left; y.MiddleLeft = x.Right; parent.Contents.RemoveAt(parent.Contents.Count - 1); parent.Children.Remove(x); return parent; } /// \u0026lt;summary\u0026gt; /// 合并兄弟结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;node\u0026#34;\u0026gt;结点。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sibling\u0026#34;\u0026gt;\u0026lt;paramref name=\u0026#34;node\u0026#34;/\u0026gt; 的兄弟结点。\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;/exception\u0026gt; private static Node Redistribution(Node node, Node sibling) { if (node.Degree != 2 || sibling.Degree == 2) { throw new InvalidOperationException(\u0026#34;node must be 2-node and sibling must not be 2-node\u0026#34;); } if (node.Parent != sibling.Parent) { throw new InvalidOperationException(\u0026#34;two nodes must be siblings to perform merge\u0026#34;); } var parent = node.Parent; if (node == parent.Left) { // flow to left node.AddPair(parent.Contents[0]); node.Right = sibling.Left; parent.Contents[0] = sibling.Contents[0]; sibling.Contents.RemoveAt(0); sibling.Children.RemoveAt(0); } else if (node == parent.Right) { // flow to right node.AddPair(parent.Contents[^1]); node.Left = sibling.Right; parent.Contents[^1] = sibling.Contents[^1]; sibling.Contents.RemoveAt(sibling.Contents.Count - 1); sibling.Children.RemoveAt(sibling.Children.Count - 1); } else { // flow to middle if (sibling == parent.Left) { node.AddPair(parent.Contents[0]); parent.Contents[0] = sibling.Contents[^1]; node.Children[0] = sibling.Right; sibling.Contents.RemoveAt(sibling.Contents.Count - 1); sibling.Children.RemoveAt(sibling.Children.Count - 1); } else { node.AddPair(parent.Contents[^1]); parent.Contents[^1] = sibling.Contents[0]; node.Children[^1] = sibling.Left; sibling.Contents.RemoveAt(0); sibling.Children.RemoveAt(0); } } return node; } /// \u0026lt;summary\u0026gt; /// 2-3 树结点。 /// \u0026lt;/summary\u0026gt; private class Node { /// \u0026lt;summary\u0026gt; /// 构造一个空的 2-3 树结点，并设置父结点。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;parent\u0026#34;\u0026gt;父结点。\u0026lt;/param\u0026gt; public Node(Node parent) { Parent = parent; } /// \u0026lt;summary\u0026gt; /// 父结点。 /// \u0026lt;/summary\u0026gt; public Node Parent { get; set; } /// \u0026lt;summary\u0026gt; /// 结点保存的键值对。 /// \u0026lt;/summary\u0026gt; public List\u0026lt;Pair\u0026gt; Contents { get; } = new(); /// \u0026lt;summary\u0026gt; /// 结点的子结点。 /// \u0026lt;/summary\u0026gt; public List\u0026lt;Node\u0026gt; Children { get; } = new() { null }; /// \u0026lt;summary\u0026gt; /// 结点的度，例如 2-结点返回的就是 2。 /// \u0026lt;/summary\u0026gt; public int Degree =\u0026gt; Children.Count; /// \u0026lt;summary\u0026gt; /// 左子结点。 /// \u0026lt;/summary\u0026gt; public Node Left { get =\u0026gt; Children[0]; set { if (value != null) value.Parent = this; Children[0] = value; } } /// \u0026lt;summary\u0026gt; /// 第二个子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 是 4 时才可以访问这个属性。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 4。\u0026lt;/exception\u0026gt; public Node MiddleLeft { get =\u0026gt; Degree == 4 ? Children[1] : throw new InvalidOperationException(\u0026#34;only 4-node has middle left\u0026#34;); set { if (value != null) value.Parent = this; Children[1] = value; } } /// \u0026lt;summary\u0026gt; /// 位于中间的子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 为 3 时才可以访问这个属性。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 3。\u0026lt;/exception\u0026gt; public Node Middle { get =\u0026gt; Degree == 3 ? Children[1] : throw new InvalidOperationException(\u0026#34;only 3-node has middle\u0026#34;); set { if (value != null) value.Parent = this; Children[1] = value; } } /// \u0026lt;summary\u0026gt; /// 第三个子结点，只有当 \u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 是 4 时才可以访问这个属性。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;exception cref=\u0026#34;InvalidOperationException\u0026#34;\u0026gt;\u0026lt;see cref=\u0026#34;Degree\u0026#34;/\u0026gt; 不为 4。\u0026lt;/exception\u0026gt; public Node MiddleRight { get =\u0026gt; Degree == 4 ? Children[2] : throw new InvalidOperationException(\u0026#34;only 4-node has middle right\u0026#34;); set { if (value != null) value.Parent = this; Children[2] = value; } } /// \u0026lt;summary\u0026gt; /// 右子结点。 /// \u0026lt;/summary\u0026gt; public Node Right { // ^1 即最后一个，与 Children.Count - 1 等同。 get =\u0026gt; Children[^1]; set { if (value != null) value.Parent = this; Children[^1] = value; } } /// \u0026lt;summary\u0026gt; /// 向结点添加一个键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public void AddPair(TKey key, TValue value) { var pair = new Pair(key, value); AddPair(pair); } /// \u0026lt;summary\u0026gt; /// 向结点添加一个键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;pair\u0026#34;\u0026gt;键值对。\u0026lt;/param\u0026gt; public void AddPair(Pair pair) { for (var i = 0; i \u0026lt; Contents.Count; i++) { var cmp = pair.Key.CompareTo(Contents[i].Key); if (cmp \u0026lt; 0) { Contents.Insert(i, pair); Children.Insert(i + 1, null); return; } } Contents.Add(pair); Children.Add(null); } /// \u0026lt;summary\u0026gt; /// 结点是否为叶结点（没有子结点）。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool IsLeaf() { return Children.All(c =\u0026gt; c == null); } /// \u0026lt;summary\u0026gt; /// 拼接并输出结点的键。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return Contents.Aggregate(string.Empty, (s, k) =\u0026gt; s + k.Key); } } /// \u0026lt;summary\u0026gt; /// 键值对。 /// \u0026lt;/summary\u0026gt; private class Pair { /// \u0026lt;summary\u0026gt; /// 新建一个键值对。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;key\u0026#34;\u0026gt;键。\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;值。\u0026lt;/param\u0026gt; public Pair(TKey key, TValue value) { Key = key; Value = value; } /// \u0026lt;summary\u0026gt; /// 键。 /// \u0026lt;/summary\u0026gt; public TKey Key { get; } /// \u0026lt;summary\u0026gt; /// 值。 /// \u0026lt;/summary\u0026gt; public TValue Value { get; } } } } 另请参阅 # [BalancedSearchTree ](https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp/tree/master/3 Searching/3.3/BalancedSearchTree)\n"},{"id":442,"href":"/3-3-2/","title":"3.3.2","section":"《算法（第四版）》C# 题解","content":" 3.3.2 # 解答 # 和 3.3.1 类似，结果如下：\nY LY |--P--| L Y |--P--| LM Y |--P--| LM XY |--LP--| H M XY |--LP--| CH M XY |--------P--------| |--L--| |--X--| CH M R Y |--------P--------| |--CL--| |--X--| A H M R Y |--------P--------| |--CL--| |--X--| A EH M R Y |--------P--------| |--CL--| |--X--| A EH M RS Y 另请参阅 # BalancedSearchTree 库\n"},{"id":443,"href":"/3-3-3/","title":"3.3.3","section":"《算法（第四版）》C# 题解","content":" 3.3.3 # 解答 # 题目给出的序列就可以，如下（只有根结点的 2-3 树的高度是 0，以此类推）：\nS ES |--E--| A S |--E--| AC S |--E--| AC HS |--ES--| AC H X |--ES--| AC HM X SEACHXM 排序后是 ACEHMSX，符合条件的一种情况即为 AC 为左子结点，HM 为中间结点，X 为右侧结点，ES 为根节点。\n也可以是其他的模式，总共有 2880 种符合条件的组合（result.txt），共三种模式，结果如下：\n864 |--CM--| A EH SX 1152 |--EM--| AC H SX 864 |--ES--| AC HM X 可以观察到树的形状是没有变化的，只是键在各结点中的分布有些变化。\n代码 # using System; using System.IO; using BalancedSearchTree; var input = \u0026#34;ACEHMSX\u0026#34;; var output = File.CreateText(\u0026#34;result.txt\u0026#34;); var count = 0; Dig(input, string.Empty); Console.WriteLine(count); void Dig(string source, string testCase) { if (source.Length == 0) { var tree = new TwoThreeBst\u0026lt;char, int\u0026gt;(); foreach (var c in testCase) { tree.Put(c, 1); } if (tree.Height() == 1) { count++; output.WriteLine(testCase); output.WriteLine(tree.ToString()); output.WriteLine(); } } for (var i = 0; i \u0026lt; source.Length; i++) { Dig(source.Remove(i, 1), testCase + source[i]); } } 另请参阅 # BalancedSearchTree 库\n"},{"id":444,"href":"/3-3-4/","title":"3.3.4","section":"《算法（第四版）》C# 题解","content":" 3.3.4 # 解答 # 一棵高度为 $h$ 的完美二叉树有：$1 + 2 + 2^2 + \u0026hellip; + 2^{h}= 2^{h+1} - 1$ 个结点，反向得到 $N$ 个结点的完美二叉树高度为 $\\log_2{(N+1)} -1$。\n一棵高度为 $h$ 的完美三叉树有：$1+3+3^2+\u0026hellip;+3^h= \\frac{3^{h+1} - 1}{2}$ 个结点，反向得到 $N$ 个结点的完美三叉树高度为 $\\log_3{(2N+1) - 1}$。\n由于 2-3 树本身介于完美二叉树和完美三叉树之间，$N$ 个结点的 2-3 树高度就会介于 $N$ 个结点的完美二叉树和完美三叉树之间，即：$\\sim\\lfloor log_3N \\rfloor \\le h \\le \\sim\\lfloor log_2{N} \\rfloor$。\n另请参阅 # 完美二叉树, 完全二叉树和完满二叉树 - veli - 博客园 (cnblogs.com)\n"},{"id":445,"href":"/3-3-5/","title":"3.3.5","section":"《算法（第四版）》C# 题解","content":" 3.3.5 # 解答 # 注：英文版原文使用的是 “ignore the order of the subtrees”，也就是忽略子树的顺序。\n我们将 N=6 时的树形简记为 [{3}, {2, 2, 3}]，代表根结点是一个 3-结点，第二层有两个 2-结点和一个 3-结点。\n一个 N=6 的示例：\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39; |--GO--| D K SY 考虑插入元素的两种效用，一种是使 2-结点变成 3-结点（当前结点或者它的父结点）；另一种是使树高增加，被插入元素的 3-结点（及其父 3-结点）变回 2-结点。这两种操作的顺序不影响最后的树形。\n于是 N=7 时，我们有两种树形。\n[{3}, {2, 3, 3}]（插入到某个 2-结点）。\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;L\u0026#39; // before |--GO--| D K SY // after |--GO--| D KL SY [{2}, {2, 2}, {2, 2, 2, 2}]（插入到 3-结点，变成满二叉树）。\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39; // before |--GO--| D K SY // after |--------O--------| |--G--| |--S--| D K Q Y N=8，对于 N=7 时的第一种树形，如果向 3-结点插入，会触发树高增加，结果相当于向第二种满二叉树底层 2-结点中的某一个插入元素后的树形。向第一种树形的 2-结点插入则会变成一个全部由 3-结点构成的 2-3 树。\n注：可以把这里插入到 2-结点的操作看作是插入到 3-结点的一种“拖延”，它只是延后了树高增加的变换，但对最后的树形没有影响。\n[{3}, {3, 3, 3}]（插入到唯一的 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39; // before |--GO--| D KL SY // after |--GO--| AD KL SY [{2}, {2, 2}, {2, 2, 2, 3}]（插入到满二叉树底部任意一个 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Z\u0026#39; // before |--------O--------| |--G--| |--S--| D K Q Y // after |--------O--------| |--G--| |--S--| D K Q YZ N=9，和 N=8 时类似，对于 N=8 时的第一种树形，插入底层任意一个 3-结点都会触发平衡，等同于满二叉树底部两个 2-结点各插入一个元素的树形。考虑第二种树形最底层各结点插入元素后的树形即可。\n[{2}, {2, 2}, {2, 2, 3, 3}]（插入到 3-结点同侧 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39; // before |--GO--| AD KL SY // after |--------G--------| |--C--| |--O--| A D KL SY [{2}, {2, 2}, {2, 3, 2, 3}] （插入到 3-结点对侧 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;J\u0026#39; // before |--GO--| AD KL SY // after |--------K--------| |--G--| |--O--| AD J L SY [{2}, {2, 3}, {2, 2, 2, 2, 2}]（插入到 3-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;X\u0026#39; // before |--------O--------| |--G--| |--S--| D K Q YZ // after |--------O--------| |--G--| |--SY--| D K Q X Z N=10\n[{2}, {2, 2}, {2, 3, 3, 3}] （插入到 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39; // before |--------G--------| |--C--| |--O--| A D KL SY // after |--------G--------| |--C--| |--O--| AB D KL SY [{2}, {2, 3}, {2, 2, 2, 2, 3}]（插入到 3-结点下的 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;P\u0026#39; // before |--------O--------| |--G--| |--SY--| D K Q X Z // after |--------O--------| |--G--| |--SY--| D K PQ X Z [{2}, {2, 3}, {2, 3, 2, 2, 2}]（插入到 2-结点下的 2-结点）\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;J\u0026#39; // before |--------O--------| |--G--| |--SY--| D K Q X Z // after |--------O--------| |--G--| |--SY--| D JK Q X Z "},{"id":446,"href":"/3-3-6/","title":"3.3.6","section":"《算法（第四版）》C# 题解","content":" 3.3.6 # 解答 # 由 3.3.5 可知，$N=6$ 时的树形只有一种。\n因此我们只需要将 $N=6$ 记为概率 1，利用乘法原理（或者说分步计数）计算之后的概率即可。\n$N=6$ 的树形，底部共有 7 个位置可以插入：\n// \u0026#39;D\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;Y\u0026#39; |--GO--| D K SY $N=7$ # 如果向 2-结点插入（示例中的 D 或 K），每个 2-结点有两个子树，概率均等，概率 $2/7 \\times 2 = 4/7$，可以得到以下树形（记为 7-1）：\n// after |--GO--| D KL SY 如果向 3-结点插入（3-结点有三个子树，概率均等，概率 $3/7$），可以得到以下树形（记为 7-2）：\n|--------O--------| |--G--| |--S--| D K Q Y $N=8$ # 向 7-1 的唯一一个 2-结点插入（示例中的 D），概率 $4/7 \\times 2/8= 1/7$，可以得到以下树形（记为 8-1）：\n|--GO--| AD KL SY 向 7-1 的 3-结点插入（示例中的 KL 或 SY），或者向 7-2 的任意一个 2-结点插入，概率 $4/7 \\times 6/8 + 3/7 = 6/7$，可以得到以下树形（记为 8-2）：\n|--------O--------| |--G--| |--S--| D K Q YZ $N=9$ # 向 8-1 的最左或最右侧 3-结点插入（示例中的 AD 或 SY），或者向 8-2 底部 3-结点的兄弟 2-结点插入（示例中的 Q），概率 $1/7 \\times 6/9 + 6/7 \\times 2/9 = 2/7$，可以得到以下树形（记为 9-1）：\n|--------G--------| |--C--| |--O--| A D KL SY 向 8-1 的中间结点插入（示例中的 KL），或者向 8-2 底部左右子树均为 2-结点的子结点插入（示例中的 D 或 K），概率 $1/7 \\times 3/9 + 6/7 \\times 4/9 = 3/7$，得到以下树形（记为 9-2）：\n|--------K--------| |--G--| |--O--| AD J L SY 向 8-2 底部唯一的 3-结点插入（示例中的 YZ），概率 $6/7 \\times 3/9 = 2/7$，得到以下树形（记为 9-3）：\n|--------O--------| |--G--| |--SY--| D K Q X Z $N=10$ # 向 9-1 的 2-结点插入（示例中的 A 或 D），或向 9-2 的 2-结点插入（示例中的 J 或 L），概率 $2/7 \\times 4/10 + 3/7 \\times 4/10 = 2/7$\n|--------G--------| |--C--| |--O--| AB D KL SY 向 9-1 底部任意 3-结点插入（示例中的 KL 或 SY），或向 9-3 中 3-结点的子结点插入（示例中的 Q 或 X 或 Z），概率 $2/7 \\times 6/10 + 2/7 \\times 6/10 = 12/35$。\n|--------O--------| |--G--| |--SY--| D K PQ X Z 向 9-2 底部任意 3-结点插入（示例中的 AD 或 SY），或向 9-3 中 2-结点的子结点插入（示例中的 D 或 K），概率 $3/7 \\times 6/10 + 2/7 \\times 4/10 = 13/35$\n|--------O--------| |--G--| |--SY--| D JK Q X Z "},{"id":447,"href":"/3-3-7/","title":"3.3.7","section":"《算法（第四版）》C# 题解","content":" 3.3.7 # 解答 # 根结点 # 父结点是 2-结点时 # 在左侧插入 # 在右侧插入 # 父结点是 3-结点时 # 在左侧插入 # 在右侧插入 # 在中间插入 # 见书本中文版图 3.3.9，或英文版 P428 插图。\n"},{"id":448,"href":"/3-3-8/","title":"3.3.8","section":"《算法（第四版）》C# 题解","content":" 3.3.8 # 解答 # 考虑在一棵表示 3-结点的红黑树中插入元素且不进行平衡操作的所有情况即可。\n这个示意图位于中文版图 3.3.20，英文版 P436 插图 Insert into a single 3-node (three cases)\n顺序插入（C-\u0026gt;B-\u0026gt;A 或 A-\u0026gt;B-\u0026gt;C） # 先中间，再两边（B-\u0026gt;A-\u0026gt;C 或 B-\u0026gt;C-\u0026gt;A） # 先两边，再中间（C-\u0026gt;A-\u0026gt;B 或 A-\u0026gt;C-\u0026gt;B） # "},{"id":449,"href":"/3-3-9/","title":"3.3.9","section":"《算法（第四版）》C# 题解","content":" 3.3.8 # 解答 # 官网有答案：https://algs4.cs.princeton.edu/33balanced/\niii 和 iv 是红黑树，i 不平衡，ii 不平衡且 F 不属于 D 和 E 之间的元素。\n"},{"id":450,"href":"/3-3-10/","title":"3.3.10","section":"《算法（第四版）》C# 题解","content":" 3.3.10 # 解答 # 按照题意插入即可，以下是步骤图，红链接会显示为红色。\n"},{"id":451,"href":"/3-3-11/","title":"3.3.11","section":"《算法（第四版）》C# 题解","content":" 3.3.11 # 解答 # 与上题类似，依次插入元素即可。\n"},{"id":452,"href":"/3-3-12/","title":"3.3.12","section":"《算法（第四版）》C# 题解","content":" 3.3.12 # 解答 # 插入 P 时的步骤如图所示，用例是 S E A R C H E X A M P L E，在 3.1 章的 3.1.3 节可以找到它。\n"},{"id":453,"href":"/3-3-13/","title":"3.3.13","section":"《算法（第四版）》C# 题解","content":" 3.3.13 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/#:~:text=True%20or%20false%3A%20If%20you%20insert%20keys%20in%20increasing%20order%20into%20a%20red%2Dblack%20BST%2C%20the%20tree%20height%20is%20monotonically%20increasing\n是真的。\n现在考虑在哪些情况下，红黑树插入元素后高度会变小。\n根据红黑树与 2-3 树的对应，红链接其实就是把 2-3 树的 3-结点中的左侧元素变为左子树，并把这个左链接标记为红色。\n那么对于一棵 2-3 树，3-结点对应的到红黑树中是带左侧结点的子树，高度会比同位置的 2-结点多 1。\n现在把 2-3 树中的 2-结点记为 1，3-结点记为 2，数字最大的路径即为决定对应红黑树高度的路径。\n那么只要插入操作后，该路径上的数字和反而减小，对应红黑树的高度不可能变大，只有可能减小或不变。（不变的原因和红黑树的性质有关，见之后的说明）\n现在考虑 2-3 树插入的情况。\n插入到 2-结点 -\u0026gt; 变为 3-结点，最大数字和增加。\n插入到 3-结点 -\u0026gt; 自身变为 2-结点，向上传递 1 个元素\n显然插入到 2-结点不可能减小高度，我们来考虑 3-结点向上传递的情况。\n父结点是 2-结点 -\u0026gt; 父结点变为 3-结点，总数字和不变，红黑树高度不变。\n父结点是 3-结点 -\u0026gt; 父结点变为 2-结点，向上传递一个元素。\n不难发现当路径上有连续两个 3-结点时，插入操作最后会有两种情况：\n停止在父级的某一个 2-结点。这时两个 3-结点变成了 2-结点（-2），一个 2-结点变成了 3-结点（+1），数字和减少 1 整棵 2-3 树的高度增加。这时两个 3-结点变成了 2-结点（-2），整条路径多了 1 个 2-结点（+1），数字和减少 1。 因此只有当该路径上最后两个元素都是 3-结点时，插入后的数字和必然减少，如果没有其他路径上的数字和比它更大，整个 2-3 树的最大数字和就会减小。\n现在我们需要考虑定义的红黑树性质，只有 左链接 是红链接。\n因此如果往一个 3-结点的右侧插入，对应红黑树的高度是不会变化的，只是左侧红链接变为黑色。\n本题中元素是递增插入的，也就是一直向 2-3 树最右侧叶子结点的右侧插入，因此对应红黑树高度只会增加或不变。因此这种情况下红黑树高度是单调递增的。\n"},{"id":454,"href":"/3-3-14/","title":"3.3.14","section":"《算法（第四版）》C# 题解","content":" 3.3.14 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/#:~:text=True%20or%20false%3A%20If%20you%20insert%20keys%20in%20increasing%20order%20into%20a%20red%2Dblack%20BST%2C%20the%20tree%20height%20is%20monotonically%20increasing\n红黑树的构造过程，|| 代表红链接。\n递增顺序插入等价于一直向 2-3 树最右侧叶子结点的右侧插入元素，对应红黑树的高度是单调递增的，具体说明见上一题的解答。\nA ||-B A |-B-| A C |---B---| A ||-D C ||---D---| |-B-| E A C ||---D---| |-B-| ||-F A C E |---D---| |-B-| |-F-| A C E G |-------D-------| |---B---| |---F---| A C E ||-H G |-------D-------| |---B---| ||---H---| A C |-F-| I E G |-------D-------| |---B---| ||---H---| A C |-F-| ||-J E G I ||-------H-------| |---D---| |---J---| |-B-| |-F-| I K A C E G "},{"id":455,"href":"/3-3-15/","title":"3.3.15","section":"《算法（第四版）》C# 题解","content":" 3.3.15 # 解答 # 官网有解答：https://algs4.cs.princeton.edu/33balanced/\n红黑树的构造过程，|| 代表红链接。\n递减顺序插入等价于一直向 2-3 树最左侧叶子结点的左侧插入元素，对应红黑树的高度不一定是单调递增的（本例中插入 E 的时候红黑树高度反而减小了），具体说明见 3.3.13 的解答。\nK ||-K J |-J-| I K |---J---| ||-I K H ||---J---| |-H-| K G I ||-------J-------| |---H---| K ||-G I F |---H---| |-F-| |-J-| E G I K |-------H-------| |---F---| |---J---| ||-E G I K D |-------H-------| ||---F---| |---J---| |-D-| G I K C E |---------------H---------------| ||-------F-------| |-------J-------| |---D---| G I K ||-C E B ||-------H-------| |---D---| |---J---| |-B-| |-F-| I K A C E G "},{"id":456,"href":"/3-3-16/","title":"3.3.16","section":"《算法（第四版）》C# 题解","content":" 3.3.16 # 解答 # 这棵红黑树看起来就像这样（||代表红链接）。\n||---------------------------------------------------------------t---------------------------------------------------------------| j-------------------------------| u |---------------r---------------| |-------p-------| s |---l---| q k |-n-| m o "},{"id":457,"href":"/run-solution-code/","title":"如何：运行题解代码","section":"《算法（第四版）》C# 题解","content":"本文将介绍如何下载题解项目并运行代码。 在开始之前，请确保你的电脑上已经安装了 Visual Studio 2015（及以上版本）并启用了 .NET Framework 4.7。 下载 Visual Studio：https://visualstudio.microsoft.com/zh-hans/downloads/\n下载全部代码 # 点击这个链接，下载 GitHub Extension 并安装。 点击本页底部的 GitHub 图标，进入题解源代码页。 点击右上角的「Clone or Download」，选择「Open in Visual Studio」。 随后 Visual Studio 会自动打开（如果提示是否允许切换应用，请选择允许）。 确保「以递归方式克隆子模块」被选中，点击「克隆」。 耐心等待克隆完毕，视网络情况，可能需要几分钟到十几分钟不等。 在解决方案资源管理器中，双击解决方案「Algorithms 4th Edition.sln」。 右键需要运行的项目，选择「设为启动项目」。 按快捷键「Ctrl」+「F5」运行代码。 下载部分代码 # 控制台应用程序 # 打开 Visual Studio，选择「文件」-「新建」-「项目」，或按「Ctrl」+「Shift」+「N」打开「新建项目」对话框。 在模板中选择「Visual C#」-「Windows 桌面」-「控制台应用」，输入项目名称和位置，点击「确定」。 这里以题 1.3.26 为例，点击本页底部的 GitHub 图标，进入题解源代码页。 依次选择文件夹「1-Fundamental」-「1.3」-「1.3.26」，找到所有后缀为 .cs 的文件。 点击「Program.cs」，随后右键点击「Raw」，选择「目标另存为」，下载代码文件。 依次对所有其他的 .cs 文件做相同操作，下载全部的代码文件。 在解决方案资源管理器中，右键点击项目名称（一般位于解决方案名称的下方），选择「在文件资源管理器中打开文件夹」。 将所有的代码文件复制到该目录下，如果存在重复则直接覆盖。 这时 Visual Studio 可能会提示文件被更改，选择「重新加载」即可。 再次右击项目名称，选择「添加」-「现有项」，或按快捷键「Shift」+「Alt」+「A」，在弹出的窗口中选择刚才复制的所有 .cs 文件。 此时，一些不需要依赖库的题目已经可运行，按快捷键「Ctrl」+「F5」即可运行代码，如果 Visual Studio 提示缺少指令集引用，请通过下面的步骤添加类库。 定位到开头的 using 指令部分，缺失的库文件会被红线标出。 右击解决方案资源管理器中的解决方案名称（一般在最上方），选择「添加」-「新建项目」。 在弹出的「新建项目」对话框中选择「Visual C#」-「Windows 桌面」-「类库」模板，项目名称与缺失的库名称相同。 接下来回到第 3 步中打开的网站，找到缺失的库，在本例中，依次点击「1-Fundamental」-「1.3」-「Generics」，利用第 5 步中的方法下载所有 .cs 文件。 回到 Visual Studio 中，在解决方案资源管理器中右键点击刚才新建的库名称（这里是 Generics），用第 10 步中的方法添加刚才下载的所有 .cs 文件。 右键点击题目项目中的「引用」，选择「添加引用」。 在弹出的「引用管理器」对话框中，勾选刚才新建的库项目，点击「确定」。 现在题目应该可运行，右键题目项目，选择「设为启动项目」，然后按快捷键「Ctrl」+「F5」运行。 Windows 窗体应用程序 # 打开 Visual Studio，选择「文件」-「新建」-「项目」，或按「Ctrl」+「Shift」+「N」打开「新建项目」对话框。 在模板中选择「Visual C#」-「Windows 桌面」-「Windows 窗体应用（.NET Framework）」，输入项目名称和位置，点击「确定」。 这里以题 1.1.31 为例，点击本页底部的 GitHub 图标，进入题解源代码页。 依次选择文件夹「1-Fundamental」-「1.1」-「1.1.31」，找到所有后缀为 .cs 和 .resx 的文件。 点击「Program.cs」，随后右键点击「Raw」，选择「目标另存为」，下载代码文件。 依次对所有其他的 .cs 以及 .resx 文件做相同操作，下载全部的代码文件。 在解决方案资源管理器中，右键点击项目名称（一般位于解决方案名称的下方），选择「在文件资源管理器中打开文件夹」。 将所有的代码文件复制到该目录下，如果存在重复则直接覆盖。 这时 Visual Studio 可能会提示文件被更改，选择「重新加载」即可。 再次右击项目名称，选择「添加」-「现有项」，或按快捷键「Shift」+「Alt」+「A」，在弹出的窗口中选择刚才复制的所有 .cs 文件（不用选择 .resx 文件，Visual Studio 会自动扫描添加）。 此时，一些不需要依赖库的题目已经可运行，按快捷键「Ctrl」+「F5」即可运行代码，如果 Visual Studio 提示缺少指令集引用，请参阅「控制台应用程序」中的第 12 步至第 19 步。 "}]