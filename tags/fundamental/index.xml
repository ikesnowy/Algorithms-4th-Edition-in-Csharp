<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fundamental on 《算法（第四版）》C# 题解</title><link>https://alg4.ikesnowy.com/tags/fundamental/</link><description>Recent content in Fundamental on 《算法（第四版）》C# 题解</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 28 Jun 2018 13:50:42 +0000</lastBuildDate><atom:link href="https://alg4.ikesnowy.com/tags/fundamental/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1.1</title><link>https://alg4.ikesnowy.com/1-1-1/</link><pubDate>Mon, 14 May 2018 19:01:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-1/</guid><description>1.1.1 # 解答 # a.7
b.200.0000002
c.True
代码 # var a = (0 + 15) / 2; var b = 2.0e-6 * 100000000.1; var c = true &amp;amp;&amp;amp; false || true &amp;amp;&amp;amp; true; // Console.WriteLine 向控制台窗口输出一行 Console.WriteLine($&amp;#34;a.{a}&amp;#34;); Console.WriteLine($&amp;#34;b.{b}&amp;#34;); Console.WriteLine($&amp;#34;c.{c}&amp;#34;);</description></item><item><title>1.1.2</title><link>https://alg4.ikesnowy.com/1-1-2/</link><pubDate>Mon, 14 May 2018 19:21:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-2/</guid><description>1.1.2 # 解答 # Name Type Value a System.Double 1.618 b System.Double 10 c System.Boolean True d System.String 33 代码 # // var 变量名 = 初始值 根据初始值自动判断变量类型 var a = (1 + 2.236) / 2; var b = 1 + 2 + 3 + 4.0; var c = 4.1 &amp;gt;= 4; var d = 1 + 2 + &amp;#34;3&amp;#34;; // Console.</description></item><item><title>1.1.3</title><link>https://alg4.ikesnowy.com/1-1-3/</link><pubDate>Mon, 14 May 2018 19:33:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-3/</guid><description>1.1.3 # 解答 # 简单的 if 判断即可。
代码 # /* * 输入 * * 用空格隔开的三个整数，例如 * 3 3 3 * * 输出 * * equal 或 not equal */ var input = Console.ReadLine(); var a = int.Parse(input.Split(&amp;#39; &amp;#39;)[0]); var b = int.Parse(input.Split(&amp;#39; &amp;#39;)[1]); var c = int.Parse(input.Split(&amp;#39; &amp;#39;)[2]); if (a == b &amp;amp;&amp;amp; b == c) { Console.WriteLine(&amp;#34;equal&amp;#34;); } else { Console.WriteLine(&amp;#34;not equal&amp;#34;); }</description></item><item><title>1.1.4</title><link>https://alg4.ikesnowy.com/1-1-4/</link><pubDate>Mon, 14 May 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-4/</guid><description>1.1.4 # 解答 # a. if 后跟 then 的语法不能在 C# 中使用。
b. if 后的判断语句需要在括号内。
c. 正确，只有一条语句时大括号可以省略。
d. c = 0 后缺少分号。
代码 # var a = 1; var b = 2; var c = 0; // if (a &amp;gt; b) then c = 0; // if 后不能跟 then // if a &amp;gt; b { c = 0; } // if后必须跟括号 if (a &amp;gt; b) c = 0; // 正确 // if (a &amp;gt; b) c = 0 else b = 0; // c = 0后缺少分号</description></item><item><title>1.1.5</title><link>https://alg4.ikesnowy.com/1-1-5/</link><pubDate>Mon, 14 May 2018 19:37:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-5/</guid><description>1.1.5 # 解答 # 比较简单，直接判断即可。
代码 # // 修改这两个值进行测试 var x = 0.05; var y = 0.01; if (x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 1 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 1) { Console.WriteLine(&amp;#34;true&amp;#34;); } else { Console.WriteLine(&amp;#34;false&amp;#34;); }</description></item><item><title>1.1.6</title><link>https://alg4.ikesnowy.com/1-1-6/</link><pubDate>Mon, 14 May 2018 19:39:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-6/</guid><description>1.1.6 # 解答 # 输出斐波那契数列。
将书中的代码直接实现即可。
代码 # //输出斐波那契数列 var f = 0; var g = 1; for (var i = 0; i &amp;lt;= 15; i++) { Console.WriteLine(f); f = f + g; g = f - g; }</description></item><item><title>1.1.7</title><link>https://alg4.ikesnowy.com/1-1-7/</link><pubDate>Mon, 14 May 2018 19:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-7/</guid><description>1.1.7 # 解答 # 同上题，直接实现即可。
a
3.00009
double计算存在误差，并不精确。
b
499500
1000 + 999 + 998……
c
10000
1000 * 10，外层循环的结束条件为 $2^i &amp;gt;1000$
代码 # static void A() { Console.WriteLine(&amp;#34;a&amp;#34;); var t = 9.0; while (Math.Abs(t - 9.0 / t) &amp;gt; .001) { t = (9.0 / t + t) / 2.0; } Console.WriteLine($&amp;#34;{t:N5}&amp;#34;); // :N5代表保留5位小数，同理可使用N1、N2…… } static void B() { Console.</description></item><item><title>1.1.8</title><link>https://alg4.ikesnowy.com/1-1-8/</link><pubDate>Mon, 14 May 2018 20:00:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-8/</guid><description>1.1.8 # 解答 # b
197
e
代码 # Console.WriteLine(&amp;#39;b&amp;#39;); Console.WriteLine(&amp;#39;b&amp;#39; + &amp;#39;c&amp;#39;); // char 被隐式转为为 int 类型，取 ascii 码 Console.WriteLine((char)(&amp;#39;a&amp;#39; + 4)); // 强制转换后，ascii 码被转换为相应的字符</description></item><item><title>1.1.9</title><link>https://alg4.ikesnowy.com/1-1-9/</link><pubDate>Mon, 14 May 2018 20:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-9/</guid><description>1.1.9 # 解答 # 有两种方法，要么直接调用库函数，要么用书中给出的代码转换。
代码 # var n = 4; // 1.直接转换 Convert.ToString(int, int) 第一个为要转换的数，第二个为要转换的进制 Console.WriteLine($&amp;#34;{Convert.ToString(n, 2)}&amp;#34;); // 2.转换为二进制数 var s = &amp;#34;&amp;#34;; for (var i = n; i &amp;gt; 0; i /= 2) { s = (i % 2) + s; } Console.WriteLine(s);</description></item><item><title>1.1.10</title><link>https://alg4.ikesnowy.com/1-1-10/</link><pubDate>Mon, 14 May 2018 20:05:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-10/</guid><description>1.1.10 # 解答 # 变量使用前需要先赋值。
代码 # int[] a; for (var i = 0; i &amp;lt; 10; i++) { // a[i] = i * i; // 不允许使用未赋值的局部变量 } a = new int[10]; for (var i = 0; i &amp;lt; 10; i++) { a[i] = i * i; // 初始化后可用 }</description></item><item><title>1.1.11</title><link>https://alg4.ikesnowy.com/1-1-11/</link><pubDate>Mon, 14 May 2018 20:31:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-11/</guid><description>1.1.11 # 解答 # 注意，二维数组 bool[M, N] 代表 M 行 N 列的布尔数组。
使用二重循环即可实现。
输出使用制表符 ’\t’ 作为分隔。
代码 # var array = new[,] { { true, true }, { false, false }, { true, false } }; PrintArray2D(array); // 打印二维数组 static void PrintArray2D(bool[,] array) { var rows = array.GetLength(0); // 获取行数 var columns = array.GetLength(1); // 获取列数 //输出列号 for (var i = 0; i &amp;lt; columns; i++) { Console.</description></item><item><title>1.1.12</title><link>https://alg4.ikesnowy.com/1-1-12/</link><pubDate>Mon, 14 May 2018 20:55:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-12/</guid><description>1.1.12 # 解答 # 第一个循环初始化数组 {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
第二个循环用相应位置的值作为下标取值，例如：a[0] = a[a[0]] = a[9] = 0
最后结果为：0,1,2,3,4,4,3,2,1,0
代码 # var a = new int[10]; for (var i = 0; i &amp;lt; 10; i++) { a[i] = 9 - i; } // a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} for (var i = 0; i &amp;lt; 10; i++) { a[i] = a[a[i]]; } // a[0] = a[9] = 0; a[1] = a[8] = 1; a[2] = a[7] = 2;.</description></item><item><title>1.1.13</title><link>https://alg4.ikesnowy.com/1-1-13/</link><pubDate>Mon, 14 May 2018 21:00:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-13/</guid><description>1.1.13 # 解答 # 转置输出只需要在二重循环的时候将行、列输出顺序取反即可。
代码 # var m = 2; var n = 3; var array = new int[m, n]; // 新建一个二维数组 for (var i = 0; i &amp;lt; m; i++) { for (var j = 0; j &amp;lt; n; j++) { array[i, j] = i + j; } } Console.WriteLine(&amp;#34;Origin&amp;#34;); PrintArray2D(array, m, n); Console.WriteLine(&amp;#34;Transposed&amp;#34;); PrintArrayTranspose2D(array, m, n); // 转置输出 static void PrintArrayTranspose2D(int[,] array, int rows, int columns) { // 交换行、列输出顺序 for (var i = 0; i &amp;lt; columns; i++) { for (var j = 0; j &amp;lt; rows; j++) { Console.</description></item><item><title>1.1.14</title><link>https://alg4.ikesnowy.com/1-1-14/</link><pubDate>Mon, 14 May 2018 21:01:40 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-14/</guid><description>1.1.14 # 解答 # 简单使用 log 的定义逼近即可。
代码 # const int n = 9; Console.WriteLine($&amp;#34;{Lg(n)}&amp;#34;); // 利用循环逼近 n，得到 log2(n) 的值 static int Lg(int n) { const int baseNumber = 2; var pow = 1; var sum = 2; for (pow = 1; sum &amp;lt; n; pow++) { sum *= baseNumber; } return pow - 1; }</description></item><item><title>1.1.15</title><link>https://alg4.ikesnowy.com/1-1-15/</link><pubDate>Mon, 14 May 2018 21:03:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-15/</guid><description>1.1.15 # 解答 # 利用二重循环，查找每个值在数组中出现的次数。
代码 # var a = new int[10]; const int m = 10; for (var i = 0; i &amp;lt; 10; i++) { a[i] = i; } var result = Histogram(a, m); Console.WriteLine($&amp;#34;a.length: {a.Length}&amp;#34;); Console.WriteLine($&amp;#34;sum of result array: {result.Sum()}&amp;#34;); static int[] Histogram(int[] a, int m) { var result = new int[m]; for (var i = 0; i &amp;lt; m; i++) { // 初始化 result[i] = 0; // 遍历数组，计算数组中值为 i 的元素个数 for (var j = 0; j &amp;lt; a.</description></item><item><title>1.1.16</title><link>https://alg4.ikesnowy.com/1-1-16/</link><pubDate>Mon, 14 May 2018 21:23:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-16/</guid><description>1.1.16 # 解答 # 填入代码测试即可。
用字符串拼接的方式展示递归。
代码 # Console.WriteLine($&amp;#34;{ExR1(6)}&amp;#34;); // ExR1(6) = // ExR1(3) + 6 + ExR1(4) + 6 // ExR1(0) + 3 + ExR1(1) + 3 + 6 + ExR1(4) + 6 // &amp;#34;&amp;#34; + 3 + ExR1(-2) + 1 + ExR1(-1) + 1 + 3 + 6 + ExR1(4) + 6 // &amp;#34;&amp;#34; + 3 + &amp;#34;&amp;#34; + 1 + &amp;#34;&amp;#34; + 1 + 3 + 6 + ExR1(4) + 6 // &amp;#34;31136&amp;#34; + ExR1(4) + 6 // .</description></item><item><title>1.1.17</title><link>https://alg4.ikesnowy.com/1-1-17/</link><pubDate>Mon, 14 May 2018 21:57:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-17/</guid><description>1.1.17 # 解答 # 书中已经给出了解释。
递归时结束条件必须放在递归语句的前面，否则会不断展开而无法结束。
代码 # Console.WriteLine($&amp;#34;{ExR2(6)}&amp;#34;); // 抛出 StackOverflow Exception static string ExR2(int n) { var s = ExR2(n - 3) + n + ExR2(n - 2) + n; // 运行到 ExR2 即展开，不会再运行下一句 if (n &amp;lt;= 0) { return &amp;#34;&amp;#34;; } return s; }</description></item><item><title>1.1.18</title><link>https://alg4.ikesnowy.com/1-1-18/</link><pubDate>Mon, 14 May 2018 21:59:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-18/</guid><description>1.1.18 # 解答 # 其实就是一种快速乘法的实现，换成乘号之后就变成了快速乘幂。
例如对于乘法 $2 \times 4$ ，可以用 $2 + 2 + 2 + 2$ 做四次加法计算；也可以变为 $(2 + 2) \times 2 = (2 + 2) + (2 + 2)$ 的形式，用两次加法就可以完成（先计算 $2 + 2$ 的值，再计算 $4 + 4$ 的值）。
同理对于乘幂 $2^8$ ，既可以用 $2\times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2$ 做 8 次乘法，也可以只用三次乘法就计算出来：
$$ 2^2 = 2 \times 2 \newline 2^4 = 2^2 \times 2^2\newline 2^8 = 2^4 \times 2^4 $$</description></item><item><title>1.1.19</title><link>https://alg4.ikesnowy.com/1-1-19/</link><pubDate>Mon, 14 May 2018 22:09:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-19/</guid><description>1.1.19 # 解答 # 普通的递归算法效率很低，原因是越到后面重复运算的数目越多。
比如：
F(2) = F(1) + F(0)
F(3) = F(2) + F(1) = F(1) + F(1) + F(0)
可以看到 F(1) 被重复计算了两次。
改进的方式是将每次运算的结果保存在数组中，之后计算过的数据直接从数组中提取。
代码 # // long 类型不够大，换成 UINT64 类型 // 用于保存计算结果的数组，UInt64? 代表可以赋值为普通 UInt64 类型的值以及 null 值 var fibnacciResults = new UInt64?[100]; var timer = Stopwatch.StartNew(); for (var n = 0; n &amp;lt; 100; n++) { // 书本中的代码，非常慢，1小时后 n = 50 // Console.</description></item><item><title>1.1.20</title><link>https://alg4.ikesnowy.com/1-1-20/</link><pubDate>Tue, 15 May 2018 11:46:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-20/</guid><description>1.1.20 # 解答 # 根据对数的性质可以得到：
$$ \ln(N!) = \ln(N) + \ln(N – 1) + \ln(N – 2)… $$
代码 # const int n = 4; Console.WriteLine($&amp;#34;{FactorialLn(n)}&amp;#34;); // ln(N!) = // ln(N * (N - 1) * ... * 1) = // ln(N) + ln((N - 1)!) static double FactorialLn(int n) { if (n == 1) { return 0; } return Math.</description></item><item><title>1.1.21</title><link>https://alg4.ikesnowy.com/1-1-21/</link><pubDate>Tue, 15 May 2018 11:48:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-21/</guid><description>1.1.21 # 解答 # 实现上没什么难度，打印表格的部分可以参考之前打印二位布尔数组的方法。
注意整型数据之间相除得到的仍然是整型，小数部分会直接舍去，例如 2 / 3 的结果会是 0。
代码 # /* * 输入示例： * * 3 * hi 1 2 * hey 1 3 * hello 1 4 * */ var columns = 2; var rows = int.Parse(Console.ReadLine()); // 行号 var names = new string[rows]; // 姓名 var array = new int[rows, columns]; // 输入的两个整数 var results = new double[rows]; // 计算结果 for (var i = 0; i &amp;lt; rows; i++) { var temp = Console.</description></item><item><title>1.1.22</title><link>https://alg4.ikesnowy.com/1-1-22/</link><pubDate>Tue, 15 May 2018 11:54:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-22/</guid><description>1.1.22 # 解答 # 按照书中的提示增加一个保存深度的参数。
代码 # var array = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; Rank(9, array); static int Rank(int key, int[] a) { return RankInternal(key, a, 0, a.Length - 1, 1); } static int RankInternal(int key, int[] a, int lo, int hi, int number) { for (var i = 0; i &amp;lt; number; i++) { Console.</description></item><item><title>1.1.23</title><link>https://alg4.ikesnowy.com/1-1-23/</link><pubDate>Tue, 15 May 2018 11:55:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-23/</guid><description>1.1.23 # 解答 # 在主函数里做一下判断就可以了，加号则输出所有找不到的值，减号则相反。
代码 # // 从largeW.txt中读取数据 var whiteListLines = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var whiteList = new int[whiteListLines.Length]; for (var i = 0; i &amp;lt; whiteListLines.Length; i++) { whiteList[i] = int.Parse(whiteListLines[i]); } Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); // 输入样例：5 824524 478510 387221 var input = Console.ReadLine(); var query = new int[input.Split(&amp;#39; &amp;#39;).Length]; for (var i = 0; i &amp;lt; query.Length; i++) { query[i] = int.</description></item><item><title>1.1.24</title><link>https://alg4.ikesnowy.com/1-1-24/</link><pubDate>Tue, 15 May 2018 12:09:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-24/</guid><description>1.1.24 # 解答 # 在书本中 GCD 的基础上，在函数开始时增加一条输出语句即可。
代码 # Gcd(105, 24); Console.WriteLine(); Gcd(111111, 1234567); static int Gcd(int a, int b) { Console.WriteLine($&amp;#34;{a} {b}&amp;#34;); if (b == 0) { return a; } return Gcd(b, a % b); }</description></item><item><title>1.1.25</title><link>https://alg4.ikesnowy.com/1-1-25/</link><pubDate>Tue, 15 May 2018 12:11:10 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-25/</guid><description>1.1.25 # 解答 # 已知：$a,b$ 皆为正整数，且 $a&amp;gt;b$。$g$ 是 $ a,b$ 的最大公约数.
设 $\ r_0=a\bmod b$ ，$r_k = r_{k-2} \bmod\ r_{k-1}$ 。
那么有 $gcd(a,b)=gcd(b,r_0)=gcd(r_0,r_1)&amp;hellip;=gcd(r_{n-1},r_n)$ 。 且 $r_n=0$ （此时算法终止）。
由于 $r_{n-2}=q_n\times r_{n-1} + r_n=q_n\times r_{n-1} \ (q_n=\lfloor r_{n-2}/r_{n-1}\rfloor)$ 。
可得 $r_{n-2}$ 能被 $r_{n-1}$ 整除。
则有
$r_{n-3}\newline =q_{n-1} \times r_{n-2} + r_{n-1}\newline =q_{n-1}\times (q_n \times r_{n-1})+r_{n-1}\newline =q_{n-1}\times q_n \times r_{n-1} + r_{n-1} \newline =(q_{n-1} \times q_n +1)\times r_{n-1}$
可得 $r_{n-3}$ 也能被 $r_{n-1}$ 整除</description></item><item><title>1.1.26</title><link>https://alg4.ikesnowy.com/1-1-26/</link><pubDate>Tue, 15 May 2018 19:28:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-26/</guid><description>1.1.26 # 解答 # 见代码部分。
代码 # var a = 3; var b = 2; var c = 1; var t = 0; if (a &amp;gt; b) { t = a; a = b; b = t; } // 如果 a &amp;gt; b，那么 a, b 交换，保证b &amp;gt;= a if (a &amp;gt; c) { t = a; a = c; c = t; } // 如果 b &amp;gt;= a &amp;gt; c，那么 a, c 交换，保证 c &amp;gt;= a if (b &amp;gt; c) { t = b; b = c; c = t; } // 如果 b &amp;gt; c &amp;gt;= a，那么 b, c 交换，保证 c &amp;gt;= b Console.</description></item><item><title>1.1.27</title><link>https://alg4.ikesnowy.com/1-1-27/</link><pubDate>Tue, 15 May 2018 19:34:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-27/</guid><description>1.1.27 # 解答 # 与之前的斐波那契数列类似，都是重复计算的问题。
答案是 7751 次。
代码 # var binomialCalled = 0; // 计算递归调用次数 double?[,] binomialCache; // 保存计算结果的数组 binomialCache = new double?[101, 51]; Console.WriteLine(Binomial(100, 50, 0.25)); Console.WriteLine(binomialCalled); double? Binomial(int n, int k, double p) { binomialCalled++; if (n == 0 &amp;amp;&amp;amp; k == 0) return 1.0; if (n &amp;lt; 0 || k &amp;lt; 0) return 0.0; if (binomialCache[n, k] !</description></item><item><title>1.1.28</title><link>https://alg4.ikesnowy.com/1-1-28/</link><pubDate>Tue, 15 May 2018 19:42:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-28/</guid><description>1.1.28 # 解答 # 实现方法有很多，这里是使用一个 HashSet 做中转，删除所有的重复元素。
也可以使用 Linq 里的 Distinct() 方法，
也可以排序后直接遍历一遍，遇到相同的就删除，遇到不同的就保存起来用于之后的比较。
代码 # // 从largeW.txt中读取数据 // 用 HashSet 的不可重复性去除重复 var hashSet = new HashSet&amp;lt;string&amp;gt;(File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;)); var strings = new string[hashSet.Count]; hashSet.CopyTo(strings); var whiteList = new int[strings.Length]; for (var i = 0; i &amp;lt; strings.Length; i++) { whiteList[i] = int.Parse(strings[i]); } Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); // 输入样例：5 824524 478510 387221 var input = Console.</description></item><item><title>1.1.29</title><link>https://alg4.ikesnowy.com/1-1-29/</link><pubDate>Tue, 15 May 2018 19:46:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-29/</guid><description>1.1.29 # 解答 # 查找小于指定值的元素数量可以多次使用二分查找实现。
例如：
序号：0 1 2 3 4 5 6 7 8
元素：1 2 2 2 2 2 2 2 3
二分查找返回 4
再次在 0~3 之间查找
二分查找返回 1
再次在 0~1 之间查找
二分查找返回 -1，没有指定值了
因此小于该值的元素数量就是 1 – 0 = 1 个
用同样的方法可以找到大于指定值的元素个数，
从总数中减去这两个数值就是等于指定值的元素数量。
代码 # var whiteList = new[] { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6 }; Array.Sort(whiteList); Console.WriteLine(&amp;#34;Type the numbers you want to query: &amp;#34;); var input = Console.</description></item><item><title>1.1.30</title><link>https://alg4.ikesnowy.com/1-1-30/</link><pubDate>Tue, 15 May 2018 19:51:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-30/</guid><description>1.1.30 # 解答 # 互质可以用之前的 GCD 最大公因数算法判断，如果最大公因数是 1 则两数互质。
代码 # // 互质 = 最大公约数为 1 = gcd(i, j) == 1 var n = int.Parse(Console.ReadLine()); var a = new bool[n, n]; for (var i = 0; i &amp;lt; n; i++) { for (var j = 0; j &amp;lt; n; j++) { a[i, j] = (Gcd(i, j) == 1); } } PrintArray2D(a, n, n); static int Gcd(int a, int b) { if (b == 0) return a; return Gcd(b, a % b); } static void PrintArray2D(bool[,] array, int rows, int columns) { for (var i = 0; i &amp;lt; rows; i++) { for (var j = 0; j &amp;lt; columns; j++) { Console.</description></item><item><title>1.1.31</title><link>https://alg4.ikesnowy.com/1-1-31/</link><pubDate>Tue, 15 May 2018 19:53:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-31/</guid><description>1.1.31 # 解答 # 概率的实现方法：
例如概率是 60 %，就在 [0, 100) 之间随机一个值，小于等于 60 则执行操作，反之不执行。
需要更精确的情况可以增大随机的范围，例如 [0, 1000)。
绘图结果
N = 10,p = 0.2, 0.5, 1
完整项目可以到 Github 上下载。
代码 # /// &amp;lt;summary&amp;gt; /// 主绘图函数 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;N&amp;#34;&amp;gt;点的总数目&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;每对点之间连接的概率&amp;lt;/param&amp;gt; public static void StartDrawing(int N, double p) { int pointSize = 5;//每个点绘制的大小 int precious = 1000;//概率判断的精度 //新建一个绘图窗口 Form2 DrawPad = new Form2(); //显示绘图窗口 DrawPad.</description></item><item><title>1.1.32</title><link>https://alg4.ikesnowy.com/1-1-32/</link><pubDate>Tue, 15 May 2018 19:57:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-32/</guid><description>1.1.32 # 解答 # 绘图结果：
完整的项目代码可以去 Github 上下载。
代码 # public static void StartDrawing(double[] array, int N, double l, double r) { //创建并显示绘图窗口 Form2 DrawPad = new Form2(); DrawPad.Show(); //新建画布 Graphics graphics = DrawPad.CreateGraphics(); //翻转默认坐标系 graphics.TranslateTransform(0, DrawPad.Height); graphics.ScaleTransform(1, -1); //对原始数组排序 Array.Sort(array); //计算各区域的值 int[] counts = new int[N]; int index = 0; for (int i = 0; i &amp;lt; N; ++i) { for (int j = index; j &amp;lt; array.</description></item><item><title>1.1.33</title><link>https://alg4.ikesnowy.com/1-1-33/</link><pubDate>Tue, 15 May 2018 20:01:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-33/</guid><description>1.1.33 # 解答 # 这里矩阵使用交错数组实现（方便取行向量），不是普通的二维数组。
矩阵和矩阵、矩阵和向量、向量和矩阵都使用行向量点乘列向量的方式计算。
代码 # public class Matrix { /// &amp;lt;summary&amp;gt; /// 计算两个向量的点积 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;需要点乘的向量&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;需要点乘的另一个向量&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回点乘的结果&amp;lt;/returns&amp;gt; /// &amp;lt;exception cref=&amp;#34;FormatException&amp;#34;&amp;gt;&amp;lt;/exception&amp;gt; public static double Dot(double[] x, double[] y) { //确保两向量等长 if (x.Length != y.Length) { throw new FormatException(&amp;#34;the length of two vectors must be equal&amp;#34;); } //点乘 double result = 0; for (int i = 0; i &amp;lt; x.</description></item><item><title>1.1.34</title><link>https://alg4.ikesnowy.com/1-1-34/</link><pubDate>Tue, 15 May 2018 20:18:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-34/</guid><description>1.1.34 # 解答 # 第二个以及最后三个需要，其他都可以设计成过滤器的模式。
这里的 largeW.txt 只需要保留前 100 个数字就可以了，太多的话最后两个测试会刷屏。
代码 # var allNumbers = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var n = allNumbers.Length; var input = new int[n]; for (var i = 0; i &amp;lt; n; i++) { input[i] = int.Parse(allNumbers[i]); } MinAndMax(input); Console.WriteLine(); MidNumber(input); Console.WriteLine(); NumberK(4, input); Console.WriteLine(); SquareSum(input); Console.WriteLine(); AboveAverage(input); Console.WriteLine(); Ascending(input); Console.WriteLine(); Shuffle(input); Console.WriteLine(); static void MinAndMax(int[] input) { // 只用到了两个变量 var min = input[0]; var max = input[0]; // 只对输入值正向遍历一遍，不需要保存 for (var i = 1; i &amp;lt; input.</description></item><item><title>1.1.35</title><link>https://alg4.ikesnowy.com/1-1-35/</link><pubDate>Tue, 15 May 2018 21:04:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-35/</guid><description>1.1.35 # 解答 # 这里用 Random 类模拟掷骰子并计算概率，最后和程序得出的比较。
代码 # // 书中给出的程序 const int sides = 6; var dist = new double[2 * sides + 1]; for (var i = 1; i &amp;lt;= sides; i++) for (var j = 1; j &amp;lt;= sides; j++) dist[i + j] += 1.0; for (var k = 2; k &amp;lt;= 2 * sides; k++) dist[k] /= 36.0; // 不断进行模拟，直至误差小于 0.</description></item><item><title>1.1.36</title><link>https://alg4.ikesnowy.com/1-1-36/</link><pubDate>Tue, 15 May 2018 21:10:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-36/</guid><description>1.1.36 # 解答 # N 取到 1000 左右数据就比较明显了。
N = 1000， M = 10
代码 # const int m = 10; // 数组大小 const int n = 1000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i &amp;lt; n; i++) { // 初始化 for (var j = 0; j &amp;lt; a.Length; j++) { a[j] = j; } // 打乱 Shuffle(a, i); // 记录 for (var j = 0; j &amp;lt; m; j++) { result[a[j], j]++; } } PrintMatrix(result); static void Shuffle(int[] a, int seed) { var n = a.</description></item><item><title>1.1.37</title><link>https://alg4.ikesnowy.com/1-1-37/</link><pubDate>Tue, 15 May 2018 21:13:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-37/</guid><description>1.1.37 # 解答 # 使用 0~N-1 的随机数会导致每次交换的数字可能相同。
例如：
原数组： 1 2 3 4。
第一次： 2 1 3 4
random = 1，第 0 个和第 1 个交换。
第二次： 1 2 3 4
random = 0，第 1 个和第 0 个交换。
代码 # // 使用 0~N-1 的随机数会导致每次交换的数字可能相同 // 例如： // 原数组： 1 2 3 4 // 第一次： 2 1 3 4 random = 1，第 0 个和第 1 个交换 // 第二次： 1 2 3 4 random = 0，第 1 个和第 0 个交换 const int m = 10; // 数组大小 const int n = 100000; // 打乱次数 var a = new int[10]; var result = new int[m, m]; for (var i = 0; i &amp;lt; n; i++) { // 初始化 for (var j = 0; j &amp;lt; a.</description></item><item><title>1.1.38</title><link>https://alg4.ikesnowy.com/1-1-38/</link><pubDate>Tue, 15 May 2018 21:15:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-38/</guid><description>1.1.38 # 解答 # 为了使差距比较明显，故意取了比较靠后的数字。
代码 # var largeWString = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var largeW = new int[largeWString.Length]; for (var i = 0; i &amp;lt; largeW.Length; i++) { largeW[i] = int.Parse(largeWString[i]); } var timer = Stopwatch.StartNew(); BruteForceSearch(111111, largeW); Console.WriteLine($&amp;#34;BruteForceSearch: {timer.ElapsedMilliseconds} ms&amp;#34;); timer.Restart(); Rank(111111, largeW); Console.WriteLine($&amp;#34;BinarySearch: {timer.ElapsedMilliseconds} ms&amp;#34;); var largeTString = File.ReadAllLines(&amp;#34;largeT.txt&amp;#34;); var largeT = new int[largeTString.Length]; for (var i = 0; i &amp;lt; largeW.Length; i++) { largeT[i] = int.</description></item><item><title>1.1.39</title><link>https://alg4.ikesnowy.com/1-1-39/</link><pubDate>Tue, 15 May 2018 21:16:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-1-39/</guid><description>1.1.39 # 解答 # 按照要求编程就好，视机器不同需要的时间也不同。
代码 # // 需要 6 秒左右的运算时间 var r = new Random(); var baseNum = 10; var powNum = 3; var T = 10; var m = 4; var matrix = new double[m, 2]; for (var i = 0; i &amp;lt; m; i++) { var n = (int)Math.Pow(baseNum, powNum + i); double sum = 0; for (var j = 0; j &amp;lt; T; j++) { sum += Test(n, r.</description></item><item><title>1.2.1</title><link>https://alg4.ikesnowy.com/1-2-1/</link><pubDate>Tue, 15 May 2018 21:38:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-1/</guid><description>1.2.1 # 解答 # 这里自己实现了一个 Point2D 类（包含在了 Geometry 库中）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Point2D.java.html。
求最近两点只需要反复调用 Point2D 类中的 DistTo() 方法就可以了。
代码 # Point2D 类 # /// &amp;lt;summary&amp;gt; /// Point2D 二维点类。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;summary&amp;gt; public sealed class Point2D : IComparable&amp;lt;Point2D&amp;gt; { /// 以 X 坐标升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以 X 坐标升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; XOrderComparer = new XOrder(); /// &amp;lt;summary&amp;gt; /// 以 Y 坐标升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以 Y 坐标升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; YOrderComparer = new YOrder(); /// &amp;lt;summary&amp;gt; /// 以极半径升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以极半径升序排序的静态比较器。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Point2D&amp;gt; ROrderComparer = new ROrder(); /// &amp;lt;summary&amp;gt; /// 二维点的 X 坐标。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;X 坐标。&amp;lt;/value&amp;gt; public double X { get; } /// &amp;lt;summary&amp;gt; /// 二维坐标的 Y 坐标。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;Y 坐标。&amp;lt;/value&amp;gt; public double Y { get; } /// &amp;lt;summary&amp;gt; /// 绘制时点的半径，以像素为单位，默认值为 2。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;点的半径，以像素为单位。&amp;lt;/value&amp;gt; public int Radius { get; set; } /// &amp;lt;summary&amp;gt; /// 构造一个二维点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;点的 X 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;点的 Y 轴坐标。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;当 &amp;lt;paramref name=&amp;#34;x&amp;#34;/&amp;gt; 或 &amp;lt;paramref name=&amp;#34;y&amp;#34;/&amp;gt; 为±无穷时抛出此异常。&amp;lt;/exception&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentNullException&amp;#34;&amp;gt;当 &amp;lt;paramref name=&amp;#34;x&amp;#34;/&amp;gt; 或 &amp;lt;paramref name=&amp;#34;y&amp;#34;/&amp;gt; 为 &amp;lt;see cref=&amp;#34;double.</description></item><item><title>1.2.2</title><link>https://alg4.ikesnowy.com/1-2-2/</link><pubDate>Tue, 15 May 2018 21:47:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-2/</guid><description>1.2.2 # 解答 # 同样实现了一个 Interval1D 类（位于 Geometry 库）。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval1D.java.html。
直接调用其中的 Intersect() 方法即可
代码 # Interval1D 类： # /// &amp;lt;summary&amp;gt; /// 一维闭区间。 /// &amp;lt;/summary&amp;gt; public class Interval1D { /// &amp;lt;summary&amp;gt; /// 优先以起点升序排序，起点相同时按照终点升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;优先以起点升序排序，起点相同时按照终点升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; MinOrder = new MinEndpointComparer(); /// &amp;lt;summary&amp;gt; /// 优先以终点升序排序，起点相同时按照起点升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;优先以终点升序排序，起点相同时按照起点升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; MaxOrder = new MaxEndpointComparer(); /// &amp;lt;summary&amp;gt; /// 以区间长度升序排序。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;以区间长度升序排序。&amp;lt;/value&amp;gt; public static readonly Comparer&amp;lt;Interval1D&amp;gt; LengthOrder = new LengthComparer(); /// &amp;lt;summary&amp;gt; /// 区间起点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;区间起点。&amp;lt;/value&amp;gt; /// &amp;lt;remarks&amp;gt;这个属性是只读的。&amp;lt;/remarks&amp;gt; public double Min { get; } /// &amp;lt;summary&amp;gt; /// 区间终点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;区间终点。&amp;lt;/value&amp;gt; /// &amp;lt;remarks&amp;gt;这个属性是只读的。&amp;lt;/remarks&amp;gt; public double Max { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;一维区域的下界。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;一维区域的上界。&amp;lt;/param&amp;gt; public Interval1D(double lo, double hi) { if (double.</description></item><item><title>1.2.3</title><link>https://alg4.ikesnowy.com/1-2-3/</link><pubDate>Tue, 15 May 2018 21:49:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-3/</guid><description>1.2.3 # 解答 # 首先先实现一个 Interval2D 类（位于 Geometry 库），再使用窗体应用程序绘图。
JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Interval2D.java.html。
代码 # Interval2D： # /// &amp;lt;summary&amp;gt; /// 二维闭合区间。 /// &amp;lt;/summary&amp;gt; public class Interval2D { private readonly Interval1D _x; private readonly Interval1D _y; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;x&amp;#34;&amp;gt;x 轴上的范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;y&amp;#34;&amp;gt;y 轴上的范围。&amp;lt;/param&amp;gt; public Interval2D(Interval1D x, Interval1D y) { _x = x; _y = y; } /// &amp;lt;summary&amp;gt; /// 判断两个平面是否相交。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;that&amp;#34;&amp;gt;需要判断的另一个平面。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;相交则返回 &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt;，否则返回 &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;。&amp;lt;/returns&amp;gt; public bool Intersects(Interval2D that) { if (!</description></item><item><title>1.2.4</title><link>https://alg4.ikesnowy.com/1-2-4/</link><pubDate>Tue, 15 May 2018 21:51:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-4/</guid><description>1.2.4 # 解答 # 在 C# 中，这段代码能够完成交换的工作，输出为：
world hello 代码 # var string1 = &amp;#34;hello&amp;#34;; var string2 = string1; string1 = &amp;#34;world&amp;#34;; Console.WriteLine(string1); Console.WriteLine(string2);</description></item><item><title>1.2.5</title><link>https://alg4.ikesnowy.com/1-2-5/</link><pubDate>Tue, 15 May 2018 21:52:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-5/</guid><description>1.2.5 # 解答 # string 类型中的 Uppercase() 以及 Substring() 都不会改变原有字符串，而是新建一个字符串并返回。
因此输出仍然为 Hello World。
代码 # var s = &amp;#34;Hello World&amp;#34;; s.ToUpper(); s.Substring(6, 5); // C# 中两个参数分别代表子串起始下标和长度 Console.WriteLine(s);</description></item><item><title>1.2.6</title><link>https://alg4.ikesnowy.com/1-2-6/</link><pubDate>Tue, 15 May 2018 21:53:48 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-6/</guid><description>1.2.6 # 解答 # 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） 其回环变位则为 s' = s2 + s1
显然 s' + s' = s2 + s1 + s2 + s1
即 s' + s' = s2 + s + s1，其中必定包含 s
例如 ABC 和 BCA， BCABCA 显然包含 ABC
代码 # var s1 = &amp;#34;ACTGACG&amp;#34;; var s2 = &amp;#34;TGACGAC&amp;#34;; Console.WriteLine(Circular(s1, s2)); // 对于任意字符串 s，将其拆分成 s = s1 + s2（s2长度即为循环移动的位数） // 其回环变位则为 s&amp;#39; = s2 + s1 // 显然 s&amp;#39; + s&amp;#39; = s2 + s1 + s2 + s1 // 即 s&amp;#39; + s&amp;#39; = s2 + s + s1，其中必定包含 s // 例如 ABC 和 BCA， BCABCA 显然包含 ABC static bool Circular(string s1, string s2) { return s1.</description></item><item><title>1.2.7</title><link>https://alg4.ikesnowy.com/1-2-7/</link><pubDate>Tue, 15 May 2018 21:55:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-7/</guid><description>1.2.7 # 解答 # 递归交换字符顺序，最后返回反序的字符串。
Mystery(ABCD) = Mystery(CD) + Mystery(AB) = Mystery(D) + Mystery(C) + Mystery(B) + Mystery(A) = DCBA 代码 # Console.WriteLine(Mystery(&amp;#34;Hello1&amp;#34;)); static string Mystery(string s) { var n = s.Length; if (n &amp;lt;= 1) return s; var a = s.Substring(0, n / 2); var b = s.Substring(n / 2, n - n / 2); return Mystery(b) + Mystery(a); }</description></item><item><title>1.2.8</title><link>https://alg4.ikesnowy.com/1-2-8/</link><pubDate>Tue, 15 May 2018 21:56:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-8/</guid><description>1.2.8 # 解答 # 作用就是交换两个数组。
但在 C# 或 JAVA 中，数组变量实际是数组的一个引用（类似于指针），交换两个引用的效率与数组大小无关（可以理解为只是交换了数组的名字，数组实际内容在内存中的位置没有改变），都是常数时间的。
代码 # // 读取 largeW.txt var allNums = File.ReadAllLines(&amp;#34;largeW.txt&amp;#34;); var n = allNums.Length; var a = new int[n]; var b = new int[n]; // 数组 a 与数组 b 数字顺序相反 for (var i = 0; i &amp;lt; n; i++) { a[i] = int.Parse(allNums[i]); b[n - i - 1] = a[i]; } // 输出前5个数字 Console.WriteLine(&amp;#34;Before Swap&amp;#34;); Console.</description></item><item><title>1.2.9</title><link>https://alg4.ikesnowy.com/1-2-9/</link><pubDate>Wed, 16 May 2018 07:32:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-9/</guid><description>1.2.9 # 解答 # 首先实现一个 Counter 类，随后使用非递归版本的 BinarySearch，每进行一次 While 循环就让 Counter 加一。
代码 # Counter 类 # class Counter { private readonly string _name; private int _count; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; public Counter(string id) { _name = id; } /// &amp;lt;summary&amp;gt; /// 计数器加一。 /// &amp;lt;/summary&amp;gt; public void Increment() { _count++; } /// &amp;lt;summary&amp;gt; /// 获取当前计数值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Tally() { return _count; } /// &amp;lt;summary&amp;gt; /// 输出形如 “1 counter” 的字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override string ToString() { return _count + &amp;#34; &amp;#34; + _name; } } Main # // 参考 1.</description></item><item><title>1.2.10</title><link>https://alg4.ikesnowy.com/1-2-10/</link><pubDate>Wed, 16 May 2018 08:17:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-10/</guid><description>1.2.10 # 解答 # 在 Counter 类基础上修改即可。
代码 # VisualCounter 类 # internal class VisualCounter { private readonly string _name; private int _count; private readonly int _max; private int _operatorTimes; /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;计数器的名称。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;max&amp;#34;&amp;gt;计数器的最大值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;operatorTimes&amp;#34;&amp;gt;计数器的最大操作数。&amp;lt;/param&amp;gt; public VisualCounter(string id, int max, int operatorTimes) { _name = id; _max = max; _operatorTimes = operatorTimes; } /// &amp;lt;summary&amp;gt; /// 计数器加一。 /// &amp;lt;/summary&amp;gt; public bool Increment() { if (_operatorTimes &amp;lt;= 0) return false; if (_count &amp;lt; _max) { _count++; _operatorTimes--; } return true; } /// &amp;lt;summary&amp;gt; /// 计数器减一。 /// &amp;lt;/summary&amp;gt; public bool Decreasement() { if (_operatorTimes &amp;lt;= 0) return false; if (_count &amp;gt; 0) { _count--; _operatorTimes--; } return true; } /// &amp;lt;summary&amp;gt; /// 获取当前计数值。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回计数值。&amp;lt;/returns&amp;gt; public int Tally() { return _count; } /// &amp;lt;summary&amp;gt; /// 返回形如 “1 counter” 的字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回形如 “1 counter” 的字符串。&amp;lt;/returns&amp;gt; public override string ToString() { return _count + &amp;#34; &amp;#34; + _name; } /// &amp;lt;summary&amp;gt; /// 绘制计数器的图形。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;g&amp;#34;&amp;gt;画布。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;width&amp;#34;&amp;gt;绘图区宽度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;height&amp;#34;&amp;gt;绘图区高度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;font&amp;#34;&amp;gt;显示的字体。&amp;lt;/param&amp;gt; public void Draw(Graphics g, int width, int height, Font font) { // 空画布 g.</description></item><item><title>1.2.11</title><link>https://alg4.ikesnowy.com/1-2-11/</link><pubDate>Wed, 16 May 2018 08:25:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-11/</guid><description>1.2.11 # 解答 # 在构造函数开始时做一次判断，非法时抛出异常。
首先建立一个数组，数组的第 1 项至第 12 项的值就是每个月的天数。
再声明一个布尔类型的变量，用于标记是否是闰年。
代码 # internal class SmartDate { public int Month { get; } // 月 public int Day { get; } // 日 public int Year { get; } // 年 // 每个月对应的天数，第 0 位空出来 private static readonly int[] DayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public SmartDate(int m, int d, int y) { if (Vaildation(m, d, y) == false) throw new FormatException(&amp;#34;Invaild Date&amp;#34;); Month = m; Day = d; Year = y; } private bool Vaildation(int m, int d, int y) { if (y &amp;lt; 0) return false; var isLeapYear = IsLeapYear(y); if (m &amp;gt; 12 || m &amp;lt; 1) return false; if (d &amp;lt; 0) return false; if (m == 2 &amp;amp;&amp;amp; d &amp;gt; 29 &amp;amp;&amp;amp; isLeapYear) return false; if (d &amp;gt; DayOfMonth[m]) return false; return true; } private bool IsLeapYear(int y) { if (y % 400 == 0) return true; if (y % 100 !</description></item><item><title>1.2.12</title><link>https://alg4.ikesnowy.com/1-2-12/</link><pubDate>Wed, 16 May 2018 08:29:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-12/</guid><description>1.2.12 # 解答 # 这里使用蔡勒公式来推算星期。
参考：http://www.cnblogs.com/mq0036/p/3534314.html
代码 # /// &amp;lt;summary&amp;gt; /// 计算当前日期是星期几，返回对应的星期名称。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public string DayOfTheWeek() { var d = Day; var m = Month; var y = Year; if (m &amp;lt; 3) { m += 12; y--; } // 使用蔡勒公式计算，参见 http://www.cnblogs.com/mq0036/p/3534314.html var w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return DayOfWeek[w]; } 另请参阅 # 蔡勒公式-维基百科</description></item><item><title>1.2.13</title><link>https://alg4.ikesnowy.com/1-2-13/</link><pubDate>Wed, 16 May 2018 08:33:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-13/</guid><description>1.2.13 # 解答 # 直接实现即可。
JAVA 版本可以参考：http://algs4.cs.princeton.edu/12oop/Transaction.java.html。
代码 # public class Transaction : IComparable&amp;lt;Transaction&amp;gt; { /// &amp;lt;summary&amp;gt; /// 客户姓名。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;客户姓名。&amp;lt;/value&amp;gt; public string Who { get; } /// &amp;lt;summary&amp;gt; /// 交易日期。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;交易日期。&amp;lt;/value&amp;gt; /// &amp;lt;seealso cref=&amp;#34;Date&amp;#34;/&amp;gt; public Date When { get; } /// &amp;lt;summary&amp;gt; /// 交易金额。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt;交易金额。&amp;lt;/value&amp;gt; public double Amount { get; } /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { var a = transaction.</description></item><item><title>1.2.14</title><link>https://alg4.ikesnowy.com/1-2-14/</link><pubDate>Wed, 16 May 2018 08:36:34 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-14/</guid><description>1.2.14 # 解答 # 上一题中的代码已经包含了对 Equals() 方法的实现。
代码 # /// &amp;lt;summary&amp;gt; /// 比较两笔交易是否相同。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;obj&amp;#34;&amp;gt;另一个对象。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public override bool Equals(object obj) { if (obj == this) return true; if (obj == null) return false; if (obj.GetType() != GetType()) return false; var that = (Transaction)obj; return Math.Abs(that.Amount - Amount) &amp;lt; float.Epsilon * 5 &amp;amp;&amp;amp; that.</description></item><item><title>1.2.15</title><link>https://alg4.ikesnowy.com/1-2-15/</link><pubDate>Wed, 16 May 2018 08:38:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-15/</guid><description>1.2.15 # 解答 # 这里我们基于 File.ReadAllLines() 进行实现。
代码 # static int[] ReadInts(string path) { var allLines = File.ReadAllLines(path); var result = new int[allLines.Length]; for (var i = 0; i &amp;lt; allLines.Length; i++) { result[i] = int.Parse(allLines[i]); } return result; }</description></item><item><title>1.2.16</title><link>https://alg4.ikesnowy.com/1-2-16/</link><pubDate>Wed, 16 May 2018 08:39:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-16/</guid><description>1.2.16 # 解答 # JAVA 版本参考：http://algs4.cs.princeton.edu/12oop/Rational.java.html
欧几里得算法仅适用于正整数，使用前需要注意。
用欧几里得算法找到公因子之后直接化简即可。
代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNegative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { _isNegative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { _isNegative = true; } else { _isNegative = false; } var gcd = Gcd(Math.</description></item><item><title>1.2.17</title><link>https://alg4.ikesnowy.com/1-2-17/</link><pubDate>Wed, 16 May 2018 08:40:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-17/</guid><description>1.2.17 # 解答 # 在 C# 中使用 checked 关键字包裹整数运算的代码即可自动检查溢出。
在 JAVA 中可以考虑在运算前控制运算数的大小。
例如 a + b 之前保证 long.MaxValue – b &amp;gt;= a 等等。
代码 # public class Rational { public long Numerator { get; } public long Denominator { get; } private readonly bool _isNagative; /// &amp;lt;summary&amp;gt; /// 构造一个有理数对象，自动变为最简形式。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;numerator&amp;#34;&amp;gt;分子。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;denominator&amp;#34;&amp;gt;分母。&amp;lt;/param&amp;gt; /// &amp;lt;exception cref=&amp;#34;ArgumentException&amp;#34;&amp;gt;分母为 0 时抛出&amp;lt;/exception&amp;gt; public Rational(long numerator, long denominator) { if (denominator == 0) throw new ArgumentException(&amp;#34;Denominator cannot be 0&amp;#34;); if (numerator &amp;lt; 0 &amp;amp;&amp;amp; denominator &amp;lt; 0) { _isNagative = false; numerator = -numerator; denominator = -denominator; } else if (numerator &amp;lt; 0 || denominator &amp;lt; 0) { _isNagative = true; } else { _isNagative = false; } var gcd = Gcd(Math.</description></item><item><title>1.2.18</title><link>https://alg4.ikesnowy.com/1-2-18/</link><pubDate>Wed, 16 May 2018 08:44:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-18/</guid><description>1.2.18 # 解答 # 当数据比较大时—— 例如 10^9 加上随机小数组成的数列，这时 double 的小数精度将受限。
求和之后整数部分更大，小数部分将自动四舍五入，出现误差
这时再计算平均值时将会带来较大的误差。
因此采用另一个递推公式：
k 为下标。
$M_k = M_{k-1}+ (x_k – M_{k-1})/k$
$S_k = S_{k-1} + (x_k – M_{k-1})\times(x_k – M_k)$.
方差 $s^2 = S_k/(k – 1)$.
这种情况下并没有直接对所有输入值求和，小数精度不会过多受到整数部分长度的影响。
有关这两个公式的证明可以参考这篇论文，或者去查看我的知乎回答。
代码 # public class Accumulator { private double _m; private double _s; private int _n; public void AddDataValue(double x) { _n++; _s = _s + 1.</description></item><item><title>1.2.19</title><link>https://alg4.ikesnowy.com/1-2-19/</link><pubDate>Wed, 16 May 2018 08:48:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-2-19/</guid><description>1.2.19 # 解答 # 之前的 Date 和 Transaction 已经包含了这些实现。
代码 # Date # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;date&amp;#34;&amp;gt;形如 &amp;#34;05/31/2017&amp;#34; 的字符串。&amp;lt;/param&amp;gt; public Date(string date) { string[] a = date.Split(&amp;#39;/&amp;#39;); if (a.Length != 3) throw new ArgumentException(&amp;#34;Illgal Date&amp;#34;); Month = int.Parse(a[0]); Day = int.Parse(a[1]); Year = int.Parse(a[2]); } Transaction # /// &amp;lt;summary&amp;gt; /// 构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;transaction&amp;#34;&amp;gt;用空格隔开的形如 “姓名 日期 金额” 的字符串。&amp;lt;/param&amp;gt; public Transaction(string transaction) { string[] a = transaction.</description></item><item><title>1.3.1</title><link>https://alg4.ikesnowy.com/1-3-1/</link><pubDate>Wed, 16 May 2018 09:02:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-1/</guid><description>1.3.1 # 解答 # 首先是 FixedCapacityStackOfStrings 类，官方 JAVA 版本参考：FixedCapacityStackOfStrings.java
IsFull() 的实现比较简单，判断 N 与数组长度是否相等即可。
代码 # internal class FixedCapacityStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private readonly string[] _a; private int _n; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfStrings(int capacity) { _a = new string[capacity]; _n = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _n == 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _n == _a.</description></item><item><title>1.3.2</title><link>https://alg4.ikesnowy.com/1-3-2/</link><pubDate>Wed, 16 May 2018 09:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-2/</guid><description>1.3.2 # 解答 # 首先是 Stack&amp;lt;&amp;gt; 类的实现，官方 JAVA 版本参考：Stack.java
输出内容：was best times of the was the it
代码 # /// &amp;lt;summary&amp;gt; /// 栈类（链表实现）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;栈中存放的元素类型。&amp;lt;/typeparam&amp;gt; public class Stack&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _first; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Stack() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 复制构造函数，链表中的元素都是浅拷贝。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;用于复制的栈。&amp;lt;/param&amp;gt; public Stack(Stack&amp;lt;TItem&amp;gt; s) { if (s.</description></item><item><title>1.3.3</title><link>https://alg4.ikesnowy.com/1-3-3/</link><pubDate>Wed, 16 May 2018 09:06:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-3/</guid><description>1.3.3 # 解答 # 这个问题的通用解法见习题 1.3.46 的解答。
第 2、6、7 个不可能产生，可以画个栈模拟一下。
第 2 个
​ 输出数 栈内数 4 0~3 6 0~3 + 5 8 0~3 + 5 + 7 7 0~3 + 5 5 0~3 3 0~2 2 0~1 9 0~1 0 Error 第 6 个
输出数 栈内数 0 null 4 1~3 6 1~3 + 5 5 1~3 3 1~2 8 1~2 + 7 1 Error 第 7 个</description></item><item><title>1.3.4</title><link>https://alg4.ikesnowy.com/1-3-4/</link><pubDate>Wed, 16 May 2018 09:07:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-4/</guid><description>1.3.4 # 解答 # 官方 JAVA 版本参考：Parentheses.java。
遇到左括号就入栈，遇到右括号就检查是否和栈顶的左括号匹配，如果匹配则弹栈，否则返回 false。
结束时如果栈不为空则返回 false，否则返回 true。
代码 # var input = &amp;#34;[()]{}{[()()]()}&amp;#34;; Console.WriteLine(IsBalanced(input)); var input2 = &amp;#34;[(])&amp;#34;; Console.WriteLine(IsBalanced(input2)); static bool IsBalanced(string input) { var stack = new Stack&amp;lt;char&amp;gt;(); foreach (var i in input) { if (i == &amp;#39;(&amp;#39; || i == &amp;#39;[&amp;#39; || i == &amp;#39;{&amp;#39;) stack.Push(i); else { if (stack.Peek() == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; i == &amp;#39;)&amp;#39;) stack.</description></item><item><title>1.3.5</title><link>https://alg4.ikesnowy.com/1-3-5/</link><pubDate>Wed, 16 May 2018 09:09:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-5/</guid><description>1.3.5 # 解答 # 实际上是用除二取余法求一个十进制数的二进制形式。
代码 # var n = 50; var stack = new Stack&amp;lt;int&amp;gt;(); while (n &amp;gt; 0) { stack.Push(n % 2); n = n / 2; } foreach (var d in stack) { Console.WriteLine(d); } Console.WriteLine(); 另请参阅 # Generics 库</description></item><item><title>1.3.6</title><link>https://alg4.ikesnowy.com/1-3-6/</link><pubDate>Wed, 16 May 2018 09:10:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-6/</guid><description>1.3.6 # 解答 # 利用一个栈对队列元素进行反序操作。
先把队列中的元素全部入栈，再依次弹出并加入队列中。
代码 # var q = new Queue&amp;lt;string&amp;gt;(); q.Enqueue(&amp;#34;first&amp;#34;); q.Enqueue(&amp;#34;second&amp;#34;); q.Enqueue(&amp;#34;third&amp;#34;); q.Enqueue(&amp;#34;fourth&amp;#34;); var stack = new Stack&amp;lt;string&amp;gt;(); while (!q.IsEmpty()) stack.Push(q.Dequeue()); while (!stack.IsEmpty()) q.Enqueue(stack.Pop()); Console.WriteLine(q.ToString()); 另请参阅 # Generics 库</description></item><item><title>1.3.7</title><link>https://alg4.ikesnowy.com/1-3-7/</link><pubDate>Wed, 16 May 2018 09:11:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-7/</guid><description>1.3.7 # 解答 # 链表实现的话就是返回第一个结点 first 的 item 字段。
数组实现的话就是返回 first 对应的数组元素。
这里给出链表实现，完整实现见习题 1.3.2 的代码。
代码 # /// &amp;lt;summary&amp;gt; /// 返回栈顶元素（但不弹出它）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Peek() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Stack Underflow&amp;#34;); return this.first.item; }</description></item><item><title>1.3.8</title><link>https://alg4.ikesnowy.com/1-3-8/</link><pubDate>Wed, 16 May 2018 09:12:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-8/</guid><description>1.3.8 # 解答 # 首先是 DoublingStackOfStrings 类，据我猜测应该是用数组实现的栈，扩容时长度增加一倍，缩短时长度减小一半。
官方 JAVA 代码参考：FixedCapacityStackOfString.java。
代码 # DoublingStackOfStrings 类 # /// &amp;lt;summary&amp;gt; /// 容量自动加倍的字符串栈。 /// &amp;lt;/summary&amp;gt; internal class DoublingStackOfStrings : IEnumerable&amp;lt;string&amp;gt; { private string[] _items; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个字符串栈。 /// &amp;lt;/summary&amp;gt; public DoublingStackOfStrings() { _items = new string[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回栈中字符串的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向栈中压入一个字符串。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(string s) { if (_count == _items.</description></item><item><title>1.3.9</title><link>https://alg4.ikesnowy.com/1-3-9/</link><pubDate>Wed, 16 May 2018 09:18:49 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-9/</guid><description>1.3.9 # 解答 # 在计算中序表达式算法的基础上做修改。
压入数字时将该数字所在的位置也一并压入。
弹出数字进行运算时在位置靠前的数字前加上左括号。
A + B ) * C + D ) ) 为例。
A 压入栈中并记录位置 。
&amp;lsquo;+&amp;rsquo; 压入栈中。
B 压入栈中并记录位置。
) 计算，在 A 之前加入左括号，结果 E 压入栈中，位置为 A 的位置。
&amp;lsquo;*&amp;rsquo; 压入栈中。
C 压入栈中并记录位置。
&amp;lsquo;+&amp;rsquo; 压入栈中。
D 压入栈中并记录位置。
) 计算，在 C 之前加入左括号，结果 F 压入栈中，位置为 C 的位置。
) 计算，在 E 之前加入左括号（也就是 A 之前），结果 G 压入栈中，位置为 E 的位置。
代码 # var input = &amp;#34;1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )&amp;#34;; var operators = new Stack&amp;lt;char&amp;gt;(); var numbers = new Stack&amp;lt;Number&amp;gt;(); var leftBrackets = new int[input.</description></item><item><title>1.3.10</title><link>https://alg4.ikesnowy.com/1-3-10/</link><pubDate>Thu, 17 May 2018 20:53:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-10/</guid><description>1.3.10 # 解答 # 官方 JAVA 代码：InfixToPostfix.java。
其实就是把右括号换成相应运算符
对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出
结果 A B +，变成后序表达式
代码 # // 其实就是把右括号换成相应运算符 // 对于 (A + B)，忽略左括号，数字直接输出，运算符入栈，遇到右括号时再弹出 // 结果 A B +，变成后序表达式 var stack = new Stack&amp;lt;string&amp;gt;(); var input = &amp;#34;( 1 + ( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) ) )&amp;#34;.Split(&amp;#39; &amp;#39;); foreach (var n in input) { if (n == &amp;#34; &amp;#34;) { continue; } if (n == &amp;#34;+&amp;#34; || n == &amp;#34;-&amp;#34; || n == &amp;#34;*&amp;#34; || n == &amp;#34;/&amp;#34;) { stack.</description></item><item><title>1.3.11</title><link>https://alg4.ikesnowy.com/1-3-11/</link><pubDate>Thu, 17 May 2018 20:57:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-11/</guid><description>1.3.11 # 解答 # 官方 JAVA 代码：EvaluatePostfix.java。
遇到数字就入栈，遇到运算符就弹出两个数字运算，再把结果入栈。
如果倒着读取的话也可以用递归做，当作前序表达式计算即可。
代码 # var stack = new Stack&amp;lt;int&amp;gt;(); var input = &amp;#34;7 16 * 5 + 16 * 3 + 16 * 1 +&amp;#34;.Split(&amp;#39; &amp;#39;); foreach (var n in input) { if (n == &amp;#34; &amp;#34;) { continue; } if (n == &amp;#34;+&amp;#34;) { stack.Push(stack.Pop() + stack.Pop()); } else if (n == &amp;#34;-&amp;#34;) { var temp = stack.</description></item><item><title>1.3.12</title><link>https://alg4.ikesnowy.com/1-3-12/</link><pubDate>Thu, 17 May 2018 21:00:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-12/</guid><description>1.3.12 # 解答 # 先用 foreach 语句遍历一遍栈，把所有元素都压入一个临时栈中。
此时临时栈变成了源栈的一个倒序副本。
再将临时栈中的元素依次压入目标栈中，就得到了源栈的一个副本。
代码 # var src = new Stack&amp;lt;string&amp;gt;(); src.Push(&amp;#34;first&amp;#34;); src.Push(&amp;#34;second&amp;#34;); src.Push(&amp;#34;third&amp;#34;); var des = CopyTo(src); while (!des.IsEmpty()) { Console.WriteLine(des.Pop()); } static Stack&amp;lt;string&amp;gt; CopyTo(Stack&amp;lt;string&amp;gt; src) { var des = new Stack&amp;lt;string&amp;gt;(); var temp = new Stack&amp;lt;string&amp;gt;(); foreach (var s in src) { temp.Push(s); } while (!temp.IsEmpty()) { des.</description></item><item><title>1.3.13</title><link>https://alg4.ikesnowy.com/1-3-13/</link><pubDate>Thu, 17 May 2018 21:03:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-13/</guid><description>1.3.13 # 解答 # 除了第一个以外都不可能。
根据题意，0 一定是最先入列的。
那么根据队列的特性，0 一定是最先出列的，因此除第一个以外其他几个序列都不可能。</description></item><item><title>1.3.14</title><link>https://alg4.ikesnowy.com/1-3-14/</link><pubDate>Thu, 17 May 2018 21:45:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-14/</guid><description>1.3.14 # 解答 # 对于 ResizingArrayQueueOfStrings 类，给出官方 JAVA 代码参考：ResizingArrayQueue.java。
代码 # ResizingArrayQueue 类 # /// &amp;lt;summary&amp;gt; /// 可变长度的队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; internal class ResizingArrayQueueOfStrings&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _q; private int _count; private int _first; private int _last; public ResizingArrayQueueOfStrings() { _q = new TItem[2]; _count = 0; _first = 0; } public bool IsEmpty() { return _count == 0; } public int Size() { return _count; } private void Resize(int capacity) { if (capacity &amp;lt; 0) throw new ArgumentException(&amp;#34;capacity should be above zero&amp;#34;); var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _q[(_first + i) % _q.</description></item><item><title>1.3.15</title><link>https://alg4.ikesnowy.com/1-3-15/</link><pubDate>Thu, 17 May 2018 21:47:53 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-15/</guid><description>1.3.15 # 解答 # 方法有很多，只要把所有输入保存，之后算出倒数第 k 个是正数第几个就可以了。
这里先全部入队，之后算出是正数第几个，再把前面的元素全部出队，剩下的第一个就是要求的元素了。
代码 # var queue = new Queue&amp;lt;string&amp;gt;(); var input = &amp;#34;1 2 3 4 5 6 7 8 9 10&amp;#34;.Split(&amp;#39; &amp;#39;); var k = 4; foreach (var s in input) { queue.Enqueue(s); } var count = queue.Size() - k; for (var i = 0; i &amp;lt; count; i++) { queue.Dequeue(); } Console.WriteLine(queue.Peek()); 另请参阅 # Generics 库</description></item><item><title>1.3.16</title><link>https://alg4.ikesnowy.com/1-3-16/</link><pubDate>Thu, 17 May 2018 21:49:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-16/</guid><description>1.3.16 # 解答 # 在习题 1.2.19 里已经写好了接受字符串作为参数构造函数
这里只要把所有字符串读入并调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入按行读取所有日期，返回一个日期数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Date[] ReadDates() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Date[] d = new Date[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { d[i] = new Date(input[i]); } return d; }</description></item><item><title>1.3.17</title><link>https://alg4.ikesnowy.com/1-3-17/</link><pubDate>Thu, 17 May 2018 21:50:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-17/</guid><description>1.3.17 # 解答 # 和前一题类似，按行读取输入再调用相应构造函数就可以了。
代码 # /// &amp;lt;summary&amp;gt; /// 从标准输入中按行读取所有交易信息，返回一个 Transaction 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Transaction[] ReadTransactions() { char[] split = new char[] { &amp;#39;\n&amp;#39; }; string[] input = Console.In.ReadToEnd().Split(split, StringSplitOptions.RemoveEmptyEntries); Transaction[] t = new Transaction[input.Length]; for (int i = 0; i &amp;lt; input.Length; ++i) { t[i] = new Transaction(input[i]); } return t; }</description></item><item><title>1.3.18</title><link>https://alg4.ikesnowy.com/1-3-18/</link><pubDate>Thu, 17 May 2018 21:51:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-18/</guid><description>1.3.18 # 解答 # 删除该结点的下一个结点。
如下图，没有任何结点指向 y 结点，失去了所有引用的 y 结点会被 GC 清理掉。
代码 # var x = new Node&amp;lt;string&amp;gt;(); x.Item = &amp;#34;first&amp;#34;; var y = new Node&amp;lt;string&amp;gt;(); y.Item = &amp;#34;second&amp;#34;; x.Next = y; var z = new Node&amp;lt;string&amp;gt;(); z.Item = &amp;#34;third&amp;#34;; y.Next = z; Console.WriteLine(&amp;#34;x: &amp;#34; + x.Item); Console.WriteLine(&amp;#34;x.next: &amp;#34; + x.Next.Item); x.Next = x.Next.Next; Console.WriteLine(); Console.WriteLine(&amp;#34;x: &amp;#34; + x.Item); Console.WriteLine(&amp;#34;x.next: &amp;#34; + x.Next.Item); 另请参阅 # Generics 库</description></item><item><title>1.3.19</title><link>https://alg4.ikesnowy.com/1-3-19/</link><pubDate>Thu, 17 May 2018 21:53:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-19/</guid><description>1.3.19 # 解答 # 建立一个结点引用 Cur，让它移动到尾结点的前一个结点，让那个结点的 next 变为 null。
代码 # var first = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;first&amp;#34; }; var second = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;second&amp;#34; }; var third = new Node&amp;lt;string&amp;gt; { Item = &amp;#34;third&amp;#34; }; first.Next = second; second.Next = third; third.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.</description></item><item><title>1.3.20</title><link>https://alg4.ikesnowy.com/1-3-20/</link><pubDate>Fri, 18 May 2018 13:17:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-20/</guid><description>1.3.20 # 解答 # 和上一题类似，只不过这次让 Cur 移动 k – 1 次即可。
代码 # /// &amp;lt;summary&amp;gt; /// 删除指定位置的元素，返回该元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;index&amp;#34;&amp;gt;需要删除元素的位置。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public Item Delete(int index) { if (index &amp;gt;= this.count) { throw new IndexOutOfRangeException(); } Node&amp;lt;Item&amp;gt; front = this.first; Item temp = this.first.item; if (index == 0) { this.first = this.first.next; return temp; } for (int i = 1; i &amp;lt; index; ++i) { front = front.</description></item><item><title>1.3.21</title><link>https://alg4.ikesnowy.com/1-3-21/</link><pubDate>Fri, 18 May 2018 13:28:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-21/</guid><description>1.3.21 # 解答 # 遍历整条链表，方法和前两题类似，用一个结点引用 Cur 去访问就可以了。
代码 # var link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); Console.WriteLine(Find(link, &amp;#34;second&amp;#34;)); Console.WriteLine(Find(link, &amp;#34;fourth&amp;#34;)); static bool Find&amp;lt;TItem&amp;gt;(LinkedList&amp;lt;TItem&amp;gt; link, TItem key) { foreach (var i in link) { if (i.Equals(key)) { return true; } } return false; } 另请参阅 # Generics 库</description></item><item><title>1.3.22</title><link>https://alg4.ikesnowy.com/1-3-22/</link><pubDate>Fri, 18 May 2018 13:30:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-22/</guid><description>1.3.22 # 解答 # 在 x 之后插入 t，如下图所示。
代码 # // 将 t 插入到 x 之后 var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current !</description></item><item><title>1.3.23</title><link>https://alg4.ikesnowy.com/1-3-23/</link><pubDate>Fri, 18 May 2018 13:32:39 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-23/</guid><description>1.3.23 # 解答 # 由于先后问题，y 在第一句代码执行完毕之后无法访问，t 的 next 会指向自己。
代码 # // x.next = t x 的下一个是 t // t.next = x.next t 的下一个和 x 的下一个相同（也就是 t） // 于是 t.next = t, 遍历会出现死循环。 var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.</description></item><item><title>1.3.24</title><link>https://alg4.ikesnowy.com/1-3-24/</link><pubDate>Fri, 18 May 2018 13:34:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-24/</guid><description>1.3.24 # 解答 # 直接把该节点的 next 域设为 null，后续元素就会因无法访问而被清理掉。
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.</description></item><item><title>1.3.25</title><link>https://alg4.ikesnowy.com/1-3-25/</link><pubDate>Fri, 18 May 2018 13:36:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-25/</guid><description>1.3.25 # 解答 # 见练习 1.3.22，加入一些对边界情况的处理即可。
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; first.Next = second; second.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.Next; } InsertAfter(second, third); Console.WriteLine(); current = first; while (current !</description></item><item><title>1.3.26</title><link>https://alg4.ikesnowy.com/1-3-26/</link><pubDate>Fri, 18 May 2018 16:28:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-26/</guid><description>1.3.26 # 解答 # 之前已经写过了删除指定结点（习题 1.3.20）和查找指定结点（习题 1.3.21），结合使用即可。
代码 # var link = new LinkedList&amp;lt;string&amp;gt;(); link.Insert(&amp;#34;first&amp;#34;, 0); link.Insert(&amp;#34;second&amp;#34;, 1); link.Insert(&amp;#34;third&amp;#34;, 2); link.Insert(&amp;#34;third&amp;#34;, 3); link.Insert(&amp;#34;third&amp;#34;, 4); Console.WriteLine(link); Remove(link, &amp;#34;third&amp;#34;); Console.WriteLine(link); static void Remove(LinkedList&amp;lt;string&amp;gt; link, string key) { for (var i = 0; i &amp;lt; link.Size(); i++) { if (link.Find(i) == key) { link.Delete(i); i--; } } } 另请参阅 # Generics 库</description></item><item><title>1.3.27</title><link>https://alg4.ikesnowy.com/1-3-27/</link><pubDate>Fri, 18 May 2018 16:31:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-27/</guid><description>1.3.27 # 解答 # 遍历一遍即可。
代码 # var first = new Node&amp;lt;int&amp;gt;(); var second = new Node&amp;lt;int&amp;gt;(); var third = new Node&amp;lt;int&amp;gt;(); var fourth = new Node&amp;lt;int&amp;gt;(); first.Item = 1; second.Item = 2; third.Item = 3; fourth.Item = 4; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; Console.WriteLine(&amp;#34;Max:&amp;#34; + Max(first)); static int Max(Node&amp;lt;int&amp;gt; first) { var max = 0; var current = first; while (current !</description></item><item><title>1.3.28</title><link>https://alg4.ikesnowy.com/1-3-28/</link><pubDate>Fri, 18 May 2018 16:32:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-28/</guid><description>1.3.28 # 解答 # 其实链表本身就是一个递归结构，链表的定义可以用递归的方式表示：
链表 = 头结点A + 链表B = 头结点A + 头结点B + 链表C……
所以 Max() 可以这么写：
Max(Node&amp;lt;Item&amp;gt; Cur, int nowmax) 如果 Cur 为空，则直接返回 nowmax。 否则检查 Cur 结点的值是否大于目前找到的最大值 nowmax。 如果不大于，继续查找下一个结点，返回 Max(Cur.next, nowmax) 否则，把 nowmax 修改为当前结点的值，继续查找，返回 Max(Cur.next, Cur.item) 代码 # var first = new Node&amp;lt;int&amp;gt;(); var second = new Node&amp;lt;int&amp;gt;(); var third = new Node&amp;lt;int&amp;gt;(); var fourth = new Node&amp;lt;int&amp;gt;(); first.Item = 1; second.Item = 2; third.</description></item><item><title>1.3.29</title><link>https://alg4.ikesnowy.com/1-3-29/</link><pubDate>Fri, 18 May 2018 16:35:56 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-29/</guid><description>1.3.29 # 解答 # 其实就是一个长这样的链表： 显然说 first 和最后一个节点的指针重复了，所以我们只需要保留 last 的指针就行了。
入队（注意顺序） 出队
代码 # Queue.cs # /// &amp;lt;summary&amp;gt; /// 队列类。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中存放的元素。&amp;lt;/typeparam&amp;gt; public class Queue&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Queue() { _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _last == null; } /// &amp;lt;summary&amp;gt; /// 返回队列中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 返回队列中的第一个元素（但不让它出队）。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public TItem Peek() { if (IsEmpty()) throw new InvalidOperationException(&amp;#34;Queue underflow&amp;#34;); return _last.</description></item><item><title>1.3.30</title><link>https://alg4.ikesnowy.com/1-3-30/</link><pubDate>Fri, 18 May 2018 16:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-30/</guid><description>1.3.30 # 解答 # 书中给出了代码，这里说一下递归的实现。
如果说一个链表除了第一个结点剩下的都已经反转了，那么我们就只要把该结点插入到最后就行了（也就是原先的第二个结点之后）。
像这样：
代码 # var first = new Node&amp;lt;string&amp;gt;(); var second = new Node&amp;lt;string&amp;gt;(); var third = new Node&amp;lt;string&amp;gt;(); var fourth = new Node&amp;lt;string&amp;gt;(); first.Item = &amp;#34;first&amp;#34;; second.Item = &amp;#34;second&amp;#34;; third.Item = &amp;#34;third&amp;#34;; fourth.Item = &amp;#34;fourth&amp;#34;; first.Next = second; second.Next = third; third.Next = fourth; fourth.Next = null; var current = first; while (current != null) { Console.Write(current.Item + &amp;#34; &amp;#34;); current = current.</description></item><item><title>1.3.31</title><link>https://alg4.ikesnowy.com/1-3-31/</link><pubDate>Fri, 18 May 2018 16:56:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-31/</guid><description>1.3.31 # 解答 # 双向链表的插入有顺序，务必当心。
双向链表长这样（似乎有一种画法是把空指针画成“接地”的样子）：
删除中间那个： 再插回去：
原则是不要让有用的结点变得无法访问。
代码 # DoubleNode&amp;lt;&amp;gt; # /// &amp;lt;summary&amp;gt; /// 双向链表。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;链表中要存放的元素。&amp;lt;/typeparam&amp;gt; public class DoubleLinkList&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Prev; public DoubleNode&amp;lt;T&amp;gt; Next; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一条双向链表。 /// &amp;lt;/summary&amp;gt; public DoubleLinkList() { _first = null; _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查链表是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回链表中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 在表头插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void InsertFront(TItem item) { var node = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Next = _first, Prev = null }; if (_first !</description></item><item><title>1.3.32</title><link>https://alg4.ikesnowy.com/1-3-32/</link><pubDate>Fri, 18 May 2018 17:00:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-32/</guid><description>1.3.32 # 解答 # 在队列的基础上增加一个在队首插入元素的方法即可。
代码 # Steque.cs # /// &amp;lt;summary&amp;gt; /// Steque。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;Steque 中要存放的元素。&amp;lt;/typeparam&amp;gt; public class Steque&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private Node&amp;lt;TItem&amp;gt; _first; private Node&amp;lt;TItem&amp;gt; _last; private int _count; private class Node&amp;lt;T&amp;gt; { public T Item; public Node&amp;lt;T&amp;gt; Next; } /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; public Steque() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回栈内元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 将一个元素压入栈中。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要压入栈中的元素。&amp;lt;/param&amp;gt; public void Push(TItem item) { var oldFirst = _first; _first = new Node&amp;lt;TItem&amp;gt;(); _first.</description></item><item><title>1.3.33</title><link>https://alg4.ikesnowy.com/1-3-33/</link><pubDate>Fri, 18 May 2018 17:03:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-33/</guid><description>1.3.33 # 解答 # 动态数组这里要注意 first 不要小于零。
代码 # Deque 类 # /// &amp;lt;summary&amp;gt; /// 双端队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; public class Deque&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Next; public DoubleNode&amp;lt;T&amp;gt; Prev; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _count; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _first = null; _last = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回队列中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向左端添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要添加的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.</description></item><item><title>1.3.34</title><link>https://alg4.ikesnowy.com/1-3-34/</link><pubDate>Fri, 18 May 2018 17:06:58 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-34/</guid><description>1.3.34 # 解答 # 在初始化迭代器的时候随机生成一个访问序列，
之后按照这个访问序列进行迭代即可。
代码 # RandomBag.cs # /// &amp;lt;summary&amp;gt; /// 随机背包。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;背包中要存放的元素。&amp;lt;/typeparam&amp;gt; public class RandomBag&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _bag; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一个随机背包。 /// &amp;lt;/summary&amp;gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查背包是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回背包中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向背包中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向背包中添加的元素。&amp;lt;/param&amp;gt; public void Add(TItem item) { if (_count == _bag.</description></item><item><title>1.3.35</title><link>https://alg4.ikesnowy.com/1-3-35/</link><pubDate>Fri, 18 May 2018 17:15:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-35/</guid><description>1.3.35 # 解答 # 事实上只需要在普通队列的基础上稍作修改就可以了。
出队时先随机选择一个元素，之后让它和最开始的元素做交换，之后正常出队即可。
代码 # RandomQueue.cs # /// &amp;lt;summary&amp;gt; /// 随机队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要存放的元素。&amp;lt;/typeparam&amp;gt; public class RandomQueue&amp;lt;TItem&amp;gt; { private TItem[] _queue; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配内存空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { if (capacity &amp;lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// &amp;lt;summary&amp;gt; /// 向队列中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向队列中添加的元素。&amp;lt;/param&amp;gt; public void Enqueue(TItem item) { if (_queue.</description></item><item><title>1.3.36</title><link>https://alg4.ikesnowy.com/1-3-36/</link><pubDate>Fri, 18 May 2018 17:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-36/</guid><description>1.3.36 # 解答 # 实现方法和 1.3.34 类似，初始化迭代器的时候同时初始化一个随机访问序列。
代码 # RandomQueue.cs # /// &amp;lt;summary&amp;gt; /// 随机队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要保存的元素。&amp;lt;/typeparam&amp;gt; public class RandomQueue&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _queue; private int _count; /// &amp;lt;summary&amp;gt; /// 新建一个随机队列。 /// &amp;lt;/summary&amp;gt; public RandomQueue() { _queue = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 判断队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配内存空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { if (capacity &amp;lt;= 0) { throw new ArgumentException(); } var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; } /// &amp;lt;summary&amp;gt; /// 向队列中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向队列中添加的元素。&amp;lt;/param&amp;gt; public void Enqueue(TItem item) { if (_queue.</description></item><item><title>1.3.37</title><link>https://alg4.ikesnowy.com/1-3-37/</link><pubDate>Fri, 18 May 2018 17:17:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-37/</guid><description>1.3.37 # 解答 # 也就是约瑟夫问题，官方给出的 JAVA 版答案：Josephus.java。
报数时将一个人出队然后入队来模拟一个环。
报到 M 个后将那个人出队但不入队（删除）
随后继续循环。
代码 # var numOfPeople = 7; var callForDeath = 2; var queue = new Queue&amp;lt;int&amp;gt;(); for (var i = 0; i &amp;lt; numOfPeople; i++) { queue.Enqueue(i); } while (!queue.IsEmpty()) { for (var i = 0; i &amp;lt; callForDeath - 1; i++) { queue.Enqueue(queue.Dequeue()); } Console.Write(queue.Dequeue() + &amp;#34; &amp;#34;); } Console.</description></item><item><title>1.3.38</title><link>https://alg4.ikesnowy.com/1-3-38/</link><pubDate>Fri, 18 May 2018 17:22:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-38/</guid><description>1.3.38 # 解答 # 这里采用“假删除”的方式，对要删除的元素不直接删除而是打上标记，这样就可以维持插入的顺序。
代码 # 数组实现 # /// &amp;lt;summary&amp;gt; /// 以一维数组为基础的队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;队列中要保存的元素。&amp;lt;/typeparam&amp;gt; internal class ArrayBasedGeneralizeQueue&amp;lt;TItem&amp;gt; { private TItem[] _queue; private bool[] _isVisited; private int _count; private int _last; /// &amp;lt;summary&amp;gt; /// 建立一个队列。 /// &amp;lt;/summary&amp;gt; public ArrayBasedGeneralizeQueue() { _queue = new TItem[2]; _isVisited = new bool[2]; _last = 0; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查队列是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 为队列重新分配空间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; private void Resize(int capacity) { var temp = new TItem[capacity]; for (var i = 0; i &amp;lt; _count; i++) { temp[i] = _queue[i]; } _queue = temp; var t = new bool[capacity]; for (var i = 0; i &amp;lt; _count; i++) { t[i] = _isVisited[i]; } _isVisited = t; } /// &amp;lt;summary&amp;gt; /// 向队列中插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入队列的元素。&amp;lt;/param&amp;gt; public void Insert(TItem item) { if (_count == _queue.</description></item><item><title>1.3.39</title><link>https://alg4.ikesnowy.com/1-3-39/</link><pubDate>Fri, 18 May 2018 17:24:29 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-39/</guid><description>1.3.39 # 解答 # 可以直接套用队列的实现方式，在满或空时抛出相应异常。
代码 # /// &amp;lt;summary&amp;gt; /// 环形缓冲区。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;缓冲区包含的元素类型。&amp;lt;/typeparam&amp;gt; internal class RingBuffer&amp;lt;TItem&amp;gt; { private readonly TItem[] _buffer; private int _count; private int _first; // 读指针 private int _last; // 写指针 /// &amp;lt;summary&amp;gt; /// 建立一个缓冲区。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;缓冲区的大小。&amp;lt;/param&amp;gt; public RingBuffer(int n) { _buffer = new TItem[n]; _count = 0; _first = 0; _last = 0; } /// &amp;lt;summary&amp;gt; /// 检查缓冲区是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _count == _buffer.</description></item><item><title>1.3.40</title><link>https://alg4.ikesnowy.com/1-3-40/</link><pubDate>Fri, 18 May 2018 17:29:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-40/</guid><description>1.3.40 # 解答 # 每次插入时都先搜索一遍链表，再判定相应动作。
代码 # /// &amp;lt;summary&amp;gt; /// 前移编码队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;typeparam name=&amp;#34;TItem&amp;#34;&amp;gt;需要前移编码的元素类型。&amp;lt;/typeparam&amp;gt; internal class MoveToFront&amp;lt;TItem&amp;gt; { private class Node&amp;lt;T&amp;gt; { public T Item; public Node&amp;lt;T&amp;gt; Next; } private Node&amp;lt;TItem&amp;gt; _first; private int _count; /// &amp;lt;summary&amp;gt; /// 检查编码组是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _first == null; } /// &amp;lt;summary&amp;gt; /// 建立一个前移编码组。 /// &amp;lt;/summary&amp;gt; public MoveToFront() { _first = null; _count = 0; } /// &amp;lt;summary&amp;gt; /// 找到相应元素的前驱结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要寻找的元素。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; private Node&amp;lt;TItem&amp;gt; Find(TItem item) { if (IsEmpty()) { return null; } var current = _first; while (current.</description></item><item><title>1.3.41</title><link>https://alg4.ikesnowy.com/1-3-41/</link><pubDate>Mon, 21 May 2018 21:17:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-41/</guid><description>1.3.41 # 解答 # 可以按照书上的提示出队再入队，也可以直接用迭代器访问一遍进行复制。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;r&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Queue(Queue&amp;lt;Item&amp;gt; r) { foreach (Item i in r) { Enqueue(i); } }</description></item><item><title>1.3.42</title><link>https://alg4.ikesnowy.com/1-3-42/</link><pubDate>Mon, 21 May 2018 21:19:12 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-42/</guid><description>1.3.42 # 解答 # 直接把链栈的整个链表复制一份即可。
代码 # /// &amp;lt;summary&amp;gt; /// 复制构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public Stack(Stack&amp;lt;Item&amp;gt; s) { if (s.first != null) { this.first = new Node&amp;lt;Item&amp;gt;(s.first); for (Node&amp;lt;Item&amp;gt; x = this.first; x.next != null; x = x.next) { x.next = new Node&amp;lt;Item&amp;gt;(x.next); } } this.count = s.count; }</description></item><item><title>1.3.43</title><link>https://alg4.ikesnowy.com/1-3-43/</link><pubDate>Mon, 21 May 2018 21:20:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-43/</guid><description>1.3.43 # 解答 # C# 中可以用 Directory 类里面的几个方法来获得文件路径和文件名。
代码 # // 获取当前目录 var path = Directory.GetCurrentDirectory(); path = Directory.GetParent(path).FullName; path = Directory.GetParent(path).FullName; // 获取文件 Console.WriteLine(path + &amp;#34;中的所有文件&amp;#34;); Search(path, 0); static void Search(string path, int tabs) { var dirs = Directory.GetDirectories(path); var files = Directory.GetFiles(path); foreach (var p in dirs) { for (var i = 0; i &amp;lt; tabs; i++) { Console.</description></item><item><title>1.3.44</title><link>https://alg4.ikesnowy.com/1-3-44/</link><pubDate>Mon, 21 May 2018 21:21:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-44/</guid><description>1.3.44 # 解答 # 这里我们使用两个栈来模拟缓冲区。
向左/向右移动 = 从左/右栈弹出相应数量的元素并压入另外一个栈。
插入/删除 = 左栈压入/弹出一个元素。
字符数量 = 左栈数量 + 右栈数量。
代码 # internal class Buffer { private readonly Stack&amp;lt;char&amp;gt; _leftside; private readonly Stack&amp;lt;char&amp;gt; _rightside; /// &amp;lt;summary&amp;gt; /// 建立一个文本缓冲区。 /// &amp;lt;/summary&amp;gt; public Buffer() { _leftside = new Stack&amp;lt;char&amp;gt;(); _rightside = new Stack&amp;lt;char&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 在光标位置插入字符 c。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;c&amp;#34;&amp;gt;要插入的字符。&amp;lt;/param&amp;gt; public void Insert(char c) { _leftside.</description></item><item><title>1.3.45</title><link>https://alg4.ikesnowy.com/1-3-45/</link><pubDate>Tue, 22 May 2018 13:39:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-45/</guid><description>1.3.45 # 解答 # 书上已经给出了思路，简单说明一下。
第一问是给定输入判断是否会下溢出，只要记录栈中元素的数量即可，一旦为负数则返回 true。
第二问是给定输出判断是否可能。
对于输出序列中的每一个数，如果栈顶为空或者栈顶数字小于当前输出序列的数，那么就从输入序列中输入数字，直到栈顶数字和当前输出序列中的数字相等。
如果当前输出序列中的数字和栈顶元素相等，从栈中弹出相应元素。
最后如果栈为空则可能，否则不可能。
可以结合习题 1.3.3 的解答查看。
通用解法见下一题。
代码 # // 给定输入序列，判断是否会出现下溢出。 var input = &amp;#34;- 0 1 2 3 4 5 6 7 8 9 - - - - - - - - -&amp;#34;; Console.WriteLine(IsUnderflow(input.Split(&amp;#39; &amp;#39;))); //True input = &amp;#34;0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 -&amp;#34;; Console.</description></item><item><title>1.3.46</title><link>https://alg4.ikesnowy.com/1-3-46/</link><pubDate>Tue, 22 May 2018 13:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-46/</guid><description>1.3.46 # 解答 # 这道题的解答参考了这篇博文：http://ceeji.net/blog/forbidden-triple-for-stack-generability/。
显然书中的解答已经十分明确，这里简单说明一下：
首先有结论：对于栈顶元素 Sn，栈中所有小于 Sn 的值都以递减形式保存（已经输出的不算）。
表现在输出序列中，Sn 输出之后，如果有小于 Sn 的值输出，其顺序必定是递减的。
例如序列 4 3 2 1 0 9 8 7 6 5
4 输出之后，3 2 1 0 递减输出；9 输出之后，8 7 6 5 递减输出。
依次验证其中的每个值都能满足结论。
而对于序列 4 6 8 7 5 3 2 9 0 1
对于 4，之后的 3 2 1 0 并不是以递减顺序输出的，因此这个序列是不合法的。</description></item><item><title>1.3.47</title><link>https://alg4.ikesnowy.com/1-3-47/</link><pubDate>Tue, 22 May 2018 13:42:37 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-47/</guid><description>1.3.47 # 解答 # 这里用的都是链式结构，头尾相接即可。
代码 # Queue # /// &amp;lt;summary&amp;gt; /// 在当前队列之后附加一个队列。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;q1&amp;#34;&amp;gt;需要被附加的队列。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q2&amp;#34;&amp;gt;需要附加的队列（将被删除）。&amp;lt;/param&amp;gt; public static Queue&amp;lt;Item&amp;gt; Catenation(Queue&amp;lt;Item&amp;gt; q1, Queue&amp;lt;Item&amp;gt; q2) { if (q1.IsEmpty()) { q1.first = q2.first; q1.last = q2.last; q1.count = q2.count; } else { q1.last.next = q2.first; q1.last = q2.last; q1.count += q2.count; } q2 = null; return q1; } Stack # /// &amp;lt;summary&amp;gt; /// 将两个栈连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;s1&amp;#34;&amp;gt;第一个栈。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;s2&amp;#34;&amp;gt;第二个栈（将被删除）。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static Stack&amp;lt;Item&amp;gt; Catenation(Stack&amp;lt;Item&amp;gt; s1, Stack&amp;lt;Item&amp;gt; s2) { if (s1.</description></item><item><title>1.3.48</title><link>https://alg4.ikesnowy.com/1-3-48/</link><pubDate>Wed, 23 May 2018 09:06:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-48/</guid><description>1.3.48 # 解答 # 按照双向队列原本的操作就可以实现，需要维护两个栈的长度以防越界。（左侧栈弹出了右侧栈栈底的内容）
代码 # public class DeStack&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private class DoubleNode&amp;lt;T&amp;gt; { public T Item; public DoubleNode&amp;lt;T&amp;gt; Next; public DoubleNode&amp;lt;T&amp;gt; Prev; } private DoubleNode&amp;lt;TItem&amp;gt; _first; private DoubleNode&amp;lt;TItem&amp;gt; _last; private int _leftCount; private int _rightCount; /// &amp;lt;summary&amp;gt; /// 默认构造函数，建立一个双端栈。 /// &amp;lt;/summary&amp;gt; public DeStack() { _first = null; _last = null; _leftCount = 0; _rightCount = 0; } /// &amp;lt;summary&amp;gt; /// 检查左侧栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsLeftEmpty() { return _leftCount == 0; } /// &amp;lt;summary&amp;gt; /// 检查右侧栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsRightEmpty() { return _rightCount == 0; } /// &amp;lt;summary&amp;gt; /// 返回左侧栈中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int LeftSize() { return _leftCount; } /// &amp;lt;summary&amp;gt; /// 返回右侧栈中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int RightSize() { return _rightCount; } /// &amp;lt;summary&amp;gt; /// 向左端添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要添加的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { var oldFirst = _first; _first = new DoubleNode&amp;lt;TItem&amp;gt; { Item = item, Prev = null, Next = oldFirst }; if (oldFirst == null) { _last = _first; } else { oldFirst.</description></item><item><title>1.3.49</title><link>https://alg4.ikesnowy.com/1-3-49/</link><pubDate>Wed, 23 May 2018 09:17:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-49/</guid><description>1.3.49 # 解答 # 那么这里就使用六个栈来解决这个问题。 这个算法来自于这篇论文。
原文里用的是 Pure Lisp，不过语法很简单，还是很容易看懂的。
先导知识——用两个栈模拟一个队列 # 如何使用两个栈来模拟一个队列操作？
这是一道很经典的题目，答案也有很多种，这里只介绍之后会用到的一种方法。
首先我们有两个栈，H 和 T，分别用作出队和入队用。
这样，入队操作等同于向 T 添加元素，T 的入栈操作只需要 O(1) 时间。
如果 H 不为空，出队操作等同于 H 弹栈，H 的弹栈操作也只需要 O(1) 时间。
但如果 H 为空，则需要将 T 中的元素依次弹出并压入到 H 中，这是一个 O(n) 的操作。
显然，这种方式中，出队操作的最坏时间复杂度是 O(n)，并不满足题目要求。
分摊 O(n) # 那么，怎么解决这个问题呢？
一个很自然的想法是，如果在栈 H 变为空之前，我们就能逐步将栈 T 的内容弹出并压入到另一个栈 H&amp;rsquo; 中，等到栈 H 为空时，直接交换 H 和 H&amp;rsquo; 即可。
假设目前的队列状态是这样，有三个元素等待出队，还有三个元素等待入队。
现在依次让三个元素出队，与此同时我们让栈 T 中的元素依次进入 H&amp;rsquo; 中。
每一次出队都执行两个操作，元素出队和元素复制（Pop &amp;amp; Push），时间复杂度 O(1) + O(1) + O(1) = O(1)。</description></item><item><title>1.3.50</title><link>https://alg4.ikesnowy.com/1-3-50/</link><pubDate>Wed, 23 May 2018 16:52:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-3-50/</guid><description>1.3.50 # 解答 # 初始化迭代器的时候记录栈已经进行过的 Pop 和 Push 数，迭代的时候检查这两个值是否改变，一旦改变就抛出异常。
代码 # private class StackEnumerator : IEnumerator&amp;lt;Item&amp;gt; { private Stack&amp;lt;Item&amp;gt; s; private int popcount; private int pushcount; private Node&amp;lt;Item&amp;gt; current; public StackEnumerator(Stack&amp;lt;Item&amp;gt; s) { this.s = s; this.current = s.first; this.popcount = s.popcount; this.pushcount = s.pushcount; } Item IEnumerator&amp;lt;Item&amp;gt;.Current =&amp;gt; current.item; object IEnumerator.</description></item><item><title>1.4.1</title><link>https://alg4.ikesnowy.com/1-4-1/</link><pubDate>Wed, 23 May 2018 18:21:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-1/</guid><description>1.4.1 # 解答 # 即为证明组合计算公式：
$C(N, 3)$
$= N! / [(N - 3)! × 3!]$
$= [(N - 2) * (N - 1) * N] / 3!$
$= N(N - 1)(N - 2) / 6$
显然 N 必须大于等于 3。
$N = 3$ 时公式正确，只有一种组合。
$N = 4$ 时公式正确，只有四种组合。
扩展到 $N+1$ 个数，将 $N = N + 1$ 代入，可得：
$(N + 1)N(N - 1) / 6$
$N + 1$ 个数能组成的三位数组合可以这样理解
前 N 个数中取三个数的所有组合 +多出的一个数和前 N 个数中的任意取两个数的所有组合</description></item><item><title>1.4.2</title><link>https://alg4.ikesnowy.com/1-4-2/</link><pubDate>Wed, 23 May 2018 18:35:38 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-2/</guid><description>1.4.2 # 解答 # 将 a[i] + a[j] + a[k] 改为 (long)a[i] + a[j] + a[k] 即可。
此时整个式子将按照精度最高（也就是 long）的标准计算。
long.MaxValue = 9223372036854775807 &amp;gt; int.MaxValue * 3 = 6442450941 代码 # /// &amp;lt;summary&amp;gt; /// 计算和为零的三元组的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;输入数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;和为零的三元组的数量。&amp;lt;/returns&amp;gt; public static int Count(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { for (var k = j + 1; k &amp;lt; n; k++) { if ((long)a[i] + a[j] + a[k] == 0) { count++; } } } } return count; } 另请参阅 # Measurement 库</description></item><item><title>1.4.3</title><link>https://alg4.ikesnowy.com/1-4-3/</link><pubDate>Wed, 23 May 2018 18:37:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-3/</guid><description>1.4.3 # 解答 # 见代码，这里贴出绘图函数，窗体只是在得到测试结果之后简单调用以下这两个函数。
代码 # public static void PaintLinear(double[] testResult) { //新建一个绘图窗口 Form2 linear = new Form2(); linear.Show(); //新建画布 Graphics canvas = linear.CreateGraphics(); //获取窗口区域 Rectangle rect = linear.ClientRectangle; //计算单位长度（十等分） int unitY = rect.Height / 10; int unitX = rect.Width / 10; //获取中心区域（上下左右增加 10% 的内补） Rectangle center = new Rectangle(rect.X + unitX, rect.Y + unitY, unitX * 8, unitY * 8); //绘制坐标系 canvas.</description></item><item><title>1.4.4</title><link>https://alg4.ikesnowy.com/1-4-4/</link><pubDate>Wed, 23 May 2018 18:39:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-4/</guid><description>1.4.4 # 解答 #</description></item><item><title>1.4.5</title><link>https://alg4.ikesnowy.com/1-4-5/</link><pubDate>Wed, 23 May 2018 18:41:31 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-5/</guid><description>1.4.5 # 解答 # 类似于取极限的做法。
a. $N$
b. $1$
c. $1$
d. $2N^3$
e. $1$
f. $2$
g. $\frac{N^{100}}{2^n}$</description></item><item><title>1.4.6</title><link>https://alg4.ikesnowy.com/1-4-6/</link><pubDate>Wed, 23 May 2018 20:49:24 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-6/</guid><description>1.4.6 # 解答 # a. N + N/2 + N/4 + … = ~2N，线性。
b. 1 + 2 + 4 + … = ~2N，线性。
c. NlogN，线性对数。</description></item><item><title>1.4.7</title><link>https://alg4.ikesnowy.com/1-4-7/</link><pubDate>Wed, 23 May 2018 21:11:35 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-7/</guid><description>1.4.7 # 解答 # 最外层循环进行了 N 次比较。
次外层循环进行了 N^2 次比较。
最里层循环进行了 N^3 次比较。
内部 if 语句进行了 N^3 次比较。
if 内部进行了 N(N-1) 次加法。
加起来，~2N^3。</description></item><item><title>1.4.8</title><link>https://alg4.ikesnowy.com/1-4-8/</link><pubDate>Wed, 23 May 2018 21:12:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-8/</guid><description>1.4.8 # 解答 # 平方级别：直接二层循环遍历一遍。
线性对数：
先对数组排序，然后遍历一遍数组，在遍历过程中计算重复元素的数量，
然后用公式 $1+2+\cdots+n-1=n(n-1)/2$ 计算重复整数对的数量。
代码 # /// &amp;lt;summary&amp;gt; /// 暴力查找数组中相等的整数对。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int CountEqual(int[] a) { var n = a.Length; var count = 0; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { if (a[i] == a[j]) count++; } } return count; } /// &amp;lt;summary&amp;gt; /// 利用 Array.</description></item><item><title>1.4.9</title><link>https://alg4.ikesnowy.com/1-4-9/</link><pubDate>Wed, 23 May 2018 21:14:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-9/</guid><description>1.4.9 # 解答 # 由题意可得：
$$ T(2N_0)=2^bT\newline T(4N_0)=2^b(2^bT)=2^{2b}T\newline &amp;hellip;&amp;hellip;\newline T(2^rN_0)=2^{rb}T $$
设：
$$ N=2^rN_0 $$
则：
$$ r=log_2(\frac{N}{N_0}) $$
所以：
$$ T(N) = 2^{log_2(\frac{N}{N_0})b}T $$</description></item><item><title>1.4.10</title><link>https://alg4.ikesnowy.com/1-4-10/</link><pubDate>Wed, 23 May 2018 21:19:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-10/</guid><description>1.4.10 # 解答 # 修改二分查找的结束条件，找到后仍然向左侧寻找，如果还能找到更小的，则返回较小的下标；否则返回当前下标。
代码 # public static int Rank(int key, int[] a, int lo, int hi) { if (hi &amp;lt; lo) return -1; var mid = (hi - lo) / 2 + lo; if (a[mid] == key) { var mini = Rank(key, a, lo, mid - 1); if (mini != -1) return mini; return mid; } if (a[mid] &amp;lt; key) { return Rank(key, a, mid + 1, hi); } return Rank(key, a, lo, mid - 1); }</description></item><item><title>1.4.11</title><link>https://alg4.ikesnowy.com/1-4-11/</link><pubDate>Wed, 23 May 2018 21:21:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-11/</guid><description>1.4.11 # 解答 # 这里给出官网上的 Java 实现：StaticSETofInts.java。
howMany() 可以用二分查找实现，在找到一个值后继续向两侧查找，最后返回找到的次数。
代码 # /// &amp;lt;summary&amp;gt; /// 有序数组，能够快速查找并自动维护其中的顺序。 /// &amp;lt;/summary&amp;gt; public class StaticSeTofInts { private readonly int[] _a; /// &amp;lt;summary&amp;gt; /// 用一个数组初始化有序数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;keys&amp;#34;&amp;gt;源数组。&amp;lt;/param&amp;gt; public StaticSeTofInts(int[] keys) { _a = new int[keys.Length]; for (var i = 0; i &amp;lt; keys.Length; i++) { _a[i] = keys[i]; } Array.</description></item><item><title>1.4.12</title><link>https://alg4.ikesnowy.com/1-4-12/</link><pubDate>Wed, 23 May 2018 21:23:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-12/</guid><description>1.4.12 # 解答 # 由于两个数组都是有序的，可以同时进行比较。
设 i, j 分别为两个数组的下标。
如果 a[i] == a[j]，i 和 j 都向后移动一位。
如果 a[i] != a[j]，比较小的那个向后移动一位。
循环直到某个数组遍历完毕。
这样最后的时间复杂度 ~2N
代码 # var a = new[] { 2, 3, 4, 10 }; var b = new[] { 1, 3, 3, 5, 10, 11 }; // 2N 次数组访问，数组 a 和数组 b 各遍历一遍 for (int i = 0, j = 0; i &amp;lt; a.Length &amp;amp;&amp;amp; j &amp;lt; b.</description></item><item><title>1.4.13</title><link>https://alg4.ikesnowy.com/1-4-13/</link><pubDate>Wed, 23 May 2018 21:25:06 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-13/</guid><description>1.4.13 # 解答 # 对象的固定开销用 Object 表示。
a. Accumulator 使用 1.2.4.3 节给出的实现。
= int * 1 + double + Object * 1 = 4 * 1 + 8 + 16 * 1 = 32 b. Transaction
= string * 1 + Date * 1 + double * 1 + Object * 1 = (40 + 16 + 4 + 4 + 2N) * 1 + (8 + 32) * 1 + 8 * 1 + 16 * 1 = 128 + 2N c.</description></item><item><title>1.4.14</title><link>https://alg4.ikesnowy.com/1-4-14/</link><pubDate>Wed, 23 May 2018 21:27:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-14/</guid><description>1.4.14 # 解答 # 这里给出暴力方法，将最内侧循环换成二分查找即为优化版本。
代码 # public static class FourSum { /// &amp;lt;summary&amp;gt; /// 输出数组中所有和为 0 的四元组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;包含所有元素的数组。&amp;lt;/param&amp;gt; public static void PrintAll(long[] a) { var n = a.Length; for (var i = 0; i &amp;lt; n; i++) { for (var j = i + 1; j &amp;lt; n; j++) { for (var k = j + 1; k &amp;lt; n; k++) { for (var l = k + 1; l &amp;lt; n; l++) { if (a[i] + a[j] + a[k] + a[l] == 0) { Console.</description></item><item><title>1.4.15</title><link>https://alg4.ikesnowy.com/1-4-15/</link><pubDate>Wed, 23 May 2018 21:28:16 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-15/</guid><description>1.4.15 # 解答 # 由于数组已经排序（从小到大），负数在左侧，正数在右侧。
TwoSumFaster
设最左侧下标为 lo，最右侧下标为 hi。
如果 a[lo] + a[hi] &amp;gt; 0, 说明正数太大，hi&amp;ndash;。
如果 a[lo] + a[hi] &amp;lt; 0，说明负数太小，lo++。
否则就找到了一对和为零的整数对，lo++, hi&amp;ndash;。
ThreeSumFaster
对于数组中的每一个数 a，ThreeSum 问题就等于求剩余数组中所有和为 -a 的 TwoSum 问题。
只要在 TwoSumFaster 外层再套一个循环即可。
代码 # /// &amp;lt;summary&amp;gt; /// TwoSum 的快速实现。（线性级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的整数对数量。&amp;lt;/returns&amp;gt; static int TwoSumFaster(int[] a) { var lo = 0; var hi = a.Length - 1; var count = 0; while (lo &amp;lt; hi) { if (a[lo] + a[hi] == 0) { count++; lo++; hi--; } else if (a[lo] + a[hi] &amp;lt; 0) { lo++; } else { hi--; } } return count; } /// &amp;lt;summary&amp;gt; /// ThreeSum 的快速实现。（平方级别） /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;需要查找的数组范围。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;数组中和为零的三元组数量。&amp;lt;/returns&amp;gt; static int ThreeSumFaster(int[] a) { var count = 0; for (var i = 0; i &amp;lt; a.</description></item><item><title>1.4.16</title><link>https://alg4.ikesnowy.com/1-4-16/</link><pubDate>Wed, 23 May 2018 21:29:44 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-16/</guid><description>1.4.16 # 解答 # 先将数组从小到大排序，再遍历一遍即可得到差距最小的两个数。
排序算法需要消耗 NlogN，具体见 MSDN：Array.Sort 方法 (Array)。
代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; Array.Sort(a); // Nlog(N) 具体见 https://msdn.microsoft.com/zh-cn/library/6tf1f0bc(v=vs.110).aspx 备注部分 var minDiff = double.MaxValue; double minA = 0; double minB = 0; for (var i = 0; i &amp;lt; a.Length - 1; i++) //N { if (a[i + 1] - a[i] &amp;lt; minDiff) { minA = a[i]; minB = a[i + 1]; minDiff = a[i + 1] - a[i]; } } Console.</description></item><item><title>1.4.17</title><link>https://alg4.ikesnowy.com/1-4-17/</link><pubDate>Wed, 23 May 2018 21:31:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-17/</guid><description>1.4.17 # 解答 # 遍历找到最小值和最大值即可。
代码 # var a = new[] { 0.1, 0.3, 0.6, 0.8, 0 }; double min = int.MaxValue; double max = int.MinValue; for (var i = 0; i &amp;lt; a.Length; i++) { if (a[i] &amp;gt; max) { max = a[i]; } if (a[i] &amp;lt; min) { min = a[i]; } } Console.WriteLine($&amp;#34;MaxDiff Pair: {min} {max}, Max Difference: {Math.</description></item><item><title>1.4.18</title><link>https://alg4.ikesnowy.com/1-4-18/</link><pubDate>Wed, 23 May 2018 21:38:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-18/</guid><description>1.4.18 # 解答 # 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。
在三个数中比较得到最小值需要两次比较，因此最坏情况下为 $~2\lg N$ 次比较。
代码 # var a = new[] { 1, 2, 5, 3, 5 }; Console.WriteLine(LocalMinimum(a)); static int LocalMinimum(int[] a) { var lo = 0; var hi = a.Length - 1; while (lo &amp;lt;= hi) { var mid = (hi - lo) / 2 + lo; var min = mid; // 取左中右最小值的下标 if (mid !</description></item><item><title>1.4.19</title><link>https://alg4.ikesnowy.com/1-4-19/</link><pubDate>Wed, 23 May 2018 21:42:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-19/</guid><description>1.4.19 # 解答 # 问题类似于 POJ 上的一道题「滑雪」，从数值较高的一侧向周围数值较小的一侧移动，直到到达「山谷」（局部最小）。
首先在中间行搜索最小值，再将最小值与其上下两个元素比较，如果不满足题意，则“滑向”较小的一侧，矩阵被分为了两半（上下两侧）。
在较小的一侧，找到中间列的最小值，再将最小值与其左右两个元素比较，如果不满足题意，类似的移动到较小的一侧（左右两侧）。
现在查找范围缩小到了原来矩阵的四分之一，递归的进行上述操作，最后可以得到答案。
每次查找最小值都是对行/列进行遍历，遍历耗时和 N 成正比。
代码 # // 先查找 N/2 行中的最小元素，并令其与上下元素比较， // 如果不满足题意，则向相邻的最小元素靠近再次查找 var matrix = new[,] { { 26, 3, 4, 10, 11 }, { 5, 1, 6, 12, 13 }, { 7, 8, 9, 14, 15 }, { 16, 17, 18, 27, 20 }, { 21, 22, 23, 24, 25 } }; Console.</description></item><item><title>1.4.20</title><link>https://alg4.ikesnowy.com/1-4-20/</link><pubDate>Wed, 23 May 2018 21:57:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-20/</guid><description>1.4.20 # 解答 # 首先给出 BitMax 类的官方 Java 实现：BitonicMax.java。
我们使用这个类生成双调数组，并使用其中的 Max() 方法找到双调数组的最大值。
找到最大值之后分别对左右两侧进行二分查找，注意对于升序和降序的数组二分查找的实现有所不同。
代码 # BitonicMax 类 # public class BitonicMax { /// &amp;lt;summary&amp;gt; /// 生成双调数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;数组的大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static int[] Bitonic(int n) { var random = new Random(); var mid = random.Next(n); var a = new int[n]; for (var i = 1; i &amp;lt; mid; i++) { a[i] = a[i - 1] + 1 + random.</description></item><item><title>1.4.21</title><link>https://alg4.ikesnowy.com/1-4-21/</link><pubDate>Wed, 23 May 2018 21:59:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-21/</guid><description>1.4.21 # 解答 # 直接将 Contains() 实现为二分查找即可。
代码 # /// &amp;lt;summary&amp;gt; /// 检查数组中是否存在指定元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;要查找的值。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;存在则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; public bool Contains(int key) { return Rank(key, 0, this.a.Length - 1) != -1; } /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键值。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;lo&amp;#34;&amp;gt;查找的起始下标。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;hi&amp;#34;&amp;gt;查找的结束下标。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回关键值的下标，如果不存在则返回 -1。&amp;lt;/returns&amp;gt; public int Rank(int key, int lo, int hi) { while (lo &amp;lt;= hi) { int mid = (hi - lo) / 2 + lo; if (key &amp;lt; this.</description></item><item><title>1.4.22</title><link>https://alg4.ikesnowy.com/1-4-22/</link><pubDate>Wed, 23 May 2018 22:00:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-22/</guid><description>1.4.22 # 解答 # 普通二分查找是通过除法不断减半缩小搜索范围。
这里我们用斐波那契数列来缩小范围。
举个例子，例如数组大小是 100，比它大的最小斐波那契数是 144。
斐波那契数列如下：0 1 1 2 3 5 8 13 21 34 55 89 144
我们记 F(n) = 144,F(n-1) = 89, F(n-2) = 55。
我们先查看第 0 + F(n-2) 个数，如果比关键值小则直接将范围缩小到 [55, 100]；否则则在[0, 55]之间查找。
之后我们令 n = n-1。
递归上述过程即可完成查找。
代码 # /// &amp;lt;summary&amp;gt; /// 使用斐波那契数列进行的查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回查找到的关键值下标，没有结果则返回 -1。&amp;lt;/returns&amp;gt; static int Rank(int[] a, int key) { // 使用斐波那契数列作为缩减范围的依据 var fk = 1; var fk1 = 1; var fk2 = 0; // 获得 Fk，Fk需要大于等于数组的大小，复杂度 lgN while (fk &amp;lt; a.</description></item><item><title>1.4.23</title><link>https://alg4.ikesnowy.com/1-4-23/</link><pubDate>Wed, 23 May 2018 22:02:30 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-23/</guid><description>1.4.23 # 解答 # 根据书中的提示，将二分查找中判断相等的条件改为两个数的差小于等于 $1/N^2$。
代码 # // 将二分查找中的相等判定条件修改为差值小于 x，其中 x = 1/N^2。 /// &amp;lt;summary&amp;gt; /// 二分查找。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;查找范围。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;key&amp;#34;&amp;gt;关键字。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结果的下标，没有结果时返回 -1。&amp;lt;/returns&amp;gt; static int BinarySearch(double[] a, double key) { var lo = 0; var hi = a.Length - 1; var threshold = 1.0 / (a.Length * a.Length); while (lo &amp;lt;= hi) { var mid = lo + (hi - lo) / 2; if (Math.</description></item><item><title>1.4.24</title><link>https://alg4.ikesnowy.com/1-4-24/</link><pubDate>Wed, 23 May 2018 22:03:52 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-24/</guid><description>1.4.24 # 解答 # 第一问：二分查找即可。
第二问： 按照第 1, 2, 4, 8,&amp;hellip;, 2^k 层顺序查找，一直到 2^k &amp;gt; F， 随后在 [2^(k - 1), 2^k] 范围中二分查找。
代码 # 这里建立了一个结构体用于返回测试结果：
internal struct TestResult { public int F; // 找到的 F 值。 public int BrokenEggs; // 打碎的鸡蛋数。 } 用于测试的方法：
/// &amp;lt;summary&amp;gt; /// 扔鸡蛋，没碎返回 true，碎了返回 false。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;floor&amp;#34;&amp;gt;扔鸡蛋的高度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static bool ThrowEgg(int floor) { return floor &amp;lt;= f; } /// &amp;lt;summary&amp;gt; /// 第一种方案。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;a&amp;#34;&amp;gt;大楼。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static TestResult PlanA(int[] a) { var lo = 0; var hi = a.</description></item><item><title>1.4.25</title><link>https://alg4.ikesnowy.com/1-4-25/</link><pubDate>Wed, 23 May 2018 22:07:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-25/</guid><description>1.4.25 # 解答 # 第一问：
第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),&amp;hellip;, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k &amp;lt;= √(N)。
k-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次。
第二问：
按照第 1, 3, 6, 10,&amp;hellip;, 1/2k^2 层顺序查找，一直到 1/2k^2 &amp;gt; F，
随后在 [1/2k^2 - k, 1/2k^2] 范围中顺序查找。
代码 # 这里我们同样定义了一个结构体：
internal struct TestResult { public int F; // 测试得出的 F 值 public int BrokenEggs; // 碎掉的鸡蛋数。 public int ThrowTimes; // 扔鸡蛋的次数。 } 之后是测试用的方法：</description></item><item><title>1.4.26</title><link>https://alg4.ikesnowy.com/1-4-26/</link><pubDate>Wed, 23 May 2018 22:09:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-26/</guid><description>1.4.26 # 解答 # 首先，我们将问题转化为证明三点
$$ A(a,a^3),B(b,b^3),C(c,c^3) $$
共线，当且仅当满足
$$ a+b+c=0 $$
证明： 若 $A,B,C$ 三点共线，则直线 $AB$ 和 $BC$ 的斜率必定相等，有方程：
$$ \frac{b^3-a^3}{b-a}=\frac{c^3-b^3}{c-b} $$
由立方差公式：
$$ \frac{(b-a)(b^2+ba+a^2)}{b-a}=\frac{(c-b)(c^2+cb+b^2)}{c-b} $$
化简有：
$$ b^2+ba+a^2=c^2+cb+b^2\newline ba+a^2=c^2+cb $$
移项，将 $c$ 视为未知数：
$$ c^2+cb-ba-a^2=0 $$
利用十字相乘法进行因式分解：
$$ (a+b+c)(c-a)=0 $$
解得：
$$ c_1=-a-b,c_2=a $$
显然 $c\ne a$ ，因此当且仅当 $a+b+c=0$ 时 $A,B,C$ 三点共线。 证毕。</description></item><item><title>1.4.27</title><link>https://alg4.ikesnowy.com/1-4-27/</link><pubDate>Wed, 23 May 2018 22:20:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-27/</guid><description>1.4.27 # 解答 # 实现比较简单，想象两个栈背靠背接在一起，左侧栈负责出队，右侧栈负责入队。
当左侧栈为空时就把右侧栈中的元素倒到左侧栈，这个过程是 O(n) 的。
但在这个过程之前必然有 n 个元素入栈，均摊后即为 O(1)。
代码 # internal class StackQueue&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _h;// 用于保存出队元素 private readonly Stack&amp;lt;TItem&amp;gt; _;// 用于保存入队元素 /// &amp;lt;summary&amp;gt; /// 构造一个队列。 /// &amp;lt;/summary&amp;gt; public StackQueue() { _h = new Stack&amp;lt;TItem&amp;gt;(); _ = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 将栈 T 中的元素依次弹出并压入栈 H 中。 /// &amp;lt;/summary&amp;gt; private void Reverse() { while (!</description></item><item><title>1.4.28</title><link>https://alg4.ikesnowy.com/1-4-28/</link><pubDate>Thu, 31 May 2018 09:12:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-28/</guid><description>1.4.28 # 解答 # 每次入队的时候将队列倒转，这样入队的元素就是第一个了。
代码 # internal class QueueStack&amp;lt;TItem&amp;gt; { private readonly Queue&amp;lt;TItem&amp;gt; _queue; /// &amp;lt;summary&amp;gt; /// 初始化一个栈。 /// &amp;lt;/summary&amp;gt; public QueueStack() { _queue = new Queue&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(TItem item) { _queue.Enqueue(item); var size = _queue.Size(); // 倒转队列 for (var i = 0; i &amp;lt; size - 1; i++) { _queue.</description></item><item><title>1.4.29</title><link>https://alg4.ikesnowy.com/1-4-29/</link><pubDate>Thu, 31 May 2018 09:13:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-29/</guid><description>1.4.29 # 解答 # 和用两个栈实现队列的方法类似。
push 的时候把右侧栈内容倒到左侧栈，之后再入栈。
pop 的时候也做相同操作，右侧栈内容进左侧栈，之后再出栈。
enqueue 的时候则将左侧栈内容倒到右侧栈，之后再入队。
代码 # internal class StackSteque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _h; private readonly Stack&amp;lt;TItem&amp;gt; _t; /// &amp;lt;summary&amp;gt; /// 初始化一个 Steque /// &amp;lt;/summary&amp;gt; public StackSteque() { _h = new Stack&amp;lt;TItem&amp;gt;(); _t = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向栈中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; public void Push(TItem item) { ReverseT(); _h.</description></item><item><title>1.4.30</title><link>https://alg4.ikesnowy.com/1-4-30/</link><pubDate>Thu, 31 May 2018 09:14:03 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-30/</guid><description>1.4.30 # 解答 # steque 作为队列的头部，stack 作为队列的尾部。
pushLeft：直接 push 到 steque 中即可。
pushRight：如果 stack 为空，则直接 enqueue 到 steque 中，否则就 push 到 stack 中。
popLeft：如果 steque 为空，则将 stack 中的元素倒到 steque 中去（steque.push(stack.pop())），然后再从 steque 中 pop。
popRight：如果 stack 为空，则将 steque 中的元素倒到 stack 中去，然后再从 stack 中 pop。
代码 # internal class Deque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _stack; // 代表队列尾部 private readonly Steque&amp;lt;TItem&amp;gt; _steque;// 代表队列头部 /// &amp;lt;summary&amp;gt; /// 创建一条空的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _stack = new Stack&amp;lt;TItem&amp;gt;(); _steque = new Steque&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 在左侧插入一个新元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { _steque.</description></item><item><title>1.4.31</title><link>https://alg4.ikesnowy.com/1-4-31/</link><pubDate>Thu, 31 May 2018 09:15:11 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-31/</guid><description>1.4.31 # 解答 # 三个栈分别命名为左中右。
左侧栈和右侧栈负责模拟队列，和用两个栈模拟队列的方法类似。
由于是双向队列，左栈和右栈会频繁的倒来倒去，因此每次都只倒一半的元素可以有效减少开销。
有一侧栈为空时，另一侧栈中上半部分先移动到中间栈中，下半部分倒到另一侧栈里，再从中间栈拿回上半部分元素。
这样可以确保接下来的 pop 操作一定是常数级别的。
代码 # internal class Deque&amp;lt;TItem&amp;gt; { private readonly Stack&amp;lt;TItem&amp;gt; _left; private readonly Stack&amp;lt;TItem&amp;gt; _middle; private readonly Stack&amp;lt;TItem&amp;gt; _right; /// &amp;lt;summary&amp;gt; /// 构造一条新的双向队列。 /// &amp;lt;/summary&amp;gt; public Deque() { _left = new Stack&amp;lt;TItem&amp;gt;(); _middle = new Stack&amp;lt;TItem&amp;gt;(); _right = new Stack&amp;lt;TItem&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 向双向队列左侧插入一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要插入的元素。&amp;lt;/param&amp;gt; public void PushLeft(TItem item) { _left.</description></item><item><title>1.4.32</title><link>https://alg4.ikesnowy.com/1-4-32/</link><pubDate>Thu, 31 May 2018 09:16:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-32/</guid><description>1.4.32 # 解答 # 首先，不需要扩容数组的的操作都只需访问数组一次，$M$ 次操作就是 $M$ 次访问。
随后我们有性质， $M$ 次栈操作后额外复制访问数组的次数小于 $2M$。
这里简单证明，设 $M$ 次操作之后栈的大小为 $n$，那么额外访问数组的次数为：
$S = \frac{n}{2} + \frac{n}{4} + \frac{n}{8} +&amp;hellip;+ 2 &amp;lt; n$
为了能使栈大小达到 $n$，$M$ 必须大于等于 $\frac{n}{2}$
因此 $2M \ge n &amp;gt; S$，得证。
因此我们可以得到 $M$ 次操作后访问数组次数的总和 $S&amp;rsquo; = S + M &amp;lt; 3M$。</description></item><item><title>1.4.33</title><link>https://alg4.ikesnowy.com/1-4-33/</link><pubDate>Thu, 31 May 2018 09:21:08 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-33/</guid><description>1.4.33 # 解答 # Integer = 4(int) + 8(对象开销) = 12
Date = 3 * 4(int * 3) + 8(对象开销) = 20
Counter = 4(String 的引用) + 4(int) + 8(对象开销) = 16
int[] = 8(对象开销) + 4(数组长度) + 4N = 12 + 4N
double[] = 8(对象开销) + 4(数组长度) + 8N = 12 + 8N
double[][] = 8(对象开销) + 4(数组长度) + 4M(引用) + M(12 + 8N)(M 个一维数组) = 12 + 16M + 8MN</description></item><item><title>1.4.34</title><link>https://alg4.ikesnowy.com/1-4-34/</link><pubDate>Thu, 31 May 2018 09:22:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-34/</guid><description>1.4.34 # 解答 # 第一种方案，类似于二分查找，先猜测左边界(lo)，再猜测右边界(hi)，如果边界值猜中的话直接返回，否则：
如果右边界比较热，那么左边界向右边界靠，lo=mid；否则，右边界向左边界靠，hi=mid。其中，mid = lo + (hi – lo)/2。
每次二分查找都要猜测两次，~2lgN。
第二种方案，假设上次猜测值为 $lastGuess$，本次即将要猜测的值为 $nowGuess$，通过方程：
$(lastGuess + nowGuess)/2 = (lo + hi)/2$
可以求得 $nowGuess$，具体可以查看示意图：
数字是猜测顺序，黑色范围是猜测值的范围（$lastGuess$ 和 $nowGuess$），绿色的是实际查找的范围（lo 和 hi）。
代码 # 首先是 Game 类
internal class Game { public int N { get; } // 目标值的最大范围。 public int SecretNumber { get; } // 目标值。 public int LastGuess { get; private set; } // 上次猜测的值 /// &amp;lt;summary&amp;gt; /// 构造函数，新开一局游戏。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;目标值的最大范围。&amp;lt;/param&amp;gt; public Game(int n) { var random = new Random(); N = n; SecretNumber = random.</description></item><item><title>1.4.35</title><link>https://alg4.ikesnowy.com/1-4-35/</link><pubDate>Thu, 31 May 2018 09:27:15 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-35/</guid><description>1.4.35 # 解答 # 1. 一个 Node 对象包含一个 int(泛型 Item) 的引用和下一个 Node 对象的引用。push 操作创建新 Node 对象时会创建一个引用。
因此对于第一种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象，创建了 2N 个引用。
2. 比起上一种情况，每个 Node 对象多包含了一个指向 Integer 的引用。
因此对于第二种情况，压入 n 个 int 类型的元素创建了 N 个 Node 对象和 N 个 Integer 对象，比起第一种情况多创建了 N 个引用。
3. 对于数组来说，创建对象只有扩容时重新创建数组对象一种情况，对于 N 次 push 操作只需要 lgN 次扩容，因此创建的对象为 lgN 个。
每次扩容都需要重新创建引用，(4 + 8 +&amp;hellip;+ 2N)(扩容) + N(每次 push 操作) = 5N - 4 = ~5N</description></item><item><title>1.4.36</title><link>https://alg4.ikesnowy.com/1-4-36/</link><pubDate>Thu, 31 May 2018 18:17:17 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-36/</guid><description>1.4.36 # 解答 # 1. N 个 Node对象的空间开销 = N * (16(对象开销) + 4(int) + 8(下一个 Node 的引用) + 4(填充字节)) = 32N
2. 比起上一题来说，空间开销变为
= N * (16(Node 对象开销) + 8(Integer 对象引用) + (16(Integer 对象开销) + 4(int) + 4(填充字节)) + 8(下一个对象的引用) = 32N + 24N = 56N。
3. 如果不扩容则是 4N，N 个元素最多可以维持 4N 的栈空间（少于四分之一将缩小）。
4. 比起上一题，数组元素变成了引用每个占用 8 字节，还要额外加上 Integer 对象的每个 24 字节。
= (8 + 24)N ~ (8 * 4 + 24)N</description></item><item><title>1.4.37</title><link>https://alg4.ikesnowy.com/1-4-37/</link><pubDate>Thu, 31 May 2018 18:19:59 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-37/</guid><description>1.4.37 # 解答 # 数据量比较大时才会有比较明显的差距。 代码 # FixedCapacityStackOfInts
/// &amp;lt;summary&amp;gt; /// 固定大小的整型数据栈。 /// &amp;lt;/summary&amp;gt; internal class FixedCapacityStackOfInts : IEnumerable&amp;lt;int&amp;gt; { private readonly int[] _a; private int _n; /// &amp;lt;summary&amp;gt; /// 默认构造函数。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;capacity&amp;#34;&amp;gt;栈的大小。&amp;lt;/param&amp;gt; public FixedCapacityStackOfInts(int capacity) { _a = new int[capacity]; _n = 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _n == 0; } /// &amp;lt;summary&amp;gt; /// 检查栈是否已满。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsFull() { return _n == _a.</description></item><item><title>1.4.38</title><link>https://alg4.ikesnowy.com/1-4-38/</link><pubDate>Thu, 31 May 2018 18:29:45 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-38/</guid><description>1.4.38 # 解答 # 把 DoublingTest 中调用的函数稍作修改即可。 代码 # ThreeSum 测试类
public static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n) { var a = new int[n]; var random = new Random(DateTime.Now.Millisecond); for (var i = 0; i &amp;lt; n; i++) { a[i] = random.</description></item><item><title>1.4.39</title><link>https://alg4.ikesnowy.com/1-4-39/</link><pubDate>Thu, 31 May 2018 18:33:14 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-39/</guid><description>1.4.39 # 解答 # 执行 N 次后取平均即可。 代码 # 修改后的 DoublingTest：
public static class DoubleTest { private static readonly int MaximumInteger = 1000000; /// &amp;lt;summary&amp;gt; /// 返回对 n 个随机整数的数组进行一次 ThreeSum 所需的时间。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;随机数组的长度。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;repeatTimes&amp;#34;&amp;gt;重复测试的次数。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static double TimeTrial(int n, int repeatTimes) { var a = new int[n]; double sum = 0; var random = new Random(DateTime.</description></item><item><title>1.4.40</title><link>https://alg4.ikesnowy.com/1-4-40/</link><pubDate>Thu, 31 May 2018 18:36:18 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-40/</guid><description>1.4.40 # 解答 # N 个数可组成的三元组的总数为：
$C(N, 3) = N(N-1)(N-2)/3! = ~ (N^3)/6​$ （组合数公式）
$[-M, M]​$ 中随机 $N​$ 次，有 $(2M+1)^N​$ 种随机序列（每次随机都有 $2M+1​$ 种可能）
按照分步计数方法，将随机序列分为和为零的三元组和其余 $N-3​$ 个数
这些序列中，和为零的三元组有 $3M^2 + 3M + 1​$ 种可能。
其他不为零的 $N-3​$ 个位置有 $(2M+1)^{(N-3)}​$ 种可能。
总共有 $((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}​$ 种可能性
平均值为：
$[((N^3)/6) \times (3M^2 + 3M + 1) \times (2M+1)^{(N-3)}] / (2M+1)^N​$ $=N^3/16M​$
$3M^2 + 3M + 1$ 的推导：</description></item><item><title>1.4.41</title><link>https://alg4.ikesnowy.com/1-4-41/</link><pubDate>Thu, 31 May 2018 19:58:51 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-41/</guid><description>1.4.41 # 解答 # 代码 # 这里使用了委托来简化代码。
DoublingRatio
public delegate int Count(int[] a); internal static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { var split = new[] { &amp;#39;\n&amp;#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i &amp;lt; a.</description></item><item><title>1.4.42</title><link>https://alg4.ikesnowy.com/1-4-42/</link><pubDate>Thu, 31 May 2018 20:20:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-42/</guid><description>1.4.42 # 解答 # 这里我们把时限设置为一小时，使用上一题的数据估计。
1.ThreeSum 暴力方法在输入倍增时耗时增加 2^3 = 8 倍。
1K 数据耗费了 1.15 秒，在一小时内（3600 秒）可以完成 2^3 = 8K 数据。
2.ThreeSumFast 方法在输入倍增时耗时增加 2^2 = 4 倍。
1K 数据耗费了 0.05 秒，在一小时内（3600 秒）可以完成 2^8 = 256K 数据。
3.TwoSum 暴力方法在输入倍增时耗时增加 2^2 = 4 倍。
8K 数据耗费了 0.14 秒，在一小时内（3600 秒）可以完成 2^10 = 1024K 数据。
4.TwoSumFast 在输入倍增时耗时增加 2^1 = 2 倍。
32K 数据耗费了 0.008 秒，在一小时内（3600 秒）可以完成 2^16 = 65536K 数据。</description></item><item><title>1.4.43</title><link>https://alg4.ikesnowy.com/1-4-43/</link><pubDate>Thu, 31 May 2018 20:22:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-43/</guid><description>1.4.43 # 解答 # 代码 # 修改后的 DoublingRatio
internal static class DoublingRatio { /// &amp;lt;summary&amp;gt; /// 从指定字符串中读入按行分割的整型数据。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;inputString&amp;#34;&amp;gt;源字符串。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;读入的整型数组&amp;lt;/returns&amp;gt; private static int[] ReadAllInts(string inputString) { var split = new[] { &amp;#39;\n&amp;#39; }; var input = inputString.Split(split, StringSplitOptions.RemoveEmptyEntries); var a = new int[input.Length]; for (var i = 0; i &amp;lt; a.Length; i++) { a[i] = int.</description></item><item><title>1.4.44</title><link>https://alg4.ikesnowy.com/1-4-44/</link><pubDate>Thu, 31 May 2018 20:25:07 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-44/</guid><description>1.4.44 # 解答 # 每生成一个随机数都和之前生成过的随机数相比较。 代码 # var random = new Random(); const int n = 10000; var a = new int[n]; var dupNum = 0; int times; for (times = 0; times &amp;lt; 500; times++) { for (var i = 0; i &amp;lt; n; i++) { a[i] = random.Next(n); if (IsDuplicated(a, i)) { dupNum += i; Console.WriteLine($&amp;#34;生成{i + 1}个数字后发生重复&amp;#34;); break; } } } Console.</description></item><item><title>1.4.45</title><link>https://alg4.ikesnowy.com/1-4-45/</link><pubDate>Thu, 31 May 2018 20:26:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-4-45/</guid><description>1.4.45 # 解答 # 建立一个布尔数组，将每次随机出来的数作为下标，将相应位置的布尔值改为 true，每次随机都检查一遍这个数组是否都是 true。
代码 # // HN 指的是调和级数 var random = new Random(); var n = 10000; var a = new bool[n]; var randomSize = 0; int times; for (times = 0; times &amp;lt; 20; times++) { for (var i = 0; i &amp;lt; n; i++) { a[i] = false; } for (var i = 0; true; i++) { var now = random.</description></item><item><title>1.5.1</title><link>https://alg4.ikesnowy.com/1-5-1/</link><pubDate>Fri, 22 Jun 2018 19:35:43 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-1/</guid><description>1.5.1 # 解答 # quick-find 的官方实现：QuickFindUF.java。
只要实现相应并查集，然后输入内容即可。
增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
样例输出：
1 2 3 4 5 6 7 8 0 数组访问：13 1 2 4 4 5 6 7 8 0 数组访问：13 1 2 4 4 8 6 7 8 0 数组访问：13 1 2 4 4 8 6 2 8 0 数组访问：13 1 1 4 4 8 6 1 8 0 数组访问：14 1 1 4 4 1 6 1 1 0 数组访问：14 1 1 4 4 1 6 1 1 4 数组访问：14 1 1 1 1 1 6 1 1 1 数组访问：16 代码 # QuickFindUF.</description></item><item><title>1.5.2</title><link>https://alg4.ikesnowy.com/1-5-2/</link><pubDate>Fri, 22 Jun 2018 19:39:25 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-2/</guid><description>1.5.2 # 解答 # quick-union 的官方实现：QuickUnionUF.java。
和上题一样的方式，增加一个记录访问数组次数的类成员变量，在每次访问数组的语句执行后自增即可。
程序输出的森林，用缩进表示子树：
|---- 0 |---- 9 |---- 1 |---- 2 |---- 3 |---- 4 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 5 |---- 6 |---- 7 |---- 8 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 4 |---- 3 |---- 6 |---- 7 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 4 |---- 3 |---- 6 |---- 8 |---- 5 数组访问：1 |---- 0 |---- 9 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 3 |---- 6 数组访问：7 |---- 1 |---- 2 |---- 7 |---- 8 |---- 5 |---- 4 |---- 0 |---- 9 |---- 3 |---- 6 数组访问：3 |---- 1 |---- 2 |---- 7 |---- 4 |---- 0 |---- 9 |---- 3 |---- 8 |---- 5 |---- 6 数组访问：3 代码 # QuickUnionUF.</description></item><item><title>1.5.3</title><link>https://alg4.ikesnowy.com/1-5-3/</link><pubDate>Fri, 22 Jun 2018 19:41:22 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-3/</guid><description>1.5.3 # 解答 # 加权 quick-union 的官方实现：WeightedQuickUnionUF.java。
样例输出：
1 2 3 4 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 8 9 数组访问：3 1 2 3 3 5 6 7 5 9 数组访问：3 1 7 3 3 5 6 7 5 9 数组访问：3 7 7 3 3 5 6 7 5 9 数组访问：5 7 7 3 3 7 6 7 5 9 数组访问：3 7 7 9 3 7 6 7 5 9 数组访问：5 7 7 9 3 7 6 7 5 7 数组访问：9 代码 # WeightedQuickUnionUF.</description></item><item><title>1.5.4</title><link>https://alg4.ikesnowy.com/1-5-4/</link><pubDate>Fri, 22 Jun 2018 19:42:54 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-4/</guid><description>1.5.4 # 解答 # 对照输入和最坏输入均在书中出现，中文版见：P146，英文版见：P229。
样例输出：
3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 8 9 size: 1 1 1 1 2 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 5 6 7 4 9 size: 1 1 1 1 3 1 1 1 1 1 parent visit count:5 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 9 size: 1 1 1 1 3 1 2 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 1 2 4 4 6 6 7 4 4 size: 1 1 1 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 2 1 1 1 parent visit count:6 size visit count:0 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 7 4 4 size: 1 1 2 1 4 1 3 1 1 1 parent visit count:5 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 2 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 3 1 1 1 parent visit count:3 size visit count:4 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:5 size visit count:4 0 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:8 size visit count:0 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 6 2 6 4 4 6 6 2 4 4 size: 1 1 3 1 4 1 6 1 1 1 parent visit count:6 size visit count:0 ------------------------------------- 1 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 2 3 4 5 6 7 8 9 size: 2 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 2 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 3 4 5 6 7 8 9 size: 3 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 3 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 4 5 6 7 8 9 size: 4 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 4 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 5 6 7 8 9 size: 5 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 5 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 6 7 8 9 size: 6 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 6 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 7 8 9 size: 7 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 7 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 8 9 size: 8 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 8 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 9 size: 9 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 9 index: 0 1 2 3 4 5 6 7 8 9 parent: 0 0 0 0 0 0 0 0 0 0 size: 10 1 1 1 1 1 1 1 1 1 parent visit count:3 size visit count:4 代码 # Main 方法：</description></item><item><title>1.5.5</title><link>https://alg4.ikesnowy.com/1-5-5/</link><pubDate>Fri, 22 Jun 2018 19:44:20 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-5/</guid><description>1.5.5 # 解答 # $10^6$ 条连接 = $10^6$ 组输入。
对于 quick-find 算法，每次 union() 都要遍历整个数组。
因此总共进行了 $10^9 \times 10^6 = 10^{15}$ 次 for 循环迭代。
每次 for 循环迭代都需要 $10$ 条机器指令，
因此总共执行了 $10 \times10^{15} = 10^{16}$ 条机器指令。
已知计算机每秒能够执行 $10^9$ 条机器指令，
因此执行完所有指令需要 $10^{16} / 10^9 = 10^7$ 秒 = $115.74$ 天。</description></item><item><title>1.5.6</title><link>https://alg4.ikesnowy.com/1-5-6/</link><pubDate>Fri, 22 Jun 2018 19:47:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-6/</guid><description>1.5.6 # 解答 # 加权 quick-union 算法最多只需要 $lgN $次迭代就可以完成一次 union()。
因此按照上题思路，总共需要 $(lg(10^9) \times 10^6 \times 10) / 10^9 = 0.299$ 秒。</description></item><item><title>1.5.7</title><link>https://alg4.ikesnowy.com/1-5-7/</link><pubDate>Fri, 22 Jun 2018 19:50:21 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-7/</guid><description>1.5.7 # 解答 # 见 1.5.1 和 1.5.2 的解答。</description></item><item><title>1.5.8</title><link>https://alg4.ikesnowy.com/1-5-8/</link><pubDate>Fri, 22 Jun 2018 19:51:02 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-8/</guid><description>1.5.8 # 解答 # 当有多个元素需要修改的时候，这个直观算法可能会出现错误。
例如如下情况：
index 0 1 2 3 4 5 6 7 8 9 id 0 0 0 0 0 5 5 5 5 5 输入 0, 5
i = 0 时，id[i] == id[p]，此时 id[i] = id[q]。
数组变为 5 0 0 0 0 5 5 5 5 5
i = 1 时，id[i] != id[p]，算法出现错误。
只要在 id[p] 之后还有需要修改的元素，那么这个算法就会出现错误。</description></item><item><title>1.5.9</title><link>https://alg4.ikesnowy.com/1-5-9/</link><pubDate>Fri, 22 Jun 2018 19:52:13 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-9/</guid><description>1.5.9 # 解答 # 不可能。 树如下所示。
由于加权 quick-union 算法任意节点的最大深度为 lgN （节点总数为 N）。
（这个结论可以在中文版 P146，或者英文版 P228 找到）
上面这个树的最大深度为 4 &amp;gt; lg10
因此这棵树不可能是通过加权 quick-union 算法得到的。</description></item><item><title>1.5.10</title><link>https://alg4.ikesnowy.com/1-5-10/</link><pubDate>Fri, 22 Jun 2018 19:54:46 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-10/</guid><description>1.5.10 # 解答 # 本题答案已经给出，也很好理解。
如果合并时只是把子树挂到结点 q 上而非其根节点，
树的高度会明显增加，进而增加每次 Find() 操作的开销。</description></item><item><title>1.5.11</title><link>https://alg4.ikesnowy.com/1-5-11/</link><pubDate>Fri, 22 Jun 2018 19:55:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-11/</guid><description>1.5.11 # 解答 # 类似于加权 quick-union 的做法，新增一个 size[] 数组以记录各个根节点的大小。
每次合并时先比较一下两棵树的大小，再进行合并。
这样会略微减少赋值语句的执行次数，提升性能。
代码 # WeightedQuickFindUF.cs
/// &amp;lt;summary&amp;gt; /// 用加权 QuickFind 算法实现的并查集。 /// &amp;lt;/summary&amp;gt; public class WeightedQuickFindUf { private readonly int[] _size; // 记录每个连通分量的大小。 private readonly int[] _id; // 记录每个结点的连通分量。 private int _count;// 连通分量总数。 public int ArrayVisitCount { get; private set; } //记录数组访问的次数。 /// &amp;lt;summary&amp;gt; /// 新建一个使用加权 quick-find 实现的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickFindUf(int n) { _count = n; _id = new int[n]; _size = new int[n]; for (var i = 0; i &amp;lt; n; i++) { _id[i] = i; _size[i] = 1; } } /// &amp;lt;summary&amp;gt; /// 重置数组访问计数。 /// &amp;lt;/summary&amp;gt; public void ResetArrayCount() { ArrayVisitCount = 0; } /// &amp;lt;summary&amp;gt; /// 表示并查集中连通分量的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回并查集中连通分量的数量。&amp;lt;/returns&amp;gt; public int Count() { return _count; } /// &amp;lt;summary&amp;gt; /// 寻找 p 所在的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;返回 p 所在的连通分量。&amp;lt;/returns&amp;gt; public int Find(int p) { Validate(p); ArrayVisitCount++; return _id[p]; } /// &amp;lt;summary&amp;gt; /// 判断两个结点是否属于同一个连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要判断的结点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q&amp;#34;&amp;gt;需要判断的另一个结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;如果属于同一个连通分量则返回 true，否则返回 false。&amp;lt;/returns&amp;gt; public bool IsConnected(int p, int q) { Validate(p); Validate(q); ArrayVisitCount += 2; return _id[p] == _id[q]; } /// &amp;lt;summary&amp;gt; /// 将两个结点所在的连通分量合并。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要合并的结点。&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;q&amp;#34;&amp;gt;需要合并的另一个结点。&amp;lt;/param&amp;gt; public void Union(int p, int q) { Validate(p); Validate(q); var pId = _id[p]; var qId = _id[q]; ArrayVisitCount += 2; // 如果两个结点同属于一个连通分量，那么什么也不做。 if (pId == qId) { return; } // 判断较大的连通分量和较小的连通分量。 int larger; int smaller; if (_size[pId] &amp;gt; _size[qId]) { larger = pId; smaller = qId; _size[pId] += _size[qId]; } else { larger = qId; smaller = pId; _size[qId] += _size[pId]; } // 将较小的连通分量连接到较大的连通分量上， // 这会减少赋值语句的执行次数，略微减少数组访问。 for (var i = 0; i &amp;lt; _id.</description></item><item><title>1.5.12</title><link>https://alg4.ikesnowy.com/1-5-12/</link><pubDate>Fri, 22 Jun 2018 19:57:05 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-12/</guid><description>1.5.12 # 解答 # QuickUnionPathCompression 的官方实现：QuickUnionPathCompressionUF.java
在找到根节点之后，再访问一遍 p 到根节点这条路径上的所有结点，将它们直接和根节点相连。
重写过后的 Find() 方法：
/// &amp;lt;summary&amp;gt; /// 寻找结点所属的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;结点所属的连通分量。&amp;lt;/returns&amp;gt; public override int Find(int p) { int root = p; while (root != this.parent[root]) { root = this.parent[root]; } while (p != root) { int newp = this.parent[p]; this.parent[p] = root; p = newp; } return p; } 由于路径压缩是在 Find() 方法中实现的，</description></item><item><title>1.5.13</title><link>https://alg4.ikesnowy.com/1-5-13/</link><pubDate>Fri, 22 Jun 2018 19:59:26 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-13/</guid><description>1.5.13 # 解答 # 官方实现：WeightedQuickUnionPathCompressionUF。
加权 quick-union 中，两个大小相等的树合并可以有效增加高度，同时输入必须保证是根节点以规避路径压缩。
代码 # WeightedQuickUnionPathCompressionUF.cs 从 WeightedQuickUnionUF.cs 继承，详情参见 1.5.3 的解答。
public class WeightedQuickUnionPathCompressionUf : WeightedQuickUnionUf { /// &amp;lt;summary&amp;gt; /// 新建一个大小为 n 的并查集。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;新建并查集的大小。&amp;lt;/param&amp;gt; public WeightedQuickUnionPathCompressionUf(int n) : base(n) { Size = new int[n]; for (var i = 0; i &amp;lt; n; i++) { Size[i] = 1; } } /// &amp;lt;summary&amp;gt; /// 寻找一个结点所在的连通分量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p&amp;#34;&amp;gt;需要寻找的结点。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;该结点所属的连通分量。&amp;lt;/returns&amp;gt; public override int Find(int p) { Validate(p); var root = p; while (root !</description></item><item><title>1.5.14</title><link>https://alg4.ikesnowy.com/1-5-14/</link><pubDate>Fri, 22 Jun 2018 20:04:04 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-14/</guid><description>1.5.14 # 解答 # WeightedQuickUnionByHeight 的官方实现：WeightedQuickUnionByHeightUF.java。
证明： 一次 Union 操作只可能发生如下两种情况。
两棵树的高度相同，这样合并后的新树的高度等于较大那棵树的高度 + 1。
两棵树的高度不同，这样合并后的新树高度等于较大那棵树的高度。
现在证明通过加权 quick-union 算法构造的高度为 h 的树至少包含 2h 个结点。
基础情况，高度 h = 0, 结点数 k = 1。
为了使高度增加，必须用一棵高度相同的树合并，而 h = 0 时结点数一定是 1，则：
h = 1, k = 2
由于两棵大小不同的树合并，最大高度不会增加，只会增加结点数。
因此，每次都使用相同高度的最小树进行合并，有：
h = 2, k = 4 h = 3, k = 8 h = 4, k = 16 ...... 递推即可得到结论，k ≥ 2^h</description></item><item><title>1.5.15</title><link>https://alg4.ikesnowy.com/1-5-15/</link><pubDate>Fri, 22 Jun 2018 20:05:57 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-15/</guid><description>1.5.15 # 解答 # 首先证明在最坏情况下加权 quick-union 算法生成的树中的每一层结点数均为二项式系数。
最坏情况下，每次 union 操作都是合并相同大小的树，如下图所示：
设第 i 层的结点数为 ki，那么最坏情况下每次合并后的 ki’ = ki + ki-1 。
这符合二项式系数的构造特点（详情可以搜索杨辉三角），
第一个结论证明完毕。
接下来求平均深度，首先根据二项式的求和公式，一棵深度为 n 的树（根结点的深度为零）结点总数为：
$$ \sum_{k=0}^{n} \begin{pmatrix} n \newline k \end{pmatrix} =2^n $$
每层结点数 × 该层深度后的和为：
$$ \sum_{k=0}^{n}k \cdot \begin{pmatrix} n \newline k \end{pmatrix}=n\sum_{k=1}^{n} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix}=n\sum_{s=0}^{n-1} \begin{pmatrix} n-1 \newline s \end{pmatrix}=n2^{n-1} $$
这里用到了这个公式化简：
$$ \begin{pmatrix} n \newline k \end{pmatrix}=\frac{n}{k} \begin{pmatrix} n-1 \newline k-1 \end{pmatrix} $$</description></item><item><title>1.5.16</title><link>https://alg4.ikesnowy.com/1-5-16/</link><pubDate>Fri, 22 Jun 2018 20:44:09 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-16/</guid><description>1.5.16 # 解答 # 给出绘图结果样例： 代码 # 仅给出绘图相关的代码，窗体部分见 github 上的代码：
using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._16 { static class Program { [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { char[] split = { &amp;#39;\n&amp;#39;, &amp;#39;\r&amp;#39; }; string[] input = TestCase.</description></item><item><title>1.5.17</title><link>https://alg4.ikesnowy.com/1-5-17/</link><pubDate>Fri, 22 Jun 2018 20:46:19 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-17/</guid><description>1.5.17 # 解答 # 官方给出的 ErdosRenyi：ErdosRenyi.java。
为了方便之后做题，除了 Count() 之外，这个类还包含其他方法，具体可以查看注释。
代码 # ErdosRenyi.cs
public class ErdosRenyi { /// &amp;lt;summary&amp;gt; /// 随机生成一组能让并查集只剩一个连通分量的连接。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;n&amp;#34;&amp;gt;并查集大小。&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;一组能让并查集只剩一个连通分量的连接。&amp;lt;/returns&amp;gt; public static Connection[] Generate(int n) { var random = new Random(); var connections = new List&amp;lt;Connection&amp;gt;(); var uf = new WeightedQuickUnionPathCompressionUf(n); while (uf.Count() &amp;gt; 1) { var p = random.</description></item><item><title>1.5.18</title><link>https://alg4.ikesnowy.com/1-5-18/</link><pubDate>Fri, 22 Jun 2018 20:48:36 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-18/</guid><description>1.5.18 # 解答 # 具体生成的连接样式见下题，这里给出 RandomGrid 的实现，需要使用 1.3 节中的随机背包辅助。
代码 # RandomGrid.cs
public class RandomBag&amp;lt;TItem&amp;gt; : IEnumerable&amp;lt;TItem&amp;gt; { private TItem[] _bag; private int _count; /// &amp;lt;summary&amp;gt; /// 建立一个随机背包。 /// &amp;lt;/summary&amp;gt; public RandomBag() { _bag = new TItem[2]; _count = 0; } /// &amp;lt;summary&amp;gt; /// 检查背包是否为空。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public bool IsEmpty() { return _count == 0; } /// &amp;lt;summary&amp;gt; /// 返回背包中元素的数量。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public int Size() { return _count; } /// &amp;lt;summary&amp;gt; /// 向背包中添加一个元素。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;item&amp;#34;&amp;gt;要向背包中添加的元素。&amp;lt;/param&amp;gt; public void Add(TItem item) { if (_count == _bag.</description></item><item><title>1.5.19</title><link>https://alg4.ikesnowy.com/1-5-19/</link><pubDate>Fri, 22 Jun 2018 20:55:33 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-19/</guid><description>1.5.19 # 解答 # 最后绘出的图像： 代码 # 给出绘图部分的代码，窗体部分见 GitHub。
using System; using System.Drawing; using System.Collections.Generic; using System.Windows.Forms; using UnionFind; namespace _1._5._19 { /* * 1.5.19 * * 动画。 * 编写一个 RandomGrid（请见练习 1.5.18）的用例， * 和我们开发用例一样使用 UnionFind 来检查触点的连通性并在处理时用 StdDraw 将它们绘出。 * */ static class Program { static RandomBag&amp;lt;Connection&amp;gt; bag; static Graphics graphics; static TextBox logBox; static PointF[] points; static Timer timer; static List&amp;lt;Connection&amp;gt; connections; static int count = 0; /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.</description></item><item><title>1.5.20</title><link>https://alg4.ikesnowy.com/1-5-20/</link><pubDate>Thu, 28 Jun 2018 13:34:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-20/</guid><description>1.5.20 # 解答 # 将 parent 数组和 size 数组用链表代替即可，很容易实现。
代码 # 修改后的 WeightedQuickUnionUF.cs
public class WeightedQuickUnionUf { protected LinkedList&amp;lt;int&amp;gt; Parent; // 记录各个结点的父级。 protected LinkedList&amp;lt;int&amp;gt; Size; // 记录各个树的大小。 protected int Count; // 分量数目。 /// &amp;lt;summary&amp;gt; /// 建立使用加权 quick-union 的并查集。 /// &amp;lt;/summary&amp;gt; public WeightedQuickUnionUf() { Parent = new LinkedList&amp;lt;int&amp;gt;(); Size = new LinkedList&amp;lt;int&amp;gt;(); } /// &amp;lt;summary&amp;gt; /// 获取 parent 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;parent 数组。&amp;lt;/returns&amp;gt; public LinkedList&amp;lt;int&amp;gt; GetParent() { return Parent; } /// &amp;lt;summary&amp;gt; /// 获取 size 数组。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;返回 size 数组。&amp;lt;/returns&amp;gt; public LinkedList&amp;lt;int&amp;gt; GetSize() { return Size; } /// &amp;lt;summary&amp;gt; /// 在并查集中增加一个新的结点。 /// &amp;lt;/summary&amp;gt; /// &amp;lt;returns&amp;gt;新结点的下标。&amp;lt;/returns&amp;gt; public int NewSite() { Parent.</description></item><item><title>1.5.21</title><link>https://alg4.ikesnowy.com/1-5-21/</link><pubDate>Thu, 28 Jun 2018 13:37:27 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-21/</guid><description>1.5.21 # 解答 # 给出我电脑上的结果：
实验结果：16 1/2NlnN：11.51292546497023 实验结果：38 1/2NlnN：29.957322735539908 实验结果：89 1/2NlnN：73.77758908227872 实验结果：194 1/2NlnN：175.28106538695525 实验结果：455 1/2NlnN：406.0139052187061 实验结果：1050 1/2NlnN：922.9313593270035 实验结果：2300 1/2NlnN：2067.6698164331897 实验结果：4918 1/2NlnN：4578.953828424745 实验结果：10812 1/2NlnN：10045.136047966218 实验结果：23478 1/2NlnN：21864.728878165897 代码 # for (var n = 10; n &amp;lt; 10000; n *= 2) { var total = 0; for (var i = 0; i &amp;lt; 100; i++) { var uf = new Uf(n); total += ErdosRenyi.Count(uf); } Console.</description></item><item><title>1.5.22</title><link>https://alg4.ikesnowy.com/1-5-22/</link><pubDate>Thu, 28 Jun 2018 13:39:41 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-22/</guid><description>1.5.22 # 解答 # 平方级别算法在输入加倍后耗时应该增加四倍，线性则是两倍。
下面给出我电脑上的结果，数据量较大时比较明显：
N:16000 quick-find 平均次数：8452 用时：143 比值：4.46875 quick-union 平均次数：7325 用时：202 比值：3.25806451612903 weighted-quick-union 平均次数：6889 用时：1 N:32000 quick-find 平均次数：15747 用时：510 比值：3.56643356643357 quick-union 平均次数：15108 用时：801 比值：3.96534653465347 weighted-quick-union 平均次数：17575 用时：3 比值：3 N:64000 quick-find 平均次数：33116 用时：2069 比值：4.05686274509804 quick-union 平均次数：38608 用时：4635 比值：5.78651685393258 weighted-quick-union 平均次数：34850 用时：6 比值：2 代码 # long lastTimeQuickFind = 0; long lastTimeQuickUnion = 0; long lastTimeWeightedQuickUnion = 0; for (var n = 2000; n &amp;lt; 100000; n *= 2) { Console.</description></item><item><title>1.5.23</title><link>https://alg4.ikesnowy.com/1-5-23/</link><pubDate>Thu, 28 Jun 2018 13:41:28 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-23/</guid><description>1.5.23 # 解答 # 先用速度最快的 WeightedQuickUnionUF 生成一系列连接，
保存后用这些连接进行测试，生成连接的方法见 1.5.17 的解答。
下面给出我电脑上的结果：
N:2000 quick-find 耗时（毫秒）：4 quick-union 耗时（毫秒）：5 比值：0.8 N:4000 quick-find 耗时（毫秒）：19 quick-union 耗时（毫秒）：24 比值：0.791666666666667 N:8000 quick-find 耗时（毫秒）：57 quick-union 耗时（毫秒）：74 比值：0.77027027027027 N:16000 quick-find 耗时（毫秒）：204 quick-union 耗时（毫秒）：307 比值：0.664495114006515 N:32000 quick-find 耗时（毫秒）：1127 quick-union 耗时（毫秒）：1609 比值：0.700435052827843 代码 # var n = 2000; for (var t = 0; t &amp;lt; 5; t++) { var input = ErdosRenyi.Generate(n); var quickFind = new QuickFindUf(n); var quickUnion = new QuickUnionUf(n); Console.</description></item><item><title>1.5.24</title><link>https://alg4.ikesnowy.com/1-5-24/</link><pubDate>Thu, 28 Jun 2018 13:47:32 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-24/</guid><description>1.5.24 # 解答 # 根据上题的代码略作修改即可，路径压缩大概可以快 1/3。
N:10000 加权 quick-find 耗时（毫秒）：9 带路径压缩的加权 quick-union 耗时（毫秒）：6 比值：1.5 N:20000 加权 quick-find 耗时（毫秒）：12 带路径压缩的加权 quick-union 耗时（毫秒）：8 比值：1.5 N:40000 加权 quick-find 耗时（毫秒）：18 带路径压缩的加权 quick-union 耗时（毫秒）：12 比值：1.5 N:80000 加权 quick-find 耗时（毫秒）：36 带路径压缩的加权 quick-union 耗时（毫秒）：30 比值：1.2 N:160000 加权 quick-find 耗时（毫秒）：67 带路径压缩的加权 quick-union 耗时（毫秒）：41 比值：1.63414634146341 代码 # var n = 10000; for (var t = 0; t &amp;lt; 5; t++) { var input = ErdosRenyi.Generate(n); var weightedQuickUnionUf = new WeightedQuickUnionUf(n); var weightedQuickUnionPathCompressionUf = new WeightedQuickUnionPathCompressionUf(n); Console.</description></item><item><title>1.5.25</title><link>https://alg4.ikesnowy.com/1-5-25/</link><pubDate>Thu, 28 Jun 2018 13:48:55 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-25/</guid><description>1.5.25 # 解答 # 略微修改 1.5.22 的代码即可。 我电脑上的结果：
Quick-Find N:1600 平均用时（毫秒）：4 N:6400 平均用时（毫秒）：67 比值：16.75 N:25600 平均用时（毫秒）：1268 比值：18.9253731343284 N:102400 平均用时（毫秒）：20554 比值：16.2097791798107 Quick-Union N:1600 平均用时（毫秒）：5 比值：0.000243261652233142 N:6400 平均用时（毫秒）：66 比值：13.2 N:25600 平均用时（毫秒）：1067 比值：16.1666666666667 N:102400 平均用时（毫秒）：18637 比值：17.4667291471415 Weighted Quick-Union N:1600 平均用时（毫秒）：0 比值：0 N:6400 平均用时（毫秒）：2 N:25600 平均用时（毫秒）：12 比值：6 N:102400 平均用时（毫秒）：64 比值：5.33333333333333 代码 # var n = 40; var t = 4; // quick-find Console.WriteLine(&amp;#34;Quick-Find&amp;#34;); long last = 0; long now; for (var i = 0; i &amp;lt; t; i++, n *= 2) { Console.</description></item><item><title>1.5.26</title><link>https://alg4.ikesnowy.com/1-5-26/</link><pubDate>Thu, 28 Jun 2018 13:50:42 +0000</pubDate><guid>https://alg4.ikesnowy.com/1-5-26/</guid><description>1.5.26 # 解答 # 和 1.5.16 的程序类似，将测试的内容改为 Erdos-Renyi 即可。
样例输出：
代码 # using System; using System.Linq; using System.Windows.Forms; using System.Drawing; using UnionFind; namespace _1._5._26 { static class Program { /// &amp;lt;summary&amp;gt; /// 应用程序的主入口点。 /// &amp;lt;/summary&amp;gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Compute(); Application.Run(new Form1()); } static void Compute() { int size = 200; QuickFindUF quickFind = new QuickFindUF(size); QuickUnionUF quickUnion = new QuickUnionUF(size); WeightedQuickUnionUF weightedQuickUnion = new WeightedQuickUnionUF(size); Connection[] connections = ErdosRenyi.</description></item></channel></rss>