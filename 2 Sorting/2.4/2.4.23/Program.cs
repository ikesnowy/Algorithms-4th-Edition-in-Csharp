namespace _2._4._23
{
    class Program
    {
        static void Main(string[] args)
        {
            // 假设以下所有 log 运算的底数均为 t。
            // 首先考虑简单的 sink 实现。
            // sink 方法会在所有的 t 个子结点中寻找最大的结点。
            // 如果找到的结点比当前结点大，那么就进行交换。
            // 否则视为结点已经下沉到了合适的位置，结束循环。
            // 根据题意，在 t 个元素中找最大值需要 t 次比较。
            // sink 操作需要找到 t 个子结点中的最大值并与当前结点相比较。
            // 于是 sink 操作每次需要使用 (t + 1) 次比较。

            // 建堆过程
            // 对 2.4.20 的证明进行推广，
            // 建堆最多需要 n 次交换，(t + 1)n 次比较
            // 排序过程
            // 每次删除最大元素的操作都会对根结点调用一次 sink
            // 故排序过程需要的比较次数为 n(t + 1) logn
            // 总共需要的比较次数为：n(t + 1) + n(t + 1) logn = (t + 1)(nlogn + n)
            // 接下来我们利用换底公式将对数的底换成 2，lg 表示以 2 为底的对数。
            // 原式 = [(t + 1)/(lg t)](nlgn + nlgt)
            // 由于考虑的是 nlgn 的系数，于是问题转化为求
            // (t+1)/lgt 的最小值，t > 1
            // 直接求解比较困难，
            // 考虑到 lg t 的导数 1/(tln2) 从 t=2 开始就小于 t+1 的导数。
            // 故简单尝试可以发现最小值点在 t=3 和 t=4 之间。
            // 计算结果为 t=4 时取最小，系数为 2.5。

            // 再考虑使用 Floyd 方法优化 sink 方法的情况
            // sink 方法使用的比较次数变为 t
            // 建堆需要的比较次数变为 tn
            // 排序需要的比较次数变为 tnlogn
            // 总共需要的比较次数为 t(nlogn + n)
            // 同样转化为求 t/lgt 的最小值。
            // 计算结果为 t=3 时取最小，系数为 1.89。
        }
    }
}
